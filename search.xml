<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【算法】剑指Offer算法题</title>
      <link href="/2020/07/05/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%89%91%E6%8C%87Offer%E7%AE%97%E6%B3%95%E9%A2%98/"/>
      <url>/2020/07/05/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%89%91%E6%8C%87Offer%E7%AE%97%E6%B3%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<ol><li>【<strong>*数组中重复的数字-1</strong>】长度为$n$的数组中，数字范围为$0 \sim n-1$，其中某些数字是重复的，但重复数字与重复次数未知，找出任意一个重复的数字，如${2, 3, 1, 0, 2, 5, 3}$对应输出$2$或$3$； <details> <summary>点击查看提示</summary> <p> 利用索引和元素值的关系，以{2, 3, 1, 0, 2, 5, 3}为例，下面程序的执行过程为 </p>  <p> [2], 3, 1, 0,  2, 5, 3 <br>     [1], 3, 2, 0,  2, 5, 3 <br>     [3], 1, 2, 0,  2, 5, 3 <br>      0,  1, 2, 3, [2], 5, 3 </p> <pre><code> class Solution { public:     // Parameters:     //        numbers:     an array of integers     //        length:      the length of array numbers     //        duplication: (Output) the duplicated number in the array number     // Return value:       true if the input is valid, and there are some duplications in the array number     //                     otherwise false     bool duplicate(int numbers[], int length, int* duplication) {         if (numbers == nullptr || length == 0 || duplication == nullptr)             return false;         int index = 0;         while (index < length) {             int num = numbers[index];             // 下标与索引一致             if (num == index) {                 index++; continue;             }             // 已经重复             if (numbers[num] == num) {                 *duplication = num;                 return true;             }             numbers[index] = numbers[num];             numbers[num] = num;         }         return false;     } }; </code></pre> </details></li><li>【<strong>*数组中重复的数字-2</strong>】长度为$n+1$的数组中，数字范围为$1 \sim n$，其中某些数字是重复的，但重复数字与重复次数未知，<strong>在不修改数组的情况下</strong>，找出任意一个重复的数字； <details> <summary>点击查看提示</summary> <p>若没有重复数字，那么数字范围为1 ~ n的数组最多有n个元素。<br> 1. 用二分查找的思路，统计落入[1, n // 2], [n // 2 + 1, n]内数字的个数，若有重复那么区间内元素个数大于区间长度，时间复杂度O(nlogn)；<br>  2. 开辟新数组作为哈希表，将各数字放入对应位置，空间复杂度与时间复杂度都是O(n)。  </p> </details></li><li>【<strong>二维数组中的查找</strong>】给定二维整数数组，每一行从左至右元素递增，每一列从上至下元素递增，在这样的数组中查找指定整数； <details> <summary>点击查看提示</summary> <p>  1. 首先按第一行查找，找第一个小于等于搜索数字的<b>列首</b>；<br>  2. 然后按最后一列进行查找，找第一个大于等于搜索数字的<b>行尾</b>；<br> 3. 如此循环直至查找到，可以考虑将查找换成二分查找。 </p> <p> 例如下数组中查找数字6 <br> 1 2 8 9 <br> 2 4  9 12 <br> 4 7 10 13 <br> 6 8 11 15 <br> 按第一行查找后为 <br> 1 2 <br> 2 4 <br> 4 7 <br> 6 8 <br> 按最后列查找后为 <br> 4 7 <br> 6 8 <br> 再按第一行查找后为 <br> 4 <br> 6 <br> 按最后列查找后为 <br> 6 <br> </p> <pre><code> class Solution { public:     bool Find(int target, vector<vector&lt;int&gt;> array) {         // 检查数组有效性         int rows = array.size();         if (rows == 0) return false;         int cols = array[0].size();         if (cols == 0) return false;         // 初始化索引：第一行、最后列         int r = 0, c = cols - 1;         while (true) {             // 按当前第一行查找第一个不大于target的元素             while (c >= 0 && array[r][c] > target) c--;             if (c == -1)                 return false;             if (array[r][c] == target)                 return true;             // 按当前最后列查找第一个不小于target的元素             while (r < rows && array[r][c] < target) r++;             if (r == rows)                 return false;             if (array[r][c] == target)                 return true;         }     } }; </vector&lt;int&gt;></code></pre> </details></li><li>【<strong>替换字符串的空格</strong>】将字符串中每个空格替换成<code>&quot;%20&quot;</code>，例如<code>&quot;we are happy.&quot;</code>输出为<code>&quot;we%20are%20happy.&quot;</code>； <details> <summary>点击查看提示</summary> <p> 内存管理；时间复杂度O(n)，空间复杂度O(1)；可应用于归并算法 </p> <pre><code> class Solution { // 注：length是指str字符数组空间的大小，不是字符串长度 public:     void replaceSpace(char* str, int length) {         if (str == nullptr) return;         // 统计空格个数         char* end = str;         int spaceCnt = 0;         for (; *end != '\0'; end++) {             if (*end == ' ') spaceCnt++;         }         // 新字符串的末尾，一个空格需要额外2个字节的空间         char* endCpy = end + 2 * spaceCnt;         // 从后往前复制         for (char* ch = end; ch >= str; ch--) {             // 空格`' '`替换为`'%20'`             if (*ch == ' ') {                 *(endCpy--) = '0';                 *(endCpy--) = '2';                 *(endCpy--) = '%';             // 其余复制即可             } else {                 *(endCpy--) = *ch;             }         }     } }; </code></pre></details></li><li>【<strong>链表：从尾到头打印输出</strong>】输入单向链表头节点，不改变结构的情况下，从尾到头打印每个节点的值； <details> <summary>点击查看提示</summary> <p> 栈；若可更改链表结构，也可考虑链表翻转；或者将链表元素顺序存入数组后翻转。 </p> <pre><code> class Solution { public:     vector&lt;int&gt; printListFromTailToHead(ListNode* head) {         vector&lt;int&gt; ret = {};         if (head == NULL) return ret;         // 顺序放入数组         ListNode* node = head;         while (node) {             ret.push_back(node->val);             node = node->next;         }         // 翻转         reverse(ret.begin(), ret.end());         return ret;     } }; </code></pre></details></li><li>【<strong>重建二叉树</strong>】给定某二叉树前序遍历和中序遍历的结果(不含重复数字)，重建该二叉树并返回根节点；<blockquote><p>如前序遍历为${1, 2, 4, 7, 3, 5, 6, 8}$，中序遍历为${4, 7, 2, 1, 5, 3, 8, 6}$，重建树;</p> <details> <summary>点击查看解析</summary> <p> 1. 前序遍历中，第1个输出元素必定是根节点元素；中序遍历中，根节点元素输出位于左子树与右子数元素中间；</p> <p> 2. 确定根节点元素在中序遍历中的位置，可确定左右子树元素数组，分别以左右侧子数组为输入，递归构建子树； </p> <pre><code>   class Solution { public:     TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre, vector&lt;int&gt; vin) {         // 终止条件         if (pre.size() == 0) return nullptr;         // 建立节点         TreeNode* root = new TreeNode(pre[0]);         // 在中序序列查找根节点位置         auto itRootVal = find(vin.begin(), vin.end(), pre[0]);         // 左子树重建         auto preBegin = pre.begin() + 1;         auto preEnd = preBegin + vinL.size();         vector&lt;int&gt; preL(preBegin, preEnd);         vector&lt;int&gt; vinL(vin.begin(), itRootVal);         TreeNode* leftChild = reConstructBinaryTree(preL, vinL);         // 右子树重建         preBegin = preEnd; preEnd = pre.end();         vector&lt;int&gt; preR(preBegin, preEnd);         vector&lt;int&gt; vinR(itRootVal + 1, vin.end());         TreeNode* rightChild = reConstructBinaryTree(preR, vinR);         // 联系根节点         root->left = leftChild;         root->right = rightChild;         return root;     } }; </code></pre> </details></blockquote></li><li><p>【<strong>*二叉树的下一个节点</strong>】给定一颗二叉树和其中的一个节点，如何找出中序遍历序列的下一个节点？树中的节点除了有两个分别指向左、右子节点的指针，还有一个指向父节点的指针。</p> <details><summary>点击查看提示</summary> <p>注意是中序遍历，考虑以下情况<br> 1. 输入节点存在右子树，那么需要遍历其右子树；<br> 2. 输入节点不存在右子树，那么子树遍历结束，又考虑是其父节点的左子节点还是右子节点。</p> <pre><code> class Solution { public:     TreeLinkNode* GetNext(TreeLinkNode* pNode) {         if (!pNode) return nullptr;         TreeLinkNode* node = nullptr;         // 是否存在右子节点，若存在则返回右子树的最左子节点         if (pNode->right) {             node = pNode->right;             while (node->left)                 node = node->left;             return node;         }         // 是否为父节点的左子节点，若是，返回父节点         if (pNode->next && pNode == pNode->next->left)             return pNode->next;         // 为父节点的右子节点，子树遍历结束         // 向上查找第一个是父节点的左子节点的祖先节点         node = pNode;         while (node->next && node != node->next->left)             node = node->next;         return node->next;     } }; </code></pre> </details></li><li><p>【<strong>用两个栈实现队列/堆</strong>】用两个栈实现一个队列/堆；</p><blockquote><p>相关题目：用两个队列实现栈/堆。</p> <details> <summary>点击查看提示</summary> <pre><code> class Solution { public:     void push(int val) {         swap(stack1, stack2);         stack2.push(val);     }     int pop() {         swap(stack2, stack1);         if (stack1.empty())              throw "Error! Empty!";         int ret = stack1.top();         stack1.pop();         return ret;     }     void swap(stack<int>& src, stack<int>& dst) {         while (!src.empty()) {             dst.push(src.top());             src.pop();         }     } private:     stack<int> stack1;     stack<int> stack2; }; </int></int></int></int></code></pre></details></blockquote></li><li><p>【<strong>斐波那契数列</strong>】求斐波那契数列第$n$项；</p><details> <summary>点击查看提示</summary><p>1. 递归，直观但重复计算较多，指数级复杂度增长； <br> 2. 循环，仅计算最近两项，时间复杂度O(n)； <br>3. 状态方程法，其中矩阵的幂用分治法计算，时间复杂度O(log n)但不够实用。 </p><pre><code>class Solution {public:    int Fibonacci(int n) {        if (n == 0) return 0;        int a = 1, b = 0;        for (int i = 1; i < n; i++){            // a, b = a + b, a            a = a + b;            b = a - b;        }        return a;    }};</code></pre></details> <script type="math/tex; mode=display">\begin{bmatrix}    f(n + 1) \\ f(n)\end{bmatrix} = \begin{bmatrix}    1 & 1 \\ 1 & 0\end{bmatrix} \times \begin{bmatrix}    f(n) \\ f(n - 1)\end{bmatrix}, n \geq 2</script></li><li><p>【<strong>青蛙跳台阶</strong>】一只青蛙一次可以跳上$1,2$级台阶，求跳上$n$级台阶共有几种跳法。</p><details> <summary>点击查看提示</summary><p> 定义函数f(n)为剩余n级台阶时的跳法，特殊处理1级或2级台阶；若取最优，即为动态规划； </p> </details> </li><li>【<strong>旋转数组的最小数字</strong>】将数组最开始的若干个元素固定顺序搬到数组的末尾，称为数据的旋转。现输入非降序数组的一个旋转，输出旋转数组的最小元素；<blockquote><p>如输入${1, 2, 3, 4, 5}$的一个旋转为${3, 4, 5, 1, 2}$，最小元素为$1$。</p><details> <summary>点击查看提示</summary><p> 二分法，前面子数组的数字必定大于后面子数组；注意特殊情况的处理如{0, 1, 1, 1}的旋转{1, 1, 0, 1}，因为l = 0, r = 3, m = 1时，nums[l] = nums[m] = nums[r]，无法确定应该向哪个方向移动 </p><pre><code>class Solution {public:    int minNumberInRotateArray(vector&lt;int&gt; rotateArray) {        if (rotateArray.empty()) return 0;        int l = 0, r = rotateArray.size() - 1;        while (l <= 2 r) { int m="(r" - l) + l; 三个数相同，顺序查找最小 if (rotatearray[l]="=" rotatearray[m] && \ rotatearray[l]="=" rotatearray[r]) return *min_element( rotatearray.begin() l, r 1); } 前面子数组的数字必定大于后面子数组，注意下面两个判断的顺序 右边是非降序的，右边界收紧 (rotatearray[m] <="rotateArray[r])" 1; 左边是非降序的，左边界收紧 else>= rotateArray[l])                l = m + 1;        }        return rotateArray[l];    }};</=></code></pre></details> </blockquote></li><li>【<strong>矩阵中的路径</strong>】设计函数判断一个矩阵中是否存在一条包含某字符串所有字符的路径，可从矩阵中任意字符出发，每一步可上下左右移动一格，且已经过的字符不可重复经过；<blockquote><p>如下矩阵中，存在<code>&quot;bfce&quot;</code>的路径</p><script type="math/tex; mode=display">\begin{bmatrix}    a & \bm{b} & t & g \\    c & \bm{f} & \bm{c} & s \\    j & d & \bm{e} & h\end{bmatrix}</script><details> <summary>点击查看提示</summary><p> 参考迷宫老鼠问题(dfs/bfs两种实现)；需考虑字符串是否有序的要求； </p> <pre><code>class Solution {public:    bool hasPath(char* matrix, int rows, int cols, char* str) {        if (!matrix || !str || rows == 0 || cols == 0) return false;        // 每个点作为起始点尝试        for (int r = 0; r < rows; r++) {            for (int c = 0; c < cols; c++) {                bool* visited = new bool[rows * cols];                memset(visited, 0, rows * cols * sizeof(bool));                bool has = hasPathDfs(matrix, visited, rows, cols, r, c, str, 0);                if (has) return true;            }        }        return false;    }    bool hasPathDfs(char* matrix, bool* visited, int rows, int cols, int r, int c, char* str, int index) {        // 终止条件1：字符串结束        if (str[index] == '\0') return true;        // 终止条件2：越界        if (r < 0 || r >= rows || c < 0 || c > cols) return false;        // 终止条件3：已经到达过        if (visited[r * cols + c] == true) return false;        // 终止条件4：字符不一致        if (matrix[r * cols + c] != str[index]) return false;        // ------------------------------------------        // 置位已到达        visited[r * cols + c] = true;        if (hasPathDfs(matrix, visited, rows, cols, r - 1, c, str, index + 1) || \            hasPathDfs(matrix, visited, rows, cols, r + 1, c, str, index + 1) || \            hasPathDfs(matrix, visited, rows, cols, r, c - 1, str, index + 1) || \            hasPathDfs(matrix, visited, rows, cols, r, c + 1, str, index + 1))            return true;        else            return false;    }};</code></pre></details> </blockquote></li><li><p>【<strong>剪绳子</strong>】一根长度为$n(n&gt;1)$的绳子，剪成$m(m&gt;1)$段，每段长度为$k_1, \cdots, k_m (k_i \in N)$，求$\max \prod_i k_i$；</p><details> <summary>点击查看解析</summary><p> 典型的动态规划 </p> <pre><code>class Solution {public:    int cutRope(int number) {        // 长度为1, 2, 3直接返回        if (number < 4) return number - 1;        // 注意数组下标1, 2, 3时与上面不同        int* dp = new int[number + 1];        for (int i = 0; i < number + 1; i++) {            if (i < 4) {                dp[i] = i;            } else {                dp[i] = max(                    max(dp[i - 1] * 1, dp[i - 2] * 2), dp[i - 3] * 3);            }        }        int ret = dp[number];        delete[] dp;        return ret;    }};</code></pre></details> </li><li><p>【<strong>*二进制数中$1$的个数</strong>】<strong>输入一个整数，输出该整数转换为二进制后$1$的位数；</strong></p><details> <summary>点击查看解析</summary><p> 1. 左移右移与算术运算的关系，移位运算符比算术运算快；<br>2. 若采用移位运算，注意负数的处理，因为左移是逻辑移位(右端补0)，右移是算术移位(左端补符号位，会导致负数移位后进入0xFFFFFFFF死循环)；<br>3. (x-1)&x相当于将x最右的1清0. </p> <pre><code>class Solution {public:    int  NumberOf1(int n) {        int count = 0;        int mask = 0x01;        while (mask) {            if (n & mask)                count++;            mask <<= 1; } return count; }; -------------------------------- class solution { public: int numberof1(int n) count="0;" while (n !="0){" n &="(n" - 1); count++; < code></=></code></pre></details><blockquote><p>相关题型：</p><ol><li>用一个语句判断一个数是否为$2$的整数次方；</li><li>输入两个数$m, n$，计算$m$的二进制表示需改更改几位才能得到$n$；</li></ol></blockquote></li><li><p>【<strong>*数值的整数次方</strong>】实现函数<code>double power(double x, int n)</code>，求$x^n$，不考虑大数情况；</p><details> <summary>点击查看解析</summary><p> 1. 不可忽略n为非正数情况；并且此时若为边界输入power(0., -1)，需考虑异常处理；<br>2. 考虑性能采用分治、位运算(二路分治、判断n奇偶)。</p> <pre><code>class Solution {public:    double Power(double base, int exponent) {        if (exponent < 0) {            // 无效输入            if (base == 0.)                throw "Invalid input: 0.0^n";            // 注意负指数的处理            exponent *= -1;            base = 1. / base;        }        return PowerCore(base, exponent);    }    double PowerCore(double base, int exponent) {        // 递归终止条件        if (exponent == 0)            return 1.;        if (exponent == 1)            return base;        // 分治法        double y = PowerCore(base, exponent >> 1);        return y * y * (exponent & 0x01? base: 1);    }};</code></pre></details> </li><li>【<strong>打印从$1$到最大的$n$位数</strong>】输入数字$n$，按顺序打印从$1$到最大的$n$位十进制数；<blockquote><p>相关题型：实现任意两个整数的加法；</p><details> <summary>点击查看提示</summary><p> 方法1：考虑大数情况(溢出)，用字符串或数组表达大数；方法2：数字排列； </p> </details></blockquote></li><li>【<strong>在$O(1)$时间内删除链表的节点</strong>】<strong>给定单向链表的头指针和一个节点指针，要求在$O(1)$时间内从链表中删除该节点；</strong><details> <summary>点击查看提示</summary><p> “腾出”下一个节点(覆盖本节点值后删除下一节点)；考虑只有一个节点、删除节点为尾节点的特殊情况，两种情况分别单独处理。 </p> </details></li><li>【<strong>*删除链表中重复节点</strong>】在排序链表中，删除重复的节点；<details> <summary>点击查看提示</summary><p> 题意要求 <br>1 -> 2 -> 3 -> 3 -> 4 -> 4 -> 5 <br>1 -> 2 -> 5 </p><pre><code>class Solution {public:    ListNode* deleteDuplication(ListNode* pHead) {        if (pHead == nullptr) return nullptr;        if (pHead->next == nullptr) return pHead;        // 首节点重复，需要被删除，直至值不同的节点        if (pHead->val == pHead->next->val) {            int val = pHead->val;            while (pHead && pHead->val == val) {                ListNode* pNext = pHead->next;                delete pHead;                pHead = pNext;            }            pHead = deleteDuplication(pHead);        // 不重复，从下一个节点开始处理，并连接首节点        } else {            ListNode* pNext = deleteDuplication(pHead->next);            pHead->next = pNext;        }        return pHead;    }};</code></pre><p> 保留一个重复节点的方法如下，即 <br>1 -> 2 -> 3 -> 3 -> 4 -> 4 -> 5 <br>1 -> 2 -> 3 -> 4 -> 5 </p><pre><code>class Solution {public:    ListNode* deleteDuplication(ListNode* pHead) {        if (pHead == nullptr) return nullptr;        ListNode* pNode = pHead;        while (pNode && pNode->next) {            // 存在重复            if (pNode->val == pNode->next->val) {                ListNode* pNext = pNode->next;                pNode->next = pNext->next;                delete pNext;            } else {                pNode = pNode->next;            }        }        return pHead;    }};</code></pre></details></li><li>【<strong>*正则表达式匹配</strong>】<strong>实现函数匹配<code>&#39;.&#39;</code>和<code>&#39;*&#39;</code>的正则表达式，<code>&#39;.&#39;</code>表示匹配任意字符，<code>&#39;*&#39;</code>表示它之前的字符可以在此处出现任意次(含$0$次)；</strong><blockquote><p>例如<code>&quot;aaa&quot;</code>与<code>&quot;a.a&quot;</code>、<code>&quot;ab*ac*a&quot;</code>匹配，但与<code>&quot;aa.a&quot;</code>或<code>&quot;ab*a&quot;</code>不匹配</p><details> <summary>点击查看解析</summary><p> 匹配形如("aaa", "a*(x* × n)a")的问题，只能考虑动态规划 </p> <pre><code>bool match(const char* str, const char* pattern) {    if (str == nullptr || pattern == nullptr) return false;    if (*str == '\0' && *pattern == '\0') return true;      // str, pattern 同时结束，匹配成功    if (*str != '\0' && *pattern == '\0') return false;     // pattern提前结束，匹配失败    // ---- str是否提前结束引起匹配失败，需考虑通配符'.'、`*`的处理 ----    char c = (*pattern == '.') ? *str : *pattern;           // 当前待匹配字符    if (*(pattern + 1) == '*') {                            // 出现"x*"的形式，处理任意个数匹配        if (*pattern == '.' && *(pattern + 2) == '\0')      // pattern = ".*\0" 匹配成功            return true;        int cnt = 0; for (; *(str + cnt) == c; cnt++);      // 统计c在str起始个数        for (int i = 0; i < cnt + 1; i++) {                 // 动态规划，任意字符个数方案，匹配遍历            bool matched = match(str + i, pattern + 2);            if (matched) return true;       // 只需一种方案匹配成功        }        return false;                       // 全部方案均匹配失败    }    else {        if (*str == '\0') return false;     // str提前结束，匹配失败        if (c != *str) return false;        // 字符不相同，匹配失败        return match(str + 1, pattern + 1); // 继续下一字符匹配    }}void Test(const char* testName, const char* string, const char* pattern, bool expected){    if (testName != nullptr)        printf("%s begins: ", testName);    if (match(string, pattern) == expected)        printf("Passed.\n");    else        printf("FAILED.\n");}int main(int argc, char* argv[]){    Test("Test01", "", "", true);    Test("Test02", "", ".*", true);    Test("Test03", "", ".", false);    Test("Test04", "", "c*", true);    Test("Test05", "a", ".*", true);    Test("Test06", "a", "a.", false);    Test("Test07", "a", "", false);    Test("Test08", "a", ".", true);    Test("Test09", "a", "ab*", true);    Test("Test10", "a", "ab*a", false);    Test("Test11", "aa", "aa", true);    Test("Test12", "aa", "a*", true);    Test("Test13", "aa", ".*", true);    Test("Test14", "aa", ".", false);    Test("Test15", "ab", ".*", true);    Test("Test17", "aaa", "aa*", true);    Test("Test18", "aaa", "aa.a", false);    Test("Test19", "aaa", "a.a", true);    Test("Test20", "aaa", ".a", false);    Test("Test21", "aaa", "a*a", true);    Test("Test22", "aaa", "ab*a", false);    Test("Test23", "aaa", "ab*ac*a", true);    Test("Test24", "aaa", "ab*a*c*a", true);    Test("Test25", "aaa", ".*", true);    Test("Test26", "aab", "c*a*b", true);    Test("Test27", "aaca", "ab*a*c*a", true);    Test("Test28", "aaba", "ab*a*c*a", false);    Test("Test29", "bbbba", ".*a*a", true);    Test("Test30", "bcbbabab", ".*a*a", false);    return 0;}</code></pre></details></blockquote></li><li>【<strong>调整数组顺序使奇数位于偶数前 I</strong>】输入整数数组，实现函数使整数前半部分为奇数，后半部分为偶数； <details> <summary>点击查看解析</summary><p> 用快速排序中，大小数据分组的思想，时间复杂度O(n) </p> <pre><code>class Solution {public:    void reOrderArray(vector&lt;int&gt;& array) {        int l = 0, r = array.size() - 1;        while (l <= r) { 向右查找第一个偶数 while (l < array.size() && array[l] & 0x01) l++; 向左查找第一个奇数 (r>= 0 && !(array[r] & 0x01)) r--;            // 交换            if (l <= r) { int t="array[l];" array[l]="array[r];" array[r]="t;" } }; < code></=></=></code></pre></details></li><li><p>【<strong>调整数组顺序使奇数位于偶数前 II</strong>】输入整数数组，实现函数使整数前半部分为奇数，后半部分为偶数，要求奇数和奇数，偶数和偶数之间的相对位置不变；</p><details> <summary>点击查看解析</summary><p> 空间复杂度、时间复杂度都是O(n)的解法。 </p> <pre><code>class Solution {public:    void reOrderArray(vector&lt;int&gt;& array) {        vector&lt;int&gt; odd, even;        for (int num : array) {            if (num & 0x01)                odd.push_back(num);            else                even.push_back(num);        }        odd.insert(odd.end(), even.begin(), even.end());        array = odd;    }};</code></pre></details></li><li><p>【<strong>链表中倒数第$k$个节点</strong>】<strong>输入一个单向链表，输出倒数第$k$个节点(符合大多数人情况，$k$不是索引)；</strong></p><blockquote><p>相关题型：找到链表的中间节点。</p><details> <summary>点击查看提示</summary><p> “先后指针”，时间复杂度O(n)；注意k范围，大于0且不能超过链表长度； </p> <pre><code>class Solution {public:    ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) {        if (pListHead == nullptr) return nullptr;        // 先走k步        ListNode* fast = pListHead;        while (k > 0) {            // 长度不足k            if (fast == nullptr)                return nullptr;            fast = fast->next; k--;        }        // 走完链表        ListNode* slow = pListHead;        while (fast) {            fast = fast->next;            slow = slow->next;        }        return slow;    }};</code></pre></details></blockquote></li><li>【<strong>*链表中环的入口节点</strong>】若一个单向链表由于误操作产生了环，如何确定环的入口节点位置？<details> <summary>点击查看提示</summary><p> 快慢指针；子问题：是否包含环、确定环的长度(节点个数)； </p> <pre><code>class Solution {public:    ListNode* EntryNodeOfLoop(ListNode* pHead) {        if (pHead == nullptr) return nullptr;        ListNode* fast = pHead;        ListNode* slow = pHead;        // --------- 是否包含环 ---------        while (fast->next) {            fast = fast->next->next;            slow = slow->next;            // 追及相遇            if (fast == slow) break;        }        // 不包含环        if (!fast->next) return nullptr;        // --- 包含环，此时为公共节点 ---        slow = pHead;        while (fast != slow) {            fast = fast->next;            slow = slow->next;        }        return slow;    }};</code></pre></details></li><li>【<strong>*反转链表</strong>】将一个单向链表中的节点反转，输出反转后链表的头节点；<details> <summary>点击查看解析</summary><pre><code>ListNode * reverse(ListNode * head) {    if (!head) return nullptr;    ListNode* oriHead = head;    ListNode* node = head->next;    while(node){        ListNode* temp = node->next;    // 下个待操作节点，防止被覆盖        oriHead->next = node->next;     // 本来的头节点后移        node->next = head;              // node移动到当前头节点前        head = node;                    // 更新当前头节点        node = temp;    }    return head;}</code></pre><pre><code>class Solution {public:    ListNode* ReverseList(ListNode* pHead) {        if (pHead == nullptr)            return nullptr;        // 递归查找尾节点        if (pHead->next == nullptr)            return pHead;        ListNode* ret = ReverseList(pHead->next);        // 修改指针方向        pHead->next->next = pHead;        pHead->next = nullptr;        return ret;    }};</code></pre></details></li><li>【<strong>合并两个排序的链表</strong>】输入两个递增的链表，合并两个链表使新链表中的节点仍然是递增的，如<code>1 -&gt; 3 -&gt; 5 -&gt; 7 -&gt; null</code>和<code>2 -&gt; 4 -&gt; 6 -&gt; 8 -&gt; null</code>合并为<code>1 -&gt;2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 8 -&gt; null</code>；<details> <summary>点击查看解析</summary><p> 难度不大；可用递归实现 </p><pre><code>class Solution {public:    ListNode* Merge(ListNode* pHead1, ListNode* pHead2) {        if ((!pHead1) && (!pHead2)) {            return nullptr;        } else if (!pHead1) {            return pHead2;        } else if (!pHead2) {            return pHead1;        } else {            ListNode* pHead = nullptr;            ListNode* pNode = nullptr;            ListNode* pNode1 = pHead1;            ListNode* pNode2 = pHead2;            while (pNode1 && pNode2) {                if (pNode1->val > pNode2->val) {                    if (!pHead) {                        pHead = pNode = pNode2;                    } else {                        pNode->next = pNode2;                        pNode = pNode->next;                    }                    pNode2 = pNode2->next;                } else {                    if (!pHead) {                        pHead = pNode = pNode1;                    } else {                        pNode->next = pNode1;                        pNode = pNode->next;                    }                    pNode1 = pNode1->next;                }            }            if (pNode1) pNode->next = pNode1;            if (pNode2) pNode->next = pNode2;            return pHead;        }    }};</code></pre></details></li><li>【<strong>*树的子结构</strong>】输入二叉树A和B，判断B是否为A的子结构；<details> <summary>点击查看解析</summary><pre><code>class Solution {public:    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) {        // 空树不是任何树的子结构        if (pRoot2 == nullptr || pRoot1 == nullptr) return false;        // 匹配树当前节点值        if (matchSubtree(pRoot1, pRoot2)) return true;        // 匹配树左、右子树        if (HasSubtree(pRoot1->left, pRoot2)) return true;        if (HasSubtree(pRoot1->right, pRoot2)) return true;    }    bool matchSubtree(TreeNode* pRoot1, TreeNode* pRoot2) {        // 模板树已空，匹配成功        if (!pRoot2) return true;        // 模板树未空，而匹配树空，匹配失败        if (!pRoot1) return false;        // 节点匹配失败        if (pRoot1->val != pRoot2->val) return false;        // 需要左右子树同时匹配        bool matchL = matchSubtree(pRoot1->left, pRoot2->left);        bool matchR = matchSubtree(pRoot1->right, pRoot2->right);        return matchL && matchR;    }};</code></pre></details></li><li>【<strong>树的镜像</strong>】输入二叉树，输出该树的镜像；<details> <summary>点击查看提示</summary><p> 二叉树子节点翻转 </p> <pre><code>class Solution {public:    void Mirror(TreeNode *pRoot) {        if (!pRoot) return;        // 翻转本节点        TreeNode* temp = pRoot->left;        pRoot->left = pRoot->right;        pRoot->right = temp;        // 递归翻转子树        Mirror(pRoot->left);        Mirror(pRoot->right);    }};</code></pre></details></li><li>【<strong>对称的二叉树</strong>】<strong>输入二叉树，判断是否对称；</strong><details> <summary>点击查看解析</summary><p> 可用递归实现；编写函数`isSymmetric(TreeNode*, TreeNode*)`判断两个节点为根的子树是否对称 </p><pre><code>class Solution {public:    bool isSymmetrical(TreeNode* pRoot) {        return isSymmetrical(pRoot, pRoot);    }    bool isSymmetrical(TreeNode* pRoot1, TreeNode* pRoot2) {        // 两棵空树，对称        if (!pRoot1 && !pRoot2) return true;        // 仅有一棵空，不对称        else if (!pRoot1 || !pRoot2) return false;        // 本节点是否对称        if (pRoot1->val != pRoot2->val) return false;        // 递归，左右子树是否对称        return isSymmetrical(pRoot1->left, pRoot2->right) &&            isSymmetrical(pRoot1->right, pRoot2->left);    }};</code></pre></details></li><li>【<strong>顺时针打印矩阵</strong>】输入矩阵，左上角元素开始按照从外向内的顺序，依次打印每个数字；<details> <summary>点击查看提示</summary><p> 将矩阵看作若干个圈，递归打印输出 </p><pre><code>/*1  2  3  45  6  7  89 10 11 1213 14 15 16*/class Solution {public:    vector&lt;int&gt; printMatrix(vector<vector&lt;int&gt;> matrix) {        vector&lt;int&gt; ret;        int rows = 0, cols = 0;        // 矩阵的第一行        if (!checkMatrix(matrix, rows, cols)) return ret;        for (int c = 0; c < cols; c++) {            ret.push_back(matrix[0][c]);        }        matrix.erase(matrix.begin());        // 矩阵的最后列        if (!checkMatrix(matrix, rows, cols)) return ret;        for (int r = 0; r < rows; r++) {            ret.push_back(matrix[r][cols - 1]);            matrix[r].erase(matrix[r].end() - 1);        }        // 矩阵的最后行        if (!checkMatrix(matrix, rows, cols)) return ret;        for (int c = cols - 1; c >= 0; c--) {            ret.push_back(matrix[rows - 1][c]);        }        matrix.erase(matrix.end() - 1);        // 矩阵的第一列        if (!checkMatrix(matrix, rows, cols)) return ret;        for (int r = rows - 1; r >= 0; r--) {            ret.push_back(matrix[r][0]);            matrix[r].erase(matrix[r].begin());        }        // 递归打印内圈，插入`ret`        vector&lt;int&gt; inside = printMatrix(matrix);        ret.insert(ret.end(), inside.begin(), inside.end());        return ret;    }    bool checkMatrix(const vector<vector&lt;int&gt;>& matrix, int& rows, int& cols) {        rows = matrix.size();        if (rows == 0) {            return false;        }        cols = matrix[0].size();        if (cols == 0) {            return false;        }        return true;    }};</vector&lt;int&gt;></vector&lt;int&gt;></code></pre></details></li><li>【<strong>*包含<code>max</code>的栈</strong>】定义栈的数据结构，实现一个能得到最大元素的函数<code>max</code>，且$\rm{min, push, pop}$时间复杂度都是$O(1)$；<details> <summary>点击查看提示</summary><p>辅助栈，每次数据栈压入数据时，将当前最大值压入辅助栈，出栈时两个栈同时出栈；<br> 也可在压入数据为<b>不小于</b>当前最大值时(考虑压入同一个数据的情况)，对辅助栈进行压入，出栈时若数据为最大值(辅助栈栈顶数据)，辅助栈也出栈，如下。</p> <pre><code>class StackWithMax {public:    StackWithMax() {}    void push(int value) {        // 空，或者栈顶不小于`value`        if (mins.empty() || \                mins.top() >= value)            mins.push(value);        nums.push(value);    }    void pop() {        if (nums.size() == 0) return;        // `nums`栈顶等于`mins`栈顶        if (mins.top() == nums.top())            mins.pop();        nums.pop();    }    int top() {        if (nums.size() == 0) return 0;        return nums.top();    }    int min() {        if (mins.size() == 0) return 0;        return mins.top();    }private:    stack<int> nums;    stack<int> mins;};</int></int></code></pre></details></li><li>【<strong>*包含最大值的队列</strong>】定义队列实现<code>max</code>函数，时间复杂度为$O(1)$得到队列的最大值；<details> <summary>点击查看解析</summary><p> 借用辅助队列，使辅助队列头部为当前最大值，并保证：1)数据降序排列(都为当前出队列后的最大值)、2)辅助队列长度与数据队列一致 </p><pre><code>class QueueWithMax{public:    QueueWithMax() {}    void push(const T& x) {        if (nums.empty()) {            nums.push(x); maxs.push(x); return;        }        nums.push(x);        // update maximum        for (int i = 0; i < maxs.size(); i++) {            // 保证队列内单调            maxs.push(maxs.front() > x ? maxs.front() : x);            maxs.pop();        }        maxs.push(x);    }    void pop() {        if (nums.empty()) throw "queue is empty!";        nums.pop(); maxs.pop();    }    const T max() const {        if (nums.empty()) throw "queue is empty!";        return maxs.front();    }private:    queue&lt;int&gt; nums;    queue&lt;int&gt; maxs;};</code></pre><p> 上面方案的入队列push(x)时间复杂度为O(n)，改进方法是，队列内只保存最大值，并保存相应标记(如计数符号)，当出数据队列元素标记与辅助队列头部元素标记一致，则进行辅助队列的弹出，这样时间复杂度为O(1)；并借助<b>两端开口的队列</b>； </p><p>例如对于{1, 3, 5, 2}，相应辅助队列为{5, 5, 5, 2}。当4入队列后，辅助队列变为{5, 5, 5, 4, 4}</p><pre><code>class QueueWithMax{    typedef pair&lt;int, int&gt; element;public:    QueueWithMax() : idx(0) {}    void push(const int& x) {        element e = make_pair(idx++, x);        nums.push_back(e);        // is empty        if (nums.empty()) {            nums.push_back(e); maxs.push_back(e); return;        }        // update maximum        while (maxs.size() > 0 && maxs.back().second < x) {            maxs.pop_back();        }        maxs.push_back(e);    }    void pop() {        if (nums.empty()) throw "queue is empty!";        if (nums.front().first == maxs.front().first) {            maxs.pop_front();        }        nums.pop_front();    }    const int max() const {        if (nums.empty()) throw "queue is empty!";        return maxs.front().second;    }private:    int idx;    deque&lt;element&gt; nums;    deque&lt;element&gt; maxs;};</code></pre></details></li><li>【<strong>栈的压入、弹出序列</strong>】输入两个整数序列(假设数字均不相等)，第一个表示栈的压入顺序，判断第二个是否可能为该栈的弹出顺序。<blockquote><p>如：若压栈序列为${1, 2, 3, 4, 5}$，那么${4, 5, 3, 2, 1}$可能为该栈的出栈序列，而${4, 5, 3, 1, 2}$不可能；<br>相关内容：共有多少种出栈顺序(卡特兰数)。</p><details> <summary>点击查看解析</summary><pre><code>class Solution {public:    bool IsPopOrder(vector&lt;int&gt; pushV, vector&lt;int&gt; popV) {        stack<int> s;        // 入栈，过程中把能出栈的数删除        for (int num : pushV) {            if (num == popV[0])                popV.erase(popV.begin());            else                s.push(num);        }        // 顺序出栈        while (s.size() > 0) {            if (s.top() != popV[0])                return false;            popV.erase(popV.begin());            s.pop();        }        return true;    }};</int></code></pre></details></blockquote></li><li>【<strong>从上到下打印二叉树</strong>】从上到下打印出二叉树的每个节点，同一层按从左到右的顺序打印；<details> <summary>点击查看解析</summary><p> 层次遍历，广度优先搜索(BFS) </p><pre><code>class Solution {public:    vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) {        vector&lt;int&gt; ret;        if (!root) return ret;        // bfs        queue&lt;TreeNode*&gt; q;        q.push(root);        while (q.size() > 0) {            // 队首出队列            TreeNode* node = q.front();            ret.push_back(node->val);            q.pop();            // 左右子节点入队列            if (node->left)                q.push(node->left);            if (node->right)                q.push(node->right);        }        return ret;    }};</code></pre></details></li><li>【<strong>从上到下打印二叉树</strong>】从上到下打印出二叉树的每个节点，<strong>要求层间分行</strong>，同一层按从左到右的顺序打印；<details> <summary>点击查看解析</summary><pre><code>class Solution {public:    vector<vector&lt;int&gt;> Print(TreeNode* pRoot) {        vector<vector&lt;int&gt;> ret;        if (!pRoot) return ret;        // bfs        vector&lt;int&gt; line;        queue&lt;TreeNode*&gt; q;        q.push(pRoot);        q.push(nullptr);        while (q.size() > 0) {            // 队首出队列            TreeNode* node = q.front();            q.pop();            // 遇到换行标记            if (!node) {                // 更新返回结果                ret.push_back(line);                line = vector&lt;int&gt;();                // 如果队列只剩换行标记，那么遍历结束                if (q.size() == 0) break;                // 加入新的换行标记                q.push(nullptr);                continue;            }            // 更新本行数据            line.push_back(node->val);            // 左右子节点入队列            if (node->left)                q.push(node->left);            if (node->right)                q.push(node->right);        }        return ret;    }};</vector&lt;int&gt;></vector&lt;int&gt;></code></pre></details></li><li>【<strong>从上到下打印二叉树</strong>】从上到下打印出二叉树的每个节点，<strong>要求层间分行</strong>，且从左到右、从右往左循环(“之”字形)的顺序打印；<details> <summary>点击查看解析</summary><p> 新增`left2right`标记位，交替从左到右从右到左 </p><pre><code>class Solution {public:    vector<vector&lt;int&gt;> Print(TreeNode* pRoot) {        vector<vector&lt;int&gt;> ret;        if (!pRoot) return ret;        // bfs        vector&lt;int&gt; line;        bool left2right = true;             // 方向标记        queue&lt;TreeNode*&gt; q;        q.push(pRoot);        q.push(nullptr);        while (q.size() > 0) {            // 队首出队列            TreeNode* node = q.front();            q.pop();            // 遇到换行标记            if (!node) {                // 更新返回结果                if (!left2right)            // 方向标记                    reverse(line.begin(), line.end());                ret.push_back(line);                line = vector&lt;int&gt;();                // 如果队列只剩换行标记，那么遍历结束                if (q.size() == 0) break;                // 加入新的换行标记                q.push(nullptr);                left2right = !left2right;   // 方向标记                continue;            }            // 更新本行数据            line.push_back(node->val);            // 左右子节点入队列            if (node->left)                q.push(node->left);            if (node->right)                q.push(node->right);        }        return ret;    }};</vector&lt;int&gt;></vector&lt;int&gt;></code></pre></details></li><li>【<strong>*二叉搜索树的后序遍历序列</strong>】输入整数数组，判断该数组是否为某二叉搜索树的后序遍历结果，树中节点值无重复；<details> <summary>点击查看解析</summary><p> 例如数组`[5, 7, 6, 9, 11, 10, 8]`，先以`8`为根节点，将序列划分为左右子树`[5, 7, 6]`和`[9, 11, 10]`，此时左子树序列内数字都应该小于`8`，右侧都大于`8`，若满足条件，递归判断左右子树 </p><pre><code>class Solution {public:    bool VerifySquenceOfBST(vector&lt;int&gt; sequence) {        int n = sequence.size();        if (n == 0) return false;        if (n <= 1) return true; 根节点值 int rootval="sequence[n" - 1]; 划分左右子树 auto rbegin="sequence.begin();" while (rbegin !="sequence.end()" && \ * < rootval) rbegin++; 右子树内是否包含小于`rootval`的值 for (auto it="rBegin;" it++) { if (*it false; } 递归，添加判断防止数组越界 子树序列长度必须`>= 1`，否则与`if (n == 0) return false;`冲突        bool lValid = true;        if (rBegin > sequence.begin() + 1)            lValid = VerifySquenceOfBST(                vector&lt;int&gt;(sequence.begin(), rBegin - 1));        bool rValid = true;        if (rBegin < sequence.end() - 1)            rValid = VerifySquenceOfBST(                vector&lt;int&gt;(rBegin, sequence.end() - 1));        return lValid && rValid;    }};</=></code></pre></details></li><li>【<strong>二叉树中和为某值的路径</strong>】给定二叉树和某值，求二叉树中根节点到叶子节点值的和为给定数值的全部路径；<details> <summary>点击查看解析</summary><pre><code>class Solution {public:    vector<vector&lt;int&gt;> FindPath(TreeNode* root,int expectNumber) {        vector<vector&lt;int&gt;> paths;        // dfs        FindPathCore(root, expectNumber, {}, paths);        return paths;    }    void FindPathCore(TreeNode* root, int expectNumber,             vector&lt;int&gt; path, vector<vector&lt;int&gt;>& paths) {        if (root == nullptr) {            return;        }        // 本节点计入路程        path.push_back(root->val);        expectNumber -= root->val;        // 若无左右子树，即到达叶子节点，判断路程是否符合条件        if (root->left == nullptr and root->right == nullptr) {            if (expectNumber == 0)                paths.push_back(path);            return;        }        // 递归左右子树        FindPathCore(root->left,  expectNumber, path, paths);        FindPathCore(root->right, expectNumber, path, paths);    }};</vector&lt;int&gt;></vector&lt;int&gt;></vector&lt;int&gt;></code></pre></details></li><li>【<strong>复杂链表的复制</strong>】实现复杂链表的复制，复杂链表节点定义如下，其中<code>m_pSibing</code>指针保存链表内另一个节点的地址：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RandomListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> label;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RandomListNode</span> *<span class="title">next</span>, *<span class="title">random</span>;</span></span><br><span class="line">    RandomListNode(<span class="keyword">int</span> x) :</span><br><span class="line">            label(x), next(<span class="literal">NULL</span>), random(<span class="literal">NULL</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><details> <summary>点击查看解析</summary><p>方法一：先复制链表前向部分，再复制支路部分，由于定位一个节点的sibing需要O(n)的搜索速度，总的时间复杂度为O(n^2)；<br>方法二：先复制链表前向部分，并在过程中创建哈希表建立原链表节点到复制链表节点的映射，那么每个节点的sibing只需O(1)即可定位，辅助空间为O(n)，时间复杂度O(n)，是一种空间换时间的方案；<br>方法三：在原链表每个节点后，插入节点的复制(“->N->N'->”的形式)，并相应拷贝sibing信息，然后将连个链表拆开，时间复杂度为O(n)，且无辅助空间。</p><pre><code>class Solution {public:    RandomListNode* Clone(RandomListNode* pHead) {        if (pHead == nullptr) return nullptr;        // 在每个节点后插入复制节点        RandomListNode* pNode = pHead;        while (pNode) {            RandomListNode* pCopy = new RandomListNode(pNode->label);            pCopy->next = pNode->next;            pNode->next = pCopy;            // 下一节点            pNode = pNode->next->next;        }        // 复制复杂链表指针        pNode = pHead;        while (pNode) {            // 注意`pNode->random`为空的判断            if (pNode->random)                pNode->next->random = pNode->random->next;            // 下一节点            pNode = pNode->next->next;        }        // 分离链表        RandomListNode* pCloneHead = nullptr;        RandomListNode* pCloneNode = nullptr;        pNode = pHead;        while (pNode) {            RandomListNode* pNext = pNode->next->next;            // 连接复制的节点            if (pCloneHead == nullptr) {                pCloneHead = pCloneNode = pNode->next;            }            else {                pCloneNode->next = pNode->next;                pCloneNode = pCloneNode->next;            }            // 连接原链表节点            pNode->next = pNext;            // 下一节点            pNode = pNode->next;        }        return pCloneHead;    }};</code></pre></details></li><li>【<strong>*二叉搜索树和双向链表</strong>】将一棵二叉搜索树转换成排序的双向链表，要求不能创建新节点，只能调整节点指针信息(<code>left, right</code>分别对应<code>prev, next</code>)；<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) :</span><br><span class="line">            val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>如二叉树${4, 2, 5, 1, 3}$转换为链表$1 \leftrightarrow 2 \leftrightarrow 3 \leftrightarrow 4 \leftrightarrow 5$</p><details> <summary>点击查看解析</summary><pre><code>class Solution {public:    TreeNode* Convert(TreeNode* pRootOfTree) {        TreeNode* pHead = nullptr; TreeNode* pTail = nullptr;        ConvertCore(pRootOfTree , &pHead, &pTail);        return pHead;    }    void ConvertCore(TreeNode* pRoot, TreeNode** pHead, TreeNode** pTail) {        if (!pRoot) return;        // 后序遍历        TreeNode* pHeadL = nullptr; TreeNode* pTailL = nullptr;        ConvertCore(pRoot->left, &pHeadL, &pTailL);        TreeNode* pHeadR = nullptr; TreeNode* pTailR = nullptr;        ConvertCore(pRoot->right, &pHeadR, &pTailR);        // 左侧，需考虑左子树是否存在的问题        if (pHeadL) {            pTailL->right = pRoot;            pRoot->left = pTailL;            *pHead = pHeadL;        } else {            *pHead = pRoot;        }        // 右侧，需考虑右子树是否存在的问题        if (pHeadR) {            pHeadR->left = pRoot;            pRoot->right = pHeadR;            *pTail = pTailR;        } else {            *pTail = pRoot;        }    }};</code></pre></details></blockquote></li><li>【<strong>*字符串的排列</strong>】输入一个字符串，打印出该字符串中字符的所有排列；<blockquote><p>如输入<code>&quot;abc&quot;</code>，所有排列为<code>&quot;abc&quot;, &quot;acb&quot;, &quot;bac&quot;, &quot;bca&quot;, &quot;cab&quot;, &quot;cba&quot;</code>；<br>相关题型：</p><ol><li>求字符的所有排列，包含$1,2,3$个字符的组合；</li><li>将$8$个数字放置在正方体的$8$个顶点上，判断是否有可能使相对的三组平面，四个顶点之和相等；</li><li>八皇后问题：在$8 \times 8$棋盘上放置$8$个皇后，使皇后间不能相互攻击(不在同一列、同一行、同一对角线上)，问有多少种摆法？<details> <summary>点击查看解析</summary><pre><code>class Solution {public:vector<string> Permutation(string str) {   vector<string> ret;   // 终止条件1：字符串空   if (str.size() == 0) return ret;   // 终止条件2：只有一个字符   if (str.size() == 1) {       ret.push_back(str);       return ret;   }   // 固定首字符   char ch = str[0];   // 剩余字符递归组合   vector<string> subper = Permutation(str.substr(1));   // 组合首字符   for (string sp : subper) {       int n = sp.size();       // 将首字符插入到字符串各个位置中       for (int i = 0; i < n + 1; i++) {           string spc(sp);           spc.insert(spc.begin() + i, ch);           // 顺序查找，去重           if (find(ret.begin(), ret.end(), spc) == ret.end())               ret.push_back(spc);       }   }   sort(ret.begin(), ret.end());   return ret;}};</string></string></string></code></pre></details></li></ol></blockquote></li><li>【<strong>*数组中出现次数超过一半的数字</strong>】数组中有一个数字出现的次数超过数组长度的一半，找出该数字；<details> <summary>点击查看解析</summary><p> 排序后数组中间的数即超过数组长度的一半的数，也就是寻找统计意义的中位数；即寻找第n/2个数，快速排序。 </p> <pre><code>class Solution {public:    // 设置全局标志位，结果是否有效    bool isValid = false;    int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) {        int n = numbers.size();        // 边界条件！        if (n == 1) return numbers[0];        // 找中位数        int t = (n + 1) / 2;        quickSort(numbers, 0, n, t);        return isValid? numbers[t]: 0;    }    void quickSort(vector&lt;int&gt;& numbers, int begin, int end, int target) {        if (end - begin <= 1) return; 左右分区 int index="partition(numbers," begin, end); 找到该位置的数，直接退出不继续排序 if (index="=" target) { isvalid="true;" } 递归 quicksort(numbers, index, target); + 1, end, partition(vector&lt;int&gt;& numbers, end) pivot="numbers[begin];" l="begin," r="end" - 1; while (true) (l < end && numbers[l] l++; (r>= begin && numbers[r] >  pivot) r--;            if (l >= r) break;            // 交换            int t = numbers[l];            numbers[l] = numbers[r];            numbers[r] = t;        }        // 交换        numbers[begin] = numbers[l - 1];        numbers[l - 1] = pivot;        return l - 1;    }};</=></code></pre></details></li><li>【<strong>最小的$k$个数</strong>】<strong>找出数组中最小的$k$个数；</strong><details> <summary>点击查看解析</summary><p> 1. 在能修改原数组元素位置的情况下，可以采用快速排序的算法，时间复杂度O(n)；</p> <p> 2. 若不能修改元素位置，可以开辟容量为k的容器，初始化为数组前k个数，然后后续数字依次进入，若小于其中的元素将其替换；考虑到每次都是与容器内最大元素比较，可采用最大堆；该方案时间复杂度O(nlogk)，但适合海量数据的搜索问题。 </p> <pre><code>class Solution {public:    vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) {        int n = input.size();        // 数据量不足k，返回空        if (n < k) return {};        // 求前k小的数字        vector&lt;int&gt; ret;        make_heap(input.begin(), input.end(), greater<int>());        while (k-- > 0 && input.size() > 0) {            pop_heap(input.begin(), input.end(), greater<int>());            ret.push_back(*(input.end() - 1));            input.pop_back();        }        return ret;    }};</int></int></code></pre></details></li><li>【<strong>数据流的中位数</strong>】求取数据流的中位数，数据数目随时间变化而增加；<details> <summary>点击查看解析</summary><p> 最好的解决方法是AVLTree，但实现较为复杂。 </p> <p> 用一个最大堆存放数据中较小的一半数据，用最小堆存放数据中较大的一般数据；<b>始终保证两个堆元素数目之差不大于1、最小堆堆顶数据大于最大堆堆顶</b>；堆顶数据即中位数附近的数。 </p> <pre><code>template&lt;typename T&gt;class MedianOfDataflow{public:    MedianOfDataflow() {}    void push(T& x) {        if (lessData.size() + greaterData.size() == 0) {            lessData.push_back(x);             push_heap(lessData.begin(), lessData.end(), greater&lt;T&gt;());            return;        }        // “较小一半”个数较多，此时应插入“较大一半”        if (lessData.size() > greaterData.size()) {            // 插入数据小于“较小一半”最大            // 若直接插入，会导致“较大一半”堆顶小于“较小一半”堆顶            // 将“较小一半”堆顶数据放置到“较大一半”中，该值将成为“较大一半”堆顶            if (x < lessData[0]) {                greaterData.push_back(lessData[0]);                 pop_heap(lessData.begin(), lessData.end(), less&lt;T&gt;());                 lessData.pop_back();                push_heap(greaterData.begin(), greaterData.end(), greater&lt;T&gt;());            }            greaterData.push_back(x);             push_heap(greaterData.begin(), greaterData.end(), greater&lt;T&gt;());        }        // “较大一半”个数较多，此时应插入“较小一半”        else {            if (x > greaterData[0]) {                lessData.push_back(greaterData[0]);                 pop_heap(greaterData.begin(), greaterData.end(), less&lt;T&gt;());                 greaterData.pop_back();                push_heap(lessData.begin(), lessData.end(), less&lt;T&gt;());            }            lessData.push_back(x);             push_heap(lessData.begin(), lessData.end(), less&lt;T&gt;());        }    }    T get() const {        if (greaterData.size() == 0 && lessData.size() == 0)            throw "无数据！";        if (greaterData.size() == lessData.size())            return (greaterData[0] + lessData[0]) / 2;        else if (greaterData.size() > lessData.size())            return greaterData[0];        else             return lessData[0];    }private:    vector&lt;T&gt; lessData;     // 存放较小一半数据    vector&lt;T&gt; greaterData;  // 存放较大一半数据};</code></pre></details></li><li>【<strong>连续子数组的最大和</strong>】给定整数数组，有正数也有负数，数组中一个或连续多个整数构成子数组，求子数组和的最大值；</li><li>【<strong>*$1 \sim n$整数中$1$出现的次数</strong>】<strong>给定$n$，求$1 \sim n$的整数中，$1$共出现了几次；</strong><details> <summary>点击查看解析</summary><pre><code>class Solution {public:    int NumberOf1Between1AndN_Solution(int n) {        int count = 0;  // 1的个数        int i = 1;      // 当前位        int current = 0, after = 0, before = 0;        while ((n / i) != 0) {            // n = 21345, i = 2 -> 213, 4, 5            current = (n / i) % 10;     // 高位数字            before = n / (i * 10);      // 当前位数字            after = n - (n / i) * i;    // 低位数字            // 如果为0,出现1的次数由高位决定, 高位数字 * 当前位数            if (current == 0)                count += before * i;            // 如果为1,出现1的次数由高位和低位决定, 高位 * 当前位 + 低位 + 1            else if (current == 1)                count += before * i + after + 1;            // 如果大于1,出现1的次数由高位决定,（高位数字 + 1）* 当前位数            else {                count += (before + 1) * i;            }            //前移一位            i = i * 10;        }        return count;    }};</code></pre></details></li><li>【<strong>*数字序列中某位的数字</strong>】将自然数序列化为字符串<code>&quot;012345678910111213...&quot;</code>的形式，输入$n$，确定该序列内索引为$n$的字符对应的数字；<details> <summary>点击查看解析</summary><p> 注意1位数、2位数、3位数……的个数 </p> <pre><code>class Solution {public:    int digitsInSequence(int n)    {        if (n <= 0) return 0; ------------- 确认位于几位数范围内 int order="0;" 阶次，order + 1表示当前位于几位数范围内 cntnumseqskip="1;" 序列化后跳过字符的数目 while (true) { cntnum="9" * pow(10, order); (order 1)位数的总个数 cntnumseq="cntNum" 1); 1)位数序列化后字符总个数 添加后不超过n，则可跳过 if (cntnumseqskip < n) order++; 确定位数范围 } else break; ------------------ 确定该数 inumseq="n" - cntnumseqskip; 1)位数序列化后，第inumseq个字符 inum="iNumSeq" 1)位数中第inum个数字 base="pow(10," 1)位数的第1个数字，如3位数第一个数字是100 number="base" inum; 获取该数 iseq="iNumSeq" % 该数序列化后第iseq位字符(一共inumseq位，每个数占(order 1)位，相除即第几个数) digit="(number" (int)pow(10, iseq)) 10; 求这个数序列化后第iseq位字符对应的数字 digit; }; code></=></code></pre></details></li><li>【<strong>*把数组排成最小的数</strong>】输入正整数数组，把数组中的数字拼接起来排成一个数，使数字最小；<details> <summary>点击查看解析</summary><p>关键是排序规则的制定</p><pre><code>class Solution {public:    string PrintMinNumber(vector&lt;int&gt; numbers) {        int len = numbers.size();        // 边界条件        if (len == 0) return "";        // 排序        sort(numbers.begin(), numbers.end(), cmp);        // 组合结果        string res;        for (int i = 0; i < len; i++)            res += to_string(numbers[i]);        return res;    }    static bool cmp(int a, int b) {        // 将a、b组合后对比进行排序        string A = to_string(a) + to_string(b);        string B = to_string(b) + to_string(a);        return A < B;    }};</code></pre></details></li><li>【<strong>数字翻译为字符串</strong>】给定数字，按照如下规则翻译为字符串：$0 \rightarrow a, 1 \rightarrow b, \cdots, 25 \rightarrow z$，问该数可翻译成几种<blockquote><p>如输入$12258$，有<code>&quot;bccfi&quot;, &quot;bwfi&quot;</code>等多种翻译方法。</p><details> <summary>点击查看解析</summary><p> 动态规划 </p> <pre><code>class Solution {public:    int translateNum(int num) {        string str = to_string(num);        int n = str.size();        // 动态规划        vector&lt;int&gt; dp(n + 1, 0);        // 填表        for (int i = 0; i < n + 1; i++) {            // 边界条件：空字符、第一个字符            if (i <= 1) { dp[i]="1;" continue; } 单个字符一定能转换 - 1]; 两个字符 string substr="str.substr(i" 2, 2); 连续0只能翻译为一位，两位不符合转换条件 if (substr[0]="=" '0' || stoi(substr)> 25) continue;            dp[i] += dp[i - 2];        }        return dp[n];    }};</=></code></pre></details></blockquote></li><li>【<strong>礼物的最大价值</strong>】在一个$m \times n$的棋盘，每一格都放有一个礼物，每个礼物具有价值(大于0)，从棋盘左上开始，每次向左或向下移动一格，直到棋盘右下角，计算最多能拿到多少价值；<details> <summary>点击查看解析</summary><p> 动态规划；用递归的思路，设计循环的程序以提高性能；用表格的形式求解，不必保存所有中间结果。 </p> <pre><code>class Solution {public:    int maxValue(vector&lt;vector&lt;int&gt;&gt;& grid) {        int rows = grid.size();        if (rows == 0) return 0;        int cols = grid[0].size();        if (cols == 0) return 0;        // 动态规划填表        vector&lt;vector&lt;int&gt;&gt; dp(rows, vector&lt;int&gt;(cols, 0));        for (int r = 0; r < rows; r++) {            for (int c = 0; c < cols; c++) {                // 边界条件和状态转移方程                if (r == 0 && c == 0)                    dp[r][c] = grid[r][c];                else if (r == 0)                    dp[r][c] = dp[r][c - 1] + grid[r][c];                else if (c == 0)                    dp[r][c] = dp[r - 1][c] + grid[r][c];                else                    dp[r][c] = max(dp[r][c - 1], dp[r - 1][c]) + grid[r][c];            }        }        return dp[rows - 1][cols - 1];    }};</code></pre></details></li><li><p>【<strong>最长不重复的子字符串</strong>】从字符串(只包含<code>&#39;a&#39;~&#39;z&#39;</code>)中找到一个最长的字符不重复的子字符串，并计算该字符串的长度；</p><details> <summary>点击查看解析</summary><p> 滑动窗口法。</p><pre><code>class Solution {public:    int lengthOfLongestSubstring(string s) {        int n = s.size();        if (n == 0) return 0;        // 双指针        int maxlen = 0;        int fast = 0, slow = 0;        while (true) {            // 快指针            fast++;            // 注意终止条件            if (fast > n) break;            // 慢指针            while (isRepeat(s.substr(slow, fast - slow))) slow++;            // 更新返回结果            maxlen = max(maxlen, fast - slow);        }        return maxlen;    }    bool isRepeat(const string& s) {        vector<bool> isShown(256, false);        for (char ch : s) {            if (isShown[ch]) return true;            isShown[ch] = true;        }        return false;    }};</bool></code></pre></details></li><li>【<strong>丑数</strong>】把只包含因子$2, 3, 5$的数称为丑数，并定义$1$是第一个丑数，求从小到大排列的第$1500$个丑数；<details> <summary>点击查看解析</summary><p>一个丑数是另一个较小的丑数乘2、3、5得到的结果；保存已求取的丑数，在这些丑数中寻找下一个更大的最小丑数；每次只找一个丑数； </p><pre><code>class Solution {public:    int nthUglyNumber(int n) {        if (n == 0) return 0;        // 动态规划        vector&lt;int&gt; dp(n, 0);        // 边界条件：1是丑数        dp[0] = 1;        // a, b, c用于保存下一个丑数的来源丑数，减少遍历        int a = 0, b = 0, c = 0;        for (int i = 1; i < n; i++){            // 抽数来源            int a2 = dp[a] * 2, b3 = dp[b] * 3, c5 = dp[c] * 5;            dp[i] = min(a2, min(b3, c5));            // 下一丑数来源更新            if (dp[i] == a2) a++;            if (dp[i] == b3) b++;            if (dp[i] == c5) c++;        }        return dp[n - 1];    }};</code></pre></details></li><li>【<strong>字符串中首个只出现一次的字符</strong>】给定字符串，输出<strong>第一个只出现一次的字符</strong>在给定字符串中的<strong>索引</strong>；<blockquote><p>相关题型：</p><ol><li>给定两个字符串，删除第一个字符串中在第二个字符串中出现过的所有字符；</li><li>删除字符串中重复字符；</li><li>若两个单词出现字母相同且字数相同，而顺序不同，这两个单词称作变位词，编写函数判断两个单词是否为变位词；</li><li>字符串流中只出现一次的字符。<details> <summary>点击查看解析</summary><p> 若遍历字符，对每个字符进行重复字符的查找，时间复杂度为O(n2)； </p><p> 遍历两次给定字符串：第一次统计字符出现次数，第二次查找出现一次的字符；时间复杂度O(n)，空间复杂度O(1)； </p><pre><code>class Solution {public: char firstUniqChar(string s) {     int n = s.size();     // 数组用作哈希表     vector&lt;int&gt; showTime(256);     for (char ch: s) {         showTime[ch] += 1;     }     // 寻找第一个出现一次的字符     for (char ch: s) {         if (showTime[ch] == 1)             return ch;     }     // 没有找到，返回`' '`     return ' '; }};</code></pre></details></li></ol></blockquote></li><li><p>【<strong>*数组中的逆序对</strong>】数组中任意两个数字，若前一个数字大于后一个数字，这两个数字构成逆序对，编写函数输出给定数组中逆序对的个数；</p><details> <summary>点击查看解析</summary><p> 利用<b>归并排序</b>的方法：对两个已升序排序的子数组a、b进行逆序对的统计，注意到此时两个子数组中数字在原数组中前后关系未变化，即a中元素在原数组中处于b中元素之前。 </p><p> <b>从a的末尾进行遍历</b>，在a_i元素时，对b进行<b>从尾遍历</b>，当b_j小于a_i时表示b_j之前(包括b_j)的元素与a_i构成逆序对，停止遍历，并记录逆序对个数。 </p><p> 每次比较过程中，保存较大的数作为排序结果。 </p><p> 这种基于归并排序的方案时间复杂度O(nlogn)，空间复杂度为O(n)，以空间换取时间效率。 </p><pre><code>class Solution {public:    int count = 0;    int reversePairs(vector&lt;int&gt;& nums) {        mergeSort(nums, 0, nums.size());        return count;    }    void mergeSort(vector&lt;int&gt;& nums, int begin, int end) {        int n = end - begin;        if (n <= 1) return; int mid="begin" + (n>> 1);        mergeSort(nums, begin, mid);        mergeSort(nums, mid, end);        // 合并过程中计数        merge(nums, begin, mid, end);    }    void merge(vector&lt;int&gt;& nums, int begin, int mid, int end) {        int n = end - begin;        vector&lt;int&gt; buff(n, 0);        int i = begin, j = mid, k = 0;        while (i < mid && j < end) {            if (nums[i] <= nums[j]) { buff[k++]="nums[i++];" } else 累计逆序对个数 例如，[7, 8], [6, 8, 9]，此时6与左半数组每个数字组成逆序对 count +="mid" - i; 以下只会触发一个循环 while(i < mid) while(j end) 复制回nums for (k="0;" k n; k++) nums[k begin]="buff[k];" }; code></=></=></code></pre></details></li><li>【<strong>两个链表的第一个公共节点</strong>】输入两个单向链表，找到它们的第一个公共节点；<details> <summary>点击查看解析</summary><p>方案一：暴力搜索，则时间复杂度为O(nm)；<br>方案二：用辅助空间(如栈)保存两个链表的节点地址，从尾部依次比较，时间复杂度O(n + m)，空间复杂度O(m + n)； <br>方案三：两个链表尾部相同，那么可以先遍历两个链表获得两个链表的长度，在较长的链表先走|n - m|步，然后同时走查找公共节点，该方案时间复杂度O(n + m)，而不需要辅助空间。 </p><pre><code>class Solution {public:    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {        if (!headA || !headB) return nullptr;        // 求长度        int lenA = lenOfList(headA);        int lenB = lenOfList(headB);        // 调整链表A为更长的链表        if (lenA < lenB) {            ListNode* headT = headA; headA = headB; headB = headT;            int lenT = lenA; lenA = lenB; lenB = lenT;        }        // 求长度差        int lenDiff = lenA - lenB;        // 求公共节点        while (lenDiff--) headA = headA->next;        while (headA != headB) {            headA = headA->next;            headB = headB->next;        }        return headA;    }    int lenOfList(ListNode* head) {        int len = 0;        while (head) {            len++; head = head->next;        }        return len;    }};</code></pre></details></li><li>【<strong>在排序数组中查找数字出现次数</strong>】给定排序数组，统计某数字出现的次数；<details> <summary>点击查看解析</summary><p> 二分查找：左侧最先出现的索引、右侧最先出现的索引；尽管搜索了两次，但总的时间复杂度仍为O(logn) </p><pre><code>class Solution {public:    int search(vector&lt;int&gt;& nums, int target) {        if (nums.size() == 0) return 0;        int l = bs_left(nums, target);        int r = bs_right(nums, target);        if (l == -1 || r == -1) return 0;        return r - l + 1;    }    // 左边界二分搜索    int bs_left(const vector&lt;int&gt;& nums, int target) {        int n = nums.size();        int l = 0, r = n - 1;        while (l <= r) { int m="l" + (r - l) 2; if (nums[m] < target) l="m" 1; } else> target) {                r = m - 1;            } else {                r = m - 1;            }        }        // 越界检查、查询检查        if (l >= n || nums[l] != target) return -1;        return l;    }    // 右边界二分搜索    int bs_right(const vector&lt;int&gt;& nums, int target) {        int n = nums.size();        int l = 0, r = n - 1;        while (l <= r) { int m="l" + (r - l) 2; if (nums[m] < target) l="m" 1; } else> target) {                r = m - 1;            } else {                l = m + 1;            }        }        // 越界检查、查询检查        if (r < 0 || nums[r] != target) return -1;        return r;    }};</=></=></code></pre></details></li><li>【<strong>$0 \sim n-1$中缺失的数字</strong>】长度为$n-1$的递增排序数组中所有数字唯一，并且每个数范围在$0 \sim n-1$内，那么有一个数字缺失，找出这个数字；<details> <summary>点击查看解析</summary><p> 方案一：二分查找：第一个下标与数组元素不一致的数字；方案二：0 ~ n-1包含n个数字，且唯一，所以 0 + 1 + ... + (n - 1) - sum(nums) 即答案。</p></details></li><li>【<strong>数组中数值和下标相等的数字</strong>】数组中元素已升序排序，且数字唯一，找出<strong>第一个</strong>数值和下标一致的元素；<details> <summary>点击查看解析</summary><p> 二分查找；由于已排序，若数值比索引小，向右搜索 </p><pre><code>class Solution {public:    int numberSameAsIndex(int* nums, int n)    {        if (!nums || n == 0) return -1;        int left = 0; int right = n;        while (left < right) {            int middle = (left + right) / 2;        // 向下取整            nums[middle] < middle ? left = middle + 1 : right = middle;        }        return left;    }};</code></pre></details></li><li>【<strong>搜索二叉树的第$k$大元素</strong>】给定搜索二叉树，求第$k$大元素；<details> <summary>点击查看解析</summary><p> 中序遍历输出为升序 </p><pre><code>class Solution {public:    int kthLargest(TreeNode* root, int k) {        vector&lt;int&gt; nums = getOrderedNums(root);        return nums[nums.size() - k];    }    vector&lt;int&gt; getOrderedNums(TreeNode* root) {        // 中序遍历获取排序数字        if (!root) return {};        vector&lt;int&gt; numsL = getOrderedNums(root->left);        vector&lt;int&gt; numsR = getOrderedNums(root->right);        // 组合数字        vector&lt;int&gt; nums;        nums.insert(nums.end(), numsL.begin(), numsL.end());        nums.push_back(root->val);        nums.insert(nums.end(), numsR.begin(), numsR.end());        return nums;    }};</code></pre></details></li><li>【<strong>平衡二叉树判断</strong>】输入二叉树根节点，判定该树是否为平衡二叉树，即左右子树的深度不超过$1$；<details> <summary>点击查看解析</summary><p> 可在每个节点处获取子树高度，判断高度差，但是这样会造成一个节点的重复遍历； </p><p> 可以通过后续遍历，在某节点处先获取子树高度并进行判断，并返回该节点的高度。 </p><pre><code>class Solution {public:    bool balanced = true;    bool isBalanced(TreeNode* root) {        if (!root) return true;        heightOf(root);        return balanced;    }    int heightOf(TreeNode* root) {        if (!root) return 0;        int heightL = heightOf(root->left );        int heightR = heightOf(root->right);        // 求高度过程中判断是否平衡，不平衡直接返回        if (abs(heightL - heightR) > 1) {            balanced = false;            return 0;        }        return max(heightL, heightR) + 1;    }};</code></pre></details></li><li>【<strong>*数组中只出现一次的数字</strong>】数组中除两个数字外仅出现一次外，其他数字都出现了两次，要求在时间复杂度$O(n)$，空间复杂度$O(1)$下找到这两个数字；<details> <summary>点击查看解析</summary><p> 关键是如何将数字进行分组，使两个数字分别所在组别内，除这两个数字外其余数字都出现两次 </p><pre><code>class Solution {public:    vector&lt;int&gt; singleNumber(vector&lt;int&gt;& nums) {        int exclusiveOr = 0;        for (int num: nums) exclusiveOr ^= num;        // 以某不为0的位，将数据分组，这里选择最低出现1的位数        int bitcount = 0;        while (!(exclusiveOr & 0x01)) {            exclusiveOr >>= 1;            bitcount++;        }        int mask = 0x01 << bitcount;        // 求这两个数        vector&lt;int&gt; sgNums(2, 0);        for (int num: nums) {            if (num & mask) {                sgNums[0] ^= num;            } else {                sgNums[1] ^= num;            }        }        return sgNums;    }};</code></pre></details></li><li>【<strong>*数组中只出现一次的数字</strong>】一个数组中一个数组仅出现一次，而其他数字均出现三次，找出这个数字；<details> <summary>点击查看解析</summary><p> 将全部数的某位加和，若能被3整除，表示待查找数该位为1，否则为0。 </p><pre><code>class Solution {public:    int singleNumber(vector&lt;int&gt;& nums) {        int sgNum = 0;        for (int bitcount = 0; bitcount < sizeof(int) * 8; bitcount++) {            // 所有数的第bitcount位累加            int sum = 0;            for (int num: nums)                sum += (num >> bitcount) & 0x01;            // 若不能被3整除，表示sgNum该位是1            sgNum += (sum % 3? 0x01: 0x00) << bitcount;        }        return sgNum;    }};</code></pre></details></li><li>【<strong>和为$s$的数字</strong>】输入递增排序的数组和一个数字，在数组中查找任意两个数字使和为$s$；<details> <summary>点击查看解析</summary><p> 从数组的左右两侧步进搜索：当左右指针数据之和小于s，左侧自增，否则右侧自减；时间复杂度O(n)。 </p><pre><code>class Solution {public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;& nums, int target) {        int l = 0, r = nums.size() - 1;        while (l < r) {            int sum = nums[l] + nums[r];            if (sum == target)                return {nums[l], nums[r]};            sum < target? l++: r--;        }        return {0, 0};    }};</code></pre></details></li><li>【<strong>*和为$s$的连续正数序列</strong>】输入正数$s$，打印所有和为$s$的正数序列(最少有两个数)；<blockquote><p>例如输入$s=15$，输出${1, 2, 3, 4, 5}, {4, 5, 6}, {7, 8}$</p><details> <summary>点击查看解析</summary><p> 与上题类似，寻找序列的最大和最小值 </p><pre><code>class Solution {public:    vector&lt;vector&lt;int&gt;&gt; findContinuousSequence(int target) {        vector&lt;vector&lt;int&gt;&gt; sequence;        // 快慢指针，表示序列的第一个元素和最后一个元素        int begin = 1, end = 1;        // end不超过(target + 1) / 2        while (end <= (target + 1) 2) { int sum="sumOfSequence(begin," end); if (sum="=" target) sequence.push_back(getsequence(begin, end)); end++; continue; } < target? end++: begin++; return sequence; sumofsequence(int begin, end) begin ... end (begin * (end - 2; vector&lt;int&gt; getsequence(int nums; for (int num="begin;" num++) nums.push_back(num); }; code></=></code></pre></details></blockquote></li><li>【<strong>翻转字符串</strong>】输入英文句子，将其中的单词翻转，但单词内字母顺序不变，标点与字母一样处理；<blockquote><p>如<code>&quot;I am a student.&quot;</code>翻转后变成<code>&quot;student. a am I&quot;</code></p><details> <summary>点击查看解析</summary><p> 先将每个单词翻转，再翻转整句 </p><pre><code>void reverse(char* begin, char* end){    if (!begin || !end) return;    while (begin < end) {        char ch = *begin;        *begin = *end;        *end = ch;        begin++; end--;    }}void reverseSentence(char* sentence){    if (!sentence) return;    // 翻转每个单词    char* begin = sentence;    char* end = sentence;    while (*end != '\0') {        if (*end == ' ') {            reverse(begin, end - 1);            begin = end + 1;        }        end++;    }    reverse(begin, end - 1);    // 翻转整句    reverse(sentence, end - 1);}</code></pre></details></blockquote></li><li>【<strong>左旋转字符串</strong>】输入字符串和数目，将字符串前面的指定数目个字符移动到字符串末尾；<blockquote><p>如<code>&quot;abcdefg&quot;</code>，$n=2$，旋转后变为<code>&quot;cdefgab&quot;</code></p><details> <summary>点击查看解析</summary><p> 调用3次上面的reverse函数 </p><pre><code>void leftRotateString(char* str, int n){    if (!str) return;    // end and length of the string    char* end = nullptr; for (end = str; *end != '\0'; end++);end--;    int strLen = end - str + 1;    if (n > strLen) return;    // left rotate    reverse(str, str + n - 1);    reverse(str + n, end);    reverse(str, end);}</code></pre></details></blockquote></li><li>【<strong>*$n$个骰子的点数</strong>】将$n$个骰子扔在地上，所有骰子朝上的面的数字之和为$s$，求$s$所有可能的值出现的概率；<details> <summary>点击查看解析</summary><pre><code>class Solution {public:    vector<double> twoSum(int n) {        vector&lt;int&gt; count(6 * n + 1, 0);        // 1 ~ n 个骰子依次计入        for (int i = 1; i < n + 1; i++) {            // 第 i 个骰子各值出现次数的计数            vector&lt;int&gt; countNext(6 * n + 1, 0);            // 第 1 个骰子            if (i == 1) {                for (int num = 6; num >= 1; num--)                    countNext[num] = 1;            } else {                // 第 i 个骰子的点数范围是 i ~ 6i                for (int j = 6 * i; j >= i; j--) {                    // 点数是 j 可能由上一次 j - num 得到                    for (int num = 6; num >= 1; num--) {                        // 上一次不可能投出小于等于0的数                        if (j - num <= 6 0) continue; 累加 countnext[j] +="count[j" - num]; } 更新 count="countNext;" 点数范围 n ~ 6n int countsum="0;" for (int i="n;" < * 1; i++) 计算概率 vector<double> prob(6 * n - n + 1);        for (int i = 0; i < 6 * n - n + 1; i++) {            prob[i] = (double)count[i + n] / (double)countSum;        }        return prob;    }};</=></double></code></pre></details></li><li>【<strong>扑克牌中的顺子</strong>】从扑克牌中随机抽取$5$张牌，判断是否为顺子(A~K连续5张)，大小王可视作任意牌；<details> <summary>点击查看解析</summary><p> 统计大小王个数和间隔数，判断大小王是否足够填充间隔 </p><pre><code>class Solution {public:    bool isStraight(vector&lt;int&gt;& nums) {        sort(nums.begin(), nums.end());        // 统计大小王个数        int nJoker = 0;         for (int num: nums) {            if (num > 0) break;            nJoker += 1;        }        // 统计间隔数字        int nGap = 0;        int lastNum = -1;        for (int i = nJoker; i < nums.size(); i++) {            // 出现相同的数，不可能是顺子            if (nums[i] == lastNum) return false;            // 第一个数不计算 gap            if (lastNum != -1)                nGap += nums[i] - lastNum - 1;            lastNum = nums[i];        }        // 大小王是否足够填充间隔        return nGap <= njoker; } }; < code></=></code></pre></details></li><li>【<strong>*圆圈中最后剩下的数字</strong>】$0, 1, \cdots, n-1$这$n$个数字排成圆圈，从数字$0$开始，每次删除第$m$个数字，求这个圆圈内最后一个数字；<details> <summary>点击查看解析</summary><p> 一种简单的解法是，实现一个环状链表(如使用vector容器)，但该方案会在环内重复遍历，时间复杂度O(mn)； </p><pre><code>bool lastNumberInLoop(int n, int m, int* num){    if (n < 1 || m < 0 || !num) return false;    vector&lt;int&gt; numbers(n);     for (int i = 0; i < n; i++) numbers[i] = i;    int index = 0;    while (numbers.size() > 1) {        int size = numbers.size();        index = (index % size + (m - 1) % size) % size;  // 防止溢出        numbers.erase(numbers.begin() + index);    }    *num = numbers[0];    return true;}</code></pre><p> 另一种方案， <br>第一轮是 [0, 1, 2, 3, 4] ，所以是 [0, 1, 2, 3, 4] 这个数组的多个复制。这一轮 2 删除了。<br>第二轮开始时，从 3 开始，所以是 [3, 4, 0, 1] 这个数组的多个复制。这一轮 0 删除了。<br>第三轮开始时，从 1 开始，所以是 [1, 3, 4] 这个数组的多个复制。这一轮 4 删除了。<br>第四轮开始时，还是从 1 开始，所以是 [1, 3] 这个数组的多个复制。这一轮 1 删除了。<br>最后剩下的数字是 3。<br><br>然后我们从最后剩下的 3 倒着看，我们可以反向推出这个数字在之前每个轮次的位置。<br>最后剩下的 3 的下标是 0。<br>第四轮反推，补上 m 个位置，然后模上当时的数组大小 2，3 的位置是(0 + 3) % 2 = 1。<br>第三轮反推，补上 m 个位置，然后模上当时的数组大小 3，3 的位置是(1 + 3) % 3 = 1。<br>第二轮反推，补上 m 个位置，然后模上当时的数组大小 4，3 的位置是(1 + 3) % 4 = 0。<br>第一轮反推，补上 m 个位置，然后模上当时的数组大小 5，3 的位置是(0 + 3) % 5 = 3。<br>总结一下反推的过程，就是 (当前index + m) % 上一轮剩余数字的个数。</p><pre><code>class Solution {public:    int lastRemaining(int n, int m) {        int ans = 0;        // 最后一轮剩下2个人，所以从2开始反推        for (int i = 2; i <= n; i++) ans="(ans" + m) % i; return ans; } }; < code></=></code></pre></details></li><li>【<strong>股票的最大利润</strong>】假设把某股票的价格按时间先后顺序存储在数组中，问买卖该股票一次可能获得的最大利润是多少；<details> <summary>点击查看解析</summary><pre><code>int maxDiff(int* nums, int n){    if (!nums || n < 1) return -1;    int maxdiff = INT_MIN, minNum = INT_MAX;    for (int i = 0; i < n; i++) {        // 保存最低价        if (nums[i] < minNum) {            minNum = nums[i];        }        // 计算当前值与最低价的差额        int diff = nums[i] - minNum;        // 保存最大差额        if (diff > maxdiff) {            maxdiff = diff;        }    }    return maxdiff;}</code></pre><p> 动态规划解法 </p><pre><code>class Solution {public:    int maxProfit(vector&lt;int&gt;& prices) {        int n = prices.size();        if (n == 0) return 0;        vector&lt;int&gt; bought(n + 1, INT_MIN);        vector&lt;int&gt; sold(n + 1, 0);        for (int i = 1; i < n + 1; i++) {            bought[i] = max(                // 前一天第 1 次买入                bought[i - 1],                // 前一天第 0 次卖出，这天第 1 次买入                0 - prices[i - 1]            );            sold[i] = max(                // 前一天第 1 次卖出                sold[i - 1],                // 前一天第 1 次买入，这天第 1 次卖出                bought[i - 1] + prices[i - 1]            );        }        return sold[n];    }};</code></pre></details></li><li>【<strong>求$1 + 2 + \cdots + n$</strong>】不使用乘除法、for、while、if、else、switch、case等关键字及三目表达式计算$1 + 2 + \cdots + n$的值；<details> <summary>点击查看解析</summary><p> 借助构造函数和静态成员变量；或&&运算符的短路原理配合递归 </p><pre><code>class Solution {public:    int sumNums(int n) {        n && (n += sumNums(n - 1));        return n;    }};</code></pre></details></li><li>【<strong>用位运算实现加法</strong>】只使用位运算实现两个整数的加法；<details> <summary>点击查看解析</summary><p> 位的加法规律与异或一致；注意进位位的处理；<br>例如 15 + 7 = 0b00001111 + 0b00000111 运算过程如下 <br>0b00001111, 0b00000111 <br>0b00001000, 0b00001110 <br>0b00000110, 0b00010000 <br>0b00010110, 0b00000000</p><pre><code>class Solution {public:    int add(int a, int b) {        int sum = 0, carry = 0;        while (true) {            sum   = a ^ b;                          // 先用 ^ 求每位和            carry = (unsigned int)(a & b) << 1;     // 再用 & 每位相加后的进位            a = sum; b = carry;                     // 更新 a, b            if (b == 0) break;                      // 进位全部消除，停止        }        return sum;    }};</code></pre></details></li><li>【<strong>构建乘积数组</strong>】给定数组$A[0, 1, \cdots, n - 1]$，请构建数组$B[0, 1, \cdots, n - 1]$，满足$B[i] = \prod_{j \neq i} A[j]$，不能使用除法；<details> <summary>点击查看解析</summary><pre><code>class Solution {public:    vector&lt;int&gt; constructArr(vector&lt;int&gt;& a) {        int n = a.size();        if (n == 0) return {};        // 自上而下计算        vector&lt;int&gt; left (n, 1);        for (int i = 1; i < n; i++)            left[i] = left[i - 1] * a[i - 1];        // 自下而上计算        vector&lt;int&gt; right(n, 1);        for (int i = n - 2; i >= 0; i--)            right[i] = right[i + 1] * a[i + 1];        // 计算结果        vector&lt;int&gt; arr(n, 0);        for (int i = 0; i < n; i++)            arr[i] = left[i] * right[i];        return arr;    }};</code></pre></details></li><li>【<strong>字符串转换为数字</strong>】输入字符串，实现<code>atoi</code>，将其转换为整数；<details> <summary>点击查看解析</summary><p> 0) 输入异常判断；1) 正负号处理；2) 数字是否有效('0'~'9'范围内)；3) 溢出判断；4) 全局变量设置是否有效输出。 </p><pre><code>class Solution {public:    int strToInt(string str) {        long res = 0;        // 默认sign = 1，正数        int i = 0, sign = 1;        // 查找第一个非空白字符        while (str[i] == ' ') i ++;        // 正负号        if (str[i] == '-') sign = -1;        if (str[i] == '-' || str[i] == '+') i++;        // 依次转换        for (; i < str.size() && isdigit(str[i]); i++)  {            // 当前位加入结果            res = res * 10 + (str[i] - '0');            // 溢出的处理            if (res >= INT_MAX && sign == 1) return  INT_MAX;            if (res > INT_MAX && sign == -1) return  INT_MIN;        }         return sign * res;    }};</code></pre></details></li><li>【<strong>树中两个节点的最低公共祖先</strong>】给定初始化后的树，输出两个节点的最低公共祖先；<details> <summary>点击查看解析</summary><p> 若为搜索二叉树，找到第一个元素值大小处于两个节点元素值之间的节点； </p><pre><code>class Solution {public:    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {        if (!root || !p || !q) return nullptr;        TreeNode* node = root;        while (true) {            int perr = p->val - node->val;            int qerr = q->val - node->val;            // 若此时节点的值与p或q值相同，或者处于两者之间，即为公共节点            if (perr * qerr <= 0 0) return node; 若都小于节点值，则向左子节点搜索 if (perr < && qerr node="node-">left;            // 若都大于节点值，则向右子节点搜索            else if (perr > 0 && qerr > 0)                node = node->right;        }        return nullptr;    }};</=></code></pre><p> 若不为搜索二叉树，且已定义父节点指针，可将节点到根节点视作单向链表，转换为找两个链表尾端部分的公共节点问题； </p><p> 若不为搜索二叉树，且未定义父节点指针，将根节点到给定节点的路径保存为两个链表，注意这两个链表前面部分为公共路径，节点地址相同。 </p><pre><code>class Solution {public:    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {        if (!root || !p || !q) return nullptr;        // 在二叉树中搜索节点，得到路径        vector&lt;TreeNode*&gt; pathP = getNodePath(root, p, {});        vector&lt;TreeNode*&gt; pathQ = getNodePath(root, q, {});        // 若某节点不存在路径，即节点不在树中，返回空        int nP = pathP.size(), nQ = pathQ.size();        if (nP == 0 || nQ == 0) return nullptr;        // 比较查找第一个公共祖先        int i = 0, j = 0;        while (true) {            if (i >= nP) return pathP[i - 1];            if (j >= nQ) return pathQ[j - 1];            if (pathP[i] != pathQ[j])                return pathP[i - 1];            i++; j++;        }    }    vector&lt;TreeNode*&gt; getNodePath(TreeNode* root, TreeNode* target, vector&lt;TreeNode*&gt; path) {        // 输入异常：目标节点空        if (!target) return {};        // 终止条件：路径结束，直接返回        if (!root) return {};        // 加入本节点        path.push_back(root);        // 本节点是否是查找结点        if (root == target) return path;        // 查找左右子节点        vector&lt;TreeNode*&gt; pathL = getNodePath(root->left, target, path);        if (pathL.size() > 0) return pathL;        vector&lt;TreeNode*&gt; pathR = getNodePath(root->right, target, path);        if (pathR.size() > 0) return pathR;        return {};    }};</code></pre></details></li></ol>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Try To Play With Hadoop</title>
      <link href="/2020/07/03/Try-To-Play-With-Hadoop/"/>
      <url>/2020/07/03/Try-To-Play-With-Hadoop/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#目录">目录</a></li><li><a href="#download-and-installation">Download and Installation</a><ul><li><a href="#ssh">SSH</a></li><li><a href="#java">Java</a></li><li><a href="#hadoop">Hadoop</a></li></ul></li><li><a href="#file-system">File System</a></li><li><a href="#streaming">Streaming</a></li><li><a href="#reference">Reference</a></li></ul><h1 id="Download-and-Installation"><a href="#Download-and-Installation" class="headerlink" title="Download and Installation"></a>Download and Installation</h1><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p>安装SSH服务端并启用<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install openssh-server</span><br><span class="line">$ sudo service ssh start</span><br></pre></td></tr></table></figure></p><p>配置为无密码登录<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/.ssh/</span><br><span class="line">$ ssh-keygen -t rsa</span><br><span class="line">$ cat ./id_rsa.pub &gt;&gt; ./authorized_keys</span><br></pre></td></tr></table></figure></p><p>如果以下命令没有问题则安装成功<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ ssh localhost</span><br><span class="line">Welcome to Ubuntu 18.04.2 LTS (GNU/Linux 4.4.0-18362-Microsoft x86_64)</span><br><span class="line"></span><br><span class="line">* Documentation:  https://help.ubuntu.com</span><br><span class="line">* Management:     https://landscape.canonical.com</span><br><span class="line">* Support:        https://ubuntu.com/advantage</span><br><span class="line"></span><br><span class="line">System information as of Fri Jul  3 19:27:27 CST 2020</span><br><span class="line"></span><br><span class="line">System load:    0.52      Memory usage: 60%   Processes:       10</span><br><span class="line">Usage of /home: unknown   Swap usage:   0%    Users logged <span class="keyword">in</span>: 0</span><br><span class="line"></span><br><span class="line">=&gt; There were exceptions <span class="keyword">while</span> processing one or more plugins. See</span><br><span class="line">    /var/<span class="built_in">log</span>/landscape/sysinfo.log <span class="keyword">for</span> more information.</span><br><span class="line"></span><br><span class="line">128 packages can be updated.</span><br><span class="line">73 updates are security updates.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Last login: Fri Jun  5 15:53:16 2020 from 127.0.0.1</span><br></pre></td></tr></table></figure></p><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>Hadoop需要Java支持，可以选择用<code>apt-get</code>安装，这里选择的是清华大学开源软件镜像站的AdoptOpenJDK<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://mirrors.tuna.tsinghua.edu.cn/AdoptOpenJDK/8/jdk/x64/linux/OpenJDK8U-jdk_x64_linux_hotspot_8u252b09.tar.gz</span><br></pre></td></tr></table></figure></p><p>下载后解压即可<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zxvf OpenJDK8U-jdk_x64_linux_hotspot_8u252b09.tar.gz</span><br><span class="line">$ ls</span><br><span class="line">OpenJDK8U-jdk_x64_linux_hotspot_8u252b09.tar.gz  jdk8u252-b09</span><br></pre></td></tr></table></figure></p><p>然后配置环境变量，在<code>~/.bashrc</code>中添加以下命令<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/home/louishsu/Downloads/jdk8u252-b09</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$&#123;JAVA_HOME&#125;</span>/jre</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$&#123;JAVA_HOME&#125;</span>/lib:<span class="variable">$&#123;JRE_HOME&#125;</span>/lib:<span class="variable">$CLASSPATH</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure></p><h2 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h2><p>先从官网下载二进制包，并解压<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://www.apache.org/dyn/closer.cgi/hadoop/common/hadoop-3.2.1/hadoop-3.2.1.tar.gz</span><br><span class="line">$ tar -zxvf hadoop-3.2.1.tar.gz</span><br><span class="line">$ ls</span><br><span class="line">hadoop-3.2.1.tar.gz hadoop-3.2.1</span><br></pre></td></tr></table></figure></p><p>配置<code>~/.bashrc</code>环境变量<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> HADOOP_HOME=/home/louishsu/Downloads/hadoop-3.2.1</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=$(<span class="variable">$HADOOP_HOME</span>/bin/hadoop classpath):<span class="variable">$CLASSPATH</span></span><br><span class="line"><span class="built_in">export</span> HADOOP_COMMON_LIB_NATIVE_DIR=<span class="variable">$HADOOP_HOME</span>/lib/native</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$HADOOP_HOME</span>/bin:<span class="variable">$HADOOP_HOME</span>/sbin</span><br></pre></td></tr></table></figure></p><p>在<code>hadoop-3.2.1/etc/hadoop/</code>目录下配置两份文件</p><ul><li><code>core-site.xml</code><br>  新建<code>hadoop-3.2.1/tmp/</code>目录，并修改配置  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;file:/home/louishsu/Downloads/hadoop-3.2.1/tmp&lt;/value&gt;</span><br><span class="line">        &lt;description&gt;Abase <span class="keyword">for</span> other temporary directories.&lt;/description&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li><li><code>hdfs-site.xml</code><br>  新建<code>hadoop-3.2.1/tmp/dfs/name/</code>和<code>hadoop-3.2.1/tmp/dfs/data/</code>目录，并修改配置  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;file:/home/louishsu/Downloads/hadoop-3.2.1/tmp/dfs/name&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;file:/home/louishsu/Downloads/hadoop-3.2.1/tmp/dfs/data&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;1&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li></ul><p>以上就完成了基本配置，可以正常使用，但是如果需要<strong>Yarn作为分布式资源管理器</strong>，那么需另外配置两份文件</p><ul><li><code>mapred-site.xml</code>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;!--指定运行mapreduce的环境是yarn--&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--配置历史服务器--&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hadoop-senior01.beifeng.com:10020&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hadoop-senior01.beifeng.com:19888&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--HADOOP_MAPRED_HOME--&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.app.mapreduce.am.env&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;HADOOP_MAPRED_HOME=<span class="variable">$&#123;HADOOP_HOME&#125;</span>&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.map.env&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;HADOOP_MAPRED_HOME=<span class="variable">$&#123;HADOOP_HOME&#125;</span>&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.reduce.env&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;HADOOP_MAPRED_HOME=<span class="variable">$&#123;HADOOP_HOME&#125;</span>&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt; </span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li><li><code>yarn-site.xml</code>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;localhost&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li></ul><p>接下来格式化<code>namenode</code>，并启动全部组件<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hdfs namenode -format</span><br><span class="line">$ start-all.sh</span><br></pre></td></tr></table></figure></p><p>到此就可以愉快地玩耍了。</p><h1 id="File-System"><a href="#File-System" class="headerlink" title="File System"></a>File System</h1><p>Hadoop分布式文件系统(HDFS)借鉴于Google的GFS，是一个分布式文件系统，有着高容错性，适合大文件的存储，抽象了一个多级的文件系统，调用文件系统(FS)Shell命令应使用<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/hadoop fs &lt;args&gt;</span><br></pre></td></tr></table></figure><br>所有的的FS shell命令使用URI路径作为参数，URI格式是<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheme://authority/path</span><br></pre></td></tr></table></figure><br>其中<code>scheme</code>和<code>authority</code>参数都是可选的，如果未加指定，就会使用配置中指定的默认<code>scheme</code>。</p><p>对HDFS文件系统，<code>scheme</code>是<code>hdfs</code>，对本地文件系统，<code>scheme</code>是<code>file</code>。例如，一个HDFS文件或目录<code>/parent/child</code>可以表示成<code>hdfs://namenode:namenodeport/parent/child</code>，或者更简单的<code>/parent/child</code>(假设你配置文件中的默认值是<code>namenode:namenodeport</code>)。</p><p>大多数FS Shell命令的行为和对应的Unix Shell命令类似，不同之处会在下面介绍各命令使用详情时指出。出错信息会输出到<code>stderr</code>，其他信息输出到<code>stdout</code>，命令格式为<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hadoop fs -<span class="built_in">command</span> URI [URI …]</span><br></pre></td></tr></table></figure></p><p>常用的指令在<a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_shell.html" target="_blank" rel="noopener">Hadoop Shell命令</a>，常用的有</p><ul><li>查看目录、文件：<code>cat</code>、<code>ls</code>、<code>tail</code>；</li><li>新建、复制、删除：<code>touchz</code>、<code>mkdir</code>、<code>cp</code>、<code>mv</code>、<code>rm</code>；</li><li>权限管理：<code>chgrp</code>、<code>chmod</code>、<code>chown</code>；</li><li>上传、下载本地文件：<code>put</code>、<code>get</code>、<code>copyFromLocal</code>、<code>copyToLocal</code>；</li><li>……</li></ul><h1 id="Streaming"><a href="#Streaming" class="headerlink" title="Streaming"></a>Streaming</h1><p>MapReduce是一种并行计算的编程模型。Hadoop的Streaming基于MapReduce，与标准的MapReduce(以下简称MR)一样的是整个MR过程依然由<code>mapper</code>、<code>[combiner]</code>、<code>reducer</code>组成(其中<code>combiner</code>为可选加入)。很重要的一点是，它可以将任意与标准输入/输出交互的软件作为<code>mapper</code>等，不是必须使用Java接口，其工作过程如下</p><p><img src="/.com//mapreduce.jpg" alt="mapreduce"></p><p>启动Streaming的命令如下，注意一定要保证<code>[genericOptions]</code>写在<code>[streamingOptions]</code>之前，否则Hadoop Streaming命令将失效。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hadoop jar <span class="variable">$&#123;HADOOP_HOME&#125;</span>/.../hadoop-streaming.jar \</span><br><span class="line">    [genericOptions] \</span><br><span class="line">    [streamingOptions]</span><br></pre></td></tr></table></figure><p><strong>常用的<code>genericOptions</code>如下</strong>：</p><ul><li><code>-D property=value</code> 指定额外的配置信息变量，详情在后文介绍</li><li><code>-files file1,file2,..</code>. 指定需要拷贝到集群节点的文件，格式以逗号分隔，通常为我们自己编写的<code>mapper</code>和<code>reducer</code>脚本或可执行程序，因为你的<code>mapper</code>和<code>reducer</code>通常要由集群中不同的节点来执行，而很可能你的脚本或可执行程序仅仅存在于你提交任务时所用的那个节点，因此遇到这种情况便需要将它们分发出去，<code>-files</code>其后的参数用不用引号括起来都可以。</li></ul><p><strong>常用的<code>streamingOptions</code>如下</strong>：</p><ul><li><code>-file filename</code> 指定需要拷贝到集群节点的文件，与<code>-files</code>的功能类似，只不过如果使用<code>-file</code>的话，就需要一个文件一个文件地去上传，比方说如果我要将我的<code>mapper.py</code>，<code>reducer.py</code>上传到集群上去运行，那就得需要两个<code>-file</code>参数。而在实际使用<code>-file</code>时，hadoop似乎并不希望我们使用<code>-file</code>参数，比如如下这条<code>warning：“18/03/26 20:17:40 WARN streaming.StreamJob: -file option is deprecated, please use generic option -files instead.”</code></li><li><code>-input myInputDirs</code> 指定给<code>mapreduce</code>任务输入的文件位置，通常为<code>hdfs</code>上的文件路径，多个文件或目录用逗号隔开</li><li><code>-output myOutputDir</code> 指定给<code>mapreduce</code>任务输出的目录，通常为<code>hdfs</code>上的文件路径。</li><li><code>-mapper executable or JavaClassName</code> 用于<code>mapper</code>的可执行程序或java类，如果是脚本文件，应该以命令行完整调用的格式作为可执行程序参数并且须加引号，比如<code>-mapper &quot;python mapper.py&quot;</code>。</li><li><code>-reducer executable or JavaClassName</code> 用于<code>reducer</code>的可执行程序或java类，要求同上</li><li><code>-partitionerJavaClassName</code> 自定义的<code>partitionerjava</code>类</li><li><code>-combiner streamingCommandor JavaClassName</code> 自定义的<code>combiner</code>类或命令</li></ul><p><strong>常用的<code>-D property=value</code>如下</strong>：</p><ul><li><code>-D mapred.job.name=jobname</code> 指定作业名称</li><li><code>-D mapred.map.tasks=numofmap</code> 每个Job运行map task的数量</li><li><code>-D mapred.reduce.tasks=numofreduce</code> 每个Job运行<code>reduce task</code>的数量，如果指定为0，则意味着提交了一个<code>map only</code>的任务</li><li><code>-D stream.map.input.field.separator</code> 指定<code>map</code>输入时的分隔符，默认为<code>&quot;\t&quot;</code></li><li><code>-D stream.map.output.field.separator</code> 指定<code>map</code>输出时使用的<code>key/value</code>分隔符，默认为<code>&quot;\t&quot;</code>，比如在我们的<code>mapper</code>中，输出<code>key/value pairs</code>的标准输出语句很可能是这样的<code>sys.stdout.write(&quot;%s,%s\n&quot;%(birthyear,gender))</code>，由于使用了非默认的分隔符，因此需要额外指定分隔符<code>&quot;,&quot;</code>。</li><li><code>-D stream.reduce.input.field.separator</code> 指定<code>reduce</code>输入时的分隔符，默认为<code>&quot;\t&quot;</code></li><li><code>-D stream.reduce.output.field.separator</code> 指定<code>reduce</code>输入时的分隔符，默认为<code>&quot;\t&quot;</code></li><li><code>-D stream.num.map.output.key.fields=num</code> 指定<code>map</code>输出中第几个分隔符作为<code>key</code>和<code>value</code>的分隔点，默认为<code>1</code>。</li><li><code>-D stream.num.reduce.output.fields=num</code> 指定<code>reduce</code>输出中第几个分隔符作为<code>key</code>和<code>value</code>的分隔点，默认为<code>1</code>。</li><li><code>-D stream.non.zero.exit.is.failure=false/true</code> 指定当mapper和reducer未返回<code>0</code>时，<code>hadoop</code>是否该认为此任务执行失败。默认为<code>true</code>。当<code>mapper</code>和<code>reducer</code>的返回值不是<code>0</code>或没有返回值时，<code>hadoop</code>将认为该任务为异常任务，将被再次执行，默认尝试4次都不是<code>0</code>，整个job都将失败。因此，如果我们在编写<code>mapper</code>和<code>reducer</code>未返回0时，则应该将该参数设置为<code>false</code>，否则hadoop streaming任务将报出异常。</li></ul><hr><p>例如，以下数据为一部分儿童的信息数据<code>samples.txt</code>，第一个属性为用户<code>id</code>，<code>birthday</code>为用户的生日，<code>gender</code>表示男女，<code>0</code>为女，<code>1</code>为男，<code>2</code>为未知。假设我们的问题是：<strong>在这些儿童中，每一年出生的男孩和女孩各是多少。</strong></p><p>新建文本<code>samples.txt</code><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ cat samples.txt</span><br><span class="line"><span class="comment"># user_id,birthday,gender</span></span><br><span class="line">2757,20130311,1</span><br><span class="line">415971,20121111,0</span><br><span class="line">1372572,20120130,1</span><br><span class="line">10339332,20110910,0</span><br><span class="line">10642245,20130213,0</span><br><span class="line">10923201,20110830,1</span><br><span class="line">11768880,20120107,1</span><br><span class="line">12519465,20130705,1</span><br><span class="line">12950574,20090708,0</span><br><span class="line">13735440,20120323,0</span><br><span class="line">14510892,20140812,1</span><br><span class="line">14905422,20110429,1</span><br><span class="line">15786531,20080922,0</span><br><span class="line">16265490,20091209,0</span><br><span class="line">17431245,20110115,0</span><br><span class="line">18190851,20110101,0</span><br><span class="line">20087991,20100808,0</span><br><span class="line">20570454,20081017,1</span><br><span class="line">21137271,20110204,1</span><br><span class="line">21415917,20060801,1</span><br><span class="line">21887268,20100526,0</span><br><span class="line">22602471,20090601,1</span><br><span class="line">23208537,20080416,1</span><br><span class="line">23927133,20081029,0</span><br><span class="line">24829944,20140826,1</span><br><span class="line">52529655,20130611,2</span><br></pre></td></tr></table></figure></p><p>将其上传到hadoop文件系统<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ hadoop fs -mkdir /user</span><br><span class="line">$ hadoop fs -mkdir /user/louishsu</span><br><span class="line">$ hadoop fs -put samples.txt /user/louishsu</span><br><span class="line">$ hadoop fs -ls /user/louishsu</span><br><span class="line">-rw-r--r--   1 louishsu supergroup        539 2020-07-03 20:50 /user/louishsu/samples.txt</span><br></pre></td></tr></table></figure></p><p>编写<code>mapper.py</code>如下，该文件将从标准输入读取数据，对每行进行处理后输出到标准输出，输出以<code>&quot;,&quot;</code>作为分隔符作为键值对，即<code>年份,性别</code><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /bin/bash</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin:</span><br><span class="line">    <span class="keyword">if</span> line[<span class="number">0</span>] == <span class="string">'#'</span>: <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    _, birthday, gender = line.strip().split(<span class="string">','</span>)</span><br><span class="line">    sys.stdout.write(<span class="string">','</span>.join([birthday[:<span class="number">4</span>], gender]) + <span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure></p><p>简单运行结果如下<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ cat samples.txt | python mapper.py</span><br><span class="line"><span class="number">2013</span>,<span class="number">1</span></span><br><span class="line"><span class="number">2012</span>,<span class="number">0</span></span><br><span class="line"><span class="number">2012</span>,<span class="number">1</span></span><br><span class="line"><span class="number">2011</span>,<span class="number">0</span></span><br><span class="line"><span class="number">2013</span>,<span class="number">0</span></span><br><span class="line"><span class="number">2011</span>,<span class="number">1</span></span><br><span class="line"><span class="number">2012</span>,<span class="number">1</span></span><br><span class="line"><span class="number">2013</span>,<span class="number">1</span></span><br><span class="line"><span class="number">2009</span>,<span class="number">0</span></span><br><span class="line"><span class="number">2012</span>,<span class="number">0</span></span><br><span class="line"><span class="number">2014</span>,<span class="number">1</span></span><br><span class="line"><span class="number">2011</span>,<span class="number">1</span></span><br><span class="line"><span class="number">2008</span>,<span class="number">0</span></span><br><span class="line"><span class="number">2009</span>,<span class="number">0</span></span><br><span class="line"><span class="number">2011</span>,<span class="number">0</span></span><br><span class="line"><span class="number">2011</span>,<span class="number">0</span></span><br><span class="line"><span class="number">2010</span>,<span class="number">0</span></span><br><span class="line"><span class="number">2008</span>,<span class="number">1</span></span><br><span class="line"><span class="number">2011</span>,<span class="number">1</span></span><br><span class="line"><span class="number">2006</span>,<span class="number">1</span></span><br><span class="line"><span class="number">2010</span>,<span class="number">0</span></span><br><span class="line"><span class="number">2009</span>,<span class="number">1</span></span><br><span class="line"><span class="number">2008</span>,<span class="number">1</span></span><br><span class="line"><span class="number">2008</span>,<span class="number">0</span></span><br><span class="line"><span class="number">2014</span>,<span class="number">1</span></span><br><span class="line"><span class="number">2013</span>,<span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>编写<code>reducer.py</code>如下，接收<code>mapper.py</code>输出进行归约，统计每年的性别人数<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /bin/bash</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    yearDict = dict()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin:</span><br><span class="line">        y, g = line.strip().split(<span class="string">','</span>)</span><br><span class="line">        yearDict[y] = yearDict.get(y, <span class="string">''</span>) + g</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> y, g <span class="keyword">in</span> yearDict.items():</span><br><span class="line">        counter = Counter(g)</span><br><span class="line">        sys.stdout.write(</span><br><span class="line">            <span class="string">'year: &#123;:s&#125;, male: &#123;:d&#125;, female: &#123;:d&#125;\n'</span>.format(</span><br><span class="line">                y, counter.get(<span class="string">'0'</span>, <span class="number">0</span>), counter.get(<span class="string">'1'</span>, <span class="number">0</span>)</span><br><span class="line">        ))</span><br></pre></td></tr></table></figure></p><p>模拟MapReduce运行过程，结果如下<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat samples.txt | python mapper.py | sort -k1,1 | python reducer.py</span><br><span class="line">year: 2006, male: 0, female: 1</span><br><span class="line">year: 2008, male: 2, female: 2</span><br><span class="line">year: 2009, male: 2, female: 1</span><br><span class="line">year: 2010, male: 2, female: 0</span><br><span class="line">year: 2011, male: 3, female: 3</span><br><span class="line">year: 2012, male: 2, female: 2</span><br><span class="line">year: 2013, male: 1, female: 2</span><br><span class="line">year: 2014, male: 0, female: 2</span><br></pre></td></tr></table></figure></p><p>在hadoop上运行命令<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ hadoop jar <span class="variable">$&#123;HADOOP_HOME&#125;</span>/share/hadoop/tools/lib/hadoop-streaming-3.2.1.jar \</span><br><span class="line">-input /user/louishsu/samples.txt \</span><br><span class="line">-output /user/louishsu/output \</span><br><span class="line">-mapper <span class="string">"python mapper.py"</span> \</span><br><span class="line">-reducer <span class="string">"python reducer.py"</span> \</span><br><span class="line">-file ~/mapper.py \</span><br><span class="line">-file ~/reducer.py</span><br></pre></td></tr></table></figure></p><p>查看结果<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ hadoop fs -ls /user/louishsu/output/</span><br><span class="line">Found 2 items</span><br><span class="line">-rw-r--r--   1 louishsu supergroup          0 2020-07-03 21:02 /user/louishsu/output/_SUCCESS</span><br><span class="line">-rw-r--r--   1 louishsu supergroup        256 2020-07-03 21:02 /user/louishsu/output/part-00000</span><br><span class="line">$ hadoop fs -cat /user/louishsu/output/part-00000</span><br><span class="line">year: 2006, male: 0, female: 1</span><br><span class="line">year: 2014, male: 0, female: 2</span><br><span class="line">year: 2008, male: 2, female: 2</span><br><span class="line">year: 2009, male: 2, female: 1</span><br><span class="line">year: 2011, male: 3, female: 3</span><br><span class="line">year: 2010, male: 2, female: 0</span><br><span class="line">year: 2013, male: 1, female: 2</span><br><span class="line">year: 2012, male: 2, female: 2</span><br></pre></td></tr></table></figure></p><p>下载到本地<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ hadoop fs -get /user/louishsu/output/part-00000 output.txt</span><br><span class="line">$ cat output.txt</span><br><span class="line">year: 2006, male: 0, female: 1</span><br><span class="line">year: 2014, male: 0, female: 2</span><br><span class="line">year: 2008, male: 2, female: 2</span><br><span class="line">year: 2009, male: 2, female: 1</span><br><span class="line">year: 2011, male: 3, female: 3</span><br><span class="line">year: 2010, male: 2, female: 0</span><br><span class="line">year: 2013, male: 1, female: 2</span><br><span class="line">year: 2012, male: 2, female: 2</span><br></pre></td></tr></table></figure></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/index.html" target="_blank" rel="noopener">Apache &gt; Hadoop &gt; Core &gt; docs &gt; r1.0.4 &gt; cn - Hadoop</a></li><li><a href="https://www.jianshu.com/p/d2f8c7153239" target="_blank" rel="noopener">Hadoop的安装和使用 - 简书</a></li><li><a href="https://zhuanlan.zhihu.com/p/34903460" target="_blank" rel="noopener">Hadoop Streaming with Python(新手向) - 知乎</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Data Mining </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【算法】单调栈和单调队列</title>
      <link href="/2020/06/29/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
      <url>/2020/06/29/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#目录">目录</a></li><li><a href="#单调栈解决下一个更大元素问题">单调栈：解决下一个更大元素问题</a><ul><li><a href="#原理">原理</a></li><li><a href="#下一个更大元素-i">下一个更大元素 I</a></li><li><a href="#下一个更大元素-ii">下一个更大元素 II</a></li><li><a href="#每日温度">每日温度</a></li><li><a href="#柱状图中最大的矩形">柱状图中最大的矩形</a></li></ul></li><li><a href="#单调队列解决滑动窗口问题">单调队列：解决滑动窗口问题</a><ul><li><a href="#原理-1">原理</a></li><li><a href="#滑动窗口最大值">滑动窗口最大值</a></li></ul></li></ul><h1 id="单调栈：解决下一个更大元素问题"><a href="#单调栈：解决下一个更大元素问题" class="headerlink" title="单调栈：解决下一个更大元素问题"></a>单调栈：解决下一个更大元素问题</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>单调栈</strong>(monotonic stack)是在栈的基础上添加一些逻辑，使每次新元素入栈后，栈内的元素都保持有序(单调递增或单调递减)，<strong>用于解决下一个更大元素问题</strong>(next greater element)。</p><p>由于需要查找下一个最大的元素，那么更大的元素入栈时应该“触发”已经在栈内的更小元素的操作，即<strong>记录当前栈内更小元素后更大的元素</strong>，所以应该定义<strong>栈底到栈顶不严格单调递减的单调栈</strong>。维护单调栈的关键代码如下<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化</span></span><br><span class="line">table = [<span class="number">-1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</span><br><span class="line"><span class="comment"># 栈底到栈顶递减的单调栈</span></span><br><span class="line">indices = deque()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">    <span class="comment"># 将小于`num[i]`的栈顶元素全部出栈</span></span><br><span class="line">    <span class="keyword">while</span> len(indices) &gt; <span class="number">0</span> <span class="keyword">and</span> nums[indices[<span class="number">-1</span>]] &lt; nums[i]:</span><br><span class="line">        table[indices[<span class="number">-1</span>]] = nums[i]</span><br><span class="line">        indices.pop()</span><br><span class="line">    <span class="comment"># 注意，保存索引</span></span><br><span class="line">    indices.append(i)</span><br></pre></td></tr></table></figure></p><p>例如给定数组$[2, 1, 2, 4, 3]$，各元素对应的下一更大元素是$[4, 2, 4, -1, -1]$，其计算过程如下，时间复杂度是$O(n)$。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">初始化表格</span><br><span class="line">[-1 -1 -1 -1 -1]</span><br><span class="line">初始化栈</span><br><span class="line">[]</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">元素: 2，栈内空[]，直接入栈</span><br><span class="line">栈内: [2]</span><br><span class="line">-----------------------</span><br><span class="line">元素: 1，小于栈顶[2]，直接入栈</span><br><span class="line">栈内: [2 1]</span><br><span class="line">-----------------------</span><br><span class="line">元素: 2，大于栈顶元素[1]，也就是说栈顶元素此时遇到了下一个更大元素，出栈并记录</span><br><span class="line">栈内: [2 2]</span><br><span class="line">表格: [-1 2 -1 -1 -1]</span><br><span class="line">-----------------------</span><br><span class="line">元素: 4，大于栈顶元素[2, 2]，将小于4的栈顶元素全部出栈，并记录，然后入栈</span><br><span class="line">栈内: [4]</span><br><span class="line">表格: [4 2 4 -1 -1]</span><br><span class="line">-----------------------</span><br><span class="line">元素: 3，小于栈顶[3]，直接入栈</span><br><span class="line">栈内: [4 3]</span><br><span class="line">表格: [4 2 4 -1 -1]</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">输出表格</span><br><span class="line">[4 2 4 -1 -1]</span><br></pre></td></tr></table></figure></p><h2 id="下一个更大元素-I"><a href="#下一个更大元素-I" class="headerlink" title="下一个更大元素 I"></a><a href="https://leetcode-cn.com/problems/next-greater-element-i/" target="_blank" rel="noopener">下一个更大元素 I</a></h2><p>给定两个 没有重复元素 的数组nums1和nums2，其中nums1是nums2的子集。找到nums1中每个元素在nums2中的下一个比其大的值。</p><p>nums1中数字$x$的下一个更大元素是指x在nums2中对应位置的右边的第一个比x大的元素。如果不存在，对应位置输出 -1 。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2].</span><br><span class="line">输出: [-1,3,-1]</span><br><span class="line">解释:</span><br><span class="line">    对于num1中的数字4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。</span><br><span class="line">    对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。</span><br><span class="line">    对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。</span><br></pre></td></tr></table></figure><br>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 &#x3D; [2,4], nums2 &#x3D; [1,2,3,4].</span><br><span class="line">输出: [3,-1]</span><br><span class="line">解释:</span><br><span class="line">    对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。</span><br><span class="line">    对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>nums1和nums2中所有元素是唯一的。</li><li>nums1和nums2 的数组大小都不超过1000。</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElement</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; List[int]:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        <span class="comment"># ---------- 求存在的更大元素 ----------</span></span><br><span class="line">        table = [<span class="number">-1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums2))]</span><br><span class="line">        <span class="comment"># 栈底到栈顶递减的单调栈</span></span><br><span class="line">        indices = deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums2)):</span><br><span class="line">            <span class="comment"># 将小于`num2[i]`的栈顶元素全部出栈</span></span><br><span class="line">            <span class="keyword">while</span> len(indices) &gt; <span class="number">0</span> <span class="keyword">and</span> nums2[indices[<span class="number">-1</span>]] &lt; nums2[i]:</span><br><span class="line">                table[indices[<span class="number">-1</span>]] = nums2[i]</span><br><span class="line">                indices.pop()</span><br><span class="line">            <span class="comment"># 注意，保存索引</span></span><br><span class="line">            indices.append(i)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># ---------- 返回结果 ----------</span></span><br><span class="line">        ret = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="comment"># 保证元素无重复，故`index()`函数没问题</span></span><br><span class="line">            pos = nums2.index(num)</span><br><span class="line">            ret += [table[pos]]</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><h2 id="下一个更大元素-II"><a href="#下一个更大元素-II" class="headerlink" title="下一个更大元素 II"></a><a href="https://leetcode-cn.com/problems/next-greater-element-ii/" target="_blank" rel="noopener">下一个更大元素 II</a></h2><p>给定一个<strong>循环数组</strong>(最后一个元素的下一个元素是数组的第一个元素)，输出每个元素的下一个更大元素。数字$x$的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出$-1$。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,1]</span><br><span class="line">输出: [2,-1,2]</span><br><span class="line">解释: 第一个 1 的下一个更大的数是 2；</span><br><span class="line">数字 2 找不到下一个更大的数； </span><br><span class="line">第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</span><br></pre></td></tr></table></figure></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElements</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># ------------ 处理循环数组 ------------</span></span><br><span class="line">        nums *= <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># ---------- 求存在的更大元素 ----------</span></span><br><span class="line">        table = [<span class="number">-1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        <span class="comment"># 栈底到栈顶递减的单调栈</span></span><br><span class="line">        indices = deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="comment"># 将小于`num[i]`的栈顶元素全部出栈</span></span><br><span class="line">            <span class="keyword">while</span> len(indices) &gt; <span class="number">0</span> <span class="keyword">and</span> nums[indices[<span class="number">-1</span>]] &lt; nums[i]:</span><br><span class="line">                table[indices[<span class="number">-1</span>]] = nums[i]</span><br><span class="line">                indices.pop()</span><br><span class="line">            <span class="comment"># 注意，保存索引</span></span><br><span class="line">            indices.append(i)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 返回前n个数</span></span><br><span class="line">        <span class="keyword">return</span> table[: len(nums) // <span class="number">2</span>]</span><br></pre></td></tr></table></figure><h2 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a><a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">每日温度</a></h2><p>请根据每日气温列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用$0$来代替。</p><p>例如，给定一个列表<code>temperatures = [73, 74, 75, 71, 69, 72, 76, 73]</code>，你的输出应该是<code>[1, 1, 4, 2, 1, 1, 0, 0]</code>。</p><p>提示：气温列表长度的范围是$[1, 30000]$。每个气温的值的均为华氏度，都是在$[30, 100]$范围内的整数。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span><span class="params">(self, T: List[int])</span> -&gt; List[int]:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        </span><br><span class="line">        daysToWait = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(T))]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 栈底到栈顶递减的单调栈</span></span><br><span class="line">        indices = deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(T)):</span><br><span class="line">            <span class="comment"># 将小于`T[i]`的栈顶元素全部出栈</span></span><br><span class="line">            <span class="keyword">while</span> len(indices) &gt; <span class="number">0</span> <span class="keyword">and</span> T[indices[<span class="number">-1</span>]] &lt; T[i]:</span><br><span class="line">                daysToWait[indices[<span class="number">-1</span>]] = i - indices[<span class="number">-1</span>]</span><br><span class="line">                indices.pop()</span><br><span class="line">            <span class="comment"># 注意，保存索引</span></span><br><span class="line">            indices.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> daysToWait</span><br></pre></td></tr></table></figure><h2 id="柱状图中最大的矩形"><a href="#柱状图中最大的矩形" class="headerlink" title="柱状图中最大的矩形"></a>柱状图中最大的矩形</h2><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1。求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png" alt></p><p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png" alt></p><p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,1,5,6,2,3]</span><br><span class="line">输出: 10</span><br></pre></td></tr></table></figure></p><p>能勾勒出的最大矩形，一定是<strong>以某个柱子开始的</strong>(即高度为该柱子高度)，而宽度是<strong>以该柱子开始连续递增的柱子个数</strong>，如下图所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">      |o|             |o|             |o|             |x|             |o|             |o|</span><br><span class="line">    |o|o|           |o|o|           |x|x|           |o|x|           |o|o|           |o|o|</span><br><span class="line">    |o|o|           |o|o|           |x|x|           |o|x|           |o|o|           |o|o|</span><br><span class="line">    |o|o| |o|       |o|o| |o|       |x|x| |o|       |o|x| |o|       |o|o| |o|       |o|o| |x|</span><br><span class="line">|x| |o|o|o|o|   |o| |o|o|o|o|   |o| |x|x|o|o|   |o| |o|x|o|o|   |o| |o|o|x|x|   |o| |o|o|o|x|</span><br><span class="line">|x|o|o|o|o|o|   |o|x|x|x|x|x|   |o|o|x|x|o|o|   |o|o|o|x|o|o|   |o|o|o|o|x|x|   |o|o|o|o|o|x|</span><br></pre></td></tr></table></figure><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, heights)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        <span class="comment"># 最后一个柱子也要考虑</span></span><br><span class="line">        heights += [<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 初始化</span></span><br><span class="line">        largetsRA = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 单调递增栈</span></span><br><span class="line">        indices = deque()</span><br><span class="line">        <span class="keyword">for</span> i, height <span class="keyword">in</span> enumerate(heights):</span><br><span class="line">            <span class="keyword">while</span> len(indices) &gt; <span class="number">0</span> <span class="keyword">and</span> heights[indices[<span class="number">-1</span>]] &gt;= height:</span><br><span class="line">                <span class="comment"># 以之前比`height`高的柱子开始的矩形结束宽度计数</span></span><br><span class="line">                h = heights[indices[<span class="number">-1</span>]]</span><br><span class="line">                <span class="comment"># 出栈</span></span><br><span class="line">                indices.pop()</span><br><span class="line">                <span class="comment"># 计算宽度</span></span><br><span class="line">                w = (i - <span class="number">1</span>) - (indices[<span class="number">-1</span>] <span class="keyword">if</span> len(indices) &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">-1</span>)</span><br><span class="line">                <span class="comment"># 计算面积</span></span><br><span class="line">                largetsRA = max(largetsRA, h * w)</span><br><span class="line">            <span class="comment"># 入栈</span></span><br><span class="line">            indices.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> largetsRA</span><br></pre></td></tr></table></figure></p><h1 id="单调队列：解决滑动窗口问题"><a href="#单调队列：解决滑动窗口问题" class="headerlink" title="单调队列：解决滑动窗口问题"></a>单调队列：解决滑动窗口问题</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p><strong>单调队列</strong>(monotonic queue)是在队列的基础上添加一些逻辑，使每次新元素入栈后，栈内的元素都保持有序(单调递增或单调递减)，一般都是需要得到当前的某个范围内的最小值或最大值，<strong>用于解决滑动窗口的一系列问题</strong>。</p><p>以求取滑动窗口最大值为例，其具体思路是，将队列作为缓存，实际上使用的是<strong>双端队列</strong></p><ul><li>队列用作滑窗，首先将<strong>位于本次循环滑窗外的元素索引</strong>从队列删除；</li><li>队列内部保证<strong>单调递减</strong>，那么<strong>队列头部始终是滑窗的最大值</strong>；</li><li>在加入新的数时，<strong>从队列尾操作，将队列尾部小于新元素的值删除</strong>(双端队列)。</li></ul><p>维护单调队列的关键代码如下<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单调递减队列</span></span><br><span class="line">indices = deque()</span><br><span class="line"><span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">    <span class="comment"># 删除本次滑窗外的元素</span></span><br><span class="line">    <span class="keyword">if</span> len(indices) &gt; <span class="number">0</span> <span class="keyword">and</span> indices[<span class="number">0</span>] &lt;= i - k:</span><br><span class="line">        indices.popleft()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保持单调递减，将**队列尾**小于`num`的元素删除</span></span><br><span class="line">    <span class="keyword">while</span> len(indices) &gt; <span class="number">0</span> <span class="keyword">and</span> nums[indices[<span class="number">-1</span>]] &lt; num:</span><br><span class="line">        indices.pop()</span><br><span class="line">    <span class="comment"># 新元素加入队列</span></span><br><span class="line">    indices.append(i)</span><br></pre></td></tr></table></figure></p><p>例如给定数组$[1, 3, -1, -3, 5, 3, 6, 7]$，滑窗大小是$3$，其计算过程如下，可以看到每次操作结束后，队首都是滑窗内的最大值，时间复杂度是$O(n)$。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">1 3 -1 3 5 3 6 7</span><br><span class="line">队列: []</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">元素个数小于k，初始化滑窗</span><br><span class="line">-----------------------------------</span><br><span class="line">[1] 3 -1 3 5 3 6 7</span><br><span class="line">队列: [] --入队尾--&gt; [1]</span><br><span class="line">-----------------------</span><br><span class="line">[1 3] -1 3 5 3 6 7</span><br><span class="line">队列: [1] --出队尾--&gt; [] --入队尾--&gt; [3]</span><br><span class="line">-----------------------</span><br><span class="line">[1 3 -1] 3 5 3 6 7</span><br><span class="line">队列: [3] --入队尾--&gt; [3 -1]</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">滑窗初始化结束</span><br><span class="line">-----------------------------------</span><br><span class="line">1 [3 -1 3] 5 3 6 7</span><br><span class="line">队列: [3 -1] --出队尾--&gt; [3] --入队尾--&gt; [3 3]</span><br><span class="line">-----------------------</span><br><span class="line">1 3 [-1 3 5] 3 6 7</span><br><span class="line">队列: [3 3] --出队首--&gt; [3] --出队尾--&gt; [] --入队尾--&gt; [5]</span><br><span class="line">-----------------------</span><br><span class="line">1 3 -1 [3 5 3] 6 7</span><br><span class="line">队列: [5] --入队尾--&gt; [5 3]</span><br><span class="line">-----------------------</span><br><span class="line">1 3 -1 3 [5 3 6] 7</span><br><span class="line">队列: [5 3] --出队尾--&gt; [] --入队尾--&gt; [6]</span><br><span class="line">-----------------------</span><br><span class="line">1 3 -1 3 5 [3 6 7]</span><br><span class="line">队列: [6] --出队尾--&gt; [] --入队尾--&gt; [7]</span><br></pre></td></tr></table></figure></p><h2 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">滑动窗口最大值</a></h2><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的最大值。<br>进阶：你能在线性时间复杂度内解决此题吗？<br>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3</span><br><span class="line">输出: [3,3,5,5,6,7] </span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><br>提示：</p><ul><li>1 &lt;= nums.length &lt;= 10^5</li><li>-10^4 &lt;= nums[i] &lt;= 10^4</li><li>1 &lt;= k &lt;= nums.length</li></ul><p>时间复杂度$O(n)$，空间复杂度$O(n)$<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        ret = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        <span class="comment"># 单调递减队列</span></span><br><span class="line">        indices = deque()</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="comment"># 删除本次滑窗外的元素</span></span><br><span class="line">            <span class="keyword">if</span> len(indices) &gt; <span class="number">0</span> <span class="keyword">and</span> indices[<span class="number">0</span>] &lt;= i - k:</span><br><span class="line">                indices.popleft()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 保持单调递减，将**队列尾**小于`num`的元素删除</span></span><br><span class="line">            <span class="keyword">while</span> len(indices) &gt; <span class="number">0</span> <span class="keyword">and</span> nums[indices[<span class="number">-1</span>]] &lt; num:</span><br><span class="line">                indices.pop()</span><br><span class="line">            <span class="comment"># 新元素加入队列</span></span><br><span class="line">            indices.append(i)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 从索引为`k-1`的数开始，队列头是当前滑窗最大值</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= k - <span class="number">1</span>: </span><br><span class="line">                ret += [nums[indices[<span class="number">0</span>]]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Data Mining: Data Preprocessing</title>
      <link href="/2020/06/26/Data-Mining-Data-Preprocessing/"/>
      <url>/2020/06/26/Data-Mining-Data-Preprocessing/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#目录">目录</a></li><li><a href="#认识数据">认识数据</a><ul><li><a href="#数据对象与属性类型">数据对象与属性类型</a><ul><li><a href="#标称二元序数数值区间标度比率标度">标称、二元、序数、数值(区间标度、比率标度)</a></li><li><a href="#离散连续">离散、连续</a></li></ul></li><li><a href="#基本统计描述">基本统计描述</a><ul><li><a href="#中心趋势度量均值中位数众数中列数">中心趋势度量：均值、中位数、众数、中列数</a></li><li><a href="#数据散布度量方差标准差极差四分位数四分位数极差">数据散布度量：方差、标准差、极差、四分位数、四分位数极差</a></li><li><a href="#图形显示分位数图分位数-分位数图直方图散点图">图形显示：分位数图、分位数-分位数图、直方图、散点图</a></li></ul></li><li><a href="#数据可视化">数据可视化</a></li><li><a href="#数据的相似性和相异性">数据的相似性和相异性</a><ul><li><a href="#数据矩阵与相异性矩阵">数据矩阵与相异性矩阵</a></li><li><a href="#标称属性的邻近性度量不匹配率">标称属性的邻近性度量：不匹配率</a></li><li><a href="#二元属性的邻近性度量">二元属性的邻近性度量</a><ul><li><a href="#对称的二元属性">对称的二元属性</a></li><li><a href="#非对称的二元属性jaccard系数">非对称的二元属性：Jaccard系数</a></li></ul></li><li><a href="#数值属性的邻近性度量math-xmlnshttpwwww3org1998mathmathmlsemanticsmrowmsubmilmimn1mnmsubmo-separatortruemomsubmilmimn2mnmsubmo-separatortruemomsubmilmimipmimsubmo-separatortruemomsubmilmimi-mathvariantnormalmimsubmrowannotation-encodingapplicationx-texl_1-l_2-l_p-l_inftyannotationsemanticsmathl1l2lpl-math-xmlnshttpwwww3org1998mathmathmlsemanticsmrowmsubmilmimimmimsubmrowannotation-encodingapplicationx-texl_mannotationsemanticsmathlm">数值属性的邻近性度量：$L_1, L_2, L_p, L_{\infty}$, $L_{M}$</a></li><li><a href="#序数属性的邻近性度量">序数属性的邻近性度量</a></li><li><a href="#混合类型属性的邻近性度量">混合类型属性的邻近性度量</a></li><li><a href="#余弦相似度度量和tanimoto系数">余弦相似度度量和Tanimoto系数</a></li></ul></li></ul></li><li><a href="#数据预处理">数据预处理</a><ul><li><a href="#数据清理">数据清理</a><ul><li><a href="#缺失值">缺失值</a></li><li><a href="#噪声">噪声</a></li><li><a href="#清理过程">清理过程</a></li></ul></li><li><a href="#数据集成">数据集成</a><ul><li><a href="#实体识别">实体识别</a></li><li><a href="#冗余和相关分析">冗余和相关分析</a><ul><li><a href="#标称数据的math-xmlnshttpwwww3org1998mathmathmlsemanticsmrowmsupmiχmimn2mnmsupmrowannotation-encodingapplicationx-texchi2annotationsemanticsmathχ2检验">标称数据的$\chi^2$检验</a></li><li><a href="#数值数据的相关系数">数值数据的相关系数</a></li></ul></li></ul></li><li><a href="#数据归约">数据归约</a><ul><li><a href="#维规约">维规约</a><ul><li><a href="#小波变换dwt">小波变换：DWT</a></li><li><a href="#主成分分析pca">主成分分析：PCA</a></li><li><a href="#属性子集选择">属性子集选择</a></li><li><a href="#回归和对数线性模型参数化数据规约">回归和对数线性模型：参数化数据规约</a></li></ul></li><li><a href="#数量规约">数量规约</a><ul><li><a href="#直方图">直方图</a></li><li><a href="#聚类">聚类</a></li><li><a href="#抽样">抽样</a></li><li><a href="#数据立方体聚集">数据立方体聚集</a></li></ul></li><li><a href="#数据压缩">数据压缩</a></li></ul></li><li><a href="#数据变换">数据变换</a><ul><li><a href="#规范化">规范化</a><ul><li><a href="#min-max最小-最大规范化">min-max(最小-最大)规范化</a></li><li><a href="#z-score零均值规范化">z-score(零均值)规范化</a></li><li><a href="#按小数定标规范化">按小数定标规范化</a></li><li><a href="#min-max与z-score的关系与对比">min-max与z-score的关系与对比</a></li></ul></li><li><a href="#数据离散化">数据离散化</a><ul><li><a href="#分箱">分箱</a></li><li><a href="#聚类-1">聚类</a></li><li><a href="#决策树">决策树</a></li><li><a href="#相关分析">相关分析</a></li></ul></li><li><a href="#概念分层">概念分层</a></li></ul></li></ul></li></ul><h1 id="认识数据"><a href="#认识数据" class="headerlink" title="认识数据"></a>认识数据</h1><h2 id="数据对象与属性类型"><a href="#数据对象与属性类型" class="headerlink" title="数据对象与属性类型"></a>数据对象与属性类型</h2><p>数据集由<strong>数据对象</strong>组成，一个数据对象代表一个实体；<strong>属性</strong>是一个数据字段，表示数据对象的一个特征。</p><h3 id="标称、二元、序数、数值-区间标度、比率标度"><a href="#标称、二元、序数、数值-区间标度、比率标度" class="headerlink" title="标称、二元、序数、数值(区间标度、比率标度)"></a>标称、二元、序数、数值(区间标度、比率标度)</h3><p>标称、二元、序数属性都是<strong>定性</strong>的，仅描述对象特征而不给出实际大小或数目</p><ol><li><strong>标称属性</strong>(nominal/categorical attribute)：值为一些符号或事务的名称，代表某种类别、编码或状态，不必具有有意义的序，也不是定量的；在计算机中，可视作<strong>枚举</strong>(enumeration)的。如头发颜色(黑、棕、淡黄、红色……)，职业(教师、牙医、程序员、农民……)，顾客编号等。</li><li><strong>二元属性</strong>(binary/bool attribute)：是一种标称属性，只有两个类别或状态。若两种状态具有同种价值且权重相同，则称该二元属性是<strong>对称的</strong>，如性别(男、女)；否则如果其状态结果不同等重要，则称<strong>不对称的</strong>，如艾滋病(阴性、阳性)阳性结果较为重要，一般作为$1$。</li><li><strong>序数属性</strong>(ordinal attribute)：可能的取值间具有有意义的序或秩(ranking)，但是相继值之间的差未知；也可以通过把数值属性进行值域划分，离散化为多个有序类别得到。<strong>序数属性的中心趋势可以用众数和中位数度量，但不能定义均值</strong>。如顾客满意度(满意、中等、不满意)。</li><li><strong>数值属性</strong>(numerical attribute)：定量的，即可度量的量，用实数表示，可以是<strong>区间标度的</strong>或<strong>比率标度的</strong><ol><li><strong>区间标度</strong>(interval-scaled)：用相等的单位尺度度量，除了中心度量众数和中位数度量外还可以定义均值。但是这类属性不具有真正的零点，<strong>不能用比率描述不同值的关系</strong>，例如温度、日期；</li><li><strong>比率标度</strong>(ratio-scaled)：具有固定零点的数值属性，除了中心度量众数和中位数度量外还可以定义均值。<strong>可以用比率描述值的关系</strong>，例如长度、速度。</li></ol></li></ol><h3 id="离散、连续"><a href="#离散、连续" class="headerlink" title="离散、连续"></a>离散、连续</h3><ul><li><strong>离散属性</strong>：具有有限或无限可数个值，可以用或不用整数表示，可以是标称的、二元的、序数的、数值的。如果一个属性可能的值集合是无限的，但是可以与自然数一一对应，那么称之为是<strong>无限可数的</strong>。在实践中用有限位数字表示；</li><li><strong>连续属性</strong>：不是离散的属性就是连续的，实践中一般用浮点变量表示。</li></ul><h2 id="基本统计描述"><a href="#基本统计描述" class="headerlink" title="基本统计描述"></a>基本统计描述</h2><h3 id="中心趋势度量：均值、中位数、众数、中列数"><a href="#中心趋势度量：均值、中位数、众数、中列数" class="headerlink" title="中心趋势度量：均值、中位数、众数、中列数"></a>中心趋势度量：均值、中位数、众数、中列数</h3><ol><li><p><strong>均值</strong>(mean)<br> 令$x_1, \cdots, x_n$为属性$X$的$n$个观测值，那么<strong>均值</strong>定义为</p><script type="math/tex; mode=display">\overline{x} = \frac{1}{n} \sum_{i=1}^n x_i</script><p> 若每个值$x_i$存在权重$w_i$与之对应，那么<strong>加权算术均值</strong>定义为</p><script type="math/tex; mode=display">\overline{x} = \frac{\sum_{i=1}^n w_i x_i}{\sum_{i=1}^n w_i}</script><p> 均值的主要问题是<strong>对极端值很敏感</strong>，如离群点，为减少少数极端值影响，用<strong>舍弃极端值</strong>(如舍弃最高和最低的$2\%$)后的数据计算均值，也即<strong>截尾均值</strong>，但是要避免截去太多。</p></li><li><p><strong>中位数</strong>(median)<br> 有序数值的中间值，<strong>将数据较高一半和较低一半划分开</strong>。对于倾斜(非对称)数据，中位数是比均值更好的度量。注意在$n$个观测值下，$n$不同奇偶性计算方法不同：奇数下取中间值，偶数下取作中间两个值的平均值。<br> <strong>当观测数据数量很大时</strong>，求取中位数计算开销很大，可以用<strong>插值</strong>的方式近似求解：将数据$x_i$划分为多个区间，每个区间的频数是可以统计的，令包含中位数的区间为<strong>中位数区间</strong>，记</p><ul><li>$L_1$：中位数区间下界；</li><li>$N$：全部数据个数；</li><li>$freq_{median}$：中位数区间的频数；</li><li>$width$：中位数区间宽度。</li><li><p>$(\sum freq)_i$：低于中位数区间的所有区间的频数和；</p><p>那么</p><script type="math/tex; mode=display">median = L_1 + \frac{N/2 - (\sum freq)_i}{freq_{median}} \times width</script></li></ul></li><li><p><strong>众数</strong>(mode)<br> 是集合中出现最频繁的值，可以对定性和定量属性确定众数。最高频率可能对应多个不同值出现多个众数，具有一个、两个、三个众数的数据集合称为<strong>单峰的</strong>(unimodal)、<strong>双峰的</strong>(bimodal)、<strong>三峰的</strong>(trimodal)。<br> 对于适度倾斜(非对称)的单峰数据，有如下经验关系，可以通过均值和中位数近似计算</p><script type="math/tex; mode=display">mean - mode \approx 3 \times (mean - median)</script></li><li><p><strong>中列数</strong>(midrange)<br> 数据集的最大和最小值的均值。</p></li></ol><h3 id="数据散布度量：方差、标准差、极差、四分位数、四分位数极差"><a href="#数据散布度量：方差、标准差、极差、四分位数、四分位数极差" class="headerlink" title="数据散布度量：方差、标准差、极差、四分位数、四分位数极差"></a>数据散布度量：方差、标准差、极差、四分位数、四分位数极差</h3><ol><li><strong>方差和标准差</strong><br> 对于属性$X$的$n$个观测值$x_1, \cdots, x_n$，其<strong>方差</strong>(variance)为<script type="math/tex; mode=display">\sigma^2 = \frac{1}{n - 1} \sum_{i=1}^n (x_i - \overline{x})^2</script></li></ol><pre><code>&gt; 原书中为有偏的样本方差。**标准差$\sigma$低表示数据观测趋向于非常靠近均值**，有如下性质- $\sigma$用作度量均值的发散，仅当选择均值作为中心度量时使用；- 所有观测值具有相同值是，$\sigma = 0$，否则$\sigma &gt; 0$。标准差是数据集发散的很好指示器，一个观测通常不会远离均值太多，可以证明最少$(1 - 1 / k^2) \times 100 \%$的观测离均值不会超过$k$个标准差。</code></pre><ol><li><p><strong>极差、四分位数和四分位数极差</strong></p><ul><li><strong>极差</strong>(range)：最大值和最小值之差；</li><li><p><strong>分位数</strong>(quantile)：假设属性$X$有$n$个按递增排列的观测，<strong>在数据分布上取$(q-1)$个$q-$分位数，将数据划分为$q$个大小近似为$n/q$的子集合</strong>。第$k$个$q-$分位数处的数据点为$x$，那么有$k/q \times 100\%$的数据小于$x$。</p><ul><li><strong>中位数</strong>：即$2-$分位数，将数据划分为两半；</li><li><strong>四分位数</strong>：数据划分为$4$个相等的部分；</li><li><strong>百分位数</strong>：即$100-$分位数.</li></ul><p>四分位数可以给出分布的<strong>中心、散布和形状</strong>的某种指示：第$1$个四分位数记作$Q_1$，砍去数据最低的$25\%$；第$2$个四分位数即中位数，给出数据分布的中心；第$3$个四分位数记作$Q_3$，砍去数据最高的$25\%$。那么<strong>四分位数极差(</strong>IQR)定义为</p><script type="math/tex; mode=display">IQR = Q_3 - Q1</script><p><strong>离群点识别的通常规则</strong>是：落在$Q_1$之下或$Q_3$之上至少$(1.5 \times IQR)$处的值。</p></li></ul></li><li><p><strong>五数概括</strong></p><p> <strong>五数概括</strong>(five-number summary)依次为</p><script type="math/tex; mode=display">Minimum, Q_1, Median, Q_3, Maximun</script><p> <strong>盒图</strong>(boxplot)是一种体现五数概括的直观表示</p><ul><li><strong>盒的端点</strong>一般在四分位数上；</li><li><strong>盒子的长度</strong>是四分位数极差；</li><li><strong>盒内的线</strong>标记中位数；</li><li><p><strong>盒外的两条线</strong>(胡须)延伸到最大和最小值。</p><p><img src="/.com//box-plot.jpg" alt="box-plot"></p></li></ul></li></ol><h3 id="图形显示：分位数图、分位数-分位数图、直方图、散点图"><a href="#图形显示：分位数图、分位数-分位数图、直方图、散点图" class="headerlink" title="图形显示：分位数图、分位数-分位数图、直方图、散点图"></a>图形显示：分位数图、分位数-分位数图、直方图、散点图</h3><ol><li><p><strong>分位数图</strong>(quantile plot)<br> 设属性$X$的$n$个观测<strong>按递增排列</strong>，定义$f_i$表示存在大约$f_i \times 100\%$的观测值小于$x_i$</p><script type="math/tex; mode=display">f_i = \frac{i - 0.5}{n}</script></li><li><p><strong>分位数-分位数图</strong>(quantile-quantile plot)<br> 用于观测从一个分布到另一个分布是否存在漂移。假设从一个分布中取得$n$个观测${x_i, i = 1, \cdots, n}$，从另一个分布中取得$n$个观测${y_i, i = 1, \cdots, n}$。两组观测递增排序后，以$(x_i, y_i)$为坐标点简单描点作图，即可得到$q-q$图。<br> <img src="/.com//q-q-plot.png" alt="q-q-plot"></p></li><li><p><strong>直方图</strong>(histogram)、<strong>频率直方图</strong>(frequency histogram)</p><ul><li><strong>标称数据</strong>：可以对于<strong>每个标称值</strong>，统计其出现的频数/频率进行作图；</li><li><strong>数值数据</strong>：将值域划分为<strong>不相交的连续子域</strong>(桶(bucket)、箱(bin))，范围称作宽度(通常等宽)，对落到每个子域内的数据频数/频率进行统计作图。</li></ul></li><li><strong>散点图</strong>(scatter plot)<br> 将数据点描绘在图上可得散点图，可用于确定两个数值变量间是否存在联系、模式或趋势，例如观察点簇和离群点，或考察相关性。</li></ol><h2 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h2><p>略。</p><h2 id="数据的相似性和相异性"><a href="#数据的相似性和相异性" class="headerlink" title="数据的相似性和相异性"></a>数据的相似性和相异性</h2><h3 id="数据矩阵与相异性矩阵"><a href="#数据矩阵与相异性矩阵" class="headerlink" title="数据矩阵与相异性矩阵"></a>数据矩阵与相异性矩阵</h3><p>基于内存的聚类和最近邻算法都在如下两种数据结构上进行</p><ul><li><p><strong>数值矩阵</strong>(data matrix)：由$n$个$p$维对象组成的$n \times p$矩阵</p><script type="math/tex; mode=display">  \begin{bmatrix}      x_{11} & \cdots & x_{1p} \\      x_{21} & \cdots & x_{2p} \\      \vdots & \ddots & \vdots \\      x_{n1} & \cdots & x_{np}  \end{bmatrix}</script></li><li><p><strong>相异性矩阵</strong>(dissimilarity matrix)：存放$n$个对象两两之间<strong>邻近度</strong>(proximity)的$n \times n$矩阵</p><script type="math/tex; mode=display">  \begin{bmatrix}           0 & d_{12} & \cdots & d_{1n} \\      d_{21} & 0 & \cdots & d_{2n} \\      \vdots & \vdots & \ddots & \vdots \\      d_{n1} & d_{n2} & \cdots & 0  \end{bmatrix}</script></li></ul><h3 id="标称属性的邻近性度量：不匹配率"><a href="#标称属性的邻近性度量：不匹配率" class="headerlink" title="标称属性的邻近性度量：不匹配率"></a>标称属性的邻近性度量：不匹配率</h3><p>用标称属性刻画的对象$i, j$之间相异性可以用<strong>不匹配率</strong>计算</p><script type="math/tex; mode=display">d(i, j) = \frac{p - m}{p}</script><p>其中</p><ul><li>$m$：匹配的属性数，即$i, j$取值相同的属性数；</li><li>$p$：对象的属性数</li></ul><p>那么<strong>相似性</strong>为</p><script type="math/tex; mode=display">s(i, j) = 1 - d(i, j) = \frac{m}{p}</script><p>或者用$one-hot$编码处理标称属性后，用<a href="#%e4%ba%8c%e5%85%83%e5%b1%9e%e6%80%a7%e7%9a%84%e9%82%bb%e8%bf%91%e6%80%a7%e5%ba%a6%e9%87%8f">二元属性的邻近性度量</a>进行度量。</p><h3 id="二元属性的邻近性度量"><a href="#二元属性的邻近性度量" class="headerlink" title="二元属性的邻近性度量"></a>二元属性的邻近性度量</h3><p>假设有$p$维二元属性的对象$i, j$，用$q, r, s, t$分别表示$i, j$取值匹配的属性数，如表</p><div class="table-container"><table><thead><tr><th>对象</th><th>1</th><th>0</th><th>sum</th></tr></thead><tbody><tr><td>1</td><td>q</td><td>r</td><td>q + r</td></tr><tr><td>0</td><td>s</td><td>t</td><td>s + t</td></tr><tr><td>sum</td><td>q + s</td><td>r + t</td><td>p</td></tr></tbody></table></div><h4 id="对称的二元属性"><a href="#对称的二元属性" class="headerlink" title="对称的二元属性"></a>对称的二元属性</h4><p>对称的二元属性指每个状态同等重要，那么$i, j$相异性为</p><script type="math/tex; mode=display">d(i, j) = \frac{r + s}{q + r + s + t}</script><p>相似性</p><script type="math/tex; mode=display">s(i, j) = 1 - d(i, j)</script><h4 id="非对称的二元属性：Jaccard系数"><a href="#非对称的二元属性：Jaccard系数" class="headerlink" title="非对称的二元属性：Jaccard系数"></a>非对称的二元属性：Jaccard系数</h4><p>两种状态并不是同等重要的二元属性，负匹配$t$(两个对象取$0$)的属性被视作是不重要的，那么</p><script type="math/tex; mode=display">d(i, j) = \frac{r + s}{q + r + s}</script><p>对应的相似性被称作<strong>Jaccard系数</strong>，即</p><script type="math/tex; mode=display">J(i, j) = s(i, j) = 1 - d(i, j)</script><h3 id="数值属性的邻近性度量：-L-1-L-2-L-p-L-infty-L-M"><a href="#数值属性的邻近性度量：-L-1-L-2-L-p-L-infty-L-M" class="headerlink" title="数值属性的邻近性度量：$L_1, L_2, L_p, L_{\infty}$, $L_{M}$"></a>数值属性的邻近性度量：$L_1, L_2, L_p, L_{\infty}$, $L_{M}$</h3><p>在计算数值属性的邻近性度量时，一般先进行<strong>规范化</strong>，涉及调整值域的数据变换。</p><p>满足如下性质的测度称作<strong>度量</strong>(metric)</p><ul><li><strong>非负性</strong>：$d(i, j) \geq 0$</li><li><strong>同一性</strong>：$d_{ii} = 0$</li><li><strong>对称性</strong>：$d(i, j) = d{ji}$</li><li><strong>三角不等式</strong>：$d(i, j) \leq d_{ik} + d_{kj}$</li></ul><p>以下距离均满足度量性质</p><ul><li><p>曼哈顿距离：$L_1$</p><script type="math/tex; mode=display">d(i, j) = \sum_{f=1}^{p} | x_{if} - x_{jf} |</script></li><li><p>欧几里得距离：$L_2$</p><script type="math/tex; mode=display">d(i, j) = \sqrt{\sum_{f=1}^{p} | x_{if} - x_{jf} |^2}</script></li><li><p>闵可夫斯基距离：$L_p$</p><script type="math/tex; mode=display">d(i, j) = \left( \sum_{f=1}^{p} | x_{if} - x_{jf} |^p \right)^{1/p}</script></li><li><p>上确界距离：$L_{\infty}$</p><script type="math/tex; mode=display">d(i, j) = \lim_{p \rightarrow \infty} \left( \sum_{f=1}^{p} | x_{if} - x_{jf} |^p \right)^{1/p} = \max_{f}^{p} | x_{if} - x_{jf} |</script></li><li><p>马氏距离: $L_M$</p><script type="math/tex; mode=display">d(i, j) = \sqrt{(x_{i} - x_{j})^T \Sigma^{-1}(x_{i} - x_{j})}</script><p>  其中$\Sigma$是多为随机变量$x_{i}, x_{j}$的协方差矩阵。</p></li></ul><p>在计算距离时，还可以对每个变量进行加权，如<strong>加权的欧几里得距离</strong>为</p><script type="math/tex; mode=display">d(i, j) = \sqrt{\sum_{f=1}^{p} w_f \times | x_{if} - x_{jf} |^2}</script><h3 id="序数属性的邻近性度量"><a href="#序数属性的邻近性度量" class="headerlink" title="序数属性的邻近性度量"></a>序数属性的邻近性度量</h3><p>假设$f$是描述对象的一组序数属性，有$M_f$个有序的<strong>排位</strong>$1, 2, \cdots, m_{if}, \cdots, M_f$。若第$i$个对象的属性$f$取值为$x_{if}$，用相应的排位$m_{if}$代替$x_{if}$，使$n$个对象的属性$f$转化为数值属性，然后通过值域变换将其缩放到$[0.0, 1.0]$上，<strong>用数值属性的距离度量进行计算</strong>，即</p><script type="math/tex; mode=display">z_{if} = \frac{m_{if} - 1}{M_{if} - 1}</script><h3 id="混合类型属性的邻近性度量"><a href="#混合类型属性的邻近性度量" class="headerlink" title="混合类型属性的邻近性度量"></a>混合类型属性的邻近性度量</h3><p>假设对象$x$的$p$个属性包含多种类型，可以将所有有意义的属性转换到共有区间$[0.0, 1.0]$上。对象$i, j$的<strong>相异性</strong>定义为</p><script type="math/tex; mode=display">d(i, j) = \frac{\sum_{f=1}^p \delta_{ij}^{(f)} d_{ij}^{(f)}}{\sum_{f=1}^p \delta_{ij}^{(f)}}</script><p>其中</p><ul><li><p>$\delta_{ij}^{(f)}$为<strong>指示符</strong>，舍弃无意义属性值</p><script type="math/tex; mode=display">  \delta_{ij}^{(f)} = \begin{cases}       0 & x_{if}或x_{jf}缺失，或者x_{if} = x_{jf} = 0 \\       1 & otherwise   \end{cases}</script></li><li><p>$d_{ij}^{(f)}$为$i, j$间<strong>相似度的贡献</strong>，根据不同类型计算</p><script type="math/tex; mode=display">  d_{ij}^{(f)} = \begin{cases}      \frac{|x_{if} - x_{jf}|}{ \max_h x_{hf} - \min_h x_{hf} } & f为数值类型 \\      \begin{cases}          1 & x_{if} = x_{jf} \\ 0 & x_{if} \neq x_{jf}      \end{cases} & f为标称或二元类型 \\      计算排位m_f和z_f，视作数值类型 & f为序数类型  \end{cases}</script><blockquote><ul><li>数值类型时，即<strong>最大-最小规范化后两属性的绝对差值</strong>(曼哈顿距离)，也可使用其他距离？</li><li>标称或二元属性时，这里使用的是<strong>Jaccard距离</strong>。</li></ul></blockquote></li></ul><h3 id="余弦相似度度量和Tanimoto系数"><a href="#余弦相似度度量和Tanimoto系数" class="headerlink" title="余弦相似度度量和Tanimoto系数"></a>余弦相似度度量和Tanimoto系数</h3><p><strong>稀疏的对象向量是高度非对称的</strong>，很多公共的$0$并不重要，但是不忽略会使得他们相似度降低。用余弦度量作为相似度函数，有</p><script type="math/tex; mode=display">s(x, y) = \frac{x \cdot y}{||x|| ||y||}</script><blockquote><p>注意余弦度量不满足度量的性质，故被称作<strong>非度量测度</strong>(nonmetric measure)。</p></blockquote><p>当属性为二元属性时，$x \cdot y$是$x, y$共有为$1$的属性数，$x \cdot x$与$y \cdot y$分别为$x, y$为$1$的属性数，那么余弦度量的变种<strong>Tanimoto系数</strong>定义为</p><script type="math/tex; mode=display">s(x, y) = \frac{x \cdot y}{x \cdot x + y \cdot y - x \cdot y}</script><blockquote><p>可以理解为$与 / 或$的运算。</p></blockquote><h1 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h1><p><strong>数据质量</strong>包括以下因素</p><ul><li>准确性</li><li>完整性</li><li>一致性</li><li>时效性</li><li>可信性</li><li>可解释性</li></ul><h2 id="数据清理"><a href="#数据清理" class="headerlink" title="数据清理"></a>数据清理</h2><h3 id="缺失值"><a href="#缺失值" class="headerlink" title="缺失值"></a>缺失值</h3><p>许多元组的一些属性可能没有记录值，即存在缺失值，有以下<strong>原因</strong>可能产生缺失值</p><ul><li>被要求提供属性值的人拒绝提供和/或没有所需要的信息；</li><li>数据输入者不知道正确的值；</li><li>值在稍后提供。</li></ul><p>有如下<strong>方法</strong>处理</p><ol><li><strong>忽略元组</strong>：通常在缺少类标号时使用，忽略整个元组，可能丢失剩余有效的属性值，特别是在每个属性缺失值变化很大时效果很差；</li><li><strong>人工填写</strong>：费时费力；</li><li><strong>全局常量填充</strong>：常量可能被挖掘算法视作一个有趣的概念，并不十分可靠；</li><li><strong>全局中心度量填充</strong>：对称数据分布可以使用均值，非对称数据分布应使用中位数；</li><li><strong>同类中心度量填充</strong>：填充与该元组类标号一致的数据的中心度量；</li><li><strong>基于推理填充</strong>：用回归、贝叶斯、决策树等方法推断缺失值；</li><li><strong>随机填充</strong>：在缺失量特别少(通常认为小于1%)的时候，可以随机生成。</li></ol><ul><li>$3 \sim 6$使数据有偏，填入值可能不正确；</li><li>缺失值并不意味着数据有误，例如某项无可填选项时用户自然不填；</li><li>实际机器学习工程中，直接删除、众数填充和直接离散化方法用的最多。</li></ul><p>每个属性应当有一个或多个关于空值条件的规则，用以说明是否允许有空值，并且/或者说明空值应当如何处理或转换，<strong>好的数据库和数据输入设计将有助于在第一现场将缺失值或错误数量降到最低</strong>。</p><h3 id="噪声"><a href="#噪声" class="headerlink" title="噪声"></a>噪声</h3><p>噪声是指被测量的变量的随机误差或方差，可以用<strong>数据光滑技术</strong>一定程度去除噪声影响</p><ol><li><strong>分箱</strong>：通过考察数据的“近邻”来光滑有序数据值，先将数据划分到大小相同的箱中，然后每个箱内进行光滑操作<ul><li>用箱中心度量光滑：箱内数据计算中心度量(均值、中位数等)，替代箱中数据；</li><li>用箱边界值光滑：计算箱中的最大、最小值，箱中每个值替换为最近的边界值。</li></ul></li><li><strong>回归</strong>：用回归方法拟合数据来光滑数据</li><li><strong>离群点分析</strong>：用聚类等方法检测离群点，并将其去除</li></ol><h3 id="清理过程"><a href="#清理过程" class="headerlink" title="清理过程"></a>清理过程</h3><p>数据清理一般通过<strong>偏差检测</strong>和<strong>数据变换</strong>两个过程迭代执行</p><ol><li><p><strong>偏差检测</strong></p><ul><li>可以通过<strong>元数据</strong>发现噪声、离群点和需要考察的不寻常的值。元数据包括<ul><li>数据类型</li><li>定义域</li><li>均值、中位数、众数等统计量</li><li>数据分布是否对称</li><li>数据分布是否符合期望，如数据落在期望的区间</li><li>每个属性的标准差</li><li>属性间的依赖关系</li><li>……</li></ul></li><li>根据<strong>唯一性规则、连续性规则和空值规则</strong>考察数据<ul><li><strong>唯一性规则</strong>：给定属性的每个值都必须不同于该属性的其他值；</li><li><strong>连续性规则</strong>：属性的最低和最高值之间没有缺失值，并且所有的值唯一；</li><li><strong>空值规则</strong>：说明指示空值条件的符号使用，以及如何处理。</li></ul></li></ul></li><li><p><strong>偏差纠正</strong>：定义并使用<strong>一系列</strong>变换来纠正偏差。</p></li></ol><h2 id="数据集成"><a href="#数据集成" class="headerlink" title="数据集成"></a>数据集成</h2><p><strong>数据集成</strong>是指合并来自多个数据存储的数据，小心集成可以减少数据集的冗余度和不一致。</p><h3 id="实体识别"><a href="#实体识别" class="headerlink" title="实体识别"></a>实体识别</h3><p><strong>实体识别问题</strong>是指如何匹配多个信息源的现实世界的等价实体。当一个数据库的属性与另一个匹配时，需要特别注意<strong>数据结构</strong>，确保源系统中函数依赖，以及参照约束与目标系统中的匹配。</p><h3 id="冗余和相关分析"><a href="#冗余和相关分析" class="headerlink" title="冗余和相关分析"></a>冗余和相关分析</h3><p><strong>冗余</strong>是指一个属性能由另一个(或另一组)属性导出，属性的命名不一致可能也会导致冗余。冗余可以通过<strong>相关分析</strong>检测：对于<strong>标称数据</strong>，可以<strong>采用$\chi^2$检验</strong>；<strong>数值数据</strong>可以采用<strong>相关系数</strong>(correlation coefficient)和<strong>协方差</strong>(covariance)检测。</p><h4 id="标称数据的-chi-2-检验"><a href="#标称数据的-chi-2-检验" class="headerlink" title="标称数据的$\chi^2$检验"></a>标称数据的$\chi^2$检验</h4><p>假设当前有两个属性$A, B$待检验，$A$包含$c$个不同值$a_1, \cdots, a_c$，$B$包含$r$个不同值$b_1, \cdots, b_r$。以$A$的$c$个属性值为列，$B$的$r$个属性值为行构成<strong>相依表</strong>，$(A_i, B_j)$表示联合事件$(A = a_i, B = b_j)$如下</p><div class="table-container"><table><thead><tr><th></th><th>$a_1$</th><th>$a_1$</th><th>$\cdots$</th><th>$a_c$</th><th>合计</th></tr></thead><tbody><tr><td>$b_1$</td><td>$o_{11}$</td><td>$o_{12}$</td><td></td><td>$o_{1c}$</td><td>$B_1$</td></tr><tr><td>$b_2$</td><td>$o_{21}$</td><td>$o_{22}$</td><td></td><td>$o_{2c}$</td><td>$B_2$</td></tr><tr><td>$\cdots$</td><td></td><td></td><td>$\ddots$</td><td></td><td>$\cdots$</td></tr><tr><td>$b_r$</td><td>$o_{r1}$</td><td>$o_{r2}$</td><td></td><td>$o_{rc}$</td><td>$B_r$</td></tr><tr><td>合计</td><td>$A_1$</td><td>$A_2$</td><td>$\cdots$</td><td>$A_c$</td><td>$n$</td></tr></tbody></table></div><p>那么$(A_i, B_j)$的<strong>期望频数</strong>为</p><script type="math/tex; mode=display">e_{ij} = \frac{|A_i| \times |B_j|}{n}</script><ul><li>$|A_i|$：$A$取$a_i$的元组个数；</li><li>$|B_j|$：$B$取$b_j$的元组个数；</li><li>$n$：总的元组个数。</li></ul><p>那么$\chi^2$计算方法如下</p><script type="math/tex; mode=display">\chi^2 = \sum_{i=1}^{c} \sum_{j=1}^r \frac{(o_{ij} - e_{ij})^2}{e_{ij}}</script><ul><li>$o_{ij}$：联合事件$(A_i, B_j)$的<strong>观测频数</strong>(实际计数)；</li><li>对$\chi^2$值贡献最大的是观测频数和期望频数很不相同的单元。</li></ul><p>$\chi^2$统计检验假设$A, B$独立，具有自由度$(r - 1) \times (c - 1)$，在置信水平$\alpha$下可以查找$\chi^2$分布百分点表得到拒绝假设的值。<strong>若计算得$\chi^2$值大于该值，那么可以拒绝$A, B$是独立的假设，也就是说这两个属性是相关的。</strong></p><h4 id="数值数据的相关系数"><a href="#数值数据的相关系数" class="headerlink" title="数值数据的相关系数"></a>数值数据的相关系数</h4><p>两个数值属性$A, B$的<strong>相关系数</strong>定义如下，$r_{AB} \in \left[-1, 1\right]$，该值的符号表示正/负相关，绝对值越大表示相关性越强。<strong>注意相关系数为$0$不能代表两个属性独立。</strong></p><script type="math/tex; mode=display">r_{AB} = \frac{Cov(A, B)}{\sqrt{D(A)} \sqrt{D(B)}} = \frac{\sum_{i=1}^n (a_i - \overline{A})(b_i - \overline{B})}{\sigma_A \sigma_B}</script><ul><li>$n$：元组总个数；</li><li>$a_i, b_i$：元组$i$在$A, B$上的值；</li><li>$\overline{A}, \overline{B}$：$A, B$的均值；</li><li>$\sigma_A, \sigma_B$：$A, B$的标准差；</li></ul><p>其<strong>几何意义</strong>解释如下，将$A, B$两个向量<strong>去中心化、单位化</strong>，即</p><script type="math/tex; mode=display">\begin{cases}    \hat{a}_i = (a_i - \overline{A}) / \sigma_A \\    \hat{b}_i = (b_i - \overline{B}) / \sigma_B\end{cases}</script><p>那么相关系数也即这两个向量的<strong>余弦距离</strong></p><script type="math/tex; mode=display">r_{AB} = \frac{\sum_{i=1}^n (a_i - \overline{A})(b_i - \overline{B})}{\sigma_A \sigma_B} = \frac{1}{n} \sum_{i=1}^n \hat{a}_i \hat{b}_i = \hat{A} \cdot \hat{B}= \cos<\hat{A}, \hat{B}></script><h2 id="数据归约"><a href="#数据归约" class="headerlink" title="数据归约"></a>数据归约</h2><p><strong>数据归约</strong>(data reduction)旨在得到数据的规约表示，但能够保持数据的完整性。</p><h3 id="维规约"><a href="#维规约" class="headerlink" title="维规约"></a>维规约</h3><p><strong>维规约</strong>(dimensionly reduction)减少所考虑的<strong>随机变量或属性的个数</strong>。</p><h4 id="小波变换：DWT"><a href="#小波变换：DWT" class="headerlink" title="小波变换：DWT"></a>小波变换：DWT</h4><h4 id="主成分分析：PCA"><a href="#主成分分析：PCA" class="headerlink" title="主成分分析：PCA"></a>主成分分析：PCA</h4><h4 id="属性子集选择"><a href="#属性子集选择" class="headerlink" title="属性子集选择"></a>属性子集选择</h4><p><strong>属性子集选择</strong>通过删除不相关或冗余的属性减少数据量，找到最小属性集使得数据类的概率分布尽可能地接近使用所有属性得到的所有属性得到的原分布。</p><p>通常使用压缩搜索空间的启发式方法(典型的贪心算法)，选择属性的“好”和“差”可以通过<strong>统计显著性检验</strong>确定，或者是<strong>信息增益度量</strong>，有以下算法</p><ul><li><strong>逐步向前归纳</strong>：由空属性集作为归约集，确定原属性集中最好的属性，并在每次的迭代中依次加入剩余属性集中最好的属性；</li><li><strong>逐步向后删除</strong>：由整个属性集开始，每一步迭代中删除剩余属性集中最差的属性；</li><li><strong>逐步向前选择和逐步向后删除的组合</strong>：每次迭代中选择一个最好的属性，并删除一个最差的属性；</li><li><strong>决策树归纳</strong>：由给定的数据构造决策树，不出现在树中的所有属性假定是不相关的，出现在树中的属性形成规约后的属性子集。</li></ul><h4 id="回归和对数线性模型：参数化数据规约"><a href="#回归和对数线性模型：参数化数据规约" class="headerlink" title="回归和对数线性模型：参数化数据规约"></a>回归和对数线性模型：参数化数据规约</h4><p><strong>回归和对数线性模型</strong>用于近似给定的数据，在回归方法中用一个(或一组)属性拟合另一个属性从而<strong>降低维数</strong>；而<strong>对数线性模型</strong>近似离散的多维概率分布，对于给定的元组集合，每个元组视作$n$维的点，用对数线性模型基于维组合的一个较小子集，估计多维空间中每个点的概率，使得高维数据可以由较低维空间构造。</p><h3 id="数量规约"><a href="#数量规约" class="headerlink" title="数量规约"></a>数量规约</h3><p><strong>数量规约</strong>(numerousity reduction)用<strong>替代的、较小的数据表示形式</strong>来替代原数据。</p><h4 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h4><p>用桶对属性值进行划分，包括<strong>等宽</strong>和<strong>等频</strong>两种方法，得到桶聚合，然后将桶作为数据的压缩表示，从而减少元组数目。</p><h4 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h4><p>类似分桶，通过聚类方法将对象划分为<strong>群或簇</strong>，用数据的簇代表替换实际数据。该方法的有效性依赖于数据的性质。</p><h4 id="抽样"><a href="#抽样" class="headerlink" title="抽样"></a>抽样</h4><p>用数据的小得多的<strong>随机样本子集</strong>代表大型数据集。抽样方法的优点是，算法复杂度仅与样本集大小有关，而与数据集大小无关。通常<strong>方法</strong>有</p><ul><li>$s$个样本的<strong>无放回简单随机抽样</strong>；</li><li>$s$个样本的<strong>有放回简单随机抽样</strong>；</li><li><strong>簇抽样</strong>：将元组放入不同的<strong>簇</strong>中，每个簇中进行抽样，例如基于邻近度定义簇；</li><li><strong>分层抽样</strong>：数据集被划分为互不相交的部分，即“<strong>层</strong>”，对每一层进行简单随机抽样。特别是当数据倾斜时，可以帮助确保样本的代表性。</li></ul><h4 id="数据立方体聚集"><a href="#数据立方体聚集" class="headerlink" title="数据立方体聚集"></a>数据立方体聚集</h4><h3 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h3><p><strong>数据压缩</strong>(data compression)使用变换得到原数据的规约或“压缩”表示，维规约和数量规约可以视作某种形式的数据压缩。</p><h2 id="数据变换"><a href="#数据变换" class="headerlink" title="数据变换"></a>数据变换</h2><p>用于将数据变换或统一成适合于挖掘的形式，包括</p><ul><li><strong>光滑</strong>：去掉噪声，包括分箱、回归和聚类；</li><li><strong>属性构造</strong>：由给定属性构造新的属性，并添加到属性集中；</li><li><strong>聚集</strong>：对数据进行汇总或聚集；</li><li><strong>规范化</strong>：把单属性数据按比例缩放，落到特定的小区间；</li><li><strong>离散化</strong>：将数值属性的原始值用区间标签或概念标签替换，这些标签可以递归地组织成更高层概念，导致数值属性地概念分层；</li><li><strong>由标称属性产生概念分层</strong>：将具有一定概念的属性泛化到更高的概念层。</li></ul><p>作用是</p><ul><li><strong>避免异常点</strong>：比如对连续变量进行份桶离散化</li><li><strong>可解释性或者需要连续输出</strong>：比如评分卡模型中的iv+woe</li><li><strong>使得原始数据的信息量更大</strong>：比如log/sqrt变换</li></ul><h3 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h3><p>试图赋予所有属性相等的权重，用于减少对度量单位的依赖性。</p><h4 id="min-max-最小-最大-规范化"><a href="#min-max-最小-最大-规范化" class="headerlink" title="min-max(最小-最大)规范化"></a>min-max(最小-最大)规范化</h4><p>对原始数据仅线性变换，仅跟最大、最小值的差别有关，只是一个去量纲的过程，将落在$[min, max]$的属性值$a$映射到$[MIN, MAX]$中</p><script type="math/tex; mode=display">a' = \frac{a - min}{max - min} \times (MAX - MIN) + MIN</script><h4 id="z-score-零均值-规范化"><a href="#z-score-零均值-规范化" class="headerlink" title="z-score(零均值)规范化"></a>z-score(零均值)规范化</h4><p>缩放和所有点都相关，数据相对分布不会改变，集中的数据标准化后依旧集中。</p><ul><li><p>基于属性$A$的均值$\overline{A}$和方差$\sigma_A$</p><script type="math/tex; mode=display">a' = \frac{a - \overline{A}}{\sigma_A}</script></li><li><p>或者是$A$的<strong>均值绝对偏差</strong>(mean absolute deviation)$s_A$代替$\sigma_A$</p><script type="math/tex; mode=display">s_A = \frac{1}{n} \sum_{i=1}^n | a_i - \overline{A} |</script></li></ul><blockquote><p>$\sigma_A$与$s_A$分别代表$A - \overline{A}$的$L_2, L1$范数。</p></blockquote><h4 id="按小数定标规范化"><a href="#按小数定标规范化" class="headerlink" title="按小数定标规范化"></a>按小数定标规范化</h4><p>移动属性$A$的值的小数点位置进行规范化</p><script type="math/tex; mode=display">a' = a / 10^j</script><p>其中$j$是使得$\max(| a_i’ |) &lt; 1$的最小整数</p><h4 id="min-max与z-score的关系与对比"><a href="#min-max与z-score的关系与对比" class="headerlink" title="min-max与z-score的关系与对比"></a>min-max与z-score的关系与对比</h4><ul><li><strong>异常点角度</strong>：特征数据上下限明显异常的时候使用z-score规范化方法，简单min-max规范化会造成数据差异模糊，整体方差下降；</li><li><strong>分布角度</strong>：使用z-score规范化之前，要求数据需要近似满足高斯分布，不然会改变数据的分布，尤其是对数据分布有强假设的情况下；</li><li><strong>上线变动角度</strong>：min-max规范化在上线的时候需要考虑上下约束界是否需要变动，z-score规范化则不需要考虑变动；</li><li><strong>值域范围角度</strong>：min-max规范化对数据范围约定较为固定，而z-score规范化的输出上下界则不定；</li><li><strong>模型角度</strong>：一般涉及距离计算，协方差计算，数据满足高斯分布的情况下用z-score规范化，其他min-max规范化或其他变换。</li></ul><h3 id="数据离散化"><a href="#数据离散化" class="headerlink" title="数据离散化"></a>数据离散化</h3><h4 id="分箱"><a href="#分箱" class="headerlink" title="分箱"></a>分箱</h4><p><strong>基于指定箱个数的自顶向下的分裂技术</strong>，例如用等宽或等频分箱后，用均值或中位数替换箱中的每个值，从而离散化。对用户指定的箱的个数很敏感，且容易受离群点影响。<strong>适用于小范围连续数据内不存在逻辑关系的数据</strong>，比如31岁和32岁之间不存在明显的差异，可以归为一个箱中。</p><h4 id="聚类-1"><a href="#聚类-1" class="headerlink" title="聚类"></a>聚类</h4><p>考虑属性$A$的分布及其数据点的邻近性，将属性值划分为多个簇，可以产生高质量的离散化结果。</p><h4 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h4><p><strong>主要思想是，通过选择划分点使得一个给定的结果分区包含尽可能多的同类元组，将属性离散化</strong>。这种离散化可以形成$A$的概念分层。</p><h4 id="相关分析"><a href="#相关分析" class="headerlink" title="相关分析"></a>相关分析</h4><p>例如，基于$\chi^2$的离散化方法$ChiMerge$采用自底向上的策略，递归找出最邻近的区间进行合并。<strong>基本思想是，对于精确的离散化，相对类频率在一个区间内应当完全一致</strong>。因此，若两个邻近区间具有类似的类分布，那么可以进行合并。</p><h3 id="概念分层"><a href="#概念分层" class="headerlink" title="概念分层"></a>概念分层</h3><p>用于将数据变换到多个粒度层，适用于有一定规律的类别数据，邮政编码，手机号等，产生方法有</p><ul><li>由用户或专家在<strong>模式级</strong>显式说明属性的部分序；</li><li>通过<strong>显式数据分组</strong>说明分层结构的一部分；</li><li><strong>说明属性集但不说明它们的偏序</strong>：可以根据给定属性集中，每个属性不同值的个数，自动产生概念分层。属性不同值个数越少，其所在概念分层结构中所处的层次越高。</li><li><strong>只说明部分属性集</strong>：依照属性的语义相关性进行分层。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】背包问题</title>
      <link href="/2020/06/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2020/06/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>背包问题是动态规划的经典问题，它的意义在于可运用到其他问题上，其<strong>基本描述</strong>为：<strong>给定容量为$W$的背包，以及$N$件物品，第$i$件物品的价值是$p_i$、所需容量为$w_i$，在不同的限制条件下，求能放进背包的物品最大价值总和是多少</strong>？根据限制条件不同，如物品数目可产生变种的背包问题。</p><ul><li><a href="#目录">目录</a></li><li><a href="#0-1背包">0-1背包</a></li><li><a href="#完全背包">完全背包</a></li><li><a href="#多重背包">多重背包</a></li><li><a href="#混合三种背包">混合三种背包</a></li><li><a href="#二维费用背包">二维费用背包</a></li><li><a href="#分组背包">分组背包</a></li><li><a href="#有依赖背包">有依赖背包</a></li><li><a href="#泛化物品背包">泛化物品背包</a></li><li><a href="#背包问题的问法">背包问题的问法</a><ul><li><a href="#最大价值总和">最大价值总和</a></li><li><a href="#任意最优方案">任意最优方案</a></li><li><a href="#字典序最小的最优方案">字典序最小的最优方案</a></li><li><a href="#满足条件的方案总数">满足条件的方案总数</a></li><li><a href="#最优方案总数">最优方案总数</a></li></ul></li><li><a href="#reference">Reference</a></li></ul><h1 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h1><p>给定容量是$W$的背包和$N$种物品，第$i$种物品的价格是$p_i$、所占容量$w_i$，<strong>每种商品最多可以选择$1$件</strong>。求解在这些物品所占容量总和不超过背包容量$W$的情况下，获得的最大价值总和。</p><p><strong>状态定义</strong>：定义二维数组$dp$，其元素$dp[i][j]$表示在背包容量为$j$的情况下，前$i$种物品能获得的最大价值总和，其中$i = 1, \cdots, N, j = 1, \cdots, W$。<br><strong>状态转移方程</strong>；求解$dp[i][j]$的过程，即考虑是否将第$j$件物品放入背包。首先考虑这件物品能否放入，即<strong>当前背包容量$j$是否满足$j \geq w_i$</strong>，那么就有以下两种情况</p><ul><li><p>$j &lt; w_i$：这件物品无法放入容量为$j$的背包，那么此时只能在前$(i - 1)$件物品中求解可行的最大价值总和，而这个子问题的结果已经保存在$dp[i - 1][j]$中，所以此时</p><script type="math/tex; mode=display">dp[i][j] = dp[i - 1][j]</script></li><li><p>$j \geq w_i$：这件背包能够放入容量为$j$的背包，那么选择将其放入后，背包剩余容量$(j - w_i)$，在前$(i - 1)$件物品中需要选择能够放入剩余容量的最大价值总和，所以此时能得到的价值总和是</p><script type="math/tex; mode=display">dp[i][j] = dp[i - 1][j - 1 \times w_i] + 1 \times p_i = dp[i - 1][j - w_i] + p_i</script><p>  <strong>但是放入这件物品一定能获得容量为$j$下最大的价值总和吗</strong>？可能前$(i - 1)$件物品放入容量$j$的背包能够产生更大的价值，即选择放入$0$件，那么</p><script type="math/tex; mode=display">dp[i][j] = dp[i - 1][j - 0 \times w_i] + 0 \times p_i = dp[i - 1][j]</script><p>  取两者最大，应该有</p><script type="math/tex; mode=display">dp[i][j] = \begin{cases}      dp[i - 1][j] & j < w_i \\      \max(dp[i - 1][j - w_i] + p_i, dp[i - 1][j]) & j \geq w_i  \end{cases}</script><p>  最多$1$件第$i$种物品放入背包，受限于背包容量$j$，实际上最多放入$K = \min(1, \lfloor j / w_i \rfloor)$件，这其中已经包括不放入这种物品的情况，即可选件数是$k \in {0, 1}$，所以上面表达式可以统一为$dp[i][j] = \max(dp[i - 1][j - w_i] + p_i, dp[i - 1][j])$，也就是</p><script type="math/tex; mode=display">dp[i][j] = \max_{k = 0}^K (dp[i - 1][j - k \times w_i] + k \times p_i), K = 1</script></li></ul><p><strong>边界条件</strong>：注意到状态$dp[i][j]$可能由$i = 0$或$j = 0$的状态转移而来，$i = 0$表示没有物品可以选择，$j = 0$表示背包容量此时为$0$，所以都不可能产生价值，即</p><script type="math/tex; mode=display">dp[i][0] = dp[0][j] = 0</script><p><strong>优化策略</strong>：实际上若$w_i &gt; w_j$但$p_i &lt; p_j$时，可以直接将物品$i$扔掉，即在计算表格时不考虑物品$i$。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPack_01</span><span class="params">(self, W, w, p)</span>:</span></span><br><span class="line">        n = len(w)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 注意数组大小</span></span><br><span class="line">        <span class="comment"># n + 1: 状态方程中包含`i - 1`，故多定义一行，减少判断条件，便于实现</span></span><br><span class="line">        <span class="comment"># W + 1: 背包的容量是W，`range`函数不包含`stop`值，因此需多加1列</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(W + <span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, W + <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># # 背包空间不够</span></span><br><span class="line">                <span class="comment"># if j &lt; w[i - 1]:</span></span><br><span class="line">                <span class="comment">#     dp[i][j] = dp[i - 1][j]</span></span><br><span class="line">                <span class="comment"># # 背包空间够，考虑是否放入</span></span><br><span class="line">                <span class="comment"># else:</span></span><br><span class="line">                <span class="comment">#     dp[i][j] = max(</span></span><br><span class="line">                <span class="comment">#         dp[i - 1][j],</span></span><br><span class="line">                <span class="comment">#         dp[i - 1][j - w[i - 1]] + p[i - 1])</span></span><br><span class="line">                <span class="comment"># ----------------------------------------------</span></span><br><span class="line">                <span class="comment"># 初始化为`0`</span></span><br><span class="line">                dp[i][j] = <span class="number">0</span></span><br><span class="line">                <span class="comment"># 最多放入`K`件</span></span><br><span class="line">                K = min(<span class="number">1</span>, j // w[i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(K + <span class="number">1</span>):</span><br><span class="line">                    dp[i][j] = max(</span><br><span class="line">                        dp[i][j], </span><br><span class="line">                        dp[i - <span class="number">1</span>][j - k * w[i - <span class="number">1</span>]] + k * p[i - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>例如输入<code>W = 10, w = [2, 3, 5, 7], p = [1, 5, 2, 4]</code>，得到表格如下</p><div class="table-container"><table><thead><tr><th>itemidx \ W</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>0</td><td>0</td><td><strong>0</strong></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td><strong>0</strong></td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>2</td><td>0</td><td>0</td><td>1</td><td><strong>5</strong></td><td>5</td><td>6</td><td>6</td><td>6</td><td>6</td><td>6</td><td>6</td></tr><tr><td>3</td><td>0</td><td>0</td><td>1</td><td><strong>5</strong></td><td>5</td><td>6</td><td>6</td><td>6</td><td>7</td><td>7</td><td>8</td></tr><tr><td>4</td><td>0</td><td>0</td><td>1</td><td>5</td><td>5</td><td>6</td><td>6</td><td>6</td><td>7</td><td>7</td><td><strong>9</strong></td></tr></tbody></table></div><p>优化空间复杂度，因为$dp[i][j]$仅与$dp[i - 1][j]$有关，故修改$dp$为一维数组，<strong>注意$j$的遍历顺序</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPack_01</span><span class="params">(self, W, w, p)</span>:</span></span><br><span class="line">        <span class="string">""" 01背包问题 """</span></span><br><span class="line">        n = len(w)</span><br><span class="line"></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(W + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(W, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="comment"># # 背包空间不够</span></span><br><span class="line">                <span class="comment"># if j &lt; w[i - 1]:</span></span><br><span class="line">                <span class="comment">#     continue    # dp[i][j] = dp[i][j]</span></span><br><span class="line">                <span class="comment"># # 背包空间够，考虑是否放入</span></span><br><span class="line">                <span class="comment"># else:</span></span><br><span class="line">                <span class="comment">#     dp[j] = max(</span></span><br><span class="line">                <span class="comment">#         dp[j], </span></span><br><span class="line">                <span class="comment">#         dp[j - w[i - 1]] + p[i - 1])</span></span><br><span class="line">                <span class="comment"># ----------------------------------------------</span></span><br><span class="line">                <span class="comment"># 初始化为`0`</span></span><br><span class="line">                dp[j] = <span class="number">0</span></span><br><span class="line">                <span class="comment"># 最多放入`K`件</span></span><br><span class="line">                K = min(<span class="number">1</span>, j // w[i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(K + <span class="number">1</span>):</span><br><span class="line">                    dp[j] = max(</span><br><span class="line">                        dp[j], </span><br><span class="line">                        dp[j - k * w[i - <span class="number">1</span>]] + k * p[i - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><h1 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h1><p>给定容量是$W$的背包和$N$种物品，第$i$种物品的价格是$p_i$、所占容量$w_i$，<strong>每种商品均有无穷多件可以选择</strong>。求解在这些物品所占容量总和不超过背包容量$W$的情况下，获得的最大价值总和。</p><ul><li><strong>状态定义</strong>：定义二维数组$dp$，其元素$dp[i][j]$表示在背包容量为$j$的情况下，前$i$种物品能获得的最大价值总和，其中$i = 1, \cdots, N, j = 1, \cdots, W$。</li><li><p><strong>状态转移方程</strong>；求解$dp[i][j]$的过程，需考虑将多少件第$i$种物品放入背包。首先考虑能放入多少件，受限于背包容量$j$，实际上最多放入$K = \lfloor j / w_i \rfloor$，这其中已经包括不放入这种物品的情况，即可选件数是$k \in {0, 1, 2, \cdots, K}$，剩余容量$(j - k \times w_i)$用前$(i - 1)$种物品填充，此子问题的结果已经保存在$dp[i - 1][j - k \times w_i]$中，所以应该有</p><script type="math/tex; mode=display">dp[i][j] = \max_{k = 0}^K (dp[i - 1][j - k \times w_i] + k \times p_i), K = \lfloor j / w_i \rfloor</script></li><li><p><strong>边界条件</strong>：注意到状态$dp[i][j]$可能由$i = 0$或$j = 0$的状态转移而来，$i = 0$表示没有物品可以选择，$j = 0$表示背包容量此时为$0$，所以都不可能产生价值，即</p><script type="math/tex; mode=display">dp[i][0] = dp[0][j] = 0</script></li></ul><p>注意到，完全背包只是将$0-1$背包件数上限从$1$修改为$K = \lfloor j / w_i \rfloor$，其中包括了$j &lt; w_i$的情况($K = 0$)。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPack_complete</span><span class="params">(self, W, w, p)</span>:</span></span><br><span class="line">        <span class="string">""" 完全背包问题 """</span></span><br><span class="line">        n = len(w)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 注意数组大小</span></span><br><span class="line">        <span class="comment"># n + 1: 状态方程中包含`i - 1`，故多定义一行，减少判断条件，便于实现</span></span><br><span class="line">        <span class="comment"># W + 1: 背包的容量是W，`range`函数不包含`stop`值，因此需多加1列</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(W + <span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, W + <span class="number">1</span>):</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 初始化为`0`</span></span><br><span class="line">                dp[i][j] = <span class="number">0</span></span><br><span class="line">                <span class="comment"># 最多放入`K`件</span></span><br><span class="line">                K = j // w[i - <span class="number">1</span>]</span><br><span class="line">                <span class="comment"># K = min(float('inf'), j // w[i - 1])</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(K + <span class="number">1</span>):</span><br><span class="line">                    dp[i][j] = max(</span><br><span class="line">                        dp[i][j], </span><br><span class="line">                        dp[i - <span class="number">1</span>][j - k * w[i - <span class="number">1</span>]] + k * p[i - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>例如输入<code>W = 10, w = [2, 3, 5, 7], p = [1, 5, 2, 4]</code>，得到表格如下</p><div class="table-container"><table><thead><tr><th>itemidx \ W</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>0</td><td>0</td><td><strong>0</strong></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td><strong>0</strong></td><td>1</td><td>1</td><td>2</td><td>2</td><td>3</td><td>3</td><td>4</td><td>4</td><td>5</td></tr><tr><td>2</td><td>0</td><td>0</td><td>1</td><td>5</td><td>5</td><td>6</td><td>10</td><td>10</td><td>11</td><td>15</td><td><strong>15</strong></td></tr><tr><td>3</td><td>0</td><td>0</td><td>1</td><td>5</td><td>5</td><td>6</td><td>10</td><td>10</td><td>11</td><td>15</td><td><strong>15</strong></td></tr><tr><td>4</td><td>0</td><td>0</td><td>1</td><td>5</td><td>5</td><td>6</td><td>10</td><td>10</td><td>11</td><td>15</td><td><strong>15</strong></td></tr></tbody></table></div><p>选择$3$件物品$2$，得到最大价值总和$15$。同样可以优化空间复杂度，略。</p><h1 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h1><p>给定容量是$W$的背包和$N$种物品，第$i$种物品的价格是$p_i$、所占容量$w_i$，<strong>每种商品可选件数是$n_i$</strong>。求解在这些物品所占容量总和不超过背包容量$W$的情况下，获得的最大价值总和。</p><ul><li><strong>状态定义</strong>：定义二维数组$dp$，其元素$dp[i][j]$表示在背包容量为$j$的情况下，前$i$种物品能获得的最大价值总和，其中$i = 1, \cdots, N, j = 1, \cdots, W$。</li><li><p><strong>状态转移方程</strong>；求解$dp[i][j]$的过程，需考虑将多少件第$i$种物品放入背包。首先考虑能放入多少件，受限于背包容量$j$，实际上最多放入$K = \min(n_i, \lfloor j / w_i \rfloor)$，这其中已经包括不放入这种物品的情况，即可选件数是$k \in {0, 1, 2, \cdots, K}$，剩余容量$(j - k \times w_i)$用前$(i - 1)$种物品填充，此子问题的结果已经保存在$dp[i - 1][j - k \times w_i]$中，所以应该有</p><script type="math/tex; mode=display">\begin{aligned}      dp[i][j] & = \max_{k = 0}^K (dp[i - 1][j - k \times w_i] + k \times p_i) \\      K & = \min(n_i, \lfloor j / w_i \rfloor)  \end{aligned}</script></li><li><p><strong>边界条件</strong>：注意到状态$dp[i][j]$可能由$i = 0$或$j = 0$的状态转移而来，$i = 0$表示没有物品可以选择，$j = 0$表示背包容量此时为$0$，所以都不可能产生价值，即</p><script type="math/tex; mode=display">dp[i][0] = dp[0][j] = 0</script></li></ul><p>注意到，多重背包只是将$0-1$背包件数上限从$1$修改为$K = \min(n_i, \lfloor j / w_i \rfloor)$，或者在完全背包基础上增加上限约束$n_i$，将其中包括了$j &lt; w_i$的情况($K = 0$)。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPack_multiple</span><span class="params">(self, W, w, p, N)</span>:</span></span><br><span class="line">        <span class="string">""" 多重背包问题 """</span></span><br><span class="line">        n = len(w)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 注意数组大小</span></span><br><span class="line">        <span class="comment"># n + 1: 状态方程中包含`i - 1`，故多定义一行，减少判断条件，便于实现</span></span><br><span class="line">        <span class="comment"># W + 1: 背包的容量是W，`range`函数不包含`stop`值，因此需多加1列</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(W + <span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, W + <span class="number">1</span>):</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 初始化为`0`</span></span><br><span class="line">                dp[i][j] = <span class="number">0</span></span><br><span class="line">                <span class="comment"># 最多放入`K`件</span></span><br><span class="line">                K = min(N[i - <span class="number">1</span>], j // w[i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(K + <span class="number">1</span>):</span><br><span class="line">                    dp[i][j] = max(</span><br><span class="line">                        dp[i][j], dp[i - <span class="number">1</span>][j - k * w[i - <span class="number">1</span>]] + k * p[i - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>例如输入<code>W = 10, w = [2, 3, 5, 7], p = [1, 5, 2, 4], N = [1, 2, 1, 1]</code>，得到表格如下</p><div class="table-container"><table><thead><tr><th>itemidx \ W</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td><strong>0</strong></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td><strong>1</strong></td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>2</td><td>0</td><td>0</td><td>1</td><td>5</td><td>5</td><td>6</td><td>10</td><td>10</td><td>11</td><td>11</td><td><strong>11</strong></td></tr><tr><td>3</td><td>0</td><td>0</td><td>1</td><td>5</td><td>5</td><td>6</td><td>10</td><td>10</td><td>11</td><td>11</td><td><strong>11</strong></td></tr><tr><td>4</td><td>0</td><td>0</td><td>1</td><td>5</td><td>5</td><td>6</td><td>10</td><td>10</td><td>11</td><td>11</td><td><strong>11</strong></td></tr></tbody></table></div><p>选择$1$件物品$1$和$2$件物品$2$，得到最大价值总和$11$。</p><h1 id="混合三种背包"><a href="#混合三种背包" class="headerlink" title="混合三种背包"></a>混合三种背包</h1><p>将<a href="#0-1背包">0-1背包</a>、<a href="#完全背包">完全背包</a>、<a href="#多重背包">多重背包</a>三个问题结合起来。即给定容量是$W$的背包和$N$种物品，第$i$种物品的价格是$p_i$、所占容量$w_i$，<strong>部分物品只有$1$件、部分物品有$n_i$件、部分物品有无穷多件</strong>。求解在这些物品所占容量总和不超过背包容量$W$的情况下，获得的最大价值总和。</p><ul><li><strong>状态定义</strong>：定义二维数组$dp$，其元素$dp[i][j]$表示在背包容量为$j$的情况下，前$i$种物品能获得的最大价值总和，其中$i = 1, \cdots, N, j = 1, \cdots, W$。</li><li><p><strong>状态转移方程</strong>；求解$dp[i][j]$的过程，需考虑将多少件第$i$种物品放入背包。首先考虑能放入多少件，受限于背包容量$j$，实际上最多放入$K = \min(n_i, \lfloor j / w_i \rfloor)$，这其中已经包括不放入这种物品的情况，即可选件数是$k \in {0, 1, 2, \cdots, K}$，剩余容量$(j - k \times w_i)$用前$(i - 1)$种物品填充，此子问题的结果已经保存在$dp[i - 1][j - k \times w_i]$中，所以应该有</p><script type="math/tex; mode=display">\begin{aligned}      dp[i][j] & = \max_{k = 0}^K (dp[i - 1][j - k \times w_i] + k \times p_i) \\      K & = \min(n_i, \lfloor j / w_i \rfloor)  \end{aligned}</script></li><li><p><strong>边界条件</strong>：注意到状态$dp[i][j]$可能由$i = 0$或$j = 0$的状态转移而来，$i = 0$表示没有物品可以选择，$j = 0$表示背包容量此时为$0$，所以都不可能产生价值，即</p><script type="math/tex; mode=display">dp[i][0] = dp[0][j] = 0</script></li></ul><p>注意到，混合三种背包与多重背包的解题思路是完全一致的。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPack_mixture</span><span class="params">(self, W, w, p, N)</span>:</span></span><br><span class="line">        <span class="string">""" 混合背包问题 """</span></span><br><span class="line">        n = len(w)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 注意数组大小</span></span><br><span class="line">        <span class="comment"># n + 1: 状态方程中包含`i - 1`，故多定义一行，减少判断条件，便于实现</span></span><br><span class="line">        <span class="comment"># W + 1: 背包的容量是W，`range`函数不包含`stop`值，因此需多加1列</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(W + <span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, W + <span class="number">1</span>):</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 初始化为`0`</span></span><br><span class="line">                dp[i][j] = <span class="number">0</span></span><br><span class="line">                <span class="comment"># 最多放入`K`件</span></span><br><span class="line">                K = min(N[i - <span class="number">1</span>], j // w[i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(K + <span class="number">1</span>):</span><br><span class="line">                    dp[i][j] = max(</span><br><span class="line">                        dp[i][j], dp[i - <span class="number">1</span>][j - k * w[i - <span class="number">1</span>]] + k * p[i - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>例如输入<code>W = 10, w = [2, 3, 5, 7], p = [1, 5, 2, 4], N = [3, 1, float(&#39;inf&#39;), 1]</code>，得到表格如下</p><div class="table-container"><table><thead><tr><th>itemidx \ W</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>0</td><td><strong>0</strong></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td><strong>0</strong></td><td>0</td><td>1</td><td>1</td><td>2</td><td>2</td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td></tr><tr><td>2</td><td>0</td><td>0</td><td>1</td><td><strong>5</strong></td><td>5</td><td>6</td><td>6</td><td>7</td><td>7</td><td>8</td><td>8</td></tr><tr><td>3</td><td>0</td><td>0</td><td>1</td><td><strong>5</strong></td><td>5</td><td>6</td><td>6</td><td>7</td><td>7</td><td>8</td><td>8</td></tr><tr><td>4</td><td>0</td><td>0</td><td>1</td><td>5</td><td>5</td><td>6</td><td>6</td><td>7</td><td>7</td><td>8</td><td><strong>9</strong></td></tr></tbody></table></div><p>选择$1$件物品$2$和$1$件物品$4$，得到最大价值总和$9$。</p><h1 id="二维费用背包"><a href="#二维费用背包" class="headerlink" title="二维费用背包"></a>二维费用背包</h1><p>给定容量是$W$的背包和$N$种物品，第$i$种物品的价格是$p_i$、<strong>所占容量$w_i$、还包含费用$v_i$</strong>，简单起见每种物品最多选择$1$件(0-1背包拓展)。求解将哪些物品装入背包，可使这些物品所占<strong>容量总和不超过背包容量$W$、且费用总和不超过$V$的情况下</strong>，价值总和最大。</p><ul><li><strong>状态定义</strong>：定义三维数组$dp$，其元素$dp[i][j][l]$表示在背包容量为$j$、费用为$k$的情况下，前$i$种物品能获得的最大价值总和，其中$i = 1, \cdots, N, j = 1, \cdots, W, k = 1, \cdots, V$。</li><li><p><strong>状态转移方程</strong>；求解$dp[i][j][l]$的过程，即将最多$K$件第$i$种物品放入背包，受限于背包容量$j$和费用$k$，实际上最多放入$K = \min(1, \lfloor j / w_i \rfloor, \lfloor k / v_i \rfloor)$，这其中已经包括不放入这种物品的情况，即可选件数是$k \in {0, 1, 2, \cdots, K}$，剩余容量$(j - k \times w_i)$、剩余费用$(k - k \times v_i)$用前$(i - 1)$种物品填充，此子问题的结果已经保存在$dp[i - 1][j - k \times w_i][k - k \times v_i]$中，所以应该有</p><script type="math/tex; mode=display">\begin{aligned}      dp[i][j][l] & = \max_{k = 0}^K (dp[i - 1][j - k \times w_i][k - k \times v_i] + k \times p_i) \\      K & = \min(1, \lfloor j / w_i \rfloor, \lfloor k / v_i \rfloor)  \end{aligned}</script></li><li><p><strong>边界条件</strong>：注意到状态$dp[i][j]$可能由$i = 0$、$j = 0$或$k = 0$的状态转移而来，$i = 0$表示没有物品可以选择，$j = 0$表示背包容量此时为$0$，$k = 0$表示可用费用此时为$0$，所以都不可能产生价值，即</p><script type="math/tex; mode=display">dp[i][0][0] = dp[0][j][0] = dp[0][0][l] = 0</script></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPack_01_cost</span><span class="params">(self, W, V, w, v, p)</span>:</span></span><br><span class="line">        <span class="string">""" 01背包拓展的二维费用背包问题 """</span></span><br><span class="line">        n = len(w)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 注意数组大小</span></span><br><span class="line">        <span class="comment"># n + 1: 状态方程中包含`i - 1`，故多定义一行，减少判断条件，便于实现</span></span><br><span class="line">        <span class="comment"># W + 1: 背包的容量是W，`range`函数不包含`stop`值，因此需多加1列</span></span><br><span class="line">        <span class="comment"># V + 1: 可用价值总量是V，`range`函数不包含`stop`值，因此需多加1列</span></span><br><span class="line">        dp = [[[<span class="number">0</span> <span class="keyword">for</span> k <span class="keyword">in</span> range(V + <span class="number">1</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> range(W + <span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, W + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> range(<span class="number">1</span>, V + <span class="number">1</span>):</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 初始化为`0`</span></span><br><span class="line">                    dp[i][j][l] = <span class="number">0</span></span><br><span class="line">                    <span class="comment"># 最多放入`K`件</span></span><br><span class="line">                    K = min(<span class="number">1</span>, j // w[i - <span class="number">1</span>], l // v[i - <span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> range(K + <span class="number">1</span>):</span><br><span class="line">                        dp[i][j][l] = max(</span><br><span class="line">                            dp[i][j][l], </span><br><span class="line">                            dp[i - <span class="number">1</span>][j - k * w[i - <span class="number">1</span>]][l - k * v[i - <span class="number">1</span>]] + k * p[i - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>输入<code>W = 10, V = 8, w = [2, 3, 5, 7], v = [1, 5, 2, 3], p = [1, 5, 2, 4]</code>，在选择$1$件物品$2$和$1$件物品$4$，得到最大价值总和$9$，所占容量为$3 + 7 = 10$，所占费用为$5 + 3 = 8$。</p><h1 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h1><p>给定容量是$W$的背包和$N$种物品，第$i$种物品的价格是$p_i$、所占容量$w_i$，简单起见每种物品最多选择$1$件(0-1背包拓展)，<strong>另外这些物品被划分成$G$组，标签为$g_i$，同组内(相同标签)的物品只能选择一种物品</strong>。求解在这些物品所占容量总和不超过背包容量$W$的情况下，获得的最大价值总和。</p><ul><li><strong>状态定义</strong>：由于同组内物品存在冲突，选择一种后其余不能选择，故定义二维数组$dp$，其元素$dp[g][j]$表示在背包容量为$j$的情况下，前$g$组物品能获得的最大价值总和，其中$g = 1, \cdots, G, j = 1, \cdots, W$。</li><li><p><strong>状态转移方程</strong>；求解$dp[g][j]$的过程，即将最多$1$件第$g$组物品放入背包，并且组中包含多件物品$w_i \in G_g$。首先考虑能放入多少件，受限于背包容量$j$，且最多选择$1$件，所以实际上最多放入$K = \min(1, \lfloor j / w_i \rfloor)$，这其中已经包括不放入这种物品的情况，即可选件数是$k \in {0, 1}$，剩余容量$(j - k \times w_i)$用前$(g - 1)$组物品填充，此子问题的结果已经保存在$dp[g - 1][j - k \times w_i]$中，所以应该有</p><script type="math/tex; mode=display">  \begin{aligned}      dp[g][j] & = \max_{i \in G_g} \left( \max_{k=1}^K(dp[g - 1][j - k \times w_i]) \right) \\      K & = \min(1, \lfloor j / w_i \rfloor)  \end{aligned}</script></li><li><p><strong>边界条件</strong>：注意到状态$dp[g][j]$可能由$g = 0$或$j = 0$的状态转移而来，$g = 0$表示没有物品可以选择，$j = 0$表示背包容量此时为$0$，所以都不可能产生价值，即</p><script type="math/tex; mode=display">dp[g][0] = dp[0][j] = 0</script></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPack_01_group</span><span class="params">(self, W, w, p, group)</span>:</span></span><br><span class="line">        <span class="string">""" 01背包拓展的分组背包问题 """</span></span><br><span class="line">        <span class="comment"># 去重求组数</span></span><br><span class="line">        gids = list(set(group)) <span class="comment"># 去重</span></span><br><span class="line">        G = len(gids)</span><br><span class="line">        n = len(w)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 注意数组大小</span></span><br><span class="line">        <span class="comment"># G + 1: 状态方程中包含`g - 1`，故多定义一行，减少判断条件，便于实现</span></span><br><span class="line">        <span class="comment"># W + 1: 背包的容量是m，`range`函数不包含`stop`值，因此需多加1列</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(W + <span class="number">1</span>)] <span class="keyword">for</span> g <span class="keyword">in</span> range(G + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> g <span class="keyword">in</span> range(<span class="number">1</span>, G + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, W + <span class="number">1</span>):</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 初始化为`0`</span></span><br><span class="line">                dp[g][j] = <span class="number">0</span></span><br><span class="line">                <span class="comment"># 从所有物品中过滤该组物品</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> group[i - <span class="number">1</span>] != gids[g - <span class="number">1</span>]:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 最多放入`K`件</span></span><br><span class="line">                    K = min(<span class="number">1</span>, j // w[i - <span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> range(K + <span class="number">1</span>):</span><br><span class="line">                        dp[g][j] = max(</span><br><span class="line">                            dp[g][j], dp[g - <span class="number">1</span>][j - k * w[i - <span class="number">1</span>]] + k * p[i - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>输入<code>W = 10, w = [2, 3, 5, 7], p = [1, 5, 2, 4], group = [0, 1, 0, 1]</code>，得到表格如下</p><div class="table-container"><table><thead><tr><th>groupidx \ W</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td><strong>0</strong></td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>2</td><td>2</td><td>2</td><td>2</td><td><strong>2</strong></td><td>2</td></tr><tr><td>2</td><td>0</td><td>0</td><td>1</td><td>5</td><td>5</td><td>6</td><td>6</td><td>6</td><td>7</td><td>7</td><td><strong>7</strong></td></tr></tbody></table></div><p>选择$1$件物品$2$和$1$件物品$4$，得到最大价值总和$9$，所占容量为$3 + 7 = 10$。</p><h1 id="有依赖背包"><a href="#有依赖背包" class="headerlink" title="有依赖背包"></a>有依赖背包</h1><p>给定容量是$W$的背包和$N$种物品，第$i$种物品的价格是$p_i$、所占容量$w_i$，简单起见每种物品最多选择$1$件(0-1背包拓展)。<strong>另外这些物品间存在依赖关系，具体地指在选择物品$i$时必须选择$j$</strong>，简单起见做以下假设：</p><ul><li>没有物品既依赖于其他物品，又被其他物品依赖</li><li>每件物品最多依赖其他一件物品，但一件物品可以被多件物品依赖</li></ul><p>求解在这些物品所占容量总和不超过背包容量$W$的情况下，获得的最大价值总和。</p><p><strong>思路分析</strong>：根据问题假设，可以将$N$件物品间的依赖关系视作，由多棵高度最大为$2$的树构成的森林，例如物品$2$依赖于物品$1$、物品$4, 5$依赖于物品$3$可以表示为下图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">erDiagram</span><br><span class="line">    item-1 ||--|| item-2 : depend</span><br><span class="line">    item-3 ||--|| item-4 : depend</span><br><span class="line">    item-3 ||--|| item-5 : depend</span><br></pre></td></tr></table></figure><br>将不依赖于其他物品的项称为“主件”，依赖于主件的项称为“附件”，那么在选择时，可以选择主件及其$m \in {0, \cdots, M}$种附件，$M$是某主件的附件总数，<strong>那么这些策略是互斥的，所以可以将这些策略视作组，每种策略是其中的项，那么就可以用<a href="#分组背包">分组背包</a>进行求解了</strong>。具体地，如上图所给的依赖关系，我们得到两个组分别为</p><script type="math/tex; mode=display">\{\{1\}, \{1, 2\}\}, \{\{3\}, \{3, 4\}, \{3, 5\}\}</script><p><strong>问题拓展</strong>：将两个假设删除，问题复杂但解题思路一致，在多级的树结构中每个节点都可视作“子主件”，多次使用上述策略进行求解。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    def backPack_01_group(self, W, w, p, group): -&gt; int: ...</span><br><span class="line">        <span class="string">""" 01背包拓展的分组背包问题 """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPack_01_easy_dependence</span><span class="params">(self, W, w, p, dependence)</span>:</span></span><br><span class="line">        <span class="string">""" 01背包拓展的、满足两种假设的简单依赖背包问题 """</span></span><br><span class="line">        n = len(w)</span><br><span class="line">        <span class="comment"># ----------------------------------------------------------</span></span><br><span class="line">        <span class="comment"># 寻找主件</span></span><br><span class="line">        masters = [i <span class="keyword">for</span> i, d <span class="keyword">in</span> enumerate(dependence) <span class="keyword">if</span> d <span class="keyword">is</span> <span class="keyword">None</span>]</span><br><span class="line">        <span class="comment"># 构造组集合</span></span><br><span class="line">        groups = []</span><br><span class="line">        <span class="keyword">for</span> master <span class="keyword">in</span> masters:</span><br><span class="line">            group = [[master]]</span><br><span class="line">            <span class="comment"># 借助Apriori算法中的连接步算法</span></span><br><span class="line">            g_k_1 = [[master, i] <span class="keyword">for</span> i, d <span class="keyword">in</span> enumerate(dependence) <span class="keyword">if</span> d == master]</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">                group += g_k_1</span><br><span class="line">                <span class="comment"># 连接</span></span><br><span class="line">                g_k = []</span><br><span class="line">                k_1 = len(g_k_1)</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(k_1):</span><br><span class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, k_1):</span><br><span class="line">                        <span class="comment"># 前`k - 2`项相同，第`k - 1`项不同</span></span><br><span class="line">                        <span class="comment"># 已经按字典序排序，`&lt;`为了简单去重</span></span><br><span class="line">                        <span class="keyword">if</span> g_k_1[i][:<span class="number">-1</span>] == g_k_1[j][:<span class="number">-1</span>] <span class="keyword">and</span> \</span><br><span class="line">                                g_k_1[i][<span class="number">-1</span>] &lt; g_k_1[j][<span class="number">-1</span>]:</span><br><span class="line">                            g_k += [g_k_1[i] + [g_k_1[j][<span class="number">-1</span>]]]</span><br><span class="line">                <span class="comment"># `k`项集空，终止循环</span></span><br><span class="line">                <span class="keyword">if</span> len(g_k) == <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">                g_k_1 = g_k</span><br><span class="line">            groups += [group]</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># ----------------------------------------------------------</span></span><br><span class="line">        <span class="comment"># 构造输入`backPack_01_group`的参数</span></span><br><span class="line">        gW, gP, gG = [], [], []</span><br><span class="line">        <span class="keyword">for</span> i, group <span class="keyword">in</span> enumerate(groups):</span><br><span class="line">            <span class="comment"># 该组内各项集计算参数</span></span><br><span class="line">            <span class="keyword">for</span> j, itemset <span class="keyword">in</span> enumerate(group):</span><br><span class="line">                <span class="comment"># 该项集占用容量和</span></span><br><span class="line">                gW += [sum(map(<span class="keyword">lambda</span> x: w[x], itemset))]</span><br><span class="line">                <span class="comment"># 该项集占用价值总和</span></span><br><span class="line">                gP += [sum(map(<span class="keyword">lambda</span> x: p[x], itemset))]</span><br><span class="line">                <span class="comment"># 该项集归属组</span></span><br><span class="line">                gG += [i]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># ----------------------------------------------------------</span></span><br><span class="line">        <span class="comment"># 计算分组背包</span></span><br><span class="line">        ret = self.backPack_01_group(W, gW, gP, gG)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><p>输入<code>W = 10, w = [2, 3, 5, 7], p = [1, 5, 2, 4], dependence = [None, 0, 0, None]</code>，，其中$dependence$表示依赖关系，第$i$件物品依赖于$dependence[i]$，得到</p><ul><li><strong>分组后的项集</strong>：<code>groups = [[0], [0, 1], [0, 2], [0, 1, 2]], [[3]]</code>；</li><li><strong>分组项集展开后对应参数</strong>：<code>gW = [2, 5, 7, 10, 7], gP = [1, 6, 3, 8, 4], gG = [0, 0, 0, 0, 1]</code></li></ul><p><code>W = 10, gW = [2, 5, 7, 10, 7], gP = [1, 6, 3, 8, 4], gG = [0, 0, 0, 0, 1]</code>输入函数<code>backPack_01_group</code>得到表格如下</p><div class="table-container"><table><thead><tr><th>groupidx \ W</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td><strong>0</strong></td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>6</td><td>6</td><td>6</td><td>6</td><td>6</td><td><strong>8</strong></td></tr><tr><td>2</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>6</td><td>6</td><td>6</td><td>6</td><td>6</td><td><strong>8</strong></td></tr></tbody></table></div><p>所以选择物品$0, 1, 2$得到最大价值总和$8$，此时占用背包容量$2 + 3 + 5 = 10$。</p><h1 id="泛化物品背包"><a href="#泛化物品背包" class="headerlink" title="泛化物品背包"></a>泛化物品背包</h1><p>给定容量是$W$的背包和$N$种物品，<strong>第$i$种物品的所占容量是变量$W_i \in [0, W]$，其价值是与容量(费用)相关的函数$p_i(W_i)$</strong>，简单起见每种物品最多选择$1$件(0-1背包拓展)。求解在这些物品所占容量总和不超过背包容量$W$的情况下，获得的最大价值总和。</p><p><strong>问题分析</strong>：假设分配到各种物品的容量是$W_i$，那么多种物品的价值总和用下式求解</p><script type="math/tex; mode=display">\begin{aligned}    f(W) & = \max \left( \sum_{i = 1}^N p_i(W_i) \right) \\    W & = \sum_{i = 1}^N W_i\end{aligned}</script><p>注意到<a href="#0-1背包">0-1背包</a>是泛化物品背包的特殊情况，即</p><script type="math/tex; mode=display">p_i(W_i) = p_i, const</script><p>而<a href="#完全背包">完全背包</a>则是</p><script type="math/tex; mode=display">p_i(W_i) = \lfloor W_i / w_i \rfloor \times p_i</script><p>实现略。</p><h1 id="背包问题的问法"><a href="#背包问题的问法" class="headerlink" title="背包问题的问法"></a>背包问题的问法</h1><h2 id="最大价值总和"><a href="#最大价值总和" class="headerlink" title="最大价值总和"></a>最大价值总和</h2><p>上面$9$个问题中讨论的都是这个问题，这种最大/最小的问题无需考虑方案等，相对来说比较容易，这类的问法还可以拓展为</p><ul><li>总价值最大/最小</li><li>总件数最大/最小</li></ul><h2 id="任意最优方案"><a href="#任意最优方案" class="headerlink" title="任意最优方案"></a>任意最优方案</h2><p>要求输出任意一个满足最大价值总和的方案。这个问题的求解的关键在于<strong>记录下每个状态的最优值，是从前面哪一个状态转移过来的</strong>。具体的求解方法是，在已得到的状态表格中进行逆推，得到最优状态的转移路径。</p><p>以<a href="#0-1背包">0-1背包</a>为例，进行讲解，假设输入<code>W = 10, w = [2, 3, 5, 7], p = [1, 5, 2, 4]</code>，得到表格如下。那么$dp[4][10]$应该有</p><script type="math/tex; mode=display">dp[4][10] = \max(dp[3][10], dp[3][10 - 7] + 4) = 9</script><p>通过比较表格数值，可以知道$dp[4][10]$是由$dp[3][3] + 4 = 5$转移而来，且物品$4$被选中，继续对$dp[3][3]$进行回溯，有</p><script type="math/tex; mode=display">dp[3][3] = \max(dp[2][3], dp[2][3 - 3] + 2) = 5</script><p>通过比较表格数值，可以知道$dp[3][3]$由$dp[2][3] = 5$转移得到，那么物品$3$未被选中，对$dp[2][3]$进行回溯，有</p><script type="math/tex; mode=display">dp[2][3] = \max(dp[1][3], dp[1][3 - 2] + 5) = 5</script><p>通过比较表格数值，可以知道$dp[2][3]$由$dp[1][1] + 5 = 5$转移得到，那么物品$2$被选中，对$dp[1][1]$进行回溯，有</p><script type="math/tex; mode=display">dp[1][1] = \max(dp[0][1], dp[0][1 - 2] + 1)</script><p>由于背包容量$1&lt;$物品$1$的所需容量$2$，所以一定由$dp[0][1]$转移得到，此时已到达边界，停止回溯。所以最终得到的方案是${2, 4}$。</p><div class="table-container"><table><thead><tr><th>itemidx \ W</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>0</td><td>0</td><td><strong>0</strong></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td><strong>0</strong></td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>2</td><td>0</td><td>0</td><td>1</td><td><strong>5</strong></td><td>5</td><td>6</td><td>6</td><td>6</td><td>6</td><td>6</td><td>6</td></tr><tr><td>3</td><td>0</td><td>0</td><td>1</td><td><strong>5</strong></td><td>5</td><td>6</td><td>6</td><td>6</td><td>7</td><td>7</td><td>8</td></tr><tr><td>4</td><td>0</td><td>0</td><td>1</td><td>5</td><td>5</td><td>6</td><td>6</td><td>6</td><td>7</td><td>7</td><td><strong>9</strong></td></tr></tbody></table></div><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPack_01_choice</span><span class="params">(self, W, w, p)</span>:</span></span><br><span class="line">        <span class="string">""" 01背包拓展的任意最优方案问题 """</span></span><br><span class="line">        n = len(w)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 注意数组大小</span></span><br><span class="line">        <span class="comment"># n + 1: 状态方程中包含`i - 1`，故多定义一行，减少判断条件，便于实现</span></span><br><span class="line">        <span class="comment"># W + 1: 背包的容量是W，`range`函数不包含`stop`值，因此需多加1列</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(W + <span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, W + <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># # 背包空间不够</span></span><br><span class="line">                <span class="comment"># if j &lt; w[i - 1]:</span></span><br><span class="line">                <span class="comment">#     dp[i][j] = dp[i - 1][j]</span></span><br><span class="line">                <span class="comment"># # 背包空间够，考虑是否放入</span></span><br><span class="line">                <span class="comment"># else:</span></span><br><span class="line">                <span class="comment">#     dp[i][j] = max(</span></span><br><span class="line">                <span class="comment">#         dp[i - 1][j],</span></span><br><span class="line">                <span class="comment">#         dp[i - 1][j - w[i - 1]] + p[i - 1])</span></span><br><span class="line">                <span class="comment"># ----------------------------------------------</span></span><br><span class="line">                <span class="comment"># 初始化为`0`</span></span><br><span class="line">                dp[i][j] = <span class="number">0</span></span><br><span class="line">                <span class="comment"># 最多放入`K`件</span></span><br><span class="line">                K = min(<span class="number">1</span>, j // w[i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(K + <span class="number">1</span>):</span><br><span class="line">                    dp[i][j] = max(</span><br><span class="line">                        dp[i][j], </span><br><span class="line">                        dp[i - <span class="number">1</span>][j - k * w[i - <span class="number">1</span>]] + k * p[i - <span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># ------------------------------------------------------</span></span><br><span class="line">        <span class="comment"># 回溯</span></span><br><span class="line">        choice = []</span><br><span class="line">        i, j = n, W</span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> j &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 可以放入`K`件物品`i`</span></span><br><span class="line">            K = min(<span class="number">1</span>, j // w[i - <span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 无法放入，跳过</span></span><br><span class="line">            <span class="keyword">if</span> K == <span class="number">0</span>: i -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 可以放入，依次选择</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>, K + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> dp[i - <span class="number">1</span>][j - k * w[i - <span class="number">1</span>]] + k * p[i - <span class="number">1</span>] == dp[i][j]:</span><br><span class="line">                    choice += [i]</span><br><span class="line">                    j -= k * w[i - <span class="number">1</span>]</span><br><span class="line">                    i -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> choice</span><br></pre></td></tr></table></figure><h2 id="字典序最小的最优方案"><a href="#字典序最小的最优方案" class="headerlink" title="字典序最小的最优方案"></a>字典序最小的最优方案</h2><p>要求输出字典序最小的、满足最大价值总和的方案。与<a href="#任意最优方案">任意最优方案</a>不同之处是，若$dp[i][j]$回溯时发现既可以从$dp[i - 1][j]$转移，也可以由$(dp[i - 1][j - k \times w_i] + k \times p_i)$转移，为得到字典序最小的方案，<strong>应该不放入物品$i$</strong>，即选择从$dp[i - 1][j]$转移得到。</p><p>实际上，<a href="#任意最优方案">任意最优方案</a>中的代码，<code>k</code>的循环方向<code>range(0, K + 1)</code>，已经决定了返回字典序最小的最优方案。</p><h2 id="满足条件的方案总数"><a href="#满足条件的方案总数" class="headerlink" title="满足条件的方案总数"></a>满足条件的方案总数</h2><p>例如，要求统计已装入物品所需总容量在某个指定容量以下的方案总数，简单起见每种物品最多选择$1$件(0-1背包拓展)。对于这类改变问法的问题，一般只需将状态转移方程中的$\max$改成$\sum$即可，</p><ul><li><strong>状态定义</strong>：定义二维数组$dp$，其元素$dp[i][j]$表示在背包容量为$j$的情况下，前$i$种物品能放入的<strong>方案数</strong>，其中$i = 1, \cdots, N, j = 1, \cdots, W$。</li><li><p><strong>状态转移方程</strong>；求解$dp[i][j]$的过程，需考虑将多少件第$i$种物品放入背包。首先考虑能放入多少件，受限于背包容量$j$，实际上最多放入$K = \min(1, \lfloor j / w_i \rfloor)$，这其中已经包括不放入这种物品的情况，即可选件数是$k \in {0, 1, 2, \cdots, K}$，剩余容量$(j - k \times w_i)$用前$(i - 1)$种物品填充，此子问题的结果已经保存在$dp[i - 1][j - k \times w_i]$中，所以应该有</p><script type="math/tex; mode=display">\begin{aligned}      dp[i][j] & = \sum_{k = 0}^K dp[i - 1][j - k \times w_i] \\      K & = \min(1, \lfloor j / w_i \rfloor)  \end{aligned}</script></li><li><p><strong>边界条件</strong>：注意到状态$dp[i][j]$可能由$i = 0$或$j = 0$的状态转移而来，$i = 0$表示没有物品可以选择，$j = 0$表示背包容量此时为$0$，方案数都是$1$，即</p><script type="math/tex; mode=display">dp[i][0] = dp[0][j] = 1</script></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPack_01_num_of_choice</span><span class="params">(self, W, w, p)</span>:</span></span><br><span class="line">        <span class="string">""" 01背包拓展的求满足方案的总数问题 """</span></span><br><span class="line">        n = len(w)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 注意数组大小</span></span><br><span class="line">        <span class="comment"># n + 1: 状态方程中包含`i - 1`，故多定义一行，减少判断条件，便于实现</span></span><br><span class="line">        <span class="comment"># W + 1: 背包的容量是W，`range`函数不包含`stop`值，因此需多加1列</span></span><br><span class="line">        dp = [[<span class="number">1</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(W + <span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, W + <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 初始化为`0`</span></span><br><span class="line">                dp[i][j] = <span class="number">0</span></span><br><span class="line">                <span class="comment"># 最多放入`K`件</span></span><br><span class="line">                K = min(<span class="number">1</span>, j // w[i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(K + <span class="number">1</span>):</span><br><span class="line">                    dp[i][j] += dp[i - <span class="number">1</span>][j - k * w[i - <span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>例如输入<code>W = 10, w = [2, 3, 5, 7], p = [1, 5, 2, 4]</code>，得到表格如下</p><div class="table-container"><table><thead><tr><th>itemidx \ W</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>0</td><td><strong>1</strong></td><td>1</td><td>1</td><td><strong>1</strong></td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td><strong>1</strong></td></tr><tr><td>1</td><td><strong>1</strong></td><td>1</td><td>2</td><td><strong>2</strong></td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td><strong>2</strong></td></tr><tr><td>2</td><td>1</td><td>1</td><td>2</td><td><strong>3</strong></td><td>3</td><td>4</td><td>4</td><td>4</td><td>4</td><td>4</td><td><strong>4</strong></td></tr><tr><td>3</td><td>1</td><td>1</td><td>2</td><td><strong>3</strong></td><td>3</td><td>5</td><td>5</td><td>6</td><td>7</td><td>7</td><td><strong>8</strong></td></tr><tr><td>4</td><td>1</td><td>1</td><td>2</td><td>3</td><td>3</td><td>5</td><td>5</td><td>7</td><td>8</td><td>9</td><td><strong>11</strong></td></tr></tbody></table></div><h2 id="最优方案总数"><a href="#最优方案总数" class="headerlink" title="最优方案总数"></a>最优方案总数</h2><p>满足最大价值总和的方案可能存在多个，要求统计这些方案共有多少种。在求解最大方案的同时，也求解最佳方案数目。</p><ul><li><p><strong>状态定义</strong>：</p><ul><li>定义二维数组$dpv$，其元素$dpv[i][j]$表示在背包容量为$j$的情况下，前$i$种物品能获得的最大价值总和；</li><li><p>定义二维数组$dpn$，其元素$dpn[i][j]$表示在背包容量为$j$的情况下，前$i$种物品能获得的最大价值总和对应的方案数。</p><p>其中$i = 1, \cdots, N, j = 1, \cdots, W$。</p></li></ul></li><li><p><strong>状态转移方程</strong>；</p><ul><li><p>求解$dpv[i][j]$的过程，需考虑将多少件第$i$种物品放入背包。首先考虑能放入多少件，受限于背包容量$j$，实际上最多放入$K = \lfloor j / w_i \rfloor$，这其中已经包括不放入这种物品的情况，即可选件数是$k \in {0, 1, 2, \cdots, K}$，剩余容量$(j - k \times w_i)$用前$(i - 1)$种物品填充，此子问题的结果已经保存在$dpv[i - 1][j - k \times w_i]$中，所以应该有</p><script type="math/tex; mode=display">dpv[i][j] = \max_{k = 0}^K (dpv[i - 1][j - k \times w_i] + k \times p_i), K = \lfloor j / w_i \rfloor</script></li><li><p>求解$dpn[i][j]$的过程，需要考虑$dpv[i][j]$是从哪里转移过来的，所以</p><script type="math/tex; mode=display">  \begin{aligned}      dpn[i][j] = \sum_{k = 0}^K I[i - 1][j - k \times w_i] \times dpn[i - 1][j - k \times w_i] \\      I[i - 1][j - k \times w_i] = (dpv[i][j] == pv[i - 1][j - k \times w_i] + k \times p_i)  \end{aligned}</script></li></ul></li><li><p><strong>边界条件</strong>：注意到状态$dpv[i][j]$可能由$i = 0$或$j = 0$的状态转移而来，$i = 0$表示没有物品可以选择，$j = 0$表示背包容量此时为$0$，所以都不可能产生价值，即</p><script type="math/tex; mode=display">\begin{aligned}  dpv[i][0] = dpv[0][j] = 0 \\  dpn[i][0] = dpn[0][j] = 0\end{aligned}</script></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPack_01_num_of_best_choice</span><span class="params">(self, W, w, p)</span>:</span></span><br><span class="line">        <span class="string">""" 01背包拓展的求最优方案总数问题 """</span></span><br><span class="line">        n = len(w)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 注意数组大小</span></span><br><span class="line">        <span class="comment"># n + 1: 状态方程中包含`i - 1`，故多定义一行，减少判断条件，便于实现</span></span><br><span class="line">        <span class="comment"># W + 1: 背包的容量是W，`range`函数不包含`stop`值，因此需多加1列</span></span><br><span class="line">        dpv = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(W + <span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        dpn = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(W + <span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, W + <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 初始化为`0`</span></span><br><span class="line">                dpv[i][j] = <span class="number">0</span></span><br><span class="line">                <span class="comment"># 最多放入`K`件</span></span><br><span class="line">                K = min(<span class="number">1</span>, j // w[i - <span class="number">1</span>])</span><br><span class="line">                <span class="comment"># 求最大价值</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(K + <span class="number">1</span>):</span><br><span class="line">                    dpv[i][j] = max(</span><br><span class="line">                        dpv[i][j], </span><br><span class="line">                        dpv[i - <span class="number">1</span>][j - k * w[i - <span class="number">1</span>]] + k * p[i - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 求最大价值对应的方案数</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(K + <span class="number">1</span>):</span><br><span class="line">                    <span class="comment"># 剩余容量</span></span><br><span class="line">                    r = j - k * w[i - <span class="number">1</span>]</span><br><span class="line">                    <span class="comment"># `dp[i][j]`是否由状态`dpv[i - 1][r]`转移而来</span></span><br><span class="line">                    <span class="keyword">if</span> dpv[i][j] == dpv[i - <span class="number">1</span>][r] + k * p[i - <span class="number">1</span>]:</span><br><span class="line">                        <span class="comment"># # `i, j`下第一次取最大价值</span></span><br><span class="line">                        <span class="comment"># if dpn[i - 1][r] == 0:</span></span><br><span class="line">                        <span class="comment">#     dpn[i][j] = 1</span></span><br><span class="line">                        <span class="comment"># # 累加</span></span><br><span class="line">                        <span class="comment"># else:</span></span><br><span class="line">                        <span class="comment">#     dpn[i][j] += dpn[i - 1][r]</span></span><br><span class="line">                        <span class="comment"># ------ 或者 ------</span></span><br><span class="line">                        dpn[i][j] += max(<span class="number">1</span>, dpn[i - <span class="number">1</span>][r])</span><br><span class="line">        <span class="keyword">return</span> dpn[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>输入<code>W = 10, w = [2, 3, 6, 7], p = [1, 5, 4, 4]</code>，得到表格如下</p><ul><li>$dpv$</li></ul><div class="table-container"><table><thead><tr><th>itemidx \ W</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>0</td><td>0</td><td><strong>0</strong></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td><strong>0</strong></td><td><strong>0</strong></td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>2</td><td>0</td><td>0</td><td>1</td><td><strong>5</strong></td><td><strong>5</strong></td><td>6</td><td>6</td><td>6</td><td>6</td><td>6</td><td>6</td></tr><tr><td>3</td><td>0</td><td>0</td><td>1</td><td><strong>5</strong></td><td>5</td><td>6</td><td>6</td><td>6</td><td>6</td><td>9</td><td><strong>9</strong></td></tr><tr><td>4</td><td>0</td><td>0</td><td>1</td><td>5</td><td>5</td><td>6</td><td>6</td><td>6</td><td>6</td><td><strong>9</strong></td><td><strong>9</strong></td></tr></tbody></table></div><ul><li>$dpn$</li></ul><div class="table-container"><table><thead><tr><th>itemidx \ W</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>0</td><td>0</td><td><strong>0</strong></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td><strong>0</strong></td><td><strong>0</strong></td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>2</td><td>0</td><td>0</td><td>1</td><td><strong>1</strong></td><td><strong>1</strong></td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>3</td><td>0</td><td>0</td><td>1</td><td><strong>1</strong></td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td><strong>1</strong></td></tr><tr><td>4</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td><strong>2</strong></td></tr></tbody></table></div><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://github.com/tianyicui/pack" target="_blank" rel="noopener">背包9讲 - Github</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【算法】动态规划经典题型</title>
      <link href="/2020/06/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%BB%8F%E5%85%B8%E9%A2%98%E5%9E%8B/"/>
      <url>/2020/06/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%BB%8F%E5%85%B8%E9%A2%98%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#目录">目录</a></li><li><a href="#解题思路">解题思路</a></li><li><a href="#零钱兑换">零钱兑换</a><ul><li><a href="#零钱兑换-i-最少硬币个数">零钱兑换 I: 最少硬币个数</a></li><li><a href="#零钱兑换-ii-硬币组合数">零钱兑换 II: 硬币组合数</a></li></ul></li><li><a href="#背包问题ii-0-1背包">背包问题II: 0-1背包</a></li><li><a href="#剪绳子-i">剪绳子 I</a></li><li><a href="#青蛙跳台阶问题">青蛙跳台阶问题</a></li><li><a href="#青蛙过河问题">*青蛙过河问题</a></li><li><a href="#最小编辑距离">最小编辑距离</a></li><li><a href="#最大子序和问题">最大子序和问题</a></li><li><a href="#乘积最大子数组">乘积最大子数组</a></li><li><a href="#最长回文子串">最长回文子串</a></li><li><a href="#最长递增子序列问题-lis">最长递增子序列问题, LIS</a></li><li><a href="#最长公共子串">最长公共子串</a></li><li><a href="#最长公共子序列问题-lcs">最长公共子序列问题, LCS</a></li><li><a href="#买卖股票的最佳时机">*买卖股票的最佳时机</a><ul><li><a href="#买卖股票的最佳时机-i-一次交易">买卖股票的最佳时机 I: 一次交易</a></li><li><a href="#买卖股票的最佳时机-ii-无穷多次交易">买卖股票的最佳时机 II: 无穷多次交易</a></li><li><a href="#买卖股票的最佳时机-iii-最多两次交易">买卖股票的最佳时机 III: 最多两次交易</a></li><li><a href="#买卖股票的最佳时机-iv-多次交易">买卖股票的最佳时机 IV: 多次交易</a></li><li><a href="#买卖股票的最佳时机-v-含手续费">买卖股票的最佳时机 V: 含手续费</a></li><li><a href="#买卖股票的最佳时机-vi-含冷冻期">买卖股票的最佳时机 VI: 含冷冻期</a></li></ul></li><li><a href="#二叉树最大路径和">二叉树最大路径和</a></li><li><a href="#网格中左上向右下的最小路径和">网格中左上向右下的最小路径和</a></li><li><a href="#floyd最短路径算法">Floyd最短路径算法</a></li><li><a href="#reference">Reference</a></li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ol><li><strong>确定子问题</strong>：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解；</li><li><strong>确定状态和状态变量</strong>：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性，<strong>重点关注如何合理设置状态，避免重复计算子问题</strong>；</li><li><strong>确定决策并写出状态转移方程</strong>：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。</li><li><strong>注意边界条件</strong>：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件，如果状态方程中包含$(i-1)$项，一般多定义一行/列，减少代码中的判断。</li></ol><h1 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h1><h2 id="零钱兑换-I-最少硬币个数"><a href="#零钱兑换-I-最少硬币个数" class="headerlink" title="零钱兑换 I: 最少硬币个数"></a><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">零钱兑换 I: 最少硬币个数</a></h2><p>给定不同面额的硬币$coins$和一个总金额$amount$。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回$-1$。<br><strong>示例 1</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: coins &#x3D; [1, 2, 5], amount &#x3D; 11</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 11 &#x3D; 5 + 5 + 1</span><br></pre></td></tr></table></figure><br><strong>示例 2</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: coins &#x3D; [2], amount &#x3D; 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure></p><hr><ol><li><strong>子问题</strong>：子问题是<strong>前$x$种硬币表示金额$y$所需要的最少硬币个数</strong>。</li><li><strong>状态和状态变量</strong>：定义二维数组$dp$，元素$dp[i][j]$表示前$i$种硬币表示面额$j$的最少硬币个数。</li><li><strong>状态转移方程</strong>：在面值为$c_i$的硬币加入时，可以选择$k_i \in [0, \lfloor j / c_i \rfloor]$枚，剩余的面额$(j - k_i \times c_i)$用前$(i - 1)$枚表示，若剩余面额无法被表示，那么用$k_i$种$c_i$面额地方案无效，用数学公式表述为<script type="math/tex; mode=display"> dp[i][j] = \min_{k_i = 0}^{\lfloor j / c_i \rfloor} (     dp[i - 1][j - k_i \times c_i] + k_i )</script></li><li><p><strong>注意边界条件</strong>：前$0$种硬币无法表示面额大于$0$的金额(为便于编程，用$+\infty$表示)，任意种硬币表示面额$0$都是$0$，即</p><script type="math/tex; mode=display"> \begin{cases}     dp[-1][j] = \infty & j > -1 \\     dp[i][-1] = 0 & \forall i \end{cases}</script><p> 即初始化表格为</p><p> | coin \ amount | 0 | 1 | 2 | 3 | 4 | 5 | 6 | … |<br> | —- | —- | —- | —- | —- | —- | —- | —- | —- |<br> | 空 | 0 | inf | inf | inf | inf | inf | inf | … |<br> | c1 | 0 |  |  |  |  |  |  | … |<br> | c2 | 0 |  |  |  |  |  |  | … |<br> | … | … |  |  |  |  |  |  | … |</p></li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins: List[int], amount: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 边界条件：金额为0</span></span><br><span class="line">        <span class="keyword">if</span> amount == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        m, n = len(coins), amount</span><br><span class="line">        <span class="comment"># 注意数组大小</span></span><br><span class="line">        <span class="comment"># m + 1: 状态方程中包含`i - 1`，故多定义一行，减少判断条件，便于实现</span></span><br><span class="line">        <span class="comment"># n + 1: 包括面值`n`，`range`函数中不包含`stop`值</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(n + <span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 边界条件</span></span><br><span class="line">        <span class="comment"># 用前0种硬币表示面额j，无法表示</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n + <span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="comment"># 用前i种硬币表示面额0，有0种方案</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m + <span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        ret = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="comment"># 状态转移方程</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line"></span><br><span class="line">                dp[i][j] = float(<span class="string">'inf'</span>)</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(j // coins[i - <span class="number">1</span>] + <span class="number">1</span>):</span><br><span class="line">                    <span class="comment"># 剩余面额</span></span><br><span class="line">                    r = j - coins[i - <span class="number">1</span>] * k</span><br><span class="line">                    <span class="comment"># 剩余面额无法表示</span></span><br><span class="line">                    <span class="keyword">if</span> dp[i - <span class="number">1</span>][r] == float(<span class="string">'inf'</span>):</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="comment"># 剩余面额能够表示，取数量最少的</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j] = min(dp[i][j], dp[i - <span class="number">1</span>][r] + k)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># --------------------------------------</span></span><br><span class="line">                <span class="comment"># 寻找能表示amount的最少硬币个数</span></span><br><span class="line">                <span class="keyword">if</span> j == n:</span><br><span class="line">                    ret = min(ret, dp[i][<span class="number">-1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span> <span class="keyword">if</span> ret == float(<span class="string">'inf'</span>) <span class="keyword">else</span> ret</span><br></pre></td></tr></table></figure><hr><p>时间超时，优化时间复杂度</p><script type="math/tex; mode=display">\begin{aligned}    dp[i][j] & = \min (        dp[i - 1][j - 0 \times c_i] + 0, \\        & \underbrace{            dp[i - 1][j - 1 \times c_i] + 1,             \cdots,             dp[i - 1][j - \lfloor j / c_i \rfloor \times c_i] + \lfloor j / c_i \rfloor)        } \\\end{aligned}</script><p>令$j := j - c_i$，有</p><script type="math/tex; mode=display">\begin{aligned}    dp[i][j - c_i] = \min (        \underbrace{            dp[i - 1][j - 1 \times c_i] + 0,            \cdots,             dp[i - 1][j - \lfloor j / c_i \rfloor \times c_i] + (\lfloor j / c_i \rfloor - 1)        }, \\        \underbrace{dp[i - 1][j - (\lfloor j / c_i \rfloor + 1) \times c_i] + \lfloor j / c_i \rfloor)}_{\infty} \\    = \min (        \underbrace{            dp[i - 1][j - 1 \times c_i] + 1,            \cdots,             dp[i - 1][j - \lfloor j / c_i \rfloor \times c_i] + (\lfloor j / c_i \rfloor)        } - 1\end{aligned}</script><p>其中$dp[i - 1][j - (\lfloor j / c_i \rfloor + 1) \times c_i + \lfloor j / c_i \rfloor] = + \infty$，所以</p><script type="math/tex; mode=display">dp[i][j] = \begin{cases}    dp[i - 1][j] & j < c_i \\    \min(        dp[i - 1][j],         dp[i][j - c_i] + 1) & \text{otherwise}\end{cases}</script><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins: List[int], amount: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 边界条件：金额为0</span></span><br><span class="line">        <span class="keyword">if</span> amount == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        m, n = len(coins), amount</span><br><span class="line">        <span class="comment"># 注意数组大小</span></span><br><span class="line">        <span class="comment"># m + 1: 状态方程中包含`i - 1`，故多定义一行，减少判断条件，便于实现</span></span><br><span class="line">        <span class="comment"># n + 1: 包括面值`n`，`range`函数中不包含`stop`值</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(n + <span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 边界条件</span></span><br><span class="line">        <span class="comment"># 用前0种硬币表示面额j，无法表示</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n + <span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="comment"># 用前i种硬币表示面额0，有0种方案</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m + <span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        ret = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 面额超过金额</span></span><br><span class="line">                <span class="keyword">if</span> j &lt; coins[i - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 递推公式修改后</span></span><br><span class="line">                dp[i][j] = min(</span><br><span class="line">                    dp[i - <span class="number">1</span>][j], </span><br><span class="line">                    dp[i][j - coins[i - <span class="number">1</span>]] + <span class="number">1</span></span><br><span class="line">                )</span><br><span class="line">                <span class="comment"># --------------------------------------</span></span><br><span class="line">                <span class="comment"># 寻找能表示amount的最少硬币个数</span></span><br><span class="line">                <span class="keyword">if</span> j == n <span class="keyword">and</span> dp[i][j] != <span class="number">-1</span>:</span><br><span class="line">                    ret = min(ret, dp[i][<span class="number">-1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span> <span class="keyword">if</span> ret == float(<span class="string">'inf'</span>) <span class="keyword">else</span> ret</span><br></pre></td></tr></table></figure><p>例如输入<code>coins = [25, 10, 5, 2], amount = 10</code>，得到表格如下</p><div class="table-container"><table><thead><tr><th>coin \ amount</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>空</td><td><strong>0</strong></td><td>inf</td><td>inf</td><td>inf</td><td>inf</td><td>inf</td><td>inf</td><td>inf</td><td>inf</td><td>inf</td><td>inf</td></tr><tr><td>25</td><td><strong>0</strong></td><td>inf</td><td>inf</td><td>inf</td><td>inf</td><td>inf</td><td>inf</td><td>inf</td><td>inf</td><td>inf</td><td>inf</td></tr><tr><td>10</td><td>0</td><td>inf</td><td>inf</td><td>inf</td><td>inf</td><td>inf</td><td>inf</td><td>inf</td><td>inf</td><td>inf</td><td><strong>1</strong></td></tr><tr><td>5</td><td>0</td><td>inf</td><td>inf</td><td>inf</td><td>inf</td><td>1</td><td>inf</td><td>inf</td><td>inf</td><td>inf</td><td><strong>1</strong></td></tr><tr><td>2</td><td>0</td><td>inf</td><td>1</td><td>inf</td><td>2</td><td>1</td><td>3</td><td>2</td><td>4</td><td>3</td><td><strong>1</strong></td></tr></tbody></table></div><h2 id="零钱兑换-II-硬币组合数"><a href="#零钱兑换-II-硬币组合数" class="headerlink" title="零钱兑换 II: 硬币组合数"></a><a href="https://leetcode-cn.com/problems/coin-change-2/" target="_blank" rel="noopener">零钱兑换 II: 硬币组合数</a></h2><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。<br><strong>示例 1</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: amount &#x3D; 5, coins &#x3D; [1, 2, 5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 有四种方式可以凑成总金额:</span><br><span class="line">5&#x3D;5</span><br><span class="line">5&#x3D;2+2+1</span><br><span class="line">5&#x3D;2+1+1+1</span><br><span class="line">5&#x3D;1+1+1+1+1</span><br></pre></td></tr></table></figure><br><strong>示例 2</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: amount &#x3D; 3, coins &#x3D; [2]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 只用面额2的硬币不能凑成总金额3。</span><br></pre></td></tr></table></figure><br><strong>示例 3</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: amount &#x3D; 10, coins &#x3D; [10] </span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><br><strong>注意</strong>:<br>你可以假设：</p><ul><li>0 &lt;= amount (总金额) &lt;= 5000</li><li>1 &lt;= coin (硬币面额) &lt;= 5000</li><li>硬币种类不超过 500 种</li><li>结果符合 32 位符号整数</li></ul><hr><ol><li><strong>子问题</strong>：硬币$coins$有多少张表示$amount$的方法，当其中一种面值为$c_i$的硬币选择固定枚数$k_i$后，子问题是剩余面值的硬币有多少种表示$(n - k_i \times c_i)$的方法，其中$0 \leq k_i \leq \lfloor n / c_i \rfloor$；</li><li><strong>状态和状态变量</strong>：考虑$dp[i][j]$，表示前$i$种硬币构成面值$j$的方案数</li><li><strong>状态转移方程</strong>：<script type="math/tex; mode=display">dp[i][j] = \sum_{k_i = 0}^{\lfloor j / c_i \rfloor} dp[i - 1][j - k_i \times c_i]</script></li><li><strong>边界条件</strong>：面值为$0$时需要设置边界条件，即$dp[:][0] = 1$。<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(self, amount: int, coins: List[int])</span> -&gt; int:</span></span><br><span class="line">        m, n = len(coins), amount</span><br><span class="line">        <span class="comment"># 注意数组大小</span></span><br><span class="line">        <span class="comment"># m + 1: 状态方程中包含`i - 1`，故多定义一行，减少判断条件，便于实现</span></span><br><span class="line">        <span class="comment"># n + 1: 包括面值`n`，`range`函数中不包含`stop`值</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(n + <span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 边界条件</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m + <span class="number">1</span>): dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递归求解</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># k枚硬币，包含`j // coins[i - 1]`枚所以`+ 1`</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>, j // coins[i - <span class="number">1</span>] + <span class="number">1</span>):</span><br><span class="line">                    dp[i][j] += dp[i - <span class="number">1</span>][j - k * coins[i - <span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></li></ol><hr><p><strong>时间复杂度优化</strong>，将状态转移方程展开，可以得到</p><script type="math/tex; mode=display">\begin{aligned}    dp[i][j] = dp[i - 1][j - 0 \times c_i] + \\ \underbrace{dp[i - 1][j - 1 \times c_i] + \cdots + dp[i - 1][j - \lfloor \frac{j}{c_i} \rfloor \times c_i]}\end{aligned}</script><p>令$j := j - c_i$，有</p><script type="math/tex; mode=display">\begin{aligned}    dp[i][j - c_i] = \underbrace{dp[i - 1][j - 1 \times c_i] + \cdots + dp[i - 1][j - \lfloor \frac{j}{c_i} \rfloor \times c_i]} + \\ \underbrace{dp[i - 1][j - (\lfloor \frac{j}{c_i} \rfloor + 1) \times c_i]}_0\end{aligned}</script><p>那么可以将$dp[i][j]$尾巴部分替换，即</p><script type="math/tex; mode=display">dp[i][j] = \begin{cases}    dp[i - 1][j] & j < c_i \\    dp[i - 1][j] + dp[i][j - c_i] & \text{otherwise}\end{cases}</script><p>此时时间复杂度仅为$O(m n)$。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(self, amount: int, coins: List[int])</span> -&gt; int:</span></span><br><span class="line">        m, n = len(coins), amount</span><br><span class="line">        <span class="comment"># 注意数组大小</span></span><br><span class="line">        <span class="comment"># m + 1: 状态方程中包含`i - 1`，故多定义一行，减少判断条件，便于实现</span></span><br><span class="line">        <span class="comment"># n + 1: 包括面值`n`，`range`函数中不包含`stop`值</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(n + <span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 边界条件</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m + <span class="number">1</span>): dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递归求解</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &lt; coins[i - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - coins[i - <span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><p>例如输入<code>amount = 10, coins = [25, 10, 5, 1]</code>，得到表格如下</p><div class="table-container"><table><thead><tr><th>coins \ amount</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>空</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td><strong>0</strong></td></tr><tr><td>10</td><td><strong>1</strong></td><td>0</td><td>0</td><td>0</td><td>0</td><td><strong>0</strong></td><td>0</td><td>0</td><td>0</td><td>0</td><td><strong>1</strong></td></tr><tr><td>5</td><td><strong>1</strong></td><td>0</td><td>0</td><td>0</td><td>0</td><td><strong>1</strong></td><td>0</td><td>0</td><td>0</td><td>0</td><td><strong>2</strong></td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>2</td><td>2</td><td>2</td><td>2</td><td><strong>2</strong></td><td><strong>4</strong></td></tr></tbody></table></div><hr><p><strong>空间复杂度优化</strong>。继续优化，考虑到在求取$dp[i][:]$时，只与$dp[i - 1][:]$元素有关，因此可以只保留这两行，甚至一行，减少空间复杂度<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(self, amount: int, coins: List[int])</span> -&gt; int:</span></span><br><span class="line">        m, n = len(coins), amount</span><br><span class="line">        <span class="comment"># 注意数组大小</span></span><br><span class="line">        <span class="comment"># n + 1: 包括面值`n`，`range`函数中不包含`stop`值</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 边界条件</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递归求解</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &lt; coins[i - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span>    <span class="comment"># dp[j] = dp[j]</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[j] = dp[j] + dp[j - coins[i - <span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><hr><p><strong>一种错误的解法</strong>：错误原因是，该问题是一个组合问题，而不是排列问题</p><ol><li><strong>子问题</strong>：金额$amount$有多少种表示方法，最后一枚硬币可以是$coins$中的一种，那么选择一枚面值为$c$的硬币后，又有子问题$(amount-c)$的金额有多少种表示方法；</li><li><strong>状态和状态变量</strong>：定义一维数组$dp$，其第$i$个元素$d[i]$表示面值为$i$时的表示方法数；</li><li><strong>状态转移方程</strong>：面值为$i$时，可以尝试用$c_j$面值的硬币<script type="math/tex; mode=display">dp[i] = \sum_j 1(i - c_j \geq 0) \times dp[i - c_j]</script></li><li><strong>边界条件</strong>：面值为$0$时需要设置边界条件，即$dp[0]=1$；需注意$i - c_j &lt; 0$的情况。</li><li><strong>其他注意点</strong>：取模运算</li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(self, amount: int, coins: List[int])</span> -&gt; int:</span></span><br><span class="line">        m, n = len(coins), amount</span><br><span class="line">        <span class="comment"># 注意数组大小</span></span><br><span class="line">        <span class="comment"># n + 1: 包括面值`n`，`range`函数中不包含`stop`值</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 边界条件：有1种表示金额0的方法，即无硬币</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i - coins[j - <span class="number">1</span>] &lt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                dp[i] += dp[i - coins[j - <span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>输入<code>amount = 10, coins = [25, 10, 5, 1]</code>，得到表格如下</p><div class="table-container"><table><thead><tr><th>coins \ amount</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>dp</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>9</td></tr></tbody></table></div><h1 id="背包问题II-0-1背包"><a href="#背包问题II-0-1背包" class="headerlink" title="背包问题II: 0-1背包"></a><a href="https://www.lintcode.com/problem/backpack-ii/description" target="_blank" rel="noopener">背包问题II: 0-1背包</a></h1><p>有$n$个物品和一个大小为$m$的背包. 给定数组$A$表示每个物品的大小和数组$V$表示每个物品的价值，问最多能装入背包的总价值是多大?</p><p>样例<br>样例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: m &#x3D; 10, A &#x3D; [2, 3, 5, 7], V &#x3D; [1, 5, 2, 4]</span><br><span class="line">输出: 9</span><br><span class="line">解释: 装入 A[1] 和 A[3] 可以得到最大价值, V[1] + V[3] &#x3D; 9</span><br></pre></td></tr></table></figure><br>样例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: m &#x3D; 10, A &#x3D; [2, 3, 8], V &#x3D; [2, 5, 8]</span><br><span class="line">输出: 10</span><br><span class="line">解释: 装入 A[0] 和 A[2] 可以得到最大价值, V[0] + V[2] &#x3D; 10</span><br></pre></td></tr></table></figure><br>挑战<br>O(nm) 空间复杂度可以通过, 不过你可以尝试 O(m) 空间复杂度吗?</p><p>注意事项</p><ul><li>A[i], V[i], n, m 均为整数</li><li>你不能将物品进行切分</li><li>你所挑选的要装入背包的物品的总大小不能超过 m</li><li>每个物品只能取一次</li></ul><hr><ol><li><strong>子问题</strong>：全局问题是在背包大小$m$下，$n$个物品中最多能装入背包的总价值。装入物品$A[i], V[i]$后，剩余容量为$(m - A[i])$，物品剩余件数为$(n-1)$，在这些中求最多能装入背包的总价值。那么子问题就是，在背包容量为$j$下，前$i$间物品最多能装入背包的总价值。</li><li><strong>状态和状态变量</strong>：定义二维数组$dp$，$dp[i][j]$表示背包容量为$j$下，前$i$间物品最多能装入背包的总价值</li><li><strong>状态转移方程</strong>：<br> 首先考虑第$i$件物品能否放入，若剩余空间$j$小于$A[i]$那么前$i$件最大价值等于前$(i - 1)$件最大价值；然后考虑是否将第$i$件物品放入，因为放入该物品后，前$(i-1)$件只能在背包容量$(j - A[i])$下进行选择，取两者的最大。<script type="math/tex; mode=display">dp[i][j] = \begin{cases}     dp[i - 1][j] & j < A[i] \\     \max(dp[i - 1][j], dp[i - 1][j - A[i]] + V[i]) & \text{otherwise} \end{cases}</script></li><li><strong>边界条件</strong>：前$0$件物品，放入背包的价值是$0$</li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param m: An integer m denotes the size of a backpack</span></span><br><span class="line"><span class="string">    @param A: Given n items with size A[i]</span></span><br><span class="line"><span class="string">    @param V: Given n items with value V[i]</span></span><br><span class="line"><span class="string">    @return: The maximum value</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backPackII</span><span class="params">(self, m, A, V)</span>:</span></span><br><span class="line">        n = len(A)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 注意数组大小</span></span><br><span class="line">        <span class="comment"># n + 1: 状态方程中包含`i - 1`，故多定义一行，减少判断条件，便于实现</span></span><br><span class="line">        <span class="comment"># m + 1: 背包的容量是m，`range`函数不包含`stop`值，因此需多加1列</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(m + <span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span> + m + <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 背包空间不够</span></span><br><span class="line">                <span class="keyword">if</span> j &lt; A[i - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br><span class="line">                <span class="comment"># 背包空间够，考虑是否放入</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = max(</span><br><span class="line">                        dp[i - <span class="number">1</span>][j],</span><br><span class="line">                        dp[i - <span class="number">1</span>][j - A[i - <span class="number">1</span>]] + V[i - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>例如输入<code>m = 10, A = [2, 3, 5, 7], V = [1, 5, 2, 4]</code>得到表格如下</p><div class="table-container"><table><thead><tr><th>物品\容量</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>空</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1(2, 1)</td><td><strong>0</strong></td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>2(3, 5)</td><td>0</td><td>0</td><td>1</td><td><strong>5</strong></td><td>5</td><td>6</td><td>6</td><td>6</td><td>6</td><td>6</td><td>6</td></tr><tr><td>3(5, 2)</td><td>0</td><td>0</td><td>1</td><td><strong>5</strong></td><td>5</td><td>6</td><td>6</td><td>6</td><td>7</td><td>7</td><td>8</td></tr><tr><td>4(7, 4)</td><td>0</td><td>0</td><td>1</td><td>5</td><td>5</td><td>6</td><td>6</td><td>6</td><td>7</td><td>7</td><td><strong>9</strong></td></tr></tbody></table></div><h1 id="剪绳子-I"><a href="#剪绳子-I" class="headerlink" title="剪绳子 I"></a><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/" target="_blank" rel="noopener">剪绳子 I</a></h1><p>给你一根长度为$n$的绳子，请把绳子剪成整数长度的$m$段($m、n$都是整数，$n&gt;1$并且$m&gt;1$)，每段绳子的长度记为$k[0],k[1]…k[m-1]$。请问$k[0] \times k[1] \times … \times k[m-1]$可能的最大乘积是多少？例如，当绳子的长度是$8$时，我们把它剪成长度分别为$2, 3, 3$的三段，此时得到的最大乘积是$18$。<br><strong>示例 1</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1</span><br></pre></td></tr></table></figure><br><strong>示例 2</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36</span><br></pre></td></tr></table></figure><br><strong>提示</strong>：<br>2 &lt;= n &lt;= 58<br><strong>注意</strong>：本题与主站 343 题相同：<a href="https://leetcode-cn.com/problems/integer-break/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/integer-break/</a></p><hr><ol><li><strong>子问题</strong>：对长度为$n$的绳子，最后一刀可以选择减去$x$，求$x * (n - x)$最大，那么子问题是剩余绳子$(n - x)$剪若干次后的最大乘积。</li><li><strong>状态和状态变量</strong>：考虑二维数组$dp$，元素$dp[i][j]$表示长度为$j$的绳子<strong>最多</strong>剪$i$次后的最大乘积，且长度$n$最多可以分隔为$n$段，所以$i, j \in [0, n]$；</li><li><strong>状态转移方程</strong>：对于$dp[i][j]$，当$j \leq 3$时绳子不剪长度乘积更大(边界条件)，$j &gt; 3$时最后一刀长度可以在${0, 1, \cdots, j}$中选择，所以<script type="math/tex; mode=display">dp[i][j] = \max_{k=0}^j(dp[i - 1][j - k] \times k)</script></li><li><strong>边界条件</strong>：注意到题中要求$m &gt; 1$，即最少剪$1$次，而在$n = 1$时无法剪所以$dp[1] = 0$、$n = 2, 3$最多只能剪$1$刀所以$dp[2]=1, dp[3]=2$，所以应该有<script type="math/tex; mode=display">maxProduct = j - 1, j \leq 3</script></li></ol><p>那么</p><script type="math/tex; mode=display">maxProduct = \begin{cases}    j - 1 & j \leq 3 \\    dp[n][n] & \text{otherwise}\end{cases}</script><p>时间复杂度$O(n^3)$，空间复杂度$O(n^2)$<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 长度1, 2, 3时，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">4</span>: <span class="keyword">return</span> n - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 状态转移</span></span><br><span class="line">        dp = [[<span class="number">1</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(n + <span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                </span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br><span class="line">                <span class="comment"># 选择剪去`0 ~ j`的长度</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(j + <span class="number">1</span>):</span><br><span class="line">                    dp[i][j] = max(</span><br><span class="line">                        dp[i][j], dp[i - <span class="number">1</span>][j - k] * k)</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><p>输入<code>n = 8</code>得到表格</p><div class="table-container"><table><thead><tr><th>m \ n</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>0</td><td><strong>1</strong></td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>2</td><td><strong>3</strong></td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td></tr><tr><td>2</td><td>1</td><td>1</td><td>2</td><td>3</td><td>4</td><td><strong>6</strong></td><td>9</td><td>12</td><td>16</td></tr><tr><td>3</td><td>1</td><td>1</td><td>2</td><td>3</td><td>4</td><td>6</td><td>9</td><td>12</td><td><strong>18</strong></td></tr><tr><td>4</td><td>1</td><td>1</td><td>2</td><td>3</td><td>4</td><td>6</td><td>9</td><td>12</td><td><strong>18</strong></td></tr><tr><td>5</td><td>1</td><td>1</td><td>2</td><td>3</td><td>4</td><td>6</td><td>9</td><td>12</td><td><strong>18</strong></td></tr><tr><td>6</td><td>1</td><td>1</td><td>2</td><td>3</td><td>4</td><td>6</td><td>9</td><td>12</td><td><strong>18</strong></td></tr><tr><td>7</td><td>1</td><td>1</td><td>2</td><td>3</td><td>4</td><td>6</td><td>9</td><td>12</td><td><strong>18</strong></td></tr><tr><td>8</td><td>1</td><td>1</td><td>2</td><td>3</td><td>4</td><td>6</td><td>9</td><td>12</td><td><strong>18</strong></td></tr></tbody></table></div><hr><p><strong>另外一种时间、空间复杂度更低的做法</strong></p><p>注意到在切割长度$j$时，$k$可选择$0 \sim j$，但是实际上这其中有很多重复计算。例如长度为$8$时选择$k = 2$与$k = 6$两种实际上重复计算了。</p><ol><li><strong>子问题</strong>：对长度为$n$的绳子，最后一刀可以选择减去$x$，求$x * (n - x)$最大，那么子问题是剩余绳子$(n - x)$剪若干次后的最大乘积。</li><li><strong>状态和状态变量</strong>：考虑一维数组$dp$，元素$dp[i]$表示长度为$i$的绳子剪若干次后的最大乘积；</li><li><p><strong>状态转移方程</strong>：当$n \leq 3$时绳子不剪长度乘积更大(边界条件)，<strong>$n &gt; 3$时最后一刀可以选择长度是$1, 2, 3$，求乘积最大的一种</strong>，即</p><script type="math/tex; mode=display">dp[j] = \begin{cases}     j & j \leq 3 \\     \max (dp[j - 1] \times 1, dp[j - 2] \times 2, dp[j - 3] \times 3) & \text{otherwise} \end{cases}</script></li><li><p><strong>边界条件</strong>：注意到题中要求$m &gt; 1$，即最少剪$1$次，而在$n = 1$时无法剪所以$dp[1] = 0$、$n = 2, 3$最多只能剪$1$刀所以$dp[2]=1, dp[3]=2$，所以应该有</p><script type="math/tex; mode=display">maxProduct = j - 1, j \leq 3</script></li></ol><p>那么</p><script type="math/tex; mode=display">maxProduct = \begin{cases}    j - 1 & j \leq 3 \\    dp[n] & \text{otherwise}\end{cases}</script><p>时间复杂度$O(n)$，空间复杂度$O(n)$<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 长度1, 2, 3时，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">4</span>: <span class="keyword">return</span> n - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 注意数组下标1, 2, 3时与上面不同</span></span><br><span class="line">        dp = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = max(</span><br><span class="line">                dp[i - <span class="number">1</span>] * <span class="number">1</span>,</span><br><span class="line">                dp[i - <span class="number">2</span>] * <span class="number">2</span>,</span><br><span class="line">                dp[i - <span class="number">3</span>] * <span class="number">3</span>,</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><p>输入<code>n = 8</code>得到表格</p><div class="table-container"><table><thead><tr><th>n</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>dp</td><td>0</td><td>1</td><td>2</td><td><strong>3</strong></td><td>4</td><td><strong>6</strong></td><td>9</td><td>12</td><td><strong>18</strong></td></tr><tr><td>maxProduct</td><td>none</td><td><em>0</em></td><td><em>1</em></td><td><em>2</em></td><td>4</td><td>6</td><td>9</td><td>12</td><td><strong>18</strong></td></tr></tbody></table></div><h1 id="青蛙跳台阶问题"><a href="#青蛙跳台阶问题" class="headerlink" title="青蛙跳台阶问题"></a><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/" target="_blank" rel="noopener">青蛙跳台阶问题</a></h1><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。答案需要取模 1e9+7(1000000007)，如计算初始结果为：1000000008，请返回 1。<br><strong>示例1</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><br><strong>示例2</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 7</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure><br><strong>提示：</strong><br>0 &lt;= n &lt;= 100</p><hr><ol><li><strong>子问题</strong>：对$n$个台阶，最后一步可以跳$1$或$2$阶，接下来相对应的待求解问题是$(n - 1)$或$(n - 2)$个台阶有多少种跳法。</li><li><strong>状态和状态变量</strong>：考虑一维数组$dp$，元素$dp[i]$表示$i$个台阶的跳法；</li><li><strong>状态转移方程</strong>：$dp[i] = dp[i - 1] + dp[i - 2]$，很显然是斐波那契数列；</li><li><strong>边界条件</strong>：$dp[0] = 1, dp[1] = 1$</li></ol><p>一步到位，优化空间复杂度后的解法<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numWays</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        a, b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            a, b = b, a + b</span><br><span class="line">        <span class="keyword">return</span> a % <span class="number">1000000007</span></span><br></pre></td></tr></table></figure></p><p>输入<code>n = 8</code>，其表格为</p><div class="table-container"><table><thead><tr><th>台阶</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>跳法</td><td>1</td><td>1</td><td>2</td><td>3</td><td>5</td><td>8</td><td>13</td><td>21</td><td>34</td></tr></tbody></table></div><h1 id="青蛙过河问题"><a href="#青蛙过河问题" class="headerlink" title="*青蛙过河问题"></a><a href="https://leetcode-cn.com/problems/frog-jump/" target="_blank" rel="noopener">*青蛙过河问题</a></h1><p>一只青蛙想要过河。 假定河流被等分为$x$个单元格，并且在每一个单元格内都有可能放有一石子(也有可能没有)。 青蛙可以跳上石子，但是不可以跳入水中。</p><p>给定石子的位置列表(用单元格序号升序表示)， <strong>请判定青蛙能否成功过河</strong>(即能否在最后一步跳至最后一个石子上)。 开始时， 青蛙默认已站在第一个石子上，并可以假定它第一步只能跳跃一个单位(即只能从单元格1跳至单元格2)。</p><p>如果青蛙上一步跳跃了$k$个单位，那么它接下来的跳跃距离只能选择为$k - 1$、$k$或$k + 1$个单位。 另请注意，青蛙只能向前方(终点的方向)跳跃。</p><p><strong>请注意</strong>：</p><ul><li>石子的数量 ≥ 2 且 &lt; 1100；</li><li>每一个石子的位置序号都是一个非负整数，且其 &lt; 231；</li><li>第一个石子的位置永远是0。<br><strong>示例 1</strong>:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[0,1,3,5,6,8,12,17]</span><br><span class="line"></span><br><span class="line">总共有8个石子。</span><br><span class="line">第一个石子处于序号为0的单元格的位置, 第二个石子处于序号为1的单元格的位置,</span><br><span class="line">第三个石子在序号为3的单元格的位置， 以此定义整个数组...</span><br><span class="line">最后一个石子处于序号为17的单元格的位置。</span><br><span class="line"></span><br><span class="line">返回 true。即青蛙可以成功过河，按照如下方案跳跃： </span><br><span class="line">跳1个单位到第2块石子, 然后跳2个单位到第3块石子, 接着 </span><br><span class="line">跳2个单位到第4块石子, 然后跳3个单位到第6块石子, </span><br><span class="line">跳4个单位到第7块石子, 最后，跳5个单位到第8个石子(即最后一块石子)。</span><br></pre></td></tr></table></figure><strong>示例 2</strong>:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[0,1,2,3,4,8,9,11]</span><br><span class="line"></span><br><span class="line">返回 false。青蛙没有办法过河。 </span><br><span class="line">这是因为第5和第6个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。</span><br></pre></td></tr></table></figure></li></ul><hr><ol><li><strong>子问题</strong>：青蛙跳到最后一个石子上，可以从之前任意一个石子跳跃过来，但是必须满足；最后一次跳跃的距离$k$，必须在最后第二次跳跃距离$[-1, 0, 1]$范围内。那么在满足这些要求的石子中，最后第三次跳跃距离也要满足该条件。那么子问题就是，青蛙能否跳到第$i$个石子上，且上一次跳跃在上上次跳跃的$[-1, 0, 1]$距离范围内。</li><li><strong>状态和状态变量</strong>：<strong>$dp[i][k]$表示能否由前面的某一个石子$j$通过跳$k$步到达当前这个石子$i$</strong>，这个$j$的范围是$[1, i - 1]$，这个$k$步是石子$i$和石子$j$之间的距离。</li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCross</span><span class="params">(self, stones: List[int])</span> -&gt; bool:</span></span><br><span class="line">        dp = [[<span class="keyword">False</span> <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1100</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1100</span>)]</span><br><span class="line">        <span class="comment"># 边界条件：石子0能通过距离1跳跃到</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        n = len(stones)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="comment"># 石子j到石子i的距离k</span></span><br><span class="line">                k = stones[i] - stones[j]</span><br><span class="line">                <span class="keyword">if</span> k &gt;= n: <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果：石子j能通过距离k跳跃到</span></span><br><span class="line">                <span class="keyword">if</span> dp[j][k]:</span><br><span class="line">                    <span class="comment"># 那么：石子i能通过距离k - 1, k, k + 1跳跃到</span></span><br><span class="line">                    dp[i][k] = <span class="keyword">True</span></span><br><span class="line">                    dp[i][k - <span class="number">1</span>] = <span class="keyword">True</span></span><br><span class="line">                    dp[i][k + <span class="number">1</span>] = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 石子n - 1能通过小于n的距离跳跃到</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> dp[n - <span class="number">1</span>][i]:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>输入<code>[0, 1, 3, 5, 6, 8, 12, 17]</code>(n=8)得到下表</p><div class="table-container"><table><thead><tr><th>stones\k</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td>0</td><td>0</td><td><strong>1</strong></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td><td><strong>1</strong></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>3</td><td>0</td><td>1</td><td><strong>1</strong></td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>5</td><td>0</td><td><strong>1</strong></td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>6</td><td>1</td><td>1</td><td><strong>1</strong></td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>8</td><td>0</td><td>1</td><td>1</td><td>1</td><td><strong>1</strong></td><td>0</td><td>0</td><td>0</td></tr><tr><td>12</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td><strong>1</strong></td><td>0</td><td>0</td></tr><tr><td>17</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td><strong>1</strong></td><td>1</td><td>0</td></tr></tbody></table></div><h1 id="最小编辑距离"><a href="#最小编辑距离" class="headerlink" title="最小编辑距离"></a><a href="https://www.lintcode.com/problem/edit-distance/" target="_blank" rel="noopener">最小编辑距离</a></h1><p>给出两个单词word1和word2，计算出将word1 转换为word2的最少操作次数。你总共三种操作方法：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p><strong>样例 1</strong>:<br>输入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;horse&quot;</span><br><span class="line">&quot;ros&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><br>解释:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">horse -&gt; rorse (替换 &#39;h&#39; 为 &#39;r&#39;)</span><br><span class="line">rorse -&gt; rose (删除 &#39;r&#39;)</span><br><span class="line">rose -&gt; ros (删除 &#39;e&#39;)</span><br></pre></td></tr></table></figure></p><p><strong>样例 2</strong>:<br>输入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;intention&quot;</span><br><span class="line">&quot;execution&quot;</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><br>解释:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">intention -&gt; inention (删除 &#39;t&#39;)</span><br><span class="line">inention -&gt; enention (替换 &#39;i&#39; 为 &#39;e&#39;)</span><br><span class="line">enention -&gt; exention (替换 &#39;n&#39; 为 &#39;x&#39;)</span><br><span class="line">exention -&gt; exection (替换 &#39;n&#39; 为 &#39;c&#39;)</span><br><span class="line">exection -&gt; execution (插入 &#39;u&#39;)</span><br></pre></td></tr></table></figure></p><hr><ol><li><strong>子问题</strong>：输入两个词<code>word1</code>、<code>word2</code>求其编辑距离，在将<code>word1</code>第1个字符编辑结束后，两个词第1个字符是一致的，那么接下来的问题是，求两个词从第2个字符起的最小编辑距离。以此类推，子问题就是，经过i-1步编辑后的两个词的最小编辑距离。</li><li><strong>状态和状态变量</strong>：定义二维数组$dp$，元素$dp[i][j]$表示<code>word1</code>前i位到<code>word2</code>前j位的最小编辑距离。</li><li><strong>状态转移方程</strong>：<ul><li>若字符$word1[i]$与$word2[j]$一致，那么该位不用编辑直接跳过；</li><li>不一致的情况下，可以对$word1$进行以下三种修改，求其最小即可。<strong>注意以下切片操作中，包括指定区间的首位元素</strong><ul><li>插入：即$word1[i]$处插入$word2[j]$，那么变为求取$word1[: i]$与$word2[:j + 1]$的最小编辑距离$dp[i - 1][j]$，例如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i &#x3D; 2               -&gt; i &#x3D; 2(s是word1的第2位)</span><br><span class="line">j &#x3D; 2               -&gt; j &#x3D; 3(s是word2的第3位)</span><br><span class="line">ho[s]e  -&gt; ho&lt;r&gt;se  -&gt; hor[s]e</span><br><span class="line">ho[r]se -&gt; ho[r]se  -&gt; hor[s]e</span><br></pre></td></tr></table></figure></li><li>删除：即删除字符$word1[i]$，那么变为求取$word1[: i + 1]$与$word2[:j]$的最小编辑距离$dp[i][j - 1]$<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i &#x3D; 2               -&gt; i &#x3D; 3(s是word1的第3位)</span><br><span class="line">j &#x3D; 2               -&gt; j &#x3D; 2(s是word2的第2位)</span><br><span class="line">ho[r]se -&gt; ho&lt;&gt;se  -&gt; ho[s]e</span><br><span class="line">ho[s]e  -&gt; ho[s]e  -&gt; ho[s]e</span><br></pre></td></tr></table></figure></li><li>替换：等同于将$word1[i]$视作与$word2[j]$一致，那么最小编辑距离$dp[i - 1][j - 1]$<script type="math/tex; mode=display">dp[i][j] = \begin{cases}dp[i - 1][j - 1] & wrod1[i] = word2[j] \\\min( \\  \quad dp[i][j - 1], \\  \quad dp[i - 1][j], \\  \quad dp[i - 1][j - 1] \\) + 1 & \text{otherwise}\end{cases}</script></li></ul></li></ul></li><li><strong>边界条件</strong>：$i = 0$或$j = 0$时，编辑距离是<script type="math/tex; mode=display">dp[0][j] = j, dp[i][0] = i</script></li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param word1: A string</span></span><br><span class="line"><span class="string">    @param word2: A string</span></span><br><span class="line"><span class="string">    @return: The minimum number of steps.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, word1, word2)</span>:</span></span><br><span class="line">        m, n = len(word1), len(word2)</span><br><span class="line">        <span class="comment"># 注意数组大小</span></span><br><span class="line">        <span class="comment"># m + 1: 状态方程中包含`i - 1`，故多定义一行，减少判断条件，便于实现</span></span><br><span class="line">        <span class="comment"># n + 1: 状态方程中包含`j - 1`，故多定义一行，减少判断条件，便于实现</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(n + <span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 边界条件：dp[0][j] = j, dp[i][0] = i</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m + <span class="number">1</span>): dp[i][<span class="number">0</span>] = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n + <span class="number">1</span>): dp[<span class="number">0</span>][j] = j</span><br><span class="line"></span><br><span class="line">        <span class="comment"># `i`, `j`均从1开始</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 状态转移方程</span></span><br><span class="line">                <span class="keyword">if</span> word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 不要忘记加一步编辑`1 + `</span></span><br><span class="line">                    dp[i][j] = <span class="number">1</span> + min(</span><br><span class="line">                        <span class="comment"># 插入</span></span><br><span class="line">                        dp[i - <span class="number">1</span>][j],</span><br><span class="line">                        <span class="comment"># 删除</span></span><br><span class="line">                        dp[i][j - <span class="number">1</span>],</span><br><span class="line">                        <span class="comment"># 替换</span></span><br><span class="line">                        dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                    )</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>输入<code>&quot;intention&quot;, &quot;inention&quot;</code>得到</p><div class="table-container"><table><thead><tr><th>word1\word2</th><th>空</th><th>i</th><th>n</th><th>e</th><th>n</th><th>t</th><th>i</th><th>o</th><th>n</th></tr></thead><tbody><tr><td>空</td><td><strong>0</strong></td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td></tr><tr><td>i</td><td>1</td><td><strong>0</strong></td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr><tr><td>n</td><td>2</td><td>1</td><td><strong>0</strong></td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td></tr><tr><td>t</td><td>3</td><td>2</td><td><strong>1</strong></td><td>1</td><td>2</td><td>2</td><td>3</td><td>4</td><td>5</td></tr><tr><td>e</td><td>4</td><td>3</td><td>2</td><td><strong>1</strong></td><td>2</td><td>3</td><td>3</td><td>4</td><td>5</td></tr><tr><td>n</td><td>5</td><td>4</td><td>3</td><td>2</td><td><strong>1</strong></td><td>2</td><td>3</td><td>4</td><td>4</td></tr><tr><td>t</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td><strong>1</strong></td><td>2</td><td>3</td><td>4</td></tr><tr><td>i</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td><strong>1</strong></td><td>2</td><td>3</td></tr><tr><td>o</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td><strong>1</strong></td><td>2</td></tr><tr><td>n</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td><strong>1</strong></td></tr></tbody></table></div><h1 id="最大子序和问题"><a href="#最大子序和问题" class="headerlink" title="最大子序和问题"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">最大子序和问题</a></h1><p>给定一个整数数组<code>nums</code>，找到一个具有最大和的连续子数组(子数组最少包含一个元素)，返回其最大和。</p><p><strong>示例</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure><br>进阶:</p><p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p><hr><ol><li><strong>子问题</strong>：要求整个数组$n$个数的最大连续子数组和，先考虑求解前$(n-1)$个数的最大连续子数组和，然后将第$n$个数加入，所以子问题是求解前$x(1 \leq x \leq n)$个数的最大连续子数组和；</li><li><strong>状态和状态变量</strong>：定义数组一维数组$dp$，元素$dp[i]$表示前$i$个数中最大的连续子数组和；</li><li><p><strong>状态转移方程</strong>：在$dp[i - 1]$小于$0$时，就应该断开数组，从当前数字开始新的数组。如上例中的元素$4$，累加左边最大连续数组和$-2$反而会使值减小，故状态转移方程是</p><script type="math/tex; mode=display"> dp[i] = \begin{cases}     nums[i] & dp[i - 1] \lt 0 \\     dp[i - 1] + nums[i] & \text{otherwise} \\ \end{cases}</script><p> 等价于</p><script type="math/tex; mode=display">dp[i] = \max(dp[i - 1] + nums[i], nums[i])</script></li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">        maxSubSum = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 状态方程</span></span><br><span class="line">            dp[i] = max(dp[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>], nums[i - <span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 记录最大连续子数组和</span></span><br><span class="line">            maxSubSum = max(maxSubSum, dp[i])</span><br><span class="line">            print(dp[i], end=<span class="string">'\n'</span> <span class="keyword">if</span> i == n <span class="keyword">else</span> <span class="string">'\t'</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxSubSum</span><br></pre></td></tr></table></figure><p>输入`[-2,1,-3,4,-1,2,1,-5,4]，得到表格如下</p><div class="table-container"><table><thead><tr><th>nums</th><th>-2</th><th>1</th><th>-3</th><th>4</th><th>-1</th><th>2</th><th>1</th><th>-5</th><th>4</th></tr></thead><tbody><tr><td>max subarray sum</td><td>-2</td><td>1</td><td>-2</td><td>4</td><td>3</td><td>5</td><td>6</td><td>1</td><td>5</td></tr></tbody></table></div><hr><p><strong>一种错误的解法</strong></p><ol><li><strong>子问题</strong>：要求整个数组$n$个数的最大连续子数组和，先考虑求解前$(n-1)$个数的最大连续子数组和，然后将第$n$个数加入，所以子问题是求解前$x, 1 \leq x \leq n$个数的最大连续子数组和；</li><li><strong>状态和状态变量</strong>：定义数组一维数组$dp$，元素$dp[i]$表示前$i$个数中最大的连续子数组和；</li><li><strong>状态转移方程</strong>：连续子数组只会以大于0的数开始，在小于0的元素处断开，一旦“<strong>在第i个数添加时，出现该数与之前数的最大和子数组小于0</strong>”这一条件触发，有两层含义：<ul><li>在此之前数组连续</li><li>之前连续的数组在该值处断开</li></ul></li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">        maxSubSum = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 状态方程</span></span><br><span class="line">            subsum = dp[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> subsum &lt; <span class="number">0</span>:      <span class="comment"># 数组断开</span></span><br><span class="line">                dp[i] = nums[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:               <span class="comment"># 数组累加</span></span><br><span class="line">                dp[i] = subsum</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 记录最大连续子数组和</span></span><br><span class="line">            maxSubSum = max(maxSubSum, dp[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>输入`[-2,1,-3,4,-1,2,1,-5,4]，得到表格如下</p><div class="table-container"><table><thead><tr><th>nums</th><th>-2</th><th>1</th><th>-3</th><th>4</th><th>-1</th><th>2</th><th>1</th><th>-5</th><th>4</th></tr></thead><tbody><tr><td>max subarray sum</td><td>-2</td><td>1</td><td>-3</td><td>1</td><td>0</td><td>2</td><td>3</td><td>-5</td><td>4</td></tr></tbody></table></div><p>上表中最大连续子数组是<code>[4]</code>，但实际答案是<code>[4,-1,2,1]</code></p><h1 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a><a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">乘积最大子数组</a></h1><p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组(该子数组中至少包含一个数字)，并返回该子数组所对应的乘积。<br>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,-2,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 子数组 [2,3] 有最大乘积 6。</span><br></pre></td></tr></table></figure><br>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,0,-1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</span><br></pre></td></tr></table></figure></p><hr><ol><li><strong>子问题</strong>：要求整个数组$n$个数的最大乘积子数组的乘积，先考虑求解前$(n-1)$个数的最大乘积子数组的乘积，然后将第$n$个数加入，所以子问题是求解前$x, 1 \leq x \leq n$个数的最大乘积子数组的乘积；</li><li><strong>状态和状态变量</strong>：考虑到乘法中，两个满足$a &gt; b$的正数，乘以负数$c$后有$ac &lt; bc$，同样地，最大值也可以由最小值乘以一个负数得到，所以需要保存两个状态，分别为<strong>最大乘积子数组的乘积</strong>和<strong>最小乘积子数组的乘积</strong>，分别定义一维数组$dpMax, dpMin$。</li><li><p><strong>状态转移方程</strong>：讨论$dpMax[i - 1], dpMin[i - 1], nums[i]$的符号，$dpMax[i]$最可能从三个状态转移而来，其余均不可能产生最大值，分别是：</p><ul><li>前面的连续数组乘积$dpMax[i - 1] &gt; 0$，且$nums[i] &gt; 0$，当前数$nums[i]$累乘后，获得更大的乘积；</li><li>前面的连续数组乘积$dpMax[i - 1] &lt; 0$，且$nums[i] &gt; 0$，那么需要以$nums[i]$开始，重新累计连续数组；</li><li><p>前面的连续数组乘积$dpMin[i - 1] &lt; 0$，且$nums[i] &lt; 0$，当前数$nums[i]$累乘后，获得更大的乘积；</p><p>所以</p><script type="math/tex; mode=display">dpMax[i] = \max(dpMax[i - 1] \times nums[i], dpMin[i - 1] \times nums[i], nums[i])</script><p>同理</p><script type="math/tex; mode=display">dpMin[i] = \max(dpMin[i - 1] \times nums[i], dpMax[i - 1] \times nums[i], nums[i])</script></li></ul></li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        ret = float(<span class="string">'-inf'</span>)</span><br><span class="line"></span><br><span class="line">        n = len(nums)</span><br><span class="line">        dpMax = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        dpMin = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="comment"># 边界条件，初始值</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                dpMax[i] = dpMin[i] = nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 更新最大连续数组乘积</span></span><br><span class="line">                dpMax[i] = max(</span><br><span class="line">                    dpMax[i - <span class="number">1</span>] * nums[i],</span><br><span class="line">                    dpMin[i - <span class="number">1</span>] * nums[i],</span><br><span class="line">                    nums[i])</span><br><span class="line">                <span class="comment"># 更新最小连续数组乘积</span></span><br><span class="line">                dpMin[i] = min(</span><br><span class="line">                    dpMin[i - <span class="number">1</span>] * nums[i],</span><br><span class="line">                    dpMax[i - <span class="number">1</span>] * nums[i],</span><br><span class="line">                    nums[i])</span><br><span class="line">            ret = max(ret, dpMax[i])</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><h1 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">最长回文子串</a></h1><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。<br><strong>示例 1</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure><br><strong>示例 2</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure></p><hr><ol><li><strong>子问题</strong>：判断一个字符串是否为回文串，最简单的方法是对每一位进行遍历，以该位字符为中心同时向两边探测，如果是回文串每次探测时的字符必定是一致的。那么子问题就是，一个字符串经过一定步数的探测后，两端是否仍旧满足回文。</li><li><strong>状态和状态变量</strong>：如果一个串已经是回文串，那么该串无需重复遍历。<strong>定义二维数组$dp$，其元素$dp[i][j]$表示从$i$到$j$的最长回文串长度。</strong></li><li><strong>状态转移方程</strong>：<br> 对于字串$s[i: j], i &gt; j$，其满足是回文串的条件是，$s[i + 1: j - 1]$也是回文串且$s[i] = s[j]$<script type="math/tex; mode=display"> dp[i][j] = \begin{cases}     dp[i + 1][j - 1] + 2 & dp[i + 1][j - 1] > 0 \quad \& \quad s[i] = s[j] \\     0 & \text{otherwise} \end{cases}</script></li><li><p><strong>边界条件</strong>：</p><ul><li>每个字符自身都是回文串(奇数长度串)，即$dp[i][i] = 1$；</li><li><p>注意两个字符相邻的情况(偶数长度串)，需要比较两个字符是否一致，即$s[i] = s[j]$才有$dp[i][j] = 2$；</p><p>即初始化条件为</p><script type="math/tex; mode=display">dp[i][j] = \begin{cases}  1 & i = j \\  2 & j = i + 1, s[i] = s[j] \\  0 & \text{otherwise}\end{cases},</script></li></ul></li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="comment"># 注意数组大小</span></span><br><span class="line">        <span class="comment"># 状态方程中有`j - 1`项，故`n + 1`；</span></span><br><span class="line">        <span class="comment"># 为保持一致性，定义`i`最大范围也是`0 ~ n`</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(n + <span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 保存最大</span></span><br><span class="line">        lp = float(<span class="string">'-inf'</span>)</span><br><span class="line">        b = e = <span class="keyword">None</span></span><br><span class="line">        <span class="comment"># 迭代求解，注意循环方向(从下向上、从左到右)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n + <span class="number">1</span>):</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 边界条件1，每个字符自身都是回文串</span></span><br><span class="line">                <span class="keyword">if</span> i == j:</span><br><span class="line">                    dp[i][j] = <span class="number">1</span></span><br><span class="line">                <span class="comment"># 边界条件2，相邻的两个字符</span></span><br><span class="line">                <span class="keyword">elif</span> i + <span class="number">1</span> == j:</span><br><span class="line">                    <span class="keyword">if</span> s[i - <span class="number">1</span>] == s[j - <span class="number">1</span>]:</span><br><span class="line">                        dp[i][j] = <span class="number">2</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j] = <span class="number">0</span></span><br><span class="line">                <span class="comment"># ---------------------------------------</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 状态转移方程</span></span><br><span class="line">                    <span class="keyword">if</span> dp[i + <span class="number">1</span>][j - <span class="number">1</span>] &gt; <span class="number">0</span> <span class="keyword">and</span> (s[i - <span class="number">1</span>] == s[j - <span class="number">1</span>]):</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j] = <span class="number">0</span></span><br><span class="line">                <span class="comment"># 更新最大</span></span><br><span class="line">                <span class="keyword">if</span> dp[i][j] &gt; lp:</span><br><span class="line">                    lp = dp[i][j]</span><br><span class="line">                    b, e = i - <span class="number">1</span>, j</span><br><span class="line">        <span class="keyword">return</span> s[b: e]</span><br></pre></td></tr></table></figure><p>例如输入<code>&quot;abcdedcaad&quot;</code>，得到</p><div class="table-container"><table><thead><tr><th></th><th>空</th><th>a</th><th>b</th><th>c</th><th>d</th><th>e</th><th>d</th><th>c</th><th>a</th><th>a</th><th>d</th></tr></thead><tbody><tr><td>空</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>a</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>b</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>c</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td><strong>5</strong></td><td>0</td><td>0</td><td>0</td></tr><tr><td>d</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td><strong>3</strong></td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>e</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td><strong>1</strong></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>d</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>c</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>a</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td><em>2</em></td><td>0</td></tr><tr><td>a</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>d</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr></tbody></table></div><h1 id="最长递增子序列问题-LIS"><a href="#最长递增子序列问题-LIS" class="headerlink" title="最长递增子序列问题, LIS"></a><a href="https://www.lintcode.com/problem/longest-increasing-subsequence/description" target="_blank" rel="noopener">最长递增子序列问题, LIS</a></h1><p>给定一个整数序列，找到最长上升子序列(LIS)，返回LIS的长度。</p><p>样例<br><strong>样例 1</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:  [5,4,1,2,3]</span><br><span class="line">输出:  3</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">LIS 是 [1,2,3]</span><br></pre></td></tr></table></figure></p><p><strong>样例 2</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,2,4,5,3,7]</span><br><span class="line">输出:  4</span><br><span class="line"></span><br><span class="line">解释: </span><br><span class="line">LIS 是 [2,4,5,7]</span><br></pre></td></tr></table></figure><br><strong>挑战</strong><br>要求时间复杂度为O(n^2)或者O(nlogn)</p><p><strong>说明</strong><br>最长上升子序列的定义：</p><ul><li>最长上升子序列问题是在一个无序的给定序列中找到一个尽可能长的由低到高排列的子序列，这种子序列不一定是连续的或者唯一的。</li><li><a href="https://en.wikipedia.org/wiki/Longest_increasing_subsequence" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Longest_increasing_subsequence</a></li></ul><hr><ol><li><strong>子问题</strong>：要求$n$个数字中的最长上升子序列，需要用到第$n$个数与前$(n - 1)$个数字的最长上升子序列，所以子问题是前$x$个数字的最长上升子序列长度。</li><li><strong>状态和状态变量</strong>：定义一维数组$dp$，其元素$dp[i]$表示前$i$个数字的最长上升子序列长度。</li><li><strong>状态转移方程</strong>：第$i$个数需要选择加入前$(i - 1)$个数中<strong>上升且最长</strong>的子序列，也就是说前$(i-1)$个数中满足$nums[j] &lt; nums[i], j = 1, \cdots, i - 1$且$dp[j]$最大</li><li><strong>边界条件</strong>：前$0$个数字的最长上升子序列是$0$。</li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param nums: An integer array</span></span><br><span class="line"><span class="string">    @return: The length of LIS (longest increasing subsequence)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestIncreasingSubsequence</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">        LIS = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 状态转移方程：从前`i-1`个数中找能入的最长的子序列</span></span><br><span class="line">            lis = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums[i - <span class="number">1</span>] &gt; nums[j - <span class="number">1</span>]:</span><br><span class="line">                    lis = max(lis, dp[j])</span><br><span class="line">            dp[i] = lis + <span class="number">1</span></span><br><span class="line">            LIS = max(LIS, dp[i])</span><br><span class="line">        <span class="keyword">return</span> LIS</span><br></pre></td></tr></table></figure><p>例如输入<code>[10, 1, 11, 2, 12, 3, 11, 2]</code>，得到表格如下</p><div class="table-container"><table><thead><tr><th>nums</th><th>空</th><th>10</th><th>1</th><th>11</th><th>2</th><th>12</th><th>3</th><th>11</th><th>2</th></tr></thead><tbody><tr><td>lis</td><td>0</td><td>1</td><td>1</td><td>2</td><td>2</td><td>3</td><td>3</td><td>4</td><td>2</td></tr></tbody></table></div><h1 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a><a href="https://www.lintcode.com/problem/longest-common-substring/" target="_blank" rel="noopener">最长公共子串</a></h1><p>给出两个字符串，找到最长公共子串，并返回其长度。</p><p><strong>样例 1</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入:  &quot;ABCD&quot; and &quot;CBCE&quot;</span><br><span class="line">输出:  2</span><br></pre></td></tr></table></figure><br>解释:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最长公共子串是 &quot;BC&quot;</span><br></pre></td></tr></table></figure><br><strong>样例 2</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;ABCD&quot; and &quot;EACB&quot;</span><br><span class="line">输出:  1</span><br></pre></td></tr></table></figure><br>解释:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最长公共子串是 &#39;A&#39; 或 &#39;C&#39; 或 &#39;B&#39;</span><br></pre></td></tr></table></figure><br><strong>挑战</strong><br>O(n x m) time and memory.</p><hr><ol><li><strong>子问题</strong>：子问题就是<code>s1</code>前$x$个字符与<code>s2</code>前$y$个字符的最长公共字串长度，由于必须是连续子串，问题转变为<code>s1</code>前$x$个字符与<code>s2</code>前$y$个字符的<strong>尾部</strong>最长公共字串长度。</li><li><strong>状态和状态变量</strong>：定义二维数组$dp$，元素$dp[i][j]$表示$s1[:i]$与$s2[:j]$的<strong>尾部</strong>最长公共字串长度；</li><li><strong>状态转移方程</strong>：<br> 先对比$s1[:i]$与$s2[:j]$结尾字符是否相同<ul><li>若相同，那么即$d[i - 1][j - 1] + 1$；</li><li>不想同时，这两个字串没有相同的结尾字串。<script type="math/tex; mode=display">dp[i][j] = \begin{cases}  d[i - 1][j - 1] + 1 & s1[i] = s2[j] \\  0 & \text{otherwise}\end{cases}</script></li></ul></li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param A: A string</span></span><br><span class="line"><span class="string">    @param B: A string</span></span><br><span class="line"><span class="string">    @return: the length of the longest common substring.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubstring</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        m, n = len(A), len(B)</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(n + <span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        lcs = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> A[i - <span class="number">1</span>] == B[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="number">0</span></span><br><span class="line">                lcs = max(lcs, dp[i][j])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lcs</span><br></pre></td></tr></table></figure><p>例如输入<code>&quot;ABCABCDE&quot;, &quot;CBCBCDE&quot;</code>，最长公共字串是<code>BCDE</code>，得到下表</p><div class="table-container"><table><thead><tr><th>A\B</th><th>空</th><th>C</th><th>B</th><th>C</th><th>B</th><th>C</th><th>D</th><th>E</th></tr></thead><tbody><tr><td>空</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>A</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>B</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>C</td><td>0</td><td>1</td><td>0</td><td>2</td><td>0</td><td>2</td><td>0</td><td>0</td></tr><tr><td>A</td><td>0</td><td>0</td><td>0</td><td><strong>0</strong></td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>B</td><td>0</td><td>0</td><td>1</td><td>0</td><td><strong>1</strong></td><td>0</td><td>0</td><td>0</td></tr><tr><td>C</td><td>0</td><td>1</td><td>0</td><td>2</td><td>0</td><td><strong>2</strong></td><td>0</td><td>0</td></tr><tr><td>D</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td><strong>3</strong></td><td>0</td></tr><tr><td>E</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td><strong>4</strong></td></tr></tbody></table></div><h1 id="最长公共子序列问题-LCS"><a href="#最长公共子序列问题-LCS" class="headerlink" title="最长公共子序列问题, LCS"></a><a href="https://www.lintcode.com/problem/longest-common-subsequence/description" target="_blank" rel="noopener">最长公共子序列问题, LCS</a></h1><p>给出两个字符串，找到最长公共子序列(LCS)，返回LCS的长度。</p><p><strong>样例 1</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入:  &quot;ABCD&quot; and &quot;EDCA&quot;</span><br><span class="line">输出:  1</span><br></pre></td></tr></table></figure><br>解释:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LCS 是 &#39;A&#39; 或  &#39;D&#39; 或 &#39;C&#39;</span><br></pre></td></tr></table></figure></p><p><strong>样例 2:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;ABCD&quot; and &quot;EACB&quot;</span><br><span class="line">输出:  2</span><br></pre></td></tr></table></figure><br>解释:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LCS 是 &quot;AC&quot;</span><br></pre></td></tr></table></figure><br>说明<br>最长公共子序列的定义：</p><ul><li>最长公共子序列问题是在一组序列(通常2个)中找到最长公共子序列(<strong>注意：不同于子串，LCS不需要是连续的子串</strong>)。该问题是典型的计算机科学问题，是文件差异比较程序的基础，在生物信息学中也有所应用。</li><li><a href="https://en.wikipedia.org/wiki/Longest_common_subsequence_problem" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Longest_common_subsequence_problem</a></li></ul><hr><ol><li><strong>子问题</strong>：子问题就是<code>s1</code>前$x$个字符与<code>s2</code>前$y$个字符的最长公共子序列长度。</li><li><strong>状态和状态变量</strong>：定义二维数组$dp$，元素$dp[i][j]$表示$s1[:i]$与$s2[:j]$的最长公共子序列长度；</li><li><p><strong>状态转移方程</strong>：需要对比最后一位是否相同，即$s1[i]$与$s2[j]$</p><ul><li>若相同，那么是$dp[i - 1][j - 1] + 1$；</li><li><p>若不相同，那么最长公共子序列由$dp[i][j - 1]$, $dp[i - 1][j]$，$dp[i - 1][j - 1] + 1$中产生</p><p>即</p><script type="math/tex; mode=display">dp[i][j] = \begin{cases}  dp[i - 1][j - 1] + 1 & s1[i] = s2[j] \\  \max(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]) & \text{otherwise}\end{cases}</script></li></ul></li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param A: A string</span></span><br><span class="line"><span class="string">    @param B: A string</span></span><br><span class="line"><span class="string">    @return: The length of longest common subsequence of A and B</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        m, n = len(A), len(B)</span><br><span class="line">        <span class="comment"># 注意数组大小</span></span><br><span class="line">        <span class="comment"># 状态转移方程中有`i - 1`与`j - 1`，故多加一行、一列，不用多余判断</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(n + <span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 最后一位字符相同</span></span><br><span class="line">                <span class="keyword">if</span> A[i - <span class="number">1</span>] == B[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="comment"># 最后一位字符不相同</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = max(         <span class="comment"># 以下区间为左开右闭</span></span><br><span class="line">                        dp[i - <span class="number">1</span>][j],       <span class="comment"># A[: i]与B[: j + 1]</span></span><br><span class="line">                        dp[i][j - <span class="number">1</span>],       <span class="comment"># A[: i + 1]与B[: j]</span></span><br><span class="line">                        dp[i - <span class="number">1</span>][j - <span class="number">1</span>]    <span class="comment"># A[: i]与B[: j]</span></span><br><span class="line">                    )</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>输入<code>hello, chealo</code>得到下表</p><div class="table-container"><table><thead><tr><th></th><th>空</th><th>h</th><th>e</th><th>l</th><th>l</th><th>o</th></tr></thead><tbody><tr><td>空</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>c</td><td><strong>0</strong></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>h</td><td>0</td><td><strong>1</strong></td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>e</td><td>0</td><td>1</td><td><strong>2</strong></td><td><strong>2</strong></td><td>2</td><td>2</td></tr><tr><td>a</td><td>0</td><td>1</td><td><strong>2</strong></td><td><strong>2</strong></td><td>2</td><td>2</td></tr><tr><td>l</td><td>0</td><td>1</td><td>2</td><td>3</td><td><strong>3</strong></td><td>3</td></tr><tr><td>o</td><td>0</td><td>1</td><td>2</td><td>2</td><td>3</td><td><strong>4</strong></td></tr></tbody></table></div><h1 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="*买卖股票的最佳时机"></a>*买卖股票的最佳时机</h1><p><strong>套路(来自labuladong的算法小抄)</strong></p><ol><li><strong>子问题</strong>：前$i$天前$k$次买入卖出后的最大利润</li><li><strong>状态和状态变量</strong>：定义两个二维数组$bought$和$sold$<ul><li>元素$bought[i][k]$表示在第$i$天以第$k$次买入后获得的最大利润</li><li>元素$sold[i][k]$表示在第$i$天以第$k$次卖出后获得的最大利润</li></ul></li><li><p><strong>状态转移方程</strong>：</p><ul><li>一次交易肯定由买开始，卖结束，那么<ul><li>$bought$数组内元素表示手头没有股票的情况，并且买入时已获得利润减少</li><li>$sold$数组内元素表示手头有股票的情况，并且卖出时已获得利润增加</li></ul></li><li>第$i$天决定是否以$k$次买入时，手头是没有股票的，这种状态可以由以下两种情况转移而来<ul><li>第$(i - 1)$天没有持有股票</li><li>第$(i - 1)$天在第$(k - 1)$次交易中卖出</li><li>希望每次卖出是最高价，所以应有卖出后利润最大</li></ul></li><li><p>第$i$天决定是否以$k$次卖出时，手头是有股票的，这种状态可以由以下两种情况转移而来</p><ul><li>第$(i - 1)$天持有股票</li><li>第$(i - 1)$天在第$k$次交易中买入</li><li>希望每次卖入是最低价，所以应有买入后利润也是最大</li></ul><p>具体地，状态转移方程就是</p><script type="math/tex; mode=display">\begin{aligned}  bought[i][k] & = \max(bought[i - 1][k], sold[i - 1][k - 1] - price[i]) \\  sold[i][k] & = \max(sold[i - 1][k], bought[i - 1][k] + price[i]) \\\end{aligned}</script></li></ul></li><li><p><strong>边界条件</strong>：</p><ul><li>在第$0$天(表格的第$1$行)不可能买入或卖出，因此<script type="math/tex; mode=display">  \begin{aligned}      bought[0][k] & = -\infty \\      sold[0][k] & = 0 \\  \end{aligned}</script></li><li><p>在第$0$次买入卖出(表格的第$1$列)时，应该有</p><script type="math/tex; mode=display">  \begin{aligned}      bought[i][0] & = -\infty \\      sold[i][0] & = 0 \\  \end{aligned}</script><blockquote><p>注：$bought[0][k]$和$bought[i][0]$必须是$-\infty$，因为卖出时最大收益可能为负，如果初始化成$0$那么卖出时最大收益最小就是$0$，不符合条件。</p></blockquote><p>即初始化表格如下，左侧是$bought$，右侧是$sold$</p></li></ul></li></ol><div class="table-container"><table><thead><tr><th>prices \ k</th><th>0</th><th>1</th><th>2</th><th>…</th><th>prices \ k</th><th>0</th><th>1</th><th>2</th><th>…</th></tr></thead><tbody><tr><td>空</td><td>-inf</td><td>-inf</td><td>-inf</td><td>…</td><td>空</td><td>0</td><td>0</td><td>0</td><td>…</td></tr><tr><td>p1</td><td>-inf</td><td></td><td></td><td></td><td>p1</td><td>0</td><td></td><td></td><td></td></tr><tr><td>p2</td><td>-inf</td><td></td><td></td><td></td><td>p2</td><td>0</td><td></td><td></td><td></td></tr><tr><td>…</td><td>…</td><td></td><td></td><td></td><td>…</td><td>…</td><td></td><td></td></tr></tbody></table></div><blockquote><p><strong>为便于理解，以下代码都没有优化空间复杂度，实际上都可以降低。</strong></p></blockquote><h2 id="买卖股票的最佳时机-I-一次交易"><a href="#买卖股票的最佳时机-I-一次交易" class="headerlink" title="买卖股票的最佳时机 I: 一次交易"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">买卖股票的最佳时机 I: 一次交易</a></h2><p>给定一个数组，它的第$i$个元素是一支给定股票第$i$天的价格。<br>如果你最多只允许完成一笔交易(即买入和卖出一支股票一次)，设计一个算法来计算你所能获取的最大利润。<br>注意：你不能在买入股票前卖出股票。<br><strong>示例 1</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天(股票价格 &#x3D; 1)的时候买入，在第 5 天(股票价格 &#x3D; 6)的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure><br><strong>示例 2</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure></p><hr><p>在第$i$天卖出的最大收益，肯定是<strong>第$i$天价格减去前$(i - 1)$天中最低价格</strong>，因此<strong>将问题转换为求取前$i$天的最低价格</strong>。</p><ol><li><strong>子问题</strong>：求前$i$天的最低价格。</li><li><strong>状态和状态变量</strong>：定义一维度数组$dp$，元素$dp[i]$表示前$i$天的最低价格。</li><li><p><strong>状态转移方程</strong>：将第$i$天的价格与前$(i - 1)$天中最低价格对比，更新最小即可</p><script type="math/tex; mode=display">dp[i] = \begin{cases}     price[i] & i = 1 \\     \min(dp[i - 1], price[i]) & i > 1 \end{cases}</script><p> 第$i$天卖出的最大收益是</p><script type="math/tex; mode=display">profit[i] = price[i] - dp[i]</script></li></ol><p>时间复杂度是$O(n)$，空间复杂度可以从$O(n)$降低至$O(1)$</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        max_profit = <span class="number">0</span></span><br><span class="line">        min_price = prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="comment"># 边界条件，第一天</span></span><br><span class="line">            min_price = min(min_price, prices[i])</span><br><span class="line">            <span class="comment"># 状态转移方程</span></span><br><span class="line">            max_profit = max(max_profit, prices[i] - min_price)</span><br><span class="line">        <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure><p>输入<code>[3, 2, 3, 1, 2]</code>，得到表格如下</p><div class="table-container"><table><thead><tr><th>price</th><th>3</th><th>2</th><th>3</th><th>1</th><th>2</th></tr></thead><tbody><tr><td>min_price</td><td>3</td><td>2</td><td>2</td><td>1</td><td>1</td></tr><tr><td>max_profit</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td></tr></tbody></table></div><hr><p>如果用套路解决，参考<a href="#买卖股票的最佳时机iv-多次交易">买卖股票的最佳时机 IV: 多次交易</a>，设置$K = 1$即可。</p><script type="math/tex; mode=display">\begin{aligned}    bought[i][k] & = \max(bought[i - 1][k], sold[i - 1][k - 1] - price[i]) \\    sold[i][k] & = \max(sold[i - 1][k], bought[i - 1][k] + price[i]) \\\end{aligned}</script><p>设置$K = 1$，有$sold[i - 1][0] = 0$，所以</p><script type="math/tex; mode=display">\begin{aligned}    bought[i] & = \max(bought[i - 1], 0 - price[i]) \\    sold[i] & = \max(sold[i - 1], bought[i - 1] + price[i]) \\\end{aligned}</script><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(prices)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 边界条件</span></span><br><span class="line">        bought = [float(<span class="string">'-inf'</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        sold   = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 状态转移方程</span></span><br><span class="line">            bought[i] = max(</span><br><span class="line">                <span class="comment"># 前一天第1次买入</span></span><br><span class="line">                bought[i - <span class="number">1</span>],</span><br><span class="line">                <span class="comment"># 前一天第0次卖出，这天第1次买入</span></span><br><span class="line">                <span class="number">0</span> - prices[i - <span class="number">1</span>]</span><br><span class="line">            )</span><br><span class="line">            sold[i] = max(</span><br><span class="line">                <span class="comment"># 前一天第1次卖出</span></span><br><span class="line">                sold[i - <span class="number">1</span>],</span><br><span class="line">                <span class="comment"># 前一天第1次买入，这天第1次卖出</span></span><br><span class="line">                bought[i - <span class="number">1</span>] + prices[i - <span class="number">1</span>]</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">return</span> sold[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>输入<code>[3,2,6,5,0,3]</code>，得到表格如下</p><div class="table-container"><table><thead><tr><th>dp \ prices</th><th>空</th><th>3</th><th>2</th><th>6</th><th>5</th><th>0</th><th>3</th></tr></thead><tbody><tr><td>bought</td><td><strong>-inf</strong></td><td><strong>-3</strong></td><td><strong>-2</strong></td><td>-2</td><td>-2</td><td>0</td><td>0</td></tr><tr><td>sold</td><td>0</td><td>0</td><td>0</td><td><strong>4</strong></td><td><strong>4</strong></td><td><strong>4</strong></td><td><strong>4</strong></td></tr></tbody></table></div><p>表示在价格为$2$时买入，价格为$6$时卖出。</p><h2 id="买卖股票的最佳时机-II-无穷多次交易"><a href="#买卖股票的最佳时机-II-无穷多次交易" class="headerlink" title="买卖股票的最佳时机 II: 无穷多次交易"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">买卖股票的最佳时机 II: 无穷多次交易</a></h2><p>给定一个数组，它的第$i$个元素是一支给定股票第$i$天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易(多次买卖一支股票)。<br>注意：你不能同时参与多笔交易(你必须在再次购买前出售掉之前的股票)。<br><strong>示例 1</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天(股票价格 &#x3D; 1)的时候买入，在第 3 天(股票价格 &#x3D; 5)的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     随后，在第 4 天(股票价格 &#x3D; 3)的时候买入，在第 5 天(股票价格 &#x3D; 6)的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。</span><br></pre></td></tr></table></figure><br><strong>示例 2</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天(股票价格 &#x3D; 1)的时候买入，在第 5 天 (股票价格 &#x3D; 5)的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure><br><strong>示例 3</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><br><strong>提示</strong>：</p><ul><li>$1 \leq prices.length \leq 3 * 10 ^ 4$</li><li>$0 \leq prices[i] \leq 10 ^ 4$</li></ul><hr><p>无穷多次交易，可以将$k-1$视作$k$，原始状态转移方程是</p><script type="math/tex; mode=display">\begin{aligned}    bought[i][k] & = \max(bought[i - 1][k], sold[i - 1][k - 1] - price[i]) \\    & = \max(bought[i - 1][k], sold[i - 1][k] - price[i]) \\    sold[i][k] & = \max(sold[i - 1][k], bought[i - 1][k] + price[i]) \\\end{aligned}</script><p>那么实际上就与$k$无关了，也就是说</p><ul><li>第$i$天决定是否买入时，手头是没有股票的，这种状态可以由以下两种情况转移而来<ul><li>第$(i - 1)$天没有持有股票</li><li>第$(i - 1)$天卖出</li></ul></li><li>第$i$天决定是否卖出时，手头是有股票的，这种状态可以由以下两种情况转移而来<ul><li>第$(i - 1)$天持有股票</li><li>第$(i - 1)$天买入</li></ul></li></ul><p>所以</p><script type="math/tex; mode=display">\begin{aligned}    bought[i] & = \max(bought[i - 1], sold[i - 1] - price[i]) \\    sold[i]   & = \max(sold[i - 1], bought[i - 1] + price[i]) \\\end{aligned}</script><p>时间复杂度$O(n)$，空间复杂度$O(n)$<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(prices)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 边界条件</span></span><br><span class="line">        bought = [float(<span class="string">'-inf'</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        sold   = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 状态转移方程</span></span><br><span class="line">            bought[i] = max(</span><br><span class="line">                <span class="comment"># 前一天买入</span></span><br><span class="line">                bought[i - <span class="number">1</span>],</span><br><span class="line">                <span class="comment"># 前一天卖出，这天买入</span></span><br><span class="line">                sold[i - <span class="number">1</span>] - prices[i - <span class="number">1</span>]</span><br><span class="line">            )</span><br><span class="line">            sold[i] = max(</span><br><span class="line">                <span class="comment"># 前一天卖出</span></span><br><span class="line">                sold[i - <span class="number">1</span>],</span><br><span class="line">                <span class="comment"># 前一天买入，这天卖出</span></span><br><span class="line">                bought[i - <span class="number">1</span>] + prices[i - <span class="number">1</span>]</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">return</span> sold[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><p>输入<code>[3,2,6,5,0,3]</code>，得到表格如下</p><div class="table-container"><table><thead><tr><th>dp \ prices</th><th>空</th><th>3</th><th>2</th><th>6</th><th>5</th><th>0</th><th>3</th></tr></thead><tbody><tr><td>bought</td><td><strong>-inf</strong></td><td><strong>-3</strong></td><td><strong>-2</strong></td><td>-2</td><td>-1</td><td><strong>4</strong></td><td>4</td></tr><tr><td>sold</td><td>0</td><td>0</td><td>0</td><td><strong>4</strong></td><td><strong>4</strong></td><td>4</td><td><strong>7</strong></td></tr></tbody></table></div><p>表示在价格为$2$时买入，价格为$6$时卖出，再在价格为$0$时买入，价格为$3$时卖出。</p><h2 id="买卖股票的最佳时机-III-最多两次交易"><a href="#买卖股票的最佳时机-III-最多两次交易" class="headerlink" title="买卖股票的最佳时机 III: 最多两次交易"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">买卖股票的最佳时机 III: 最多两次交易</a></h2><p>给定一个数组，它的第$i$个元素是一支给定的股票在第$i$天的价格。<br>设计一个算法来计算你所能获取的最大利润。你最多可以完成<strong>两笔</strong>交易。<br>注意: 你不能同时参与多笔交易(你必须在再次购买前出售掉之前的股票)。</p><p><strong>示例 1</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,3,5,0,0,3,1,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 在第 4 天(股票价格 &#x3D; 0)的时候买入，在第 6 天(股票价格 &#x3D; 3)的时候卖出，这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。</span><br><span class="line">     随后，在第 7 天(股票价格 &#x3D; 1)的时候买入，在第 8 天 (股票价格 &#x3D; 4)的时候卖出，这笔交易所能获得利润 &#x3D; 4-1 &#x3D; 3 。</span><br></pre></td></tr></table></figure><br><strong>示例 2</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天(股票价格 &#x3D; 1)的时候买入，在第 5 天 (股票价格 &#x3D; 5)的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。   </span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   </span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure><br><strong>示例 3</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1] </span><br><span class="line">输出: 0 </span><br><span class="line">解释: 在这个情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure></p><hr><p>状态转移方程仍旧是以下，不用修改</p><script type="math/tex; mode=display">\begin{aligned}    bought[i][k] & = \max(bought[i - 1][k], sold[i - 1][k - 1] - price[i]) \\    sold[i][k] & = \max(sold[i - 1][k], bought[i - 1][k] + price[i]) \\\end{aligned}</script><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(prices)</span><br><span class="line"></span><br><span class="line">        K = <span class="number">2</span></span><br><span class="line">        <span class="comment"># 边界条件</span></span><br><span class="line">        bought = [[float(<span class="string">'-inf'</span>) <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span> + K)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        sold   = [[<span class="number">0</span> <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span> + K)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, K + <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 状态转移方程</span></span><br><span class="line">                bought[i][k] = max(</span><br><span class="line">                    <span class="comment"># 前一天第k次买入</span></span><br><span class="line">                    bought[i - <span class="number">1</span>][k],</span><br><span class="line">                    <span class="comment"># 前一天第k-1次卖出，这天第k次买入</span></span><br><span class="line">                    sold[i - <span class="number">1</span>][k - <span class="number">1</span>] - prices[i - <span class="number">1</span>]</span><br><span class="line">                )</span><br><span class="line">                sold[i][k] = max(</span><br><span class="line">                    <span class="comment"># 前一天第k次卖出</span></span><br><span class="line">                    sold[i - <span class="number">1</span>][k],</span><br><span class="line">                    <span class="comment"># 前一天第k次买入，这天第k次卖出</span></span><br><span class="line">                    bought[i - <span class="number">1</span>][k] + prices[i - <span class="number">1</span>]</span><br><span class="line">                )</span><br><span class="line">        <span class="keyword">return</span> sold[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>例如输入<code>K = 2, prices = [3,2,6,5,0,3]</code>，得到表格如下，左侧是$bought$，右侧是$sold$</p><div class="table-container"><table><thead><tr><th>prices \ k</th><th>0</th><th>1</th><th>2</th><th>prices \ k</th><th>0</th><th>1</th><th>2</th></tr></thead><tbody><tr><td>空</td><td>-inf</td><td>-inf</td><td><strong>-inf</strong></td><td>空</td><td>0</td><td>0</td><td>0</td></tr><tr><td>3</td><td>-inf</td><td>-3</td><td><strong>-3</strong></td><td>3</td><td>0</td><td>0</td><td>0</td></tr><tr><td>2</td><td>-inf</td><td>-2</td><td><strong>-2</strong></td><td>2</td><td>0</td><td>0</td><td>0</td></tr><tr><td>6</td><td>-inf</td><td>-2</td><td>-2</td><td>6</td><td>0</td><td>4</td><td><strong>4</strong></td></tr><tr><td>5</td><td>-inf</td><td>-2</td><td>-1</td><td>5</td><td>0</td><td>4</td><td><strong>4</strong></td></tr><tr><td>0</td><td>-inf</td><td>0</td><td><strong>4</strong></td><td>0</td><td>0</td><td>4</td><td>4</td></tr><tr><td>3</td><td>-inf</td><td>0</td><td>4</td><td>3</td><td>0</td><td>4</td><td><strong>7</strong></td></tr></tbody></table></div><p>表示在价格为$2$时买入，价格为$6$时卖出，再在价格为$0$时买入，价格为$3$时卖出。</p><h2 id="买卖股票的最佳时机-IV-多次交易"><a href="#买卖股票的最佳时机-IV-多次交易" class="headerlink" title="买卖股票的最佳时机 IV: 多次交易"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">买卖股票的最佳时机 IV: 多次交易</a></h2><p>给定一个数组，它的第$i$个元素是一支给定的股票在第$i$天的价格。<br>设计一个算法来计算你所能获取的最大利润。你最多可以完成$k$笔交易。<br>注意: 你不能同时参与多笔交易(你必须在再次购买前出售掉之前的股票)。</p><p><strong>示例 1</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,4,1], k &#x3D; 2</span><br><span class="line">输出: 2</span><br><span class="line">解释: 在第 1 天 (股票价格 &#x3D; 2) 的时候买入，在第 2 天 (股票价格 &#x3D; 4) 的时候卖出，这笔交易所能获得利润 &#x3D; 4-2 &#x3D; 2 。</span><br></pre></td></tr></table></figure><br><strong>示例 2</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,6,5,0,3], k &#x3D; 2</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天 (股票价格 &#x3D; 2) 的时候买入，在第 3 天 (股票价格 &#x3D; 6) 的时候卖出, 这笔交易所能获得利润 &#x3D; 6-2 &#x3D; 4 。</span><br><span class="line">     随后，在第 5 天 (股票价格 &#x3D; 0) 的时候买入，在第 6 天 (股票价格 &#x3D; 3) 的时候卖出, 这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。</span><br></pre></td></tr></table></figure></p><hr><p>如果输入的$K$特别大，会造成时间复杂度过高，Leetcode上通不过。实际上，一次买卖由买入、卖出组成，所以当$K \gt \lfloor n / 2 \rfloor$时相当于无穷多次交易，所以代码应该如下，时间复杂度$O(nk)$，空间复杂度$O(nk)$。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(prices)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 视作无穷多次</span></span><br><span class="line">        <span class="keyword">if</span> K &gt; n // <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> self.maxProfit_inf(prices)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 边界条件</span></span><br><span class="line">        bought = [[float(<span class="string">'-inf'</span>) <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span> + K)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        sold   = [[<span class="number">0</span> <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span> + K)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, K + <span class="number">1</span>):</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 状态转移方程</span></span><br><span class="line">                bought[i][k] = max(</span><br><span class="line">                    <span class="comment"># 前一天第k次买入</span></span><br><span class="line">                    bought[i - <span class="number">1</span>][k],</span><br><span class="line">                    <span class="comment"># 前一天第k-1次卖出，这天第k次买入</span></span><br><span class="line">                    sold[i - <span class="number">1</span>][k - <span class="number">1</span>] - prices[i - <span class="number">1</span>]</span><br><span class="line">                )</span><br><span class="line">                sold[i][k] = max(</span><br><span class="line">                    <span class="comment"># 前一天第k次卖出</span></span><br><span class="line">                    sold[i - <span class="number">1</span>][k],</span><br><span class="line">                    <span class="comment"># 前一天第k次买入，这天第k次卖出</span></span><br><span class="line">                    bought[i - <span class="number">1</span>][k] + prices[i - <span class="number">1</span>]</span><br><span class="line">                )</span><br><span class="line">        <span class="keyword">return</span> sold[<span class="number">-1</span>][<span class="number">-1</span>]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit_inf</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        ...     <span class="comment"># 同无穷多次交易</span></span><br></pre></td></tr></table></figure></p><p>例如输入<code>K = 2, prices = [3,2,6,5,0,3]</code>，得到表格如下，左侧是$bought$，右侧是$sold$</p><div class="table-container"><table><thead><tr><th>prices \ k</th><th>0</th><th>1</th><th>2</th><th>prices \ k</th><th>0</th><th>1</th><th>2</th></tr></thead><tbody><tr><td>空</td><td>-inf</td><td>-inf</td><td><strong>-inf</strong></td><td>空</td><td>0</td><td>0</td><td>0</td></tr><tr><td>3</td><td>-inf</td><td>-3</td><td><strong>-3</strong></td><td>3</td><td>0</td><td>0</td><td>0</td></tr><tr><td>2</td><td>-inf</td><td>-2</td><td><strong>-2</strong></td><td>2</td><td>0</td><td>0</td><td>0</td></tr><tr><td>6</td><td>-inf</td><td>-2</td><td>-2</td><td>6</td><td>0</td><td>4</td><td><strong>4</strong></td></tr><tr><td>5</td><td>-inf</td><td>-2</td><td>-1</td><td>5</td><td>0</td><td>4</td><td><strong>4</strong></td></tr><tr><td>0</td><td>-inf</td><td>0</td><td><strong>4</strong></td><td>0</td><td>0</td><td>4</td><td>4</td></tr><tr><td>3</td><td>-inf</td><td>0</td><td>4</td><td>3</td><td>0</td><td>4</td><td><strong>7</strong></td></tr></tbody></table></div><p>表示在价格为$2$时买入，价格为$6$时卖出，再在价格为$0$时买入，价格为$3$时卖出。</p><h2 id="买卖股票的最佳时机-V-含手续费"><a href="#买卖股票的最佳时机-V-含手续费" class="headerlink" title="买卖股票的最佳时机 V: 含手续费"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">买卖股票的最佳时机 V: 含手续费</a></h2><p>给定一个整数数组$prices$，其中第$i$个元素代表了第$i$天的股票价格 ；非负整数$fee$代表了交易股票的手续费用。你可以<strong>无限次</strong>地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。返回获得利润的最大值。<br>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><p><strong>示例 1</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: prices &#x3D; [1, 3, 2, 8, 4, 9], fee &#x3D; 2</span><br><span class="line">输出: 8</span><br><span class="line">解释: 能够达到的最大利润:  </span><br><span class="line">在此处买入 prices[0] &#x3D; 1</span><br><span class="line">在此处卖出 prices[3] &#x3D; 8</span><br><span class="line">在此处买入 prices[4] &#x3D; 4</span><br><span class="line">在此处卖出 prices[5] &#x3D; 9</span><br><span class="line">总利润: ((8 - 1) - 2) + ((9 - 4) - 2) &#x3D; 8.</span><br></pre></td></tr></table></figure><br><strong>注意</strong>:</p><ul><li>0 &lt; prices.length &lt;= 50000.</li><li>0 &lt; prices[i] &lt; 50000.</li><li>0 &lt;= fee &lt; 50000.</li></ul><hr><p>在卖出股票时，增加手续费，其余与<a href="#买卖股票的最佳时机-ii-无穷多次交易">买卖股票的最佳时机 II: 无穷多次交易</a>一致，即状态转移方程为</p><script type="math/tex; mode=display">\begin{aligned}    bought[i][k] & = \max(bought[i - 1][k], sold[i - 1][k - 1] - price[i]) \\    sold[i][k] & = \max(sold[i - 1][k], bought[i - 1][k] + price[i] - fee) \\\end{aligned}</script><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int], fee: int)</span> -&gt; int:</span></span><br><span class="line">        n = len(prices)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 边界条件</span></span><br><span class="line">        bought = [float(<span class="string">'-inf'</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        sold   = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 状态转移方程</span></span><br><span class="line">            bought[i] = max(</span><br><span class="line">                <span class="comment"># 前一天买入</span></span><br><span class="line">                bought[i - <span class="number">1</span>],</span><br><span class="line">                <span class="comment"># 前一天卖出，这天买入</span></span><br><span class="line">                sold[i - <span class="number">1</span>] - prices[i - <span class="number">1</span>]</span><br><span class="line">            )</span><br><span class="line">            sold[i] = max(</span><br><span class="line">                <span class="comment"># 前一天卖出</span></span><br><span class="line">                sold[i - <span class="number">1</span>],</span><br><span class="line">                <span class="comment"># 前一天买入，这天卖出</span></span><br><span class="line">                bought[i - <span class="number">1</span>] + prices[i - <span class="number">1</span>] - fee</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">return</span> sold[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="买卖股票的最佳时机-VI-含冷冻期"><a href="#买卖股票的最佳时机-VI-含冷冻期" class="headerlink" title="买卖股票的最佳时机 VI: 含冷冻期"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">买卖股票的最佳时机 VI: 含冷冻期</a></h2><p>给定一个整数数组，其中第$i$个元素代表了第$i$天的股票价格 。​设计一个算法计算出最大利润。在满足以下约束条件下，你可以<strong>尽可能地完成更多的交易</strong>(多次买卖一支股票):</p><ul><li>你不能同时参与多笔交易(你必须在再次购买前出售掉之前的股票)。</li><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><p><strong>示例</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,0,2]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></pre></td></tr></table></figure></p><hr><p>唯一的区别是买入的状态转移方程需要修改</p><ul><li>第$i$天决定是否以$k$次买入时，手头是没有股票的，这种状态可以由以下两种情况转移而来<ul><li>第$(i - 1)$天没有持有股票</li><li><strong>第$(i - 2)$天在第$(k - 1)$次交易中卖出</strong>，注意边界条件$i=1$时，前面不可能有卖出操作，所以这里注意<strong>边界条件</strong></li></ul></li><li>第$i$天决定是否以$k$次卖出时，手头是有股票的，这种状态可以由以下两种情况转移而来<ul><li>第$(i - 1)$天持有股票</li><li>第$(i - 1)$天在第$k$次交易中买入</li></ul></li></ul><script type="math/tex; mode=display">\begin{aligned}    bought[i][k] & = \begin{cases}        \max(bought[i - 1][k], 0 - price[i]) & i = 1 \\        \max(bought[i - 1][k], sold[i - 2][k - 1] - price[i]) & i > 1    \end{cases} \\    sold[i][k] & = \max(sold[i - 1][k], bought[i - 1][k] + price[i]) \\\end{aligned}</script><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(prices)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 边界条件</span></span><br><span class="line">        bought = [float(<span class="string">'-inf'</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        sold   = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 状态转移方程</span></span><br><span class="line">            bought[i] = max(</span><br><span class="line">                <span class="comment"># 前一天买入</span></span><br><span class="line">                bought[i - <span class="number">1</span>],</span><br><span class="line">                <span class="comment"># 前一天卖出，这天买入</span></span><br><span class="line">                (sold[i - <span class="number">2</span>] <span class="keyword">if</span> i &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span>) - prices[i - <span class="number">1</span>]</span><br><span class="line">            )</span><br><span class="line">            sold[i] = max(</span><br><span class="line">                <span class="comment"># 前一天卖出</span></span><br><span class="line">                sold[i - <span class="number">1</span>],</span><br><span class="line">                <span class="comment"># 前一天买入，这天卖出</span></span><br><span class="line">                bought[i - <span class="number">1</span>] + prices[i - <span class="number">1</span>]</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">return</span> sold[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1 id="二叉树最大路径和"><a href="#二叉树最大路径和" class="headerlink" title="二叉树最大路径和"></a><a href="https://www.lintcode.com/problem/binary-tree-maximum-path-sum/description?_from=ladder&amp;&amp;fromId=131" target="_blank" rel="noopener">二叉树最大路径和</a></h1><p>给出一棵二叉树，寻找一条路径使其路径和最大，路径可以在任一节点中开始和结束(路径和为两个节点之间所在路径上的节点权值之和)</p><p><strong>样例 1</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入:  给定一棵树(只有一个节点):</span><br><span class="line">2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><br><strong>样例 2</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:  给定一棵树：</span><br><span class="line"></span><br><span class="line">      1</span><br><span class="line">     &#x2F; \</span><br><span class="line">    2   3</span><br><span class="line"></span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure></p><p><strong>该题的一个关键是，确定二叉树路径和的求法</strong></p><ul><li><strong>路径和为两个节点之间所在路径上的节点权值之和</strong>，也就是以任意节点为根，向左右子节点拓展的“八”字形树；</li><li>某节点的“八字形”路径和，应该由<strong>节点值、左子孩的最大单边路径和、右子孩的最大单边路径和</strong>得到；</li><li><strong>如果子孩的最大单边路径和小于$0$，不能计入加和</strong>，因为加入后反而使路径和变小。</li></ul><ol><li><strong>子问题</strong>：以<code>root</code>节点为根节点的树中最大路径和，由其左右子孩<code>root.left</code>、<code>root.right</code>的单边最大路径和加上<code>root</code>节点自身的值求得，每个节点均是如此，也就是子问题；</li><li><strong>状态和状态变量</strong>：以节点的<strong>最大单边路径</strong>(max leaf path sum, mlps)作为状态</li><li><strong>状态转移方程</strong>：<script type="math/tex; mode=display">mlps_r = \max(mlps_{r.l}, mlps_{r.r}) + val_r</script></li></ol><hr><p>以下的解法中</p><ul><li><code>maxPathSumCore</code>直接返回以参数节点<code>root</code>为根节点的“八”字形路径和；</li><li>在判断语句<code>if root.left</code>、<code>if root.right</code>两个判断前初始化了变量<code>path</code>，并在两个判断块内累加<code>path</code>变量，用于计算最大路径；</li><li>其中<code>spL</code>、<code>spR</code>为左右子孩的最大单边路径和，并更新<code>root.sp</code>，注意该变量是不包含该节点自身的值<code>root.val</code>的。</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Definition of TreeNode:</span></span><br><span class="line"><span class="string">class TreeNode:</span></span><br><span class="line"><span class="string">    def __init__(self, val):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left, self.right = None, None</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param root: The root of binary tree.</span></span><br><span class="line"><span class="string">    @return: An integer</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPathSum</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> self.maxPathSumCore(root, float(<span class="string">'-inf'</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPathSumCore</span><span class="params">(self, root, maxPath)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        - 后序遍历；</span></span><br><span class="line"><span class="string">        - 求每个节点到所有叶子节点的路径中，最大的路径和；</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>: </span><br><span class="line">            <span class="keyword">return</span> maxPath</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 没有子树</span></span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">and</span> root.right <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            root.sp = <span class="number">0</span></span><br><span class="line">            maxPath = max(maxPath, root.val)</span><br><span class="line">            <span class="keyword">return</span> maxPath</span><br><span class="line">    </span><br><span class="line">        root.sp = float(<span class="string">'-inf'</span>)</span><br><span class="line">        path = root.val</span><br><span class="line">        <span class="comment"># 有左子树</span></span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            <span class="comment"># 前序遍历</span></span><br><span class="line">            maxPath = self.maxPathSumCore(root.left, maxPath)</span><br><span class="line">            <span class="comment"># 计算单边，用于1和2</span></span><br><span class="line">            spL = max(<span class="number">0</span>, root.left.sp + root.left.val)</span><br><span class="line">            <span class="comment"># 1. 更新最大单边路径和</span></span><br><span class="line">            root.sp = max(root.sp, spL)</span><br><span class="line">            <span class="comment"># 2. 累加path</span></span><br><span class="line">            path += spL</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 有右子树，流程同上</span></span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            maxPath = self.maxPathSumCore(root.right, maxPath)</span><br><span class="line">            spR = max(<span class="number">0</span>, root.right.sp + root.right.val)</span><br><span class="line">            root.sp = max(root.sp, spR)</span><br><span class="line">            path += spR</span><br><span class="line">          </span><br><span class="line">        <span class="comment"># 更新最大路径和</span></span><br><span class="line">        <span class="keyword">return</span> max(maxPath, path)</span><br></pre></td></tr></table></figure><hr><p>上面的解法需要对节点添加变量<code>sp</code>，一种更好的解法如下</p><ul><li><code>maxLeafPathSum</code>返回的是节点<code>root</code>最大的单边路径和(已包括节点的值)；</li><li>在函数<code>maxLeafPathSum</code>内直接修改<code>mlps</code>，借助列表作为变量的引用，可直接修改；</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Definition of TreeNode:</span></span><br><span class="line"><span class="string">class TreeNode:</span></span><br><span class="line"><span class="string">    def __init__(self, val):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left, self.right = None, None</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param root: The root of binary tree.</span></span><br><span class="line"><span class="string">    @return: An integer</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPathSum</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ret = [float(<span class="string">'-inf'</span>)]</span><br><span class="line">        _ = self.maxLeafPathSum(root, ret)</span><br><span class="line">        <span class="keyword">return</span> ret[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxLeafPathSum</span><span class="params">(self, root, mlps)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 左子孩最大单边，必须大于等于0，否则加入后反而使和减小</span></span><br><span class="line">        lpsL = max(<span class="number">0</span>, self.maxLeafPathSum(root.left, mlps))</span><br><span class="line">        <span class="comment"># 右子孩最大单边，必须大于等于0，否则加入后反而使和减小</span></span><br><span class="line">        lpsR = max(<span class="number">0</span>, self.maxLeafPathSum(root.right, mlps))</span><br><span class="line">        <span class="comment"># 求最大路径和</span></span><br><span class="line">        mlps[<span class="number">0</span>] = max(mlps[<span class="number">0</span>], lpsL + lpsR + root.val)</span><br><span class="line">        <span class="comment"># 状态转移方程，返回最大单边</span></span><br><span class="line">        <span class="keyword">return</span> max(lpsL, lpsR) + root.val</span><br></pre></td></tr></table></figure><h1 id="网格中左上向右下的最小路径和"><a href="#网格中左上向右下的最小路径和" class="headerlink" title="网格中左上向右下的最小路径和"></a><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">网格中左上向右下的最小路径和</a></h1><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。<br><strong>说明</strong>：<br>每次只能向下或者向右移动一步。<br><strong>示例</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure></p><hr><ol><li><strong>子问题</strong>：终点可以从终点的左侧或上方过来，需要选择这两条路径中数字和最小的路径，那么就要求解到达终点左侧或上方的网格的数字和最小路径，所以子问题是求解到达任意网格数字和最小的路径。</li><li><strong>状态和状态变量</strong>：定义二维数组$dp$，元素$dp[i][j]$表示到达第$i$行第$j$列网格的最小数字和。</li><li><strong>状态转移方程</strong>：<br> 注意在第一行和第一列时，只能由一条路径通过，所以这两种情况需要特殊处理<script type="math/tex; mode=display"> dp[i][j] = \begin{cases}     nums[j] & i = 0 且 j = 0 \\     dp[i][j - 1] + nums[j] & i = 0 \\     dp[i - 1][j] + nums[j] & j = 0 \\     \min(dp[i][j - 1], dp[i - 1][j]) + nums[j] & \text{otherwise} \end{cases}</script></li><li><strong>注意边界条件</strong>：<script type="math/tex; mode=display">dp[i][-1] = dp[-1][j] = 0</script></li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        m = len(grid)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dp = grid.copy()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="comment"># 起点，已赋值</span></span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> j == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 第一行，只能从左边向右一步</span></span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>] + grid[i][j]</span><br><span class="line">                <span class="comment"># 第一列，只能从上方向下一步</span></span><br><span class="line">                <span class="keyword">elif</span> j == <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + grid[i][j]</span><br><span class="line">                <span class="comment"># 选择从上向下一步，或从左向右一步</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = min(</span><br><span class="line">                        dp[i - <span class="number">1</span>][j], </span><br><span class="line">                        dp[i][j - <span class="number">1</span>]</span><br><span class="line">                    ) + grid[i][j]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1 id="Floyd最短路径算法"><a href="#Floyd最短路径算法" class="headerlink" title="Floyd最短路径算法"></a>Floyd最短路径算法</h1><p>给定图$G(V, E)$的邻接矩阵$W$，其中不存在的路径权重设置为$\infty$，<strong>求两两节点间的最短路径</strong>。</p><ol><li><strong>子问题</strong>：两两间的最短路径，可以经过最多$n$次中转得到</li><li><strong>状态和状态变量</strong>：递推产生一个矩阵序列$A_1, \cdots, A_k, \cdots, A_n$，其中矩阵$A_k$的第$i$行第$j$列元素$A_k(i, j)$表示<strong>从顶点$v_i$到顶点$v_j$的路径上所经过的顶点个数不大于$k$的最短路径长度</strong>。</li><li><p><strong>状态转移方程</strong>：Floyd算法的思路是这样的，节点$v_i$到顶点$v_j$最多可以经过$n$个节点的中转。在求节点$v_i$到节点$v_j$最多$k$次中转的最短路径$A_k(i, j)$时，已经求得最多$(k - 1)$次中转的最短路径$A_{k - 1}(i, :)$和$A_{k - 1}(:, j)$，那么再经过节点$v_t$中转的路径是$A_{k-1}(i, t) + A_{k-1}(t, j)$，要从中选择最短的路径$A_{k-1}(i, t^{<em>}) + A_{k-1}(t^{</em>}, j)$，当然也可以选择不中转，所以再将$A_{k-1}(i, t^{<em>}) + A_{k-1}(t^{</em>}, j)$与$A_{k-1}(i, j)$比较选择最短路径，具体的状态转移方程是</p><script type="math/tex; mode=display"> A_k(i, j) = \min \{ A_{k-1}(i, j), \quad A_{k-1}(i, t) + A_{k-1}(t, j) \}, \quad k \gt 1, \quad t = 1, \cdots, n</script></li><li><p><strong>边界条件</strong>：应该有</p><script type="math/tex; mode=display">A_1 = W</script></li></ol><p>时间和空间复杂度都是$O(n^3)$，考虑到第$k$次仅与第$(k - 1)$次有关，优化后使空间复杂度降低至$O(n^2)$，具体代码如下<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param W: List&#123;List&#123;int&#125;&#125;</span></span><br><span class="line"><span class="string">    @return A: List&#123;List&#123;int&#125;&#125;</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">floyd</span><span class="params">(self, W)</span>:</span></span><br><span class="line">        <span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">        n = len(W)</span><br><span class="line">        <span class="comment"># 最多n次中转</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="comment"># 边界条件</span></span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">                A = copy.deepcopy(W)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 状态转移方程</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                    <span class="comment"># 不中转，A_&#123;k&#125;[i][j] = A_&#123;k - 1&#125;[i][j]</span></span><br><span class="line">                    min_dist = A[i][j]</span><br><span class="line">                    <span class="comment"># 经过v_t中转，A_&#123;k - 1&#125;[i][t] + A_&#123;k - 1&#125;[t][j]</span></span><br><span class="line">                    <span class="keyword">for</span> t <span class="keyword">in</span> range(n):</span><br><span class="line">                        min_dist = min(</span><br><span class="line">                            min_dist,</span><br><span class="line">                            A[i][t] + A[t][j]</span><br><span class="line">                        )</span><br><span class="line">                    <span class="comment"># 更新A_&#123;k&#125;[i][j]</span></span><br><span class="line">                    A[i][j] = min_dist</span><br><span class="line">        <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure></p><p>输入邻接矩阵$W$如下，得到矩阵序列</p><script type="math/tex; mode=display">W = \left[\begin{matrix}    0      & 2      & 4      & \infty & \infty & \infty & \infty \\    2      & 0      & \infty & 3      & 3      & 1      & \infty \\    4      & \infty & 0      & 2      & 3      & 1      & \infty \\    \infty & 3      & 2      & 0      & \infty & \infty & 1      \\    \infty & 3      & 3      & \infty & 0      & \infty & 3      \\    \infty & 1      & 1      & \infty & \infty & 0      & 4      \\    \infty & \infty & \infty & 1      & 3      & 4      & 0      \end{matrix}\right]</script><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">A1</span><br><span class="line">[[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, inf, inf, inf, inf],</span><br><span class="line"> [<span class="number">2</span>, <span class="number">0</span>, inf, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, inf],    </span><br><span class="line"> [<span class="number">4</span>, inf, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, inf],    </span><br><span class="line"> [inf, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, inf, inf, <span class="number">1</span>],  </span><br><span class="line"> [inf, <span class="number">3</span>, <span class="number">3</span>, inf, <span class="number">0</span>, inf, <span class="number">3</span>],  </span><br><span class="line"> [inf, <span class="number">1</span>, <span class="number">1</span>, inf, inf, <span class="number">0</span>, <span class="number">4</span>],  </span><br><span class="line"> [inf, inf, inf, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>]]  </span><br><span class="line"></span><br><span class="line">A2</span><br><span class="line">[[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>],        </span><br><span class="line"> [<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>],        </span><br><span class="line"> [<span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>],        </span><br><span class="line"> [<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>],        </span><br><span class="line"> [<span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>],        </span><br><span class="line"> [<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>],        </span><br><span class="line"> [<span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>]]        </span><br><span class="line"></span><br><span class="line">A3</span><br><span class="line">[[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>],</span><br><span class="line"> [<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>],</span><br><span class="line"> [<span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line"> [<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line"> [<span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>],</span><br><span class="line"> [<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>],</span><br><span class="line"> [<span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">A4</span><br><span class="line">[[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>],</span><br><span class="line"> [<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>],</span><br><span class="line"> [<span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line"> [<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line"> [<span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>],</span><br><span class="line"> [<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>],</span><br><span class="line"> [<span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">A5</span><br><span class="line">[[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>],</span><br><span class="line"> [<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>],</span><br><span class="line"> [<span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line"> [<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line"> [<span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>],</span><br><span class="line"> [<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>],</span><br><span class="line"> [<span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">A6</span><br><span class="line">[[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>],</span><br><span class="line"> [<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>],</span><br><span class="line"> [<span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line"> [<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line"> [<span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>],</span><br><span class="line"> [<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>],</span><br><span class="line"> [<span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">A7</span><br><span class="line">[[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>],</span><br><span class="line"> [<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>],</span><br><span class="line"> [<span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line"> [<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line"> [<span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>],</span><br><span class="line"> [<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>],</span><br><span class="line"> [<span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>]]</span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://labuladong.github.io/ebook/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/" target="_blank" rel="noopener">动态规划系列 - labuladong的算法小抄</a></li><li><a href="https://my.oschina.net/u/4007037/blog/3165715" target="_blank" rel="noopener">干货：图解算法——动态规划系列 - OSCHINA</a></li><li><a href="https://github.com/tianyicui/pack" target="_blank" rel="noopener">背包9讲 - Github</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【算法】Huffman Coding</title>
      <link href="/2020/06/16/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91Huffman-Coding/"/>
      <url>/2020/06/16/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91Huffman-Coding/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#目录">目录</a></li><li><a href="#文本等长编码">文本等长编码</a></li><li><a href="#霍夫曼编码与霍夫曼树">霍夫曼编码与霍夫曼树</a><ul><li><a href="#原理">原理</a></li><li><a href="#构建">构建</a></li><li><a href="#实现">实现</a></li></ul></li><li><a href="#reference">Reference</a></li></ul><h1 id="文本等长编码"><a href="#文本等长编码" class="headerlink" title="文本等长编码"></a>文本等长编码</h1><p>某文本内容如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">This is my prayer to thee, my lord</span><br><span class="line">strike, strike at the root of penury in my heart.</span><br><span class="line">Give me the strength lightly to bear my joys and sorrows.</span><br><span class="line">Give me the strength to make my love fruitful in service.</span><br><span class="line">Give me the strength never to disown the poor or bend my knees before insolent might.</span><br><span class="line">Give me the strength to raise my mind high above daily trifles.</span><br><span class="line">And give me the strength to surrender my strength to thy will with love.</span><br></pre></td></tr></table></figure></p><blockquote><p>主，这是我对你的祈求 ——<br>请你铲除，铲除我心中贫乏的根源。<br>赐我力量，让我从容承受欢乐和悲伤。<br>赐我力量，让我的爱在服务中丰收。<br>赐我力量，让我永不抛弃贫贱也永不向强权屈膝。<br>赐我力量，让我的心灵超脱日常琐事。<br>再赐我力量，让我的力量满怀爱意遵从你的意志。<br>—— 节选自泰戈尔《吉檀迦利》</p></blockquote><p>各字符的统计频数如下</p><div class="table-container"><table><thead><tr><th>字符</th><th><code>\n</code></th><th><code>T</code></th><th><code>h</code></th><th><code>i</code></th><th><code>s</code></th><th><code> </code></th><th><code>m</code></th><th><code>y</code></th><th><code>p</code></th><th><code>r</code></th><th><code>a</code></th><th><code>e</code></th><th><code>t</code></th><th><code>o</code></th><th><code>,</code></th><th><code>l</code></th><th><code>d</code></th><th><code>k</code></th><th><code>f</code></th><th><code>n</code></th><th><code>u</code></th><th><code>.</code></th><th><code>G</code></th><th><code>v</code></th><th><code>g</code></th><th><code>b</code></th><th><code>j</code></th><th><code>w</code></th><th><code>c</code></th><th><code>A</code></th><th>合计</th></tr></thead><tbody><tr><td>频数</td><td>8</td><td>1</td><td>22</td><td>24</td><td>20</td><td>75</td><td>16</td><td>14</td><td>3</td><td>28</td><td>9</td><td>49</td><td>39</td><td>23</td><td>2</td><td>11</td><td>8</td><td>4</td><td>5</td><td>19</td><td>4</td><td>6</td><td>4</td><td>10</td><td>10</td><td>4</td><td>1</td><td>4</td><td>1</td><td>1</td><td>425</td></tr></tbody></table></div><p>共$30$个字符，如果用<strong>二进制等长编码</strong>对这些字符进行编码，每个字符最少需要$\lceil \log_2 31 \rceil = 5(bit)$，那么整个文本至少需要$425 \times 5 / 8 = 265.625(B)$的空间用于存储，即</p><div class="table-container"><table><thead><tr><th>字符</th><th><code>\n</code></th><th><code>T</code></th><th><code>h</code></th><th><code>i</code></th><th>…</th></tr></thead><tbody><tr><td>编码</td><td>00000</td><td>00001</td><td>00010</td><td>00011</td><td>…</td></tr></tbody></table></div><h1 id="霍夫曼编码与霍夫曼树"><a href="#霍夫曼编码与霍夫曼树" class="headerlink" title="霍夫曼编码与霍夫曼树"></a>霍夫曼编码与霍夫曼树</h1><p><strong>霍夫曼编码</strong>(Huffman Coding)是一种<strong>可变长编码</strong>(VLC)，作用是根据使用频率来最大化节省字符(编码)的存储空间，完全依据字符出现概率来构造异字头的平均长度最短的码字，有时称作<strong>最佳编码</strong>。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>先介绍一些术语</p><ul><li><strong>路径</strong>：在一棵树中，一个结点到另一个结点之间的通路，称为路径；</li><li><strong>路径长度</strong>：在一条路径中，每经过一个结点，路径长度都要加$1$；</li><li><strong>结点的权</strong>：给每一个结点赋予一个新的数值，被称为这个结点的权；</li><li><strong>结点的带权路径长度</strong>：指的是从根结点到该结点之间的路径长度与该结点的权的乘积；</li><li><strong>树的带权路径长度(WPL)</strong>：树中所有叶子结点的带权路径长度之和，即<script type="math/tex; mode=display">WPL = \sum_{i=1}^n w_i \times l_i</script></li></ul><p><strong>当用$n$个结点(都做叶子结点且都有各自的权值)</strong>试图构建一棵二叉树时，如果构建的这棵树的带权路径长度最小，称这棵树为<strong>最优二叉树</strong>，有时也叫<strong>霍夫曼树</strong>(Huffman Tree)。</p><p>霍夫曼编码的有两个重要的<strong>思想</strong></p><ol><li><strong>任何一个字符编码，都不是其他字符编码的前缀</strong>：每个字符对应于树中的<strong>叶子节点</strong>，且每个节点赋予权值$w_i$；</li><li>信息编码的总长度最小：树的带权路径长度最小。</li></ol><p><strong>在编码时，叶子节点的权值定义为字符的出现频率。</strong></p><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p><strong>霍夫曼树的构建基于贪心法</strong>，具体步骤如下</p><ol><li>初始化各叶子节点，每个节点包含代表字符及其权重；</li><li>从剩余节点中选取权重最小的两个节点，置为新节点的子节点，新节点的权值为两个子节点的权重和；</li><li>将上个步骤中的两个子节点从待选节点中删除，将新节点加入；</li><li>重复2-3步骤，直至只剩余根节点，那么霍夫曼树构建完毕。</li></ol><p>注意霍夫曼树某节点左右子树顺序无固定要求，所以<strong>最终生成的树不唯一</strong>。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> nlargest</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter, deque</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuffmanTreeNode</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, weight, char=None)</span>:</span></span><br><span class="line">        <span class="comment"># 左右子树</span></span><br><span class="line">        self.left = <span class="keyword">None</span></span><br><span class="line">        self.right = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 属性</span></span><br><span class="line">        self.weight = weight    <span class="comment"># 权重</span></span><br><span class="line">        self.char = char        <span class="comment"># 代表字符</span></span><br><span class="line">        self.code = <span class="keyword">None</span>        <span class="comment"># 节点编码，用字符串表示</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isLeaf</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.left <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">and</span> self.right <span class="keyword">is</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuffmanTree</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.root = <span class="keyword">None</span></span><br><span class="line">        self.table = <span class="keyword">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_build</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        <span class="string">""" 构建霍夫曼树</span></span><br><span class="line"><span class="string">        Parameters:</span></span><br><span class="line"><span class="string">            text: &#123;str&#125;</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            node: &#123;HuffmanTreeNode&#125;</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 统计字符数</span></span><br><span class="line">        counter = Counter(text)</span><br><span class="line">        <span class="comment"># 初始化节点，这里进行了一次排序使树结构尽量稳定</span></span><br><span class="line">        kvps = sorted(counter.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">        nodes = [HuffmanTreeNode(n / sum(counter.values()), c) \</span><br><span class="line">                <span class="keyword">for</span> c, n <span class="keyword">in</span> kvps]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 循环构建树</span></span><br><span class="line">        <span class="keyword">while</span> len(nodes) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 选择权重最小的两个节点</span></span><br><span class="line">            left, right = nlargest(<span class="number">2</span>, nodes, key=<span class="keyword">lambda</span> x: - x.weight)</span><br><span class="line">            <span class="comment"># 新建节点</span></span><br><span class="line">            weight = left.weight + right.weight</span><br><span class="line">            node = HuffmanTreeNode(weight)</span><br><span class="line">            node.left, node.right = left, right</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 移除节点</span></span><br><span class="line">            nodes.remove(left)</span><br><span class="line">            nodes.remove(right)</span><br><span class="line">            <span class="comment"># 加入节点</span></span><br><span class="line">            nodes += [node]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nodes[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_table</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">""" 获取编码列表</span></span><br><span class="line"><span class="string">        Parameters:</span></span><br><span class="line"><span class="string">            root: &#123;HuffmanTreeNode&#125;</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            table</span></span><br><span class="line"><span class="string">        Notes:</span></span><br><span class="line"><span class="string">            层次遍历(BFS)得到各字符的表示</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 初始化队列</span></span><br><span class="line">        q = deque()</span><br><span class="line">        self.root.code = <span class="string">''</span></span><br><span class="line">        q.extend([self.root])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># bfs</span></span><br><span class="line">        table = dict()</span><br><span class="line">        <span class="keyword">while</span> len(q) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 队首元素</span></span><br><span class="line">            node = q.popleft()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 叶子节点</span></span><br><span class="line">            <span class="keyword">if</span> node.isLeaf():</span><br><span class="line">                table[node.char] = node.code</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 非叶子节点</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                node.left.code = node.code + <span class="string">'0'</span></span><br><span class="line">                q.extend([node.left])</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                node.right.code = node.code + <span class="string">'1'</span></span><br><span class="line">                q.extend([node.right])</span><br><span class="line">        <span class="keyword">return</span> table</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Parameters:</span></span><br><span class="line"><span class="string">            text: &#123;str&#125;</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.root = self._build(text)</span><br><span class="line">        self.table = self._table(self.root)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">encode</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Parameters:</span></span><br><span class="line"><span class="string">            text: &#123;str&#125;</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            encoded: &#123;int&#125;</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        encoded = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, char <span class="keyword">in</span> enumerate(text):</span><br><span class="line">            <span class="comment"># 查询编码</span></span><br><span class="line">            code = self.table[char]</span><br><span class="line">            <span class="comment"># 每一位加入编码</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> code:</span><br><span class="line">                encoded = (encoded &lt;&lt; <span class="number">1</span>) + int(c)</span><br><span class="line">        <span class="keyword">return</span> encoded</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decode</span><span class="params">(self, encoded)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Parameters:</span></span><br><span class="line"><span class="string">            encoded: &#123;int&#125;</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            text: &#123;str&#125;</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        text = <span class="string">''</span></span><br><span class="line">        encoded = bin(encoded)</span><br><span class="line">        node = self.root</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(encoded[<span class="number">2</span>:]):</span><br><span class="line">            <span class="comment"># 向子树游走</span></span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">'0'</span>:</span><br><span class="line">                node = node.left</span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">'1'</span>:</span><br><span class="line">                node = node.right</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 查找到叶子节点，从根节点重新开始</span></span><br><span class="line">            <span class="keyword">if</span> node.isLeaf():</span><br><span class="line">                text += node.char</span><br><span class="line">                node = self.root</span><br><span class="line">        <span class="keyword">return</span> text</span><br></pre></td></tr></table></figure><p>调用方法如下，有以下结论</p><ul><li>编码后共占$224.25(B)$，用等长编码(5 bit)所占空间为$265.625(B)$；</li><li>不存在某字符的编码是另一个字符的编码前缀，造成解码错误，如<code>&#39;n&#39;</code>编码为<code>0b11010</code>，不存在字符编码是<code>0b11010xxxx</code>；</li><li>出现次数越多的字符编码越短，如<code>&#39;t&#39;</code>和<code>&#39;e&#39;</code>编码后只有3位。</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">poem = \</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">This is my prayer to thee, my lord</span></span><br><span class="line"><span class="string">strike, strike at the root of penury in my heart.</span></span><br><span class="line"><span class="string">Give me the strength lightly to bear my joys and sorrows.</span></span><br><span class="line"><span class="string">Give me the strength to make my love fruitful in service.</span></span><br><span class="line"><span class="string">Give me the strength never to disown the poor or bend my knees before insolent might.</span></span><br><span class="line"><span class="string">Give me the strength to raise my mind high above daily trifles.</span></span><br><span class="line"><span class="string">And give me the strength to surrender my strength to thy will with love.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建</span></span><br><span class="line">tree = HuffmanTree()</span><br><span class="line">tree.build(poem)</span><br><span class="line">print(tree.table)</span><br><span class="line"><span class="comment"># &#123;'t': '000', 'e': '011', ' ': '111', 's': '0010', 'h': '0100', 'o': '0101', 'i': '1000', 'r': '1010', 'v': '00110', 'l': </span></span><br><span class="line"><span class="comment"># '10010', 'y': '10011', 'm': '10111', 'n': '11010', 'f': '001110', '.': '101100', '\n': '101101', 'd': '110000', 'a': '110110', 'g': '110111', 'p': '0011111', 'G': '1100010', 'b': '1100011', 'k': '1100100', 'u': '1100101', 'w': '1100110', 'c': '00111100', 'j': '00111101', ',': '11001110', 'A': '110011110', 'T': '110011111'&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编码</span></span><br><span class="line">encoded = tree.encode(poem)</span><br><span class="line">strEncoded = bin(encoded)</span><br><span class="line">print(strEncoded)</span><br><span class="line">print((len(strEncoded) - <span class="number">2</span>) / <span class="number">8</span>, <span class="string">"Bytes"</span>)</span><br><span class="line"><span class="comment"># 0b101101110011111010010000010111100000101111011110011111001111110101101101001101110101110000101111000010001101111001110111101111001111110010010110101100001011010010000101010001100100011110011101110010000101010001100100011111110110000111000010001111110100101010100011101010011101110011111011110101100101101010011111100011010111101111001111101000111101101010000101100101101110001010000011001111110111011111000010001111100100001010011110101101110000100111100101000110111010000010010100111110000101111110001101111011010101111011110011111001111010101100110010111110110110101100001110010010110101010010111001100010101100101101110001010000011001111110111011111000010001111100100001010011110101101110000100111000010111110111110110110010001111110111100111111001001010011001111100111010101100101100000000111011001011001011110001101011100100111010001101000001111000111011001011011100010100000110011111101110111110000100011111001000010100111101011011100001001111101001100110011101011100001011111100001000001001011100110110101110000100011111001111101010101101011101011010111110001101111010110000111101111001111111001001101001101100101111100011011001110010110100111111000110100010010110010011110100001111011110001101110100000101100101101110001010000011001111110111011111000010001111100100001010011110101101110000100111000010111110101101101000001001111110111100111111011110001101011000011101001000110111010011111011011000110101001100111111100001101101000100101001111100010101000001110100100110010101100101101110011110110101100001111101111000001100111111011101111100001000111110010000101001111010110111000010011100001011110010110010110101010011110101100000111010111101111001111100100001010011110101101110000100111000010111100001001001111111001101000100101001011111001101000000010011110010010100110011101100101101</span></span><br><span class="line"><span class="comment"># 224.25 Bytes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解码</span></span><br><span class="line">decoded = tree.decode(encoded)</span><br><span class="line">print(decoded)</span><br><span class="line"><span class="comment"># This is my prayer to thee, my lord</span></span><br><span class="line"><span class="comment"># strike, strike at the root of penury in my heart.</span></span><br><span class="line"><span class="comment"># Give me the strength lightly to bear my joys and sorrows.</span></span><br><span class="line"><span class="comment"># Give me the strength to make my love fruitful in service.</span></span><br><span class="line"><span class="comment"># Give me the strength never to disown the poor or bend my knees before insolent might.</span></span><br><span class="line"><span class="comment"># Give me the strength to raise my mind high above daily trifles.</span></span><br><span class="line"><span class="comment"># And give me the strength to surrender my strength to thy will with love.</span></span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/67855882" target="_blank" rel="noopener">哈夫曼编码 - 知乎</a></li><li><a href="https://blog.csdn.net/weixin_42104573/article/details/80445630" target="_blank" rel="noopener">哈夫曼编码 - CSDN</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Graph Neural Network</title>
      <link href="/2020/06/13/Graph-Neural-Network/"/>
      <url>/2020/06/13/Graph-Neural-Network/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>《深入浅出图神经网络》阅读笔记，这本书非常OK，看着没多少字，都是干货，比什么《xxx从入门到精通》类的书好太多。</p><ul><li><a href="#目录">目录</a></li><li><a href="#图卷积神经网络gcn">图卷积神经网络(GCN)</a><ul><li><a href="#图信号">图信号</a></li><li><a href="#拉普拉斯算子">拉普拉斯算子</a></li><li><a href="#图傅里叶变换">图傅里叶变换</a><ul><li><a href="#gft与igft">GFT与IGFT</a></li><li><a href="#总变差tv">总变差(TV)</a></li><li><a href="#图信号的频域描述">图信号的频域描述</a></li></ul></li><li><a href="#图滤波器">图滤波器</a><ul><li><a href="#定义">定义</a></li><li><a href="#拉普拉斯矩阵多项式拓展形式">拉普拉斯矩阵多项式拓展形式</a></li><li><a href="#空域角度">空域角度</a></li><li><a href="#频域角度">频域角度</a></li></ul></li><li><a href="#图卷积的定义">图卷积的定义</a></li><li><a href="#滤波器的参数化">滤波器的参数化</a><ul><li><a href="#频域图卷积模型">频域图卷积模型</a><ul><li><a href="#频率响应函数的参数化">频率响应函数的参数化</a></li><li><a href="#拉普拉斯矩阵多项式拓展形式系数的参数化">拉普拉斯矩阵多项式拓展形式系数的参数化</a></li></ul></li><li><a href="#空域图卷积模型">空域图卷积模型</a><ul><li><a href="#固定滤波器的参数化">固定滤波器的参数化</a></li></ul></li></ul></li></ul></li><li><a href="#gcn的性质">GCN的性质</a><ul><li><a href="#gcn与cnn联系">GCN与CNN联系</a></li><li><a href="#端到端学习">端到端学习</a></li><li><a href="#低通滤波器">低通滤波器</a></li><li><a href="#过平滑问题">过平滑问题</a><ul><li><a href="#频域视角">频域视角</a></li><li><a href="#空域视角">空域视角</a></li><li><a href="#解决方法">解决方法</a><ul><li><a href="#跳跃连接">跳跃连接</a></li><li><a href="#重分配权重">重分配权重</a></li></ul></li></ul></li></ul></li><li><a href="#gcn变体与框架">GCN变体与框架</a><ul><li><a href="#graphsage">GraphSAGE</a><ul><li><a href="#邻居采样">邻居采样</a></li><li><a href="#邻居聚合">邻居聚合</a></li><li><a href="#算法流程与实现">算法流程与实现</a></li></ul></li><li><a href="#gat">GAT</a></li><li><a href="#r-gcn">R-GCN</a></li></ul></li><li><a href="#图分类">图分类</a><ul><li><a href="#基于一次性全局池化的图分类">基于一次性全局池化的图分类</a></li><li><a href="#基于层次化池化的图分类">基于层次化池化的图分类</a><ul><li><a href="#基于图坍缩的池化机制">基于图坍缩的池化机制</a><ul><li><a href="#diffpool">DIFFPOOL</a></li><li><a href="#eigenpooling">EigenPooling</a></li></ul></li><li><a href="#基于topk的池化机制">基于TopK的池化机制</a></li><li><a href="#基于边收缩的池化机制">基于边收缩的池化机制</a></li></ul></li></ul></li><li><a href="#图表示学习">图表示学习</a><ul><li><a href="#基于重构损失的gnn">基于重构损失的GNN</a></li><li><a href="#基于对比损失的gnn">基于对比损失的GNN</a><ul><li><a href="#邻居上下文">邻居上下文</a></li><li><a href="#子图上下文">子图上下文</a></li><li><a href="#全图上下文">全图上下文</a></li></ul></li></ul></li><li><a href="#reference">Reference</a></li></ul><h1 id="图卷积神经网络-GCN"><a href="#图卷积神经网络-GCN" class="headerlink" title="图卷积神经网络(GCN)"></a>图卷积神经网络(GCN)</h1><h2 id="图信号"><a href="#图信号" class="headerlink" title="图信号"></a>图信号</h2><p>给定图$G = (V, E)$，$V$表示图中节点集合，$E$表示边集合。假设有$n$个节点，第$i$个节点的<strong>信号强度</strong>为$x_i$，这个图的图信号可以表示为向量的形式</p><script type="math/tex; mode=display">x = \left[ x_1, \cdots, x_i, \cdots, x_n \right]^T \tag{1}</script><blockquote><p>注意研究图信号性质时，除了考虑图信号的强度外，还需考虑<strong>图的拓扑结构</strong>。</p></blockquote><h2 id="拉普拉斯算子"><a href="#拉普拉斯算子" class="headerlink" title="拉普拉斯算子"></a>拉普拉斯算子</h2><p><strong>拉普拉斯矩阵</strong>(Laplacian Matrix)是用于研究图的结构性质的核心对象，定义为</p><script type="math/tex; mode=display">L = D - A \tag{2.1}</script><p>其一种<strong>正则化</strong>的形式(symmetric normalized laplacian)为</p><script type="math/tex; mode=display">L_{sym} = D^{-1/2} L D^{1/2} \tag{2.2}</script><p>其中$A$是图的<strong>邻接矩阵</strong>，$D$是邻接矩阵对应的<strong>度矩阵</strong></p><script type="math/tex; mode=display">d_{ii} = \sum_{j=1}^n a_{ij} \tag{3.1}</script><p>因此</p><script type="math/tex; mode=display">A = \begin{bmatrix}    a_{11} & a_{12} & \cdots & a_{1n} \\    a_{21} & a_{22} & \cdots & a_{2n} \\    \vdots & \vdots & \ddots & \vdots \\    a_{n1} & a_{n2} & \cdots & a_{nn} \\\end{bmatrix},D = \begin{bmatrix}    \sum_j a_{1j} & 0 & \cdots & 0 \\    0 & \sum_j a_{2j} & \cdots & 0 \\    \vdots & \vdots & \ddots & \vdots \\    0 & 0 & \cdots & \sum_j a_{nj}\end{bmatrix} \tag{3.2}</script><p><strong>拉普拉斯算子</strong><a id="laplacian_operator"></a>被用作描述中心节点与邻居节点之间的差异，对于图信号$x$，有</p><script type="math/tex; mode=display">L x = (D - A) x = \begin{bmatrix} \cdots & x_i' & \cdots \end{bmatrix}^T \tag{4.1}</script><p>其中</p><script type="math/tex; mode=display">\begin{aligned}    x_i' & = \underbrace{(- a_{ii} + \sum_j a_{ij})}_{对角线元素} x_i - \sum_{j \neq i} a_{ij} x_j \\    & = x_i \sum_j a_{ij} - \sum_j a_{ij} x_j \\    & = \sum_j a_{ij} (x_i - x_j) \\\end{aligned} \tag{4.2}</script><p>可以看到经$L$变换实际上是<strong>根据节点间信号差异$x_i - x_j$更新$x_i’$</strong>。</p><p><a id="eigen_of_V"><strong>注意</strong></a> </p><ul><li>$x^T L x \geq 0$，因此$L$是<strong>半正定矩阵</strong>，所有特征值大于等于$0$；</li><li>由$(4.1)$，$L \cdot \bm{1} = 0 = 0 \cdot \bm{1}$，所以$L$有<strong>最小的特征值</strong>$0$，且对应特征向量为$\bm{1}$；</li><li>$L_{sym}$的<strong>特征值存在上限</strong>，即$\lambda_{sym} \leq 2$。</li></ul><h2 id="图傅里叶变换"><a href="#图傅里叶变换" class="headerlink" title="图傅里叶变换"></a>图傅里叶变换</h2><p>图傅里叶变换可将图信号由<strong>空域</strong>(spatial domain)视角转换到<strong>频域</strong>(frequency domain)视角，便于图信号处理理论体系的建立。</p><h3 id="GFT与IGFT"><a href="#GFT与IGFT" class="headerlink" title="GFT与IGFT"></a>GFT与IGFT</h3><p>假设图$G$的拉普拉斯矩阵为$L \in R^{n \times n}$，注意到$L$是一个<strong>实对称矩阵</strong>，可以被<strong>正交对角化</strong>为</p><script type="math/tex; mode=display">L = V \Lambda V^T =     \begin{bmatrix}        v_1 & \cdots & v_n    \end{bmatrix}    \begin{bmatrix}        \lambda_1 & & \\        & \ddots & \\        & & \lambda_n    \end{bmatrix}    \begin{bmatrix}        v_1^T \\ \vdots \\ v_n^T    \end{bmatrix} \tag{5}</script><p>其中$0 \leq \lambda_1 \leq \cdots \leq \lambda_n$；$V$是<strong>正交矩阵</strong>，即满足$V V^T = I$，$v_i = \begin{bmatrix} v_{i1} &amp; \cdots &amp; v_{in} \end{bmatrix}^T$，<strong>$v$彼此正交，且均为单位向量</strong>。</p><p><strong>图傅里叶变换</strong>(Graph Fourier Transform, GFT)：对于任意一个在图$G$上的信号$x$，其图傅里叶变换为</p><script type="math/tex; mode=display">\tilde{x} = V^T x, \tilde{x} \in R^n \tag{6.1}</script><p><strong>逆图傅里叶变换</strong>(Inverse Graph Fourier Transform, IGFT)定义为</p><script type="math/tex; mode=display">x = V \tilde{x}, x \in R^{n} \tag{6.2}</script><p>那么从线性变换的角度来看，特征向量$v_k$即<strong>傅里叶基</strong>(完备的)，$\tilde{x}_k$是<strong>傅里叶系数</strong>，即图信号在$v_k$上的投影，<strong>衡量了图信号与傅里叶基之间的相似度</strong>。</p><h3 id="总变差-TV"><a href="#总变差-TV" class="headerlink" title="总变差(TV)"></a>总变差(TV)</h3><p>一个重要的二次型$TV(x)$如下，称图信号的<strong>总变差</strong>(Total Variation)，<strong>刻画图信号整体的平滑度</strong></p><script type="math/tex; mode=display">TV(x) = x^T L x = \sum_i \sum_j a_{ij} (x_i - x_j)^2 \tag{7}</script><p>可以进行如下变换</p><script type="math/tex; mode=display">\begin{aligned}    & \begin{cases}        TV(x) & = & x^T L x \\        x & = & V \tilde{x} \\        L & = & V \Lambda V^T    \end{cases} \\ \Rightarrow     TV(x) & = (V \tilde{x})^T (V \Lambda V^T) (V \tilde{x}) \\     & = \tilde{x}^T \Lambda \tilde{x} = \sum_{i=1}^n \tilde{x}_i^2 \cdot \lambda_i\end{aligned} \tag{8}</script><p>因此，<strong>图的总变差与图的特征值$\lambda_i$之间有非常直接的线性对应关系(权重为$\tilde{x}_i^2$)</strong></p><h3 id="图信号的频域描述"><a href="#图信号的频域描述" class="headerlink" title="图信号的频域描述"></a>图信号的频域描述</h3><blockquote><p>有一个问题需要思考：<strong>一个图中什么样的图信号具有最小的总变差？</strong></p></blockquote><p><strong>限定图信号$x$为单位向量</strong>，经<a href="#eigen_of_V">分析</a>$\lambda_1 = 0$，那么当$x$与$v_1$完全重合时，$x$在$v_{i\neq1}$上投影均为$0$，即</p><script type="math/tex; mode=display">\tilde{x}_i = x \cdot v_i =     \begin{cases}        1 & i = 1 \\        0 & i \neq 1    \end{cases} \Rightarrow \min TV(x) = \lambda_1 \tag{9.1}</script><p>实际上可以证明</p><script type="math/tex; mode=display">TV(x_k) = \lambda_k \tag{9.2}</script><p>如果要选择一组彼此正交的图信号，使各自总变差依次取得最小值，那么这组图信号即傅里叶基$v_1, \cdots, v_n$</p><script type="math/tex; mode=display">\lambda_k = \min_{x: ||x||=1, x \bot x_{x \neq k}} x^T L x \tag{9.3}</script><p><strong>特征值排列后，对图信号的平滑度做出了梯度刻画，因此可以将特征值等价成频率</strong>。特征值越小即频率越低，对应傅里叶基上的图信号总变差越小，变换得越缓慢，相近节点上信号值趋于一致；反之亦然。相应的，<strong>傅里叶系数即图信号在对应频率分量上的幅值</strong>，反应其强度，在低频分量上强度越大，则信号平滑度越高。</p><hr><p><strong>例</strong>：给定图的邻接矩阵如下</p><script type="math/tex; mode=display">A = \begin{bmatrix}    0 & 1 & 1 & 0 & 0 \\    1 & 0 & 1 & 1 & 0 \\    1 & 1 & 0 & 1 & 0 \\    0 & 1 & 1 & 0 & 1 \\    0 & 0 & 0 & 1 & 0\end{bmatrix} \RightarrowL = \begin{bmatrix}    2 & -1 & -1 & 0 & 0 \\    -1 & 3 & -1 & -1 & 0 \\    -1 & -1 & 3 & -1 & 0 \\    0 & -1 & -1 & 3 & -1 \\    0 & 0 & 0 & -1 & 1\end{bmatrix}</script><p>$L$的特征分解为<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A = np.array([</span><br><span class="line"><span class="meta">... </span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line"><span class="meta">... </span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line"><span class="meta">... </span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line"><span class="meta">... </span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line"><span class="meta">... </span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"><span class="meta">... </span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>D = np.diag(A.sum(axis=<span class="number">1</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>D</span><br><span class="line">array([[<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = D - A</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.linalg.eig(L)</span><br><span class="line">(array([<span class="number">0.</span>        , <span class="number">0.82991351</span>, <span class="number">2.68889218</span>, <span class="number">4.4811943</span> , <span class="number">4.</span>        ]), </span><br><span class="line">array([[ <span class="number">4.47213595e-01</span>,  <span class="number">4.37531395e-01</span>, <span class="number">-7.03081478e-01</span>, <span class="number">-3.37998097e-01</span>, <span class="number">-1.24491566e-16</span>],</span><br><span class="line">       [ <span class="number">4.47213595e-01</span>,  <span class="number">2.55974786e-01</span>,  <span class="number">2.42173667e-01</span>, <span class="number">4.19319477e-01</span>,  <span class="number">7.07106781e-01</span>],</span><br><span class="line">       [ <span class="number">4.47213595e-01</span>,  <span class="number">2.55974786e-01</span>,  <span class="number">2.42173667e-01</span>, <span class="number">4.19319477e-01</span>, <span class="number">-7.07106781e-01</span>],</span><br><span class="line">       [ <span class="number">4.47213595e-01</span>, <span class="number">-1.38018756e-01</span>,  <span class="number">5.36249932e-01</span>, <span class="number">-7.02415001e-01</span>, <span class="number">-8.17563909e-16</span>],</span><br><span class="line">       [ <span class="number">4.47213595e-01</span>, <span class="number">-8.11462211e-01</span>, <span class="number">-3.17515788e-01</span>, <span class="number">2.01774144e-01</span>,  <span class="number">3.46536171e-16</span>]]))</span><br></pre></td></tr></table></figure></p><p>可以看到$v_1 =  [0.4472136, 0.4472136, 0.4472136, 0.4472136, 0.4472136]^T$，变化最缓慢，全部相同，而$v_5$变化最剧烈。</p><hr><p>我们把图信号所有傅里叶系数合在一起称作其<strong>频谱</strong>(spectrum)，给定频谱就可以通过逆图傅里叶变换完整得到空域中的图信号；同时，<strong>频谱也完整描述了图信号的频域特性</strong>。</p><p>继续以上面给出的图为例，输入随机图信号，其在频域中表示为<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eigval, eigvec = np.linalg.eig(L)       <span class="comment"># 拉氏矩阵分解得到傅里叶基</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.random.rand(<span class="number">5</span>); x                <span class="comment"># 随机生成图信号</span></span><br><span class="line">array([<span class="number">0.24427103</span>, <span class="number">0.69121671</span>, <span class="number">0.26806286</span>, <span class="number">0.62879822</span>, <span class="number">0.53215482</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.T.dot(L).dot(x)                       <span class="comment"># 总变差</span></span><br><span class="line"><span class="number">0.5227516746889123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>frequency = eigenval                    <span class="comment"># 特征值等价为频率</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>amplitude = eigvec.T.dot(x); amplitude  <span class="comment"># 图信号投影到傅里叶基上，计算幅值</span></span><br><span class="line">array([ <span class="number">1.05743818</span>, <span class="number">-0.16618185</span>,  <span class="number">0.22879526</span>, <span class="number">-0.01462076</span>,  <span class="number">0.29921495</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plt.figure()</span><br><span class="line">&lt;Figure size <span class="number">640</span>x480 <span class="keyword">with</span> <span class="number">0</span> Axes&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 空域</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plt.subplot(<span class="number">211</span>); plt.grid()</span><br><span class="line">&lt;matplotlib.axes._subplots.AxesSubplot object at <span class="number">0x000001BB66698FD0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plt.bar(np.arange(<span class="number">1</span>, <span class="number">6</span>), x, width=<span class="number">0.2</span>)</span><br><span class="line">&lt;BarContainer object of <span class="number">5</span> artists&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plt.title(<span class="string">"spatial domain"</span>)</span><br><span class="line">Text(<span class="number">0.5</span>, <span class="number">1.0</span>, <span class="string">'spatial domain'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plt.xlabel(<span class="string">"index"</span>)</span><br><span class="line">Text(<span class="number">0.5</span>, <span class="number">0</span>, <span class="string">'index'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plt.ylabel(<span class="string">"x_i"</span>)</span><br><span class="line">Text(<span class="number">0</span>, <span class="number">0.5</span>, <span class="string">'x_i'</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 频域</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plt.subplot(<span class="number">212</span>); plt.grid()</span><br><span class="line">&lt;matplotlib.axes._subplots.AxesSubplot object at <span class="number">0x000001BB666C3048</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plt.bar(frequency, amplitude, width=<span class="number">0.2</span>)</span><br><span class="line">&lt;BarContainer object of <span class="number">5</span> artists&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plt.title(<span class="string">"frequency domain"</span>)</span><br><span class="line">Text(<span class="number">0.5</span>, <span class="number">1.0</span>, <span class="string">'frequency domain'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plt.xlabel(<span class="string">"frequency"</span>)</span><br><span class="line">Text(<span class="number">0.5</span>, <span class="number">0</span>, <span class="string">'frequency'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plt.ylabel(<span class="string">"amplitude"</span>)</span><br><span class="line">Text(<span class="number">0</span>, <span class="number">0.5</span>, <span class="string">'amplitude'</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plt.show()</span><br></pre></td></tr></table></figure></p><p><img src="/2020/06/13/Graph-Neural-Network/spatial_frequency_domain_eg.png" alt="spatial_frequency_domain_eg"></p><h2 id="图滤波器"><a href="#图滤波器" class="headerlink" title="图滤波器"></a>图滤波器</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>定义<strong>图滤波器</strong>(Graph Filter)为对给定图信号的频谱中<strong>各个频率分量强度进行增强或衰减的操作</strong>，假设输入信号频谱为$\tilde{x}$，经滤波器$H \in R^{n \times n}$调整后，得到输出信号频谱为$\tilde{y}$</p><script type="math/tex; mode=display">y = H x \tag{10.1}</script><p>那么<strong>各频率分量上调整幅值</strong>，有</p><script type="math/tex; mode=display">\tilde{y}_k = h(\lambda_k) \times \tilde{x}_k \tag{10.2}</script><p>也即</p><script type="math/tex; mode=display">\tilde{y} = \begin{bmatrix} h(\lambda_1) & & \\ & \ddots & \\ & & h(\lambda_n) \end{bmatrix} \tilde{x} \tag{10.3}</script><p>那么对应的输出图信号可以通过傅里叶基重构</p><script type="math/tex; mode=display">y = \sum_{k=1}^n \tilde{y}_k \cdot v_k = V \cdot \tilde{y} \tag{10.4}</script><p>$(10.3)$带入$(10.4)$后有</p><script type="math/tex; mode=display">y = V \cdot \Lambda_h \cdot \tilde{x} = \underbrace{V \Lambda_h V^T}_H \cdot x \tag{10}</script><p>可以看到$H$只在对角与边坐标上时才有可能取非零值，即</p><script type="math/tex; mode=display">H_{ij} = 0, if \quad i \neq j \quad or \quad e_{ij} \notin E</script><p>从算子角度看，$Hx$描述了一种作用在每个节点一阶子图上的变换操作。一般来说，满足以上性质的变换矩阵称为$G$的<strong>图位移算子</strong>(Graph Shift Operator)，拉普拉斯矩阵与邻接矩阵都是典型的图位移算子。</p><hr><p>图滤波器具有如下<strong>性质</strong>：</p><ol><li><strong>线性</strong>：$H(x + y) = Hx + Hy$；</li><li><strong>顺序无关</strong>：$H_1 (H_2 x) = H_2 (H_1 x)$；</li><li><strong>可逆</strong>：若$h(\lambda) \neq 0$，那么滤波操作可逆。</li></ol><hr><script type="math/tex; mode=display">H = V \Lambda_h V^T \tag{11.1}</script><p>称$\Lambda_h$是图滤波器$H$的<strong>频率响应矩阵</strong>，其对角元素$h(\lambda)$是$H$的<strong>频率响应函数</strong>，不同的频率响应函数可以实现不同的滤波效果，如低通、高通、带通等。</p><h3 id="拉普拉斯矩阵多项式拓展形式"><a href="#拉普拉斯矩阵多项式拓展形式" class="headerlink" title="拉普拉斯矩阵多项式拓展形式"></a>拉普拉斯矩阵多项式拓展形式</h3><p>理论上任意性质的图滤波器都可以被实现，即任意类型函数曲线的频率响应函数。通过泰勒展开用多项式进行逼近，有<strong>拉普拉斯矩阵多项式拓展形式的图滤波器</strong>如下</p><script type="math/tex; mode=display">H = \sum_{k=0}^K h_k L^k \tag{11.2}</script><p>其中$K$是图滤波器$H$的阶数，$h_k$是多项式系数。</p><blockquote><p>为什么是上述形式，请参考<a href="#频域角度">频域角度</a>。</p></blockquote><h3 id="空域角度"><a href="#空域角度" class="headerlink" title="空域角度"></a>空域角度</h3><p>对于$y = Hx = (\sum_{k=0}^K h_k L^k) \cdot x$，记</p><script type="math/tex; mode=display">x^{(k)} =  L^k \cdot x \tag{12.1}</script><p>由于$L$是图位移算子，那么$x^{(k-1)}$到$x^{(k)}$的变换只需所有节点的<strong>一阶邻居</strong>参与计算，所以$x^{(k)}$需要所有节点的$k$阶邻居参与，这种性质称为<strong>图滤波器的局部性</strong>。那么输出图信号是$(K + 1)$组图信号的线性加权</p><script type="math/tex; mode=display">y = \sum_{k=0}^K h_k x^{(k)} \tag{12.2}</script><blockquote><ul><li>经$k$次拉普拉斯矩阵线性变换，每次<strong>聚合节点$i$的$k$阶邻居</strong>($k$随着$i$递增)得到图信号$x^{(k)}_i$；</li><li>$K$次<strong>局部性不同</strong>的聚合$x^{(k)}$，经过线性组合(权重$h_k$)得到本次滤波的输出。</li></ul></blockquote><hr><p>从<strong>空域角度</strong>来看，滤波操作的性质为</p><ol><li><strong>局部性</strong>：每个节点的输出信号仅需考虑其$K$阶子图；</li><li>通过$K$步迭<strong>代式的矩阵向量乘法</strong>完成滤波操作。</li></ol><h3 id="频域角度"><a href="#频域角度" class="headerlink" title="频域角度"></a>频域角度</h3><p>由于$L = V \Lambda V^T$，那么</p><script type="math/tex; mode=display">\begin{aligned}    H & = \sum_{k=0}^K h_k L^k \\    & = \sum_{k=0}^K h_k (V \Lambda V^T)^k \\    & = \sum_{k=0}^K h_k (V \Lambda V^T) \cdots (V \Lambda V^T) \\    & = V \underbrace{(\sum_{k=0}^K h_k \Lambda^k)}_{\Lambda_h} V^T \end{aligned} \tag{13.1}</script><p>其中</p><script type="math/tex; mode=display">\Lambda_h = \sum_{k=0}^K h_k \Lambda^k =     \begin{bmatrix}        \underbrace{\sum_{k=0}^K h_k \lambda_1^k}_{h(\lambda_1)} & & \\        & \ddots & \\        & & \underbrace{\sum_{k=0}^K h_k \lambda_n^k }_{h(\lambda_n)}    \end{bmatrix} \tag{13.2}</script><p>那么$H$的<strong>频率响应函数$h(\lambda) = \sum_{k=0}^K h_k \lambda^k$是$\lambda$的$K$次多项式</strong>，如果$K$足够大，可以逼近任意一个关于$\lambda$的函数。</p><hr><p>在滤波操作时</p><script type="math/tex; mode=display">y = Hx = V \Lambda_h V^T \cdot x \tag{13.3}</script><p>可以看到变换过程由<strong>以下三步</strong>组成</p><ol><li>通过图傅里叶变换，求取$x$的频谱$\tilde{x} = V^T x$；</li><li>用$\Lambda_h$对频率分量的幅值进行调节，得到调整后的频谱$\tilde{y} = \Lambda_h \tilde{x}$；</li><li>通过反图傅里叶变换，求取输出图信号$y = V \tilde{y}$。</li></ol><hr><p>设多项式系数构成向量$h$，那么$H$的频率响应矩阵为</p><script type="math/tex; mode=display">\Lambda_h = \sum_{k=0}^K h_k \Lambda^k = \text{diag}(\Psi \cdot h) \tag{14.1 }</script><p>$\text{diag}$表示将列向量转换为对角矩阵。</p><p>其中$\Psi = \begin{bmatrix} 1 &amp; \lambda_1 &amp; \cdots &amp; \lambda_1^K \ 1 &amp; \lambda_2 &amp; \cdots &amp; \lambda_2^K \ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \ 1 &amp; \lambda_n &amp; \cdots &amp; \lambda_n^K \end{bmatrix}$为<strong>范德蒙矩阵</strong>，$h = \begin{bmatrix} h_1 &amp; \cdots &amp; h_n \end{bmatrix}^T$。所以在确定频率响应函数$h(\lambda)$后，可以<strong>反解</strong>得到多项式系数$h$</p><script type="math/tex; mode=display">h = \Psi^{-1} \text{diag}^{-1} (\Lambda_h) \tag{14.2}</script><p>$\text{diag}^{-1}$表示将对角矩阵转换为列向量。</p><hr><p>从<strong>频域角度</strong>来看，滤波操作的性质为</p><ol><li>能更加清晰地完成对图信号地特定滤波操作；</li><li>有显式的公式知道图滤波器的设计；</li><li>不必进行矩阵分解，减少计算量。</li></ol><h2 id="图卷积的定义"><a href="#图卷积的定义" class="headerlink" title="图卷积的定义"></a>图卷积的定义</h2><p>给定两组$G$上的图信号$x_1, x_2$，其图卷积运算定义为</p><script type="math/tex; mode=display">x_1 * x_2 = IGFT \left( GFT(x_1) \bigodot GFT(x_2) \right) \tag{15.1}</script><p>这里定义和离散时间信号处理中卷积定义相同，即<strong>时域中的卷积运算等价于频域中的乘法运算</strong>，其中</p><script type="math/tex; mode=display">\begin{cases}    GFT(x) = V^T x \\    IGFT(x) = V x\end{cases} \tag{15.2}</script><p>$\bigodot$表示哈达玛积，那么</p><script type="math/tex; mode=display">\begin{aligned}    x_1 * x_2 & = V \left( V^T (x_1) \bigodot V^T (x_2) \right) \\    & =  V \left( \tilde{x_1} \bigodot V^T (x_2) \right) \\    & =  V \left( \text{diag}(\tilde{x_1}) \cdot V^T (x_2) \right) \\    & = \left( V \text{diag}(\tilde{x_1}) V^T \right) \cdot x_2\end{aligned} \tag{15.3}</script><p>令</p><script type="math/tex; mode=display">H_{\tilde{x}} = V \text{diag}(\tilde{x_1}) V^T \tag{15.4}</script><p>显然$H_{\tilde{x}}$是一个图位移算子，<strong>其频率响应矩阵对应$x_1$的频谱</strong>，那么</p><script type="math/tex; mode=display">x_1 * x_2 = H_{\tilde{x}} \cdot x_2 \tag{15.5}</script><p>所以两组图信号的图卷积运算能转化为对应形式的图滤波运算，<strong>可以说图卷积等价于图滤波</strong>，后文提到的图卷积都是等号右边的滤波形式，相对应的卷积信号无需显示地表达出来。</p><hr><p>设定义在包含$N$个节点的图$G$上的图信号，为$d$维数据，表示为<strong>图信号矩阵</strong>如下，其中$d$为<strong>图信号的总通道数</strong></p><script type="math/tex; mode=display">X_{N \times d} = \begin{bmatrix}    x_{11} & x_{12} & \cdots & x_{1d} \\     x_{21} & x_{22} & \cdots & x_{2d} \\     \vdots & \vdots & \ddots & \vdots \\    x_{N1} & x_{N2} & \cdots & x_{Nd}\end{bmatrix} \tag{16.1}</script><p>那么$Y = HX$可以视作用图滤波器$H$对信号矩阵<strong>每个通道(列)的信号</strong>分别进行滤波操作。</p><h2 id="滤波器的参数化"><a href="#滤波器的参数化" class="headerlink" title="滤波器的参数化"></a>滤波器的参数化</h2><p>将图卷积运算推广到图数据的学习中，定义神经网络层，并对滤波器进行参数化。神经网络层内引入图滤波器$H$，一般定义为</p><script type="math/tex; mode=display">Y = \sigma(H X) \tag{17}</script><p>其中$\sigma(\cdot)$是激活函数。</p><h3 id="频域图卷积模型"><a href="#频域图卷积模型" class="headerlink" title="频域图卷积模型"></a>频域图卷积模型</h3><p>只能从频域出发进行矩阵特征分解从而执行图卷积计算的模型。</p><h4 id="频率响应函数的参数化"><a href="#频率响应函数的参数化" class="headerlink" title="频率响应函数的参数化"></a>频率响应函数的参数化</h4><p>经过前面讨论，图滤波器$H$可以分解为</p><script type="math/tex; mode=display">H = V \Lambda_h V^T \tag{11.1}</script><p>其中</p><script type="math/tex; mode=display">\Lambda_h =  \begin{bmatrix}     h(\lambda_1) & & \\     & \ddots & \\     & & h(\lambda_n) \end{bmatrix} \tag{10.3}</script><p>我们将其参数化，用待估参数$\theta_i$代替$h(\lambda_i)$，得到参数矩阵$\text{diag}(\theta)$</p><script type="math/tex; mode=display">\text{diag}(\theta) =  \begin{bmatrix}     \theta_1 & & \\     & \ddots & \\     & & \theta_n \end{bmatrix} \tag{18}</script><p><strong>神经网络层</strong>定义为</p><script type="math/tex; mode=display">Y = \sigma(V \text{diag}(\theta) V^T X) = \sigma(\Theta X) \tag{19}</script><p>其中$\Theta$即需要学习的滤波器</p><ul><li>从<strong>空域的角度</strong>理解，该层引入自适应的<strong>图位移算子</strong>，通过学习的手段指导算子的学习，完成对输入图信号的针对性变换操作；</li><li>从<strong>频域的角度</strong>理解，该层训练了一个可自适应的图滤波器。其<strong>频率响应函数</strong>可通过任务与数据间的对应关系来进行学习。</li></ul><p>但是这种参数化方法有以下<strong>缺点</strong></p><ol><li>要学习的参数量与节点数目一致，引入过多的参数，在大规模图数据(上亿节点)的图中极易过拟合；</li><li>真实图数据中，数据有效信息通常蕴含在低频段中，因此$n$个维度自由度的图滤波器，是完全没有必要的。</li></ol><h4 id="拉普拉斯矩阵多项式拓展形式系数的参数化"><a href="#拉普拉斯矩阵多项式拓展形式系数的参数化" class="headerlink" title="拉普拉斯矩阵多项式拓展形式系数的参数化"></a>拉普拉斯矩阵多项式拓展形式系数的参数化</h4><p>考虑用<strong>拉普拉斯矩阵多项式拓展形式</strong>逼近任意频率响应函数</p><script type="math/tex; mode=display">\begin{aligned}    H & = \sum_{k=0}^K h_k L^k \\    & = \sum_{k=0}^K h_k (V \Lambda V^T)^k \\    & = \sum_{k=0}^K h_k (V \Lambda V^T) \cdots (V \Lambda V^T) \\    & = V \underbrace{(\sum_{k=0}^K h_k \Lambda^k)}_{\Lambda_h} V^T \end{aligned} \tag{13.1}</script><p>将各阶次的系数参数化为$\theta$，神经网络层定义为</p><script type="math/tex; mode=display">\begin{aligned}    Y & = \sigma \left( \left( \sum_{k=0}^K h_k L^k \right) X \right) \\    & = \sigma \left( V \left( \sum_{k=0}^K \theta_k \Lambda^k \right) V^T X \right) \\    & = \sigma \left( V \text{diag}(\Psi \theta) V^T X \right)\end{aligned} \tag{20}</script><p>这种方法定义神经网络层，参数量$K$可控制，$K$越大，可拟合的频率响应函数次数越高，可以对应输入图信号矩阵与输出图信号矩阵之间复杂的滤波关系。一般设$k &lt;&lt; N$，大大降低模型过拟合风险。<strong>但是这种方法还是需要进行矩阵的分解，计算复杂度高。</strong></p><h3 id="空域图卷积模型"><a href="#空域图卷积模型" class="headerlink" title="空域图卷积模型"></a>空域图卷积模型</h3><p>不需要进行矩阵特征分解，能在空域视角执行矩阵乘法运算的模型。</p><h4 id="固定滤波器的参数化"><a href="#固定滤波器的参数化" class="headerlink" title="固定滤波器的参数化"></a>固定滤波器的参数化</h4><p>为解决计算复杂度的问题，对$(19)$进行<strong>极大简化</strong>，设$K = 1$，那么</p><script type="math/tex; mode=display">Y = \sigma \left( (\theta_0 + \theta_1 L) X \right) \tag{21.1}</script><p>令$\theta_0 = \theta_1 = \theta$，那么</p><script type="math/tex; mode=display">Y = \sigma \left( \theta (I + L) X \right) \tag{21.2}</script><p>实际上，$\theta$此时只是一个比例缩放因子，是不必要引入的。设$\theta = 1$，得到<strong>固定的图滤波器$\tilde{L} = I + L$</strong></p><script type="math/tex; mode=display">Y = \sigma(\tilde{L} X) \tag{21.3}</script><blockquote><p>从空域上看，只聚合了$1$阶邻居节点的信息。</p></blockquote><p>为了加强网络学习时的数值稳定性，对$\tilde{L}$进行归一化处理，防止梯度消失或爆炸问题</p><script type="math/tex; mode=display">\begin{aligned}    \begin{cases}        \tilde{A} = A + I \\        \tilde{D} = \text{diag} (\begin{bmatrix}            \cdots & \sum_j \tilde{A}_{ij} & \cdots        \end{bmatrix}) = D + I    \end{cases} \\ \\ \Rightarrow    \tilde{L}_{sym} = \tilde{D}^{-1/2} \tilde{A} \tilde{D}^{-1/2}\end{aligned} \tag{21.4}</script><blockquote><p>注意$\tilde{L}_{sym}$的特征值取值范围为$(-1, 1]$。</p></blockquote><p>为了加强网络拟合能力，<strong>引入参数化的权重矩阵$W$对输入的图信号矩阵进行仿射变换</strong>，可变换数据的维度，即</p><script type="math/tex; mode=display">Y = \sigma(\tilde{L}_{sym} \cdot X W) \tag{22}</script><p>由于$\tilde{L}_{sym}$是一个图位移算子，$\tilde{L}_{sym} X$的计算<strong>等价于对邻居节点的特征向量($X$的行向量，$d$个通道)进行聚合操作</strong></p><script type="math/tex; mode=display">y_{i, :} = \sigma(\sum_{v_j \in \tilde{N}(v_i)} {\tilde{L}_{sym}}_{ij} \cdot W x_{j, :}) \tag{23}</script><blockquote><p>对于$v_i$节点，根据每个邻居节点$v_j$更新自身状态</p><ul><li>对节点特征向量进行一次仿射变换$W x_j$；</li><li>固定滤波器$\tilde{L}_{sym}$的是<a href="#laplacian_operator">拉普拉斯算子</a>，第$i$行的可以聚合节点$v_i$的邻居节点；</li><li>聚合后非线性激活作为输出。</li></ul></blockquote><p>实际工程中，可以用<strong>稀疏矩阵</strong>表示$\tilde{L}_{sym}$，进一步降低计算复杂度。相比较于分解矩阵的$O(n^3)$，可以降低至$O(|E|d)$。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.keras.initializers <span class="keyword">import</span> Identity, glorot_uniform, Zeros</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.keras.layers <span class="keyword">import</span> Dropout, Input, Layer, Embedding, Reshape</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.keras.models <span class="keyword">import</span> Model</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.keras.regularizers <span class="keyword">import</span> l2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphConvolution</span><span class="params">(Layer)</span>:</span>  <span class="comment"># ReLU(AXW)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, units,</span></span></span><br><span class="line"><span class="function"><span class="params">                 activation=tf.nn.relu, dropout_rate=<span class="number">0.5</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 use_bias=True, l2_reg=<span class="number">0</span>, feature_less=False,</span></span></span><br><span class="line"><span class="function"><span class="params">                 seed=<span class="number">1024</span>, **kwargs)</span>:</span></span><br><span class="line">        super(GraphConvolution, self).__init__(**kwargs)</span><br><span class="line">        self.units = units</span><br><span class="line">        self.feature_less = feature_less</span><br><span class="line">        self.use_bias = use_bias</span><br><span class="line">        self.l2_reg = l2_reg</span><br><span class="line">        self.dropout_rate = dropout_rate</span><br><span class="line">        self.activation = activation</span><br><span class="line">        self.seed = seed</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(self, input_shapes)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.feature_less:</span><br><span class="line">            input_dim = int(input_shapes[<span class="number">0</span>][<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">assert</span> len(input_shapes) == <span class="number">2</span></span><br><span class="line">            features_shape = input_shapes[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">            input_dim = int(features_shape[<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">        self.kernel = self.add_weight(shape=(input_dim,</span><br><span class="line">                                             self.units),</span><br><span class="line">                                      initializer=glorot_uniform(</span><br><span class="line">                                          seed=self.seed),</span><br><span class="line">                                      regularizer=l2(self.l2_reg),</span><br><span class="line">                                      name=<span class="string">'kernel'</span>, )</span><br><span class="line">        <span class="keyword">if</span> self.use_bias:</span><br><span class="line">            self.bias = self.add_weight(shape=(self.units,),</span><br><span class="line">                                        initializer=Zeros(),</span><br><span class="line">                                        name=<span class="string">'bias'</span>, )</span><br><span class="line"></span><br><span class="line">        self.dropout = Dropout(self.dropout_rate, seed=self.seed)</span><br><span class="line"></span><br><span class="line">        self.built = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(self, inputs, training=None, **kwargs)</span>:</span></span><br><span class="line">        features, A = inputs</span><br><span class="line">        features = self.dropout(features, training=training)</span><br><span class="line">        output = tf.matmul(tf.sparse_tensor_dense_matmul(</span><br><span class="line">            A, features), self.kernel)</span><br><span class="line">        <span class="keyword">if</span> self.bias:</span><br><span class="line">            output += self.bias</span><br><span class="line">        act = self.activation(output)</span><br><span class="line"></span><br><span class="line">        act._uses_learning_phase = features._uses_learning_phase</span><br><span class="line">        <span class="keyword">return</span> act</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_config</span><span class="params">(self)</span>:</span></span><br><span class="line">        config = &#123;<span class="string">'units'</span>: self.units,</span><br><span class="line">                  <span class="string">'activation'</span>: self.activation,</span><br><span class="line">                  <span class="string">'dropout_rate'</span>: self.dropout_rate,</span><br><span class="line">                  <span class="string">'l2_reg'</span>: self.l2_reg,</span><br><span class="line">                  <span class="string">'use_bias'</span>: self.use_bias,</span><br><span class="line">                  <span class="string">'feature_less'</span>: self.feature_less,</span><br><span class="line">                  <span class="string">'seed'</span>: self.seed</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">        base_config = super(GraphConvolution, self).get_config()</span><br><span class="line">        <span class="keyword">return</span> dict(list(base_config.items()) + list(config.items()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GCN</span><span class="params">(adj_dim,feature_dim,n_hidden, num_class, num_layers=<span class="number">2</span>,activation=tf.nn.relu,dropout_rate=<span class="number">0.5</span>, l2_reg=<span class="number">0</span>, feature_less=True, )</span>:</span></span><br><span class="line">    Adj = Input(shape=(<span class="keyword">None</span>,), sparse=<span class="keyword">True</span>)</span><br><span class="line">    <span class="keyword">if</span> feature_less:</span><br><span class="line">        X_in = Input(shape=(<span class="number">1</span>,), )</span><br><span class="line"></span><br><span class="line">        emb = Embedding(adj_dim, feature_dim,</span><br><span class="line">                        embeddings_initializer=Identity(<span class="number">1.0</span>), trainable=<span class="keyword">False</span>)</span><br><span class="line">        X_emb = emb(X_in)</span><br><span class="line">        h = Reshape([X_emb.shape[<span class="number">-1</span>]])(X_emb)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        X_in = Input(shape=(feature_dim,), )</span><br><span class="line"></span><br><span class="line">        h = X_in</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num_layers):</span><br><span class="line">        <span class="keyword">if</span> i == num_layers - <span class="number">1</span>:</span><br><span class="line">            activation = tf.nn.softmax</span><br><span class="line">            n_hidden = num_class</span><br><span class="line">        h = GraphConvolution(n_hidden, activation=activation, dropout_rate=dropout_rate, l2_reg=l2_reg)([h,Adj])</span><br><span class="line"></span><br><span class="line">    output = h</span><br><span class="line">    model = Model(inputs=[X_in,Adj], outputs=output)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure><h1 id="GCN的性质"><a href="#GCN的性质" class="headerlink" title="GCN的性质"></a>GCN的性质</h1><h2 id="GCN与CNN联系"><a href="#GCN与CNN联系" class="headerlink" title="GCN与CNN联系"></a>GCN与CNN联系</h2><ol><li>CNN中卷积运算没有显式表达邻接矩阵，可视作处理<strong>2D栅格结构的图数据</strong>；GCN卷积运算用于处理更普遍的非结构化的图数据，数据之间关系更复杂多样；</li><li>两者都是<strong>局部连接</strong>，减少单层网络的计算复杂度；</li><li>两者都<strong>共享参数</strong>，减少单层网络的参数量，避免过拟合；</li><li>节点自身特征的更新与卷积运算强耦合，<strong>感受野</strong>都随着卷积层的增加而变大，特征也更抽象；</li><li>在任务上，CNN有对全局进行的图像分类和对局部进行的语义分割，GNN相应地有<strong>图分类和图节点分类</strong>。</li></ol><h2 id="端到端学习"><a href="#端到端学习" class="headerlink" title="端到端学习"></a>端到端学习</h2><p><strong>端到端学习</strong>实现了一种自动化地从数据中进行高效学习的机制，需要<strong>大量针对特定类型数据的学习任务的适配工作</strong>。图数据中包含两部分信息</p><ul><li><strong>属性信息</strong>：描述了图中节点的固有性质；</li><li><strong>机构信息</strong>：描述了节点间的关联性质。</li></ul><hr><p>GCN方法对于属性和结构信息的学习，体现在其核心公式上</p><script type="math/tex; mode=display">\tilde{L}_{sym} X W \tag{24}</script><p>可以看到计算过程可以分为两部分</p><ul><li><strong>特征间的交互</strong>：用$X W$对属性信息进行放射变换，以学习属性特征间的交互模式；</li><li><strong>节点局部结构信息编码</strong>：$\tilde{L}_{sym} (X W)$从空域角度看，是聚合邻居节点的过程，对结构信息进行编码。</li></ul><hr><p><strong>GCN模型有以下优点</strong></p><ul><li>表示学习和任务学习一起进行<strong>端到端优化</strong>，节点的特征表示和下游任务间有很好的适应性；</li><li>同时进行<strong>结构信息和属性信息的学习</strong>，两者具有很好的互补关系<ul><li>对于结构稀疏的图，属性信息的补充可以很好地提高模型对节点表示学习的质量；</li><li>结构信息蕴含属性信息中没有的知识，对节点刻画十分重要。</li></ul></li></ul><h2 id="低通滤波器"><a href="#低通滤波器" class="headerlink" title="低通滤波器"></a>低通滤波器</h2><p>再次回到GCN的核心公式$\tilde{L}_{sym} X W$，其中</p><script type="math/tex; mode=display">\tilde{L}_{sym} = \tilde{D}^{-1/2} \tilde{A} \tilde{D}^{-1/2} \tag{25.1}</script><p>根据</p><script type="math/tex; mode=display">\begin{cases}    \tilde{A} = A + I \\    \tilde{D} = D + I \\    L = D - A\end{cases} \Rightarrow \tilde{A} = \tilde{D} - L \tag{25.2}</script><p>那么$\tilde{A}$带入$\tilde{L}_{sym}$可以得到</p><script type="math/tex; mode=display">\tilde{L}_{sym} = \tilde{D}^{-1/2} (\tilde{D} - L) \tilde{D}^{-1/2} = I -  \tilde{D}^{-1/2} L \tilde{D}^{-1/2} \tag{25.3}</script><p>记</p><script type="math/tex; mode=display">\tilde{L}_s = \tilde{D}^{-1/2} L \tilde{D}^{-1/2} \tag{25.4}</script><p>可以被正交对角化如下，且<strong>特征值满足$\tilde{\lambda}_i \in [0, 2)$</strong></p><script type="math/tex; mode=display">\tilde{L}_s = V \tilde{\Lambda} V^T \tag{25.5}</script><p>所以</p><script type="math/tex; mode=display">\tilde{L}_{sym} = I - V \tilde{\Lambda} V^T = V (1 - \tilde{\Lambda}) V^T \tag{26.1}</script><p>对应的频率响应函数如下，是一个线性收缩函数，并且$\tilde{\lambda}_1 \leq \cdots  \leq \tilde{\lambda}_n$，所以对高频信号有更大的缩减作用，是一个<strong>低通滤波器</strong></p><script type="math/tex; mode=display">p_i(\lambda) = 1 - \tilde{\lambda}_i \in (-1, 1] \tag{26.2}</script><p>如果将信号矩阵$X$不断左乘$K$次$\tilde{L}_{sym}$，其对应的频率响应函数为</p><script type="math/tex; mode=display">p_i^k (\lambda) = (1 - \tilde{\lambda}_i)^k \in (-1, 1] \tag{26.3}</script><p>其函数图像如下，可以看到<strong>当$K$增大时，低通滤波器的效应更强</strong><br><img src="/2020/06/13/Graph-Neural-Network/low_pass_filter.png" alt="low_pass_filter"></p><p>事实上，为了突出这种低通滤波的能力、减少模型参数量，也有直接将多层GCN退化为</p><script type="math/tex; mode=display">Y = \sigma(\tilde{L}_{sym}^K \cdot X W) \tag{27}</script><h2 id="过平滑问题"><a href="#过平滑问题" class="headerlink" title="过平滑问题"></a>过平滑问题</h2><p>由于每层GCN都是一个低通滤波器，在多层堆叠时，信号经不断平滑会越来越趋同，丧失节点特征的多样性，以下分别从频域和空域两个视角对这个问题进行分析。</p><h3 id="频域视角"><a href="#频域视角" class="headerlink" title="频域视角"></a>频域视角</h3><p>从退化的多层GCN模型出发</p><script type="math/tex; mode=display">\begin{aligned}    \lim_{K \rightarrow + \infty} \tilde{L}_{sym}^K &=        \lim_{K \rightarrow + \infty} (I - \tilde{L}_s)^K    = \lim_{K \rightarrow + \infty} \left( V (I - \tilde{\Lambda}) V^T \right)^K \\    & = \lim_{K \rightarrow + \infty} V        \begin{bmatrix}            (1 - \tilde{\lambda}_1)^K & & & \\            & (1 - \tilde{\lambda}_2)^K & & \\            & & \ddots & \\            & & & (1 - \tilde{\lambda}_n)^K \\        \end{bmatrix} V^T\end{aligned} \tag{28.1}</script><p>由于$\tilde{\lambda}_1 = 0, \tilde{\lambda}_i &gt; 0, i = 2, \cdots, n$，所以</p><script type="math/tex; mode=display">\lim_{K \rightarrow + \infty} \tilde{L}_{sym}^K = V     \begin{bmatrix}        1 & & & \\        & 0 & & \\        & & \ddots & \\        & & & 0 \\    \end{bmatrix} V^T \tag{28.2}</script><p>那么对于输入图信号$x$，有</p><script type="math/tex; mode=display">\begin{aligned}    (\lim_{K \rightarrow + \infty} \tilde{L}_{sym}^K) \cdot x & = V         \begin{bmatrix}            1 & & & \\            & 0 & & \\            & & \ddots & \\            & & & 0 \\        \end{bmatrix} V^T \cdot x \\        & = v_1 V^T \cdot x = v_1 v_1^T \cdot x = \tilde{x}_1 v_1\end{aligned} \tag{28.3}</script><hr><p>考虑</p><script type="math/tex; mode=display">\tilde{L}_{sym} \cdot \tilde{D}^{1/2} \bm{1}     = \tilde{D}^{-1/2} L \tilde{D}^{-1/2} \cdot \tilde{D}^{1/2} \bm{1}    = \tilde{D}^{-1/2} \underbrace{L \bm{1}}_{\sum_j a_{ij} - d_i = 0}    = \tilde{D}^{-1/2}   \bm{0}    = \bm{0} \tag{28.4}</script><p>所以$(\tilde{D}^{1/2} \bm{1}, 0)$是$\tilde{L}_{sym}$的特征对，又因为</p><script type="math/tex; mode=display">\tilde{L}_s = \tilde{D}^{-1/2} L \tilde{D}^{-1/2} = \begin{cases}    \tilde{D}^{-1/2} V \Lambda V^T \tilde{D}^{-1/2} \\    V \tilde{\Lambda} V^T\end{cases}\tag{28.5}</script><p>经<a href="#eigen_of_V">拉普拉斯算子</a>一节分析，拉普拉斯矩阵$L$存在特征对$(\bm{1}, 0)$，所以</p><script type="math/tex; mode=display">v_1 = \tilde{D}^{1/2} \bm{1} \tag{28.6}</script><hr><p>结合$(28.3)与(28.6)$可以得到</p><script type="math/tex; mode=display">(\lim_{K \rightarrow + \infty} \tilde{L}_{sym}^K) \cdot x = \tilde{x}_1 \tilde{D}^{1/2} \cdot \bm{1} \tag{29}</script><p><strong>也就是说，经过$K \rightarrow + \infty$次平滑后，图信号最终趋于常向量，不具有区分性。</strong></p><h3 id="空域视角"><a href="#空域视角" class="headerlink" title="空域视角"></a>空域视角</h3><p>GCN从空域角度理解，是聚合邻居节点的信息。<strong>随着GCN层数增加，节点的聚合半径也在增长，最终会覆盖整个图</strong>，这与从那个结点出发开始聚合是无关的。这种情况会大大降低每个节点的局部网络结构的多样性，对节点自身的特征学习十分不利。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="跳跃连接"><a href="#跳跃连接" class="headerlink" title="跳跃连接"></a>跳跃连接</h4><p>通过跳跃连接来聚合模型的每层节点输出，聚合后的节点特征具有混合性的聚合半径。对于任意一个节点而言，都不会因为聚合半径过大而出现过平滑问题，也不会因为半径过小而未充分学习结构信息。</p><p>具体操作是将每层GCN网络层的输出，通过跳跃连接与网络的最终输出相连，可以选择如拼接、平均池化、最大池化等操作，得到的最终输出用于监督学习。</p><h4 id="重分配权重"><a href="#重分配权重" class="headerlink" title="重分配权重"></a>重分配权重</h4><p>回到频域视角调节图滤波器的值，例如</p><script type="math/tex; mode=display">A_{ij}' = \begin{cases}    1 - p & i = j \\    p \times \frac{A_{ij}}{\text{deg}(v_i)} & i \neq j\end{cases} \tag{30}</script><p>其中$\text{deg}(\cdot)$表示取节点的度，也即</p><script type="math/tex; mode=display">\text{deg}(v_i) = \sum_{v_j \in \mathcal{N}(v_i)} A_{ij} \tag{31}</script><p>调节$p$的值对节点自身权重进行重分配</p><ul><li>$p \rightarrow 0$时，模型趋向于不聚合邻居信息，减缓了模型低通滤波的效应；</li><li>$p \rightarrow 1$时，模型趋向于不使用自身信息，加速了模型低通滤波的效应。</li></ul><h1 id="GCN变体与框架"><a href="#GCN变体与框架" class="headerlink" title="GCN变体与框架"></a>GCN变体与框架</h1><h2 id="GraphSAGE"><a href="#GraphSAGE" class="headerlink" title="GraphSAGE"></a><a href="https://papers.nips.cc/paper/6703-inductive-representation-learning-on-large-graphs.pdf" target="_blank" rel="noopener">GraphSAGE</a></h2><p>上面以随机游走算法训练过程中，用到了拉普拉斯矩阵$L_{n \times n}$，$n$为节点个数，也就是说需要用全部节点的信息进行参数的学习，这对极大规模的图数据非常不友好，存在以下问题</p><ul><li><strong>子图的节点数呈指数级增长</strong>：例如节点度的均值为$\overline{d}$，执行$K$层GCN就涉及$1 + \overline{d} + \overline{d}^2 + \cdots + \overline{d}^K$个节点，导致很高的时间复杂度；</li><li><strong>图数据节点度呈幂律分布</strong>：一些节点的度非常大(超级节点)，这些节点就放大了指数级增长的问题。</li></ul><p>GraphSAGE从空域角度出发，每个节点聚合其$K$阶邻居节点的信息用于更新自身图信号，这就涉及到以下两个方面</p><ul><li><strong>邻居采样</strong>：将GCN由全图的训练方式改造为以节点为中心的小批量训练方式，可以用于训练大规模图数据；</li><li><strong>邻居聚合</strong>：对聚合操作进行拓展，提出几种新的方式，</li></ul><h3 id="邻居采样"><a href="#邻居采样" class="headerlink" title="邻居采样"></a>邻居采样</h3><p>GraphSAGE使用非常自然的采样邻居操作，用于控制子图发散的增长率。具体操作是在第$k$层的邻居采样倍率设置为$S_k$，即每个节点采样的一阶邻居不超过$S_k$(均匀采样)，那么任意一个中心节点的表达计算涉及的节点数目在$O(\prod_k S_k)$级别。</p><blockquote><p>例如一个$2$层的模型，设置$S_1 = 3, S_2 = 2$，那么总节点个数为$1 + 3 + 3 \times 2 = 10$。</p></blockquote><h3 id="邻居聚合"><a href="#邻居聚合" class="headerlink" title="邻居聚合"></a>邻居聚合</h3><p><img src="/2020/06/13/Graph-Neural-Network/graphsage_1.png" alt="graphsage_1"></p><p>邻居图信息的聚合需要满足以下两个条件</p><ul><li>自适应聚合节点数，聚合输出维度必须一致，即长度统一的向量；</li><li>聚合操作对节点具有排列不变性，即邻居节点的顺序与聚合输出无关。</li></ul><p>符合以上性质的操作算子有</p><ul><li>逐元素的平均/加和：是GCN中图卷积操作的线性近似，加和聚合的网络层公式如下，其中$W, b$是代估参数<script type="math/tex; mode=display">y^{sum} = \sigma \left( \sum_{v_j \in \mathcal{N}(v_i)} (W h_j + b) \right)\tag{31}</script></li><li>逐元素的池化：借鉴CNN的池化操作，最大池化聚合的网络层公式如下<script type="math/tex; mode=display">y^{maxpool} = \max_{v_j \in \mathcal{N}(v_i)} \left( \sigma(Wh_j + b) \right) \tag{32}</script></li></ul><blockquote><p>注意激活函数的位置是不同的。</p></blockquote><h3 id="算法流程与实现"><a href="#算法流程与实现" class="headerlink" title="算法流程与实现"></a>算法流程与实现</h3><p><img src="/2020/06/13/Graph-Neural-Network/graphsage_2.png" alt="graphsage_2"></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.keras.initializers <span class="keyword">import</span> glorot_uniform, Zeros</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.keras.layers <span class="keyword">import</span> Input, Dense, Dropout, Layer, LSTM</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.keras.models <span class="keyword">import</span> Model</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.keras.regularizers <span class="keyword">import</span> l2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MeanAggregator</span><span class="params">(Layer)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, units, input_dim, neigh_max, concat=True, dropout_rate=<span class="number">0.0</span>, activation=tf.nn.relu, l2_reg=<span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 use_bias=False,</span></span></span><br><span class="line"><span class="function"><span class="params">                 seed=<span class="number">1024</span>, **kwargs)</span>:</span></span><br><span class="line">        super(MeanAggregator, self).__init__()</span><br><span class="line">        self.units = units</span><br><span class="line">        self.neigh_max = neigh_max</span><br><span class="line">        self.concat = concat</span><br><span class="line">        self.dropout_rate = dropout_rate</span><br><span class="line">        self.l2_reg = l2_reg</span><br><span class="line">        self.use_bias = use_bias</span><br><span class="line">        self.activation = activation</span><br><span class="line">        self.seed = seed</span><br><span class="line">        self.input_dim = input_dim</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(self, input_shapes)</span>:</span></span><br><span class="line"></span><br><span class="line">        self.neigh_weights = self.add_weight(shape=(self.input_dim, self.units),</span><br><span class="line">                                             initializer=glorot_uniform(</span><br><span class="line">                                                 seed=self.seed),</span><br><span class="line">                                             regularizer=l2(self.l2_reg),</span><br><span class="line">                                             name=<span class="string">"neigh_weights"</span>)</span><br><span class="line">        <span class="keyword">if</span> self.use_bias:</span><br><span class="line">            self.bias = self.add_weight(shape=(self.units), initializer=Zeros(),</span><br><span class="line">                                        name=<span class="string">'bias_weight'</span>)</span><br><span class="line"></span><br><span class="line">        self.dropout = Dropout(self.dropout_rate)</span><br><span class="line">        self.built = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(self, inputs, training=None)</span>:</span></span><br><span class="line">        features, node, neighbours = inputs</span><br><span class="line"></span><br><span class="line">        node_feat = tf.nn.embedding_lookup(features, node)</span><br><span class="line">        neigh_feat = tf.nn.embedding_lookup(features, neighbours)</span><br><span class="line"></span><br><span class="line">        node_feat = self.dropout(node_feat, training=training)</span><br><span class="line">        neigh_feat = self.dropout(neigh_feat, training=training)</span><br><span class="line"></span><br><span class="line">        concat_feat = tf.concat([neigh_feat, node_feat], axis=<span class="number">1</span>)</span><br><span class="line">        concat_mean = tf.reduce_mean(concat_feat, axis=<span class="number">1</span>, keep_dims=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line">        output = tf.matmul(concat_mean, self.neigh_weights)</span><br><span class="line">        <span class="keyword">if</span> self.use_bias:</span><br><span class="line">            output += self.bias</span><br><span class="line">        <span class="keyword">if</span> self.activation:</span><br><span class="line">            output = self.activation(output)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># output = tf.nn.l2_normalize(output,dim=-1)</span></span><br><span class="line">        output._uses_learning_phase = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_config</span><span class="params">(self)</span>:</span></span><br><span class="line">        config = &#123;<span class="string">'units'</span>: self.units,</span><br><span class="line">                  <span class="string">'concat'</span>: self.concat,</span><br><span class="line">                  <span class="string">'seed'</span>: self.seed</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">        base_config = super(MeanAggregator, self).get_config()</span><br><span class="line">        <span class="keyword">return</span> dict(list(base_config.items()) + list(config.items()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PoolingAggregator</span><span class="params">(Layer)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, units, input_dim, neigh_max, aggregator=<span class="string">'meanpooling'</span>, concat=True,</span></span></span><br><span class="line"><span class="function"><span class="params">                 dropout_rate=<span class="number">0.0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 activation=tf.nn.relu, l2_reg=<span class="number">0</span>, use_bias=False,</span></span></span><br><span class="line"><span class="function"><span class="params">                 seed=<span class="number">1024</span>, )</span>:</span></span><br><span class="line">        super(PoolingAggregator, self).__init__()</span><br><span class="line">        self.output_dim = units</span><br><span class="line">        self.input_dim = input_dim</span><br><span class="line">        self.concat = concat</span><br><span class="line">        self.pooling = aggregator</span><br><span class="line">        self.dropout_rate = dropout_rate</span><br><span class="line">        self.l2_reg = l2_reg</span><br><span class="line">        self.use_bias = use_bias</span><br><span class="line">        self.activation = activation</span><br><span class="line">        self.neigh_max = neigh_max</span><br><span class="line">        self.seed = seed</span><br><span class="line"></span><br><span class="line">        <span class="comment"># if neigh_input_dim is None:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(self, input_shapes)</span>:</span></span><br><span class="line"></span><br><span class="line">        self.dense_layers = [Dense(</span><br><span class="line">            self.input_dim, activation=<span class="string">'relu'</span>, use_bias=<span class="keyword">True</span>, kernel_regularizer=l2(self.l2_reg))]</span><br><span class="line"></span><br><span class="line">        self.neigh_weights = self.add_weight(</span><br><span class="line">            shape=(self.input_dim * <span class="number">2</span>, self.output_dim),</span><br><span class="line">            initializer=glorot_uniform(</span><br><span class="line">                seed=self.seed),</span><br><span class="line">            regularizer=l2(self.l2_reg),</span><br><span class="line"></span><br><span class="line">            name=<span class="string">"neigh_weights"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.use_bias:</span><br><span class="line">            self.bias = self.add_weight(shape=(self.output_dim,),</span><br><span class="line">                                        initializer=Zeros(),</span><br><span class="line">                                        name=<span class="string">'bias_weight'</span>)</span><br><span class="line"></span><br><span class="line">        self.built = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(self, inputs, mask=None)</span>:</span></span><br><span class="line"></span><br><span class="line">        features, node, neighbours = inputs</span><br><span class="line"></span><br><span class="line">        node_feat = tf.nn.embedding_lookup(features, node)</span><br><span class="line">        neigh_feat = tf.nn.embedding_lookup(features, neighbours)</span><br><span class="line"></span><br><span class="line">        dims = tf.shape(neigh_feat)</span><br><span class="line">        batch_size = dims[<span class="number">0</span>]</span><br><span class="line">        num_neighbors = dims[<span class="number">1</span>]</span><br><span class="line">        h_reshaped = tf.reshape(</span><br><span class="line">            neigh_feat, (batch_size * num_neighbors, self.input_dim))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> self.dense_layers:</span><br><span class="line">            h_reshaped = l(h_reshaped)</span><br><span class="line">        neigh_feat = tf.reshape(</span><br><span class="line">            h_reshaped, (batch_size, num_neighbors, int(h_reshaped.shape[<span class="number">-1</span>])))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.pooling == <span class="string">"meanpooling"</span>:</span><br><span class="line">            neigh_feat = tf.reduce_mean(neigh_feat, axis=<span class="number">1</span>, keep_dims=<span class="keyword">False</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            neigh_feat = tf.reduce_max(neigh_feat, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        output = tf.concat(</span><br><span class="line">            [tf.squeeze(node_feat, axis=<span class="number">1</span>), neigh_feat], axis=<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        output = tf.matmul(output, self.neigh_weights)</span><br><span class="line">        <span class="keyword">if</span> self.use_bias:</span><br><span class="line">            output += self.bias</span><br><span class="line">        <span class="keyword">if</span> self.activation:</span><br><span class="line">            output = self.activation(output)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># output = tf.nn.l2_normalize(output, dim=-1)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_config</span><span class="params">(self)</span>:</span></span><br><span class="line">        config = &#123;<span class="string">'output_dim'</span>: self.output_dim,</span><br><span class="line">                  <span class="string">'concat'</span>: self.concat</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">        base_config = super(PoolingAggregator, self).get_config()</span><br><span class="line">        <span class="keyword">return</span> dict(list(base_config.items()) + list(config.items()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GraphSAGE</span><span class="params">(feature_dim, neighbor_num, n_hidden, n_classes, use_bias=True, activation=tf.nn.relu,</span></span></span><br><span class="line"><span class="function"><span class="params">              aggregator_type=<span class="string">'mean'</span>, dropout_rate=<span class="number">0.0</span>, l2_reg=<span class="number">0</span>)</span>:</span></span><br><span class="line">    features = Input(shape=(feature_dim,))</span><br><span class="line">    node_input = Input(shape=(<span class="number">1</span>,), dtype=tf.int32)</span><br><span class="line">    neighbor_input = [Input(shape=(l,), dtype=tf.int32) <span class="keyword">for</span> l <span class="keyword">in</span> neighbor_num]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> aggregator_type == <span class="string">'mean'</span>:</span><br><span class="line">        aggregator = MeanAggregator</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        aggregator = PoolingAggregator</span><br><span class="line"></span><br><span class="line">    h = features</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(neighbor_num)):</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span>:</span><br><span class="line">            feature_dim = n_hidden</span><br><span class="line">        <span class="keyword">if</span> i == len(neighbor_num) - <span class="number">1</span>:</span><br><span class="line">            activation = tf.nn.softmax</span><br><span class="line">            n_hidden = n_classes</span><br><span class="line">        h = aggregator(units=n_hidden, input_dim=feature_dim, activation=activation, l2_reg=l2_reg, use_bias=use_bias,</span><br><span class="line">                       dropout_rate=dropout_rate, neigh_max=neighbor_num[i], aggregator=aggregator_type)(</span><br><span class="line">            [h, node_input, neighbor_input[i]])  <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    output = h</span><br><span class="line">    input_list = [features, node_input] + neighbor_input</span><br><span class="line">    model = Model(input_list, outputs=output)</span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample_neighs</span><span class="params">(G, nodes, sample_num=None, self_loop=False, shuffle=True)</span>:</span>  <span class="comment"># 抽样邻居节点</span></span><br><span class="line">    _sample = np.random.choice</span><br><span class="line">    neighs = [list(G[int(node)]) <span class="keyword">for</span> node <span class="keyword">in</span> nodes]  <span class="comment"># nodes里每个节点的邻居</span></span><br><span class="line">    <span class="keyword">if</span> sample_num:</span><br><span class="line">        <span class="keyword">if</span> self_loop:</span><br><span class="line">            sample_num -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        samp_neighs = [</span><br><span class="line">            list(_sample(neigh, sample_num, replace=<span class="keyword">False</span>)) <span class="keyword">if</span> len(neigh) &gt;= sample_num <span class="keyword">else</span> list(</span><br><span class="line">                _sample(neigh, sample_num, replace=<span class="keyword">True</span>)) <span class="keyword">for</span> neigh <span class="keyword">in</span> neighs]  <span class="comment"># 采样邻居</span></span><br><span class="line">        <span class="keyword">if</span> self_loop:</span><br><span class="line">            samp_neighs = [</span><br><span class="line">                samp_neigh + list([nodes[i]]) <span class="keyword">for</span> i, samp_neigh <span class="keyword">in</span> enumerate(samp_neighs)]  <span class="comment"># gcn邻居要加上自己</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> shuffle:</span><br><span class="line">            samp_neighs = [list(np.random.permutation(x)) <span class="keyword">for</span> x <span class="keyword">in</span> samp_neighs]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        samp_neighs = neighs</span><br><span class="line">    <span class="keyword">return</span> np.asarray(samp_neighs), np.asarray(list(map(len, samp_neighs)))</span><br></pre></td></tr></table></figure><h2 id="GAT"><a href="#GAT" class="headerlink" title="GAT"></a>GAT</h2><p><strong>图注意力网络</strong>(Graph Attention Networks, GAT)通过注意力机制对邻居节点进行聚合操作，实现对不同邻居权重的自适应分配，提高模型表达能力。</p><p>设图中任意节点$v_i$在$l$层对应的特征向量为$h^{(l)}_i \in R^{d^{(l)}}$，$d^{(l)}$表示节点的特征维数。经过以注意力机制为核心的聚合操作后，得到输出$h^{(l + 1)}_i \in R^{d^{(l + 1)}}$。</p><p>设中心节点为$v_i$，定义$W^{(l)} \in R^{d^{(l + 1)} \times d^{(l)}}$是该层节点特征变换的权重参数，$a(\cdot)$是计算两个节点相关度的函数，那么邻居节点$v_j$(可以将每个节点都视作自己的邻居)到$v_i$的权重系数为</p><script type="math/tex; mode=display">e^{(l)}_{ij} = a(W^{(l)} h^{(l)}_i, W^{(l)} h^{(l)}_j) \tag{33}</script><p>原文中，作者采用了以下函数计算权重</p><script type="math/tex; mode=display">e^{(l)}_{ij} = \text{Leaky ReLU}({a^{(l)}}^T [W^{(l)} h^{(l)}_i || W^{(l)} h^{(l)}_j]) \tag{34.1}</script><p>其中$a^{(l)} \in R^{2d^{(l + 1)}}$，$[\cdot || \cdot]$表示特征拼接操作。用softmax进行归一化，得到权重系数$\alpha^{(l)}_{ij}$</p><script type="math/tex; mode=display">\alpha^{(l)}_{ij} = \text{softmax}_j (e^{(l)}_{ij}) = \exp(e^{(l)}_{ij}) / \sum_{v_k \in \mathcal{N}(v_i)} e^{(l)}_{ik} \tag{34.2}</script><p>那么网络层输入输出的关系可以表示为</p><script type="math/tex; mode=display">h^{(l + 1)}_i = \sigma\left( \sum_{v_k \in \mathcal{N}(v_i)} \alpha^{(l)}_{ij} \cdot W^{(l)} h^{(l)}_j \right) \tag{35}</script><hr><p>为进一步提高注意力层的表达能力，可以加入<strong>多头注意力机制</strong>(mult-head attention)，具体操作是对$(35)$多次调用$K$组相互独立的注意力机制，然后将结果聚集，例如拼接操作</p><script type="math/tex; mode=display">h^{(l + 1)}_i = ||_{k=1}^K \sigma \left( \sum_{v_k \in \mathcal{N}(v_i)} {\alpha^{(l)}_{ij}}_k \cdot W_k^{(l)} h^{(l)}_j \right) \tag{36.1}</script><p>或者取均值</p><script type="math/tex; mode=display">h^{(l + 1)}_i = \frac{1}{K} \sum_{k=1}^K \sigma \left( \sum_{v_k \in \mathcal{N}(v_i)} {\alpha^{(l)}_{ij}}_k \cdot W_k^{(l)} h^{(l)}_j \right) \tag{36.2}</script><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.keras <span class="keyword">import</span> backend <span class="keyword">as</span> K</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.keras.initializers <span class="keyword">import</span> Zeros</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.keras.layers <span class="keyword">import</span> Layer, Dropout,Input</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.keras.regularizers <span class="keyword">import</span> l2</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.keras.models <span class="keyword">import</span> Model</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GATLayer</span><span class="params">(Layer)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, att_embedding_size=<span class="number">8</span>, head_num=<span class="number">8</span>, dropout_rate=<span class="number">0.5</span>, l2_reg=<span class="number">0</span>, activation=tf.nn.relu,</span></span></span><br><span class="line"><span class="function"><span class="params">                 reduction=<span class="string">'concat'</span>, use_bias=True, seed=<span class="number">1024</span>, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> head_num &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'head_num must be a int &gt; 0'</span>)</span><br><span class="line">        self.att_embedding_size = att_embedding_size</span><br><span class="line">        self.head_num = head_num</span><br><span class="line">        self.dropout_rate = dropout_rate</span><br><span class="line">        self.l2_reg = l2_reg</span><br><span class="line">        self.activation = activation</span><br><span class="line">        self.act = activation</span><br><span class="line">        self.reduction = reduction</span><br><span class="line">        self.use_bias = use_bias</span><br><span class="line">        self.seed = seed</span><br><span class="line">        super(GATLayer, self).__init__(**kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(self, input_shape)</span>:</span></span><br><span class="line"></span><br><span class="line">        X, A = input_shape</span><br><span class="line">        embedding_size = int(X[<span class="number">-1</span>])</span><br><span class="line">        self.weight = self.add_weight(name=<span class="string">'weight'</span>, shape=[embedding_size, self.att_embedding_size * self.head_num],</span><br><span class="line">                                      dtype=tf.float32,</span><br><span class="line">                                      regularizer=l2(self.l2_reg),</span><br><span class="line">                                      initializer=tf.keras.initializers.glorot_uniform())</span><br><span class="line">        self.att_self_weight = self.add_weight(name=<span class="string">'att_self_weight'</span>,</span><br><span class="line">                                               shape=[<span class="number">1</span>, self.head_num,</span><br><span class="line">                                                      self.att_embedding_size],</span><br><span class="line">                                               dtype=tf.float32,</span><br><span class="line">                                               regularizer=l2(self.l2_reg),</span><br><span class="line">                                               initializer=tf.keras.initializers.glorot_uniform())</span><br><span class="line">        self.att_neighs_weight = self.add_weight(name=<span class="string">'att_neighs_weight'</span>,</span><br><span class="line">                                                 shape=[<span class="number">1</span>, self.head_num,</span><br><span class="line">                                                        self.att_embedding_size],</span><br><span class="line">                                                 dtype=tf.float32,</span><br><span class="line">                                                 regularizer=l2(self.l2_reg),</span><br><span class="line">                                                 initializer=tf.keras.initializers.glorot_uniform())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.use_bias:</span><br><span class="line">            self.bias_weight = self.add_weight(name=<span class="string">'bias'</span>, shape=[<span class="number">1</span>, self.head_num, self.att_embedding_size],</span><br><span class="line">                                               dtype=tf.float32,</span><br><span class="line">                                               initializer=Zeros())</span><br><span class="line">        self.in_dropout = Dropout(self.dropout_rate)</span><br><span class="line">        self.feat_dropout = Dropout(self.dropout_rate, )</span><br><span class="line">        self.att_dropout = Dropout(self.dropout_rate, )</span><br><span class="line">        <span class="comment"># Be sure to call this somewhere!</span></span><br><span class="line">        super(GATLayer, self).build(input_shape)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(self, inputs, training=None, **kwargs)</span>:</span></span><br><span class="line"></span><br><span class="line">        X, A = inputs</span><br><span class="line">        X = self.in_dropout(X)  <span class="comment"># N * D</span></span><br><span class="line">        <span class="comment"># A = self.att_dropout(A, training=training)</span></span><br><span class="line">        <span class="keyword">if</span> K.ndim(X) != <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(</span><br><span class="line">                <span class="string">"Unexpected inputs dimensions %d, expect to be 2 dimensions"</span> % (K.ndim(X)))</span><br><span class="line"></span><br><span class="line">        features = tf.matmul(X, self.weight, )  <span class="comment"># None F'*head_num</span></span><br><span class="line">        features = tf.reshape(</span><br><span class="line">            features, [<span class="number">-1</span>, self.head_num, self.att_embedding_size])  <span class="comment"># None head_num F'</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># attn_for_self = K.dot(features, attention_kernel[0])  # (N x 1), [a_1]^T [Wh_i]</span></span><br><span class="line">        <span class="comment"># attn_for_neighs = K.dot(features, attention_kernel[1])  # (N x 1), [a_2]^T [Wh_j]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># head_num None F D --- &gt; head_num None(F) D</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># querys = tf.stack(tf.split(querys, self.head_num, axis=1))</span></span><br><span class="line">        <span class="comment"># keys = tf.stack(tf.split(keys, self.head_num, axis=1))#[?,1,1433,64]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># features = tf.stack(tf.split(features, self.head_num, axis=1))  # head_num None F'</span></span><br><span class="line">        attn_for_self = tf.reduce_sum(</span><br><span class="line">            features * self.att_self_weight, axis=<span class="number">-1</span>, keep_dims=<span class="keyword">True</span>)  <span class="comment"># None head_num 1</span></span><br><span class="line">        attn_for_neighs = tf.reduce_sum(</span><br><span class="line">            features * self.att_neighs_weight, axis=<span class="number">-1</span>, keep_dims=<span class="keyword">True</span>)</span><br><span class="line">        dense = tf.transpose(attn_for_self, [<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>]) + \</span><br><span class="line">                    tf.transpose(attn_for_neighs, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        dense = tf.nn.leaky_relu(dense, alpha=<span class="number">0.2</span>)</span><br><span class="line">        mask = <span class="number">-10e9</span> * (<span class="number">1.0</span> - A)</span><br><span class="line">        dense += tf.expand_dims(mask, axis=<span class="number">0</span>)  <span class="comment"># [?,8,8], [1,?,2708]</span></span><br><span class="line"></span><br><span class="line">        self.normalized_att_scores = tf.nn.softmax(</span><br><span class="line">            dense, dim=<span class="number">-1</span>, )  <span class="comment"># head_num None(F) None(F)</span></span><br><span class="line"></span><br><span class="line">        features = self.feat_dropout(features, )</span><br><span class="line">        self.normalized_att_scores = self.att_dropout(</span><br><span class="line">            self.normalized_att_scores)</span><br><span class="line"></span><br><span class="line">        result = tf.matmul(self.normalized_att_scores,</span><br><span class="line">                           tf.transpose(features, [<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>]))  <span class="comment"># head_num None F D   [8,2708,8] [8,2708,3]</span></span><br><span class="line">        result = tf.transpose(result, [<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>])  <span class="comment"># None head_num attsize</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.use_bias:</span><br><span class="line">            result += self.bias_weight</span><br><span class="line"></span><br><span class="line">        <span class="comment"># head_num Node embeding_size</span></span><br><span class="line">        <span class="keyword">if</span> self.reduction == <span class="string">"concat"</span>:</span><br><span class="line">            result = tf.concat(</span><br><span class="line">                tf.split(result, self.head_num, axis=<span class="number">1</span>), axis=<span class="number">-1</span>)</span><br><span class="line">            result = tf.squeeze(result, axis=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result = tf.reduce_mean(result, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.act:</span><br><span class="line">            result = self.activation(result)</span><br><span class="line"></span><br><span class="line">        result._uses_learning_phase = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute_output_shape</span><span class="params">(self, input_shape)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.reduction == <span class="string">"concat"</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">None</span>, self.att_embedding_size * self.head_num)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">None</span>, self.att_embedding_size)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_config</span><span class="params">(self, )</span>:</span></span><br><span class="line">        config = &#123;<span class="string">'att_embedding_size'</span>: self.att_embedding_size, <span class="string">'head_num'</span>: self.head_num, <span class="string">'use_res'</span>: self.use_res,</span><br><span class="line">                  <span class="string">'seed'</span>: self.seed&#125;</span><br><span class="line">        base_config = super(GATLayer, self).get_config()</span><br><span class="line">        <span class="keyword">return</span> dict(list(base_config.items()) + list(config.items()))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GAT</span><span class="params">(adj_dim,feature_dim,num_class,num_layers=<span class="number">2</span>,n_attn_heads = <span class="number">8</span>,att_embedding_size=<span class="number">8</span>,dropout_rate=<span class="number">0.0</span>,l2_reg=<span class="number">0.0</span>,use_bias=True)</span>:</span></span><br><span class="line">    X_in = Input(shape=(feature_dim,))</span><br><span class="line">    A_in = Input(shape=(adj_dim,))</span><br><span class="line">    h = X_in</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(num_layers<span class="number">-1</span>):</span><br><span class="line">        h = GATLayer(att_embedding_size=att_embedding_size, head_num=n_attn_heads, dropout_rate=dropout_rate, l2_reg=l2_reg,</span><br><span class="line">                                     activation=tf.nn.elu, use_bias=use_bias, )([h, A_in])</span><br><span class="line"></span><br><span class="line">    h = GATLayer(att_embedding_size=num_class, head_num=<span class="number">1</span>, dropout_rate=dropout_rate, l2_reg=l2_reg,</span><br><span class="line">                                 activation=tf.nn.softmax, use_bias=use_bias, reduction=<span class="string">'mean'</span>)([h, A_in])</span><br><span class="line"></span><br><span class="line">    model = Model(inputs=[X_in, A_in], outputs=h)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure><h2 id="R-GCN"><a href="#R-GCN" class="headerlink" title="R-GCN"></a>R-GCN</h2><p>R-GCN用于对节点不同关系进行建模，之前介绍的GCN模型都是考虑同构图，而现实生活中图数据往往是异构的。例如在搜索某人的信息时，异构图中需要考虑与其在多种关系图中有关联的人员，如国籍、年龄、出生地等，而关系间没有很大的关联性。</p><p>R-GCN基于GCN的聚合邻居操作，<strong>增加了聚合关系的维度，使得节点的聚合操作变成双重聚合过程</strong>，如下</p><script type="math/tex; mode=display">h^{(l + 1)}_i =     \sigma \left( \sum_{r \in R}        \sum_{v_k \in \mathcal{N}_r(v_i)}             \frac{1}{ {c_i}_r }            W_r^{(l)} h^{(l)}_j +             W_o^{(l)} h^{(l)}_i    \right) \tag{37}</script><p>其中</p><ul><li>$R$表示所有关系的集合；</li><li>$\mathcal{N}_r(v_i)$表示与节点$v_i$具有$r$关系的邻居集合；</li><li>${c_i}_r$用于归一化，如${c_i}_r = |\mathcal{N}_r(v_i)|$；</li><li>$W_r^{(l)}$是具有$r$关系的邻居对应的权重系数；</li><li>$W_o^{(l)}$是节点自身对应的权重系数。</li></ul><hr><p>但是以上方式存在以下问题</p><ul><li>多关系图中可能包含大量关系，如果为每一种关系设计一组权重，那么单层R-GCN参数量十分庞大；</li><li>不同关系的节点数目不同，例如不常见关对应的权重参数非常少，增加了过拟合风险。</li></ul><p>R-GCN提出了对$W_r^{(l)}$进行<strong>基分解</strong>(basic decomposition)，即</p><script type="math/tex; mode=display">W_r^{(l)} = \sum_{b=1}^B { {a_b}_r }^{(l)} V_b^{(l)} \tag{38.1}</script><p>其中$V_b^{(l)} \in R^{d^{(l + 1)} \times d^{(l)}}$，${ {a_b}_r }^{(l)}$是分解系数，$B$是控制分解个数的超参数(一般取$B &lt;&lt; \min(|R|,  d^{(l + 1)} \times d^{(l)})$)。那么经过分解后，参数量是原来的</p><script type="math/tex; mode=display">\frac{(|R| + d^{(l + 1)} \times d^{(l)}) \times B}{|R| \times d^{(l + 1)} \times d^{(l)}} \tag{38.2}</script><h1 id="图分类"><a href="#图分类" class="headerlink" title="图分类"></a>图分类</h1><p><strong>图分类问题</strong>与节点层面任务不同，给定多张图及其对应标签，需要通过学习得出一个<strong>由图到相应标签的图分类模型</strong>。需要关注图数据的<strong>全局信息</strong>(包括图的结构信息和各个节点的属性信息)，重点在于如何通过学习得到一个优秀的全图表示向量。</p><p>图分类任务与视觉中图像分类一样，需要对全局的信息进行融合学习。CNN中通常采用的方法是<strong>层次化池化</strong>(Hierarchical Pooling)。由于图像数据为规则的栅格结构，固定大小和步长的滑窗使最大池化或平均池化等简单操作都能高效地提取高阶信息，但非规则结构的图数据无法直接迁移这类池化操作。</p><p>以下主要介绍两个部分：基于一次性全局池化的图分类、基于层次化池化的图分类。</p><h2 id="基于一次性全局池化的图分类"><a href="#基于一次性全局池化的图分类" class="headerlink" title="基于一次性全局池化的图分类"></a>基于一次性全局池化的图分类</h2><p>类似CNN模型中常用的最后一个卷积层的<strong>全局池化</strong>(Global Pooling)，这种方法对经过$K$轮迭代的所有节点进行一次性聚合操作，得到全图的全局表示</p><script type="math/tex; mode=display">y = R(\{ h^{(k)}_i | \forall v_i \in V \}) \tag{39}</script><p>$R$可以是Sum、Mean、Max等类型的函数。考虑到<strong>经过$K$仑迭代后，各个节点的表达会接近全局表达，所以能较好地提取全局信息</strong>。但是这种处理方法本质上是将输入数据看作平整且规则的结构数据，<strong>丢失了图数据中丰富的结构信息</strong>，适用于结构信息相对单一的小规模图数据；</p><h2 id="基于层次化池化的图分类"><a href="#基于层次化池化的图分类" class="headerlink" title="基于层次化池化的图分类"></a>基于层次化池化的图分类</h2><h3 id="基于图坍缩的池化机制"><a href="#基于图坍缩的池化机制" class="headerlink" title="基于图坍缩的池化机制"></a>基于图坍缩的池化机制</h3><p>将图划分成不同的子图，然后将子图视作<strong>超级节点</strong>，从而形成坍缩的图。</p><p>给定图$G$，通过某种划分策略得到$K$个子图${G^{(k), k = 1, \cdots, K}}$，子图$G^{(k)}$中的节点个数为$N_k$、节点列表为$\Gamma^{(k)}$，并定义两个关键矩阵：</p><ul><li><p><strong>簇分配矩阵</strong>$S \in R^{N \times K}$：当且仅当$v_i \in \Gamma^{(k)}$时，有$S_{ik} = 1$。考察一下<strong>簇分配矩阵$S$的含义</strong>，有</p><script type="math/tex; mode=display">{ A_{coar} }_{K \times K} = S^T A S \tag{40}</script><p>  $A_{coar}$描述了<strong>图坍塌后超级节点之间的连接强度</strong>，${ A_{coar} }_{ii}$是超级节点自身内部的连接强度。</p></li><li><p><strong>采样算子</strong>$C^{(k)} \in R^{N \times N_k}$，$N_k$是簇$k$中结点的个数：当且仅当$v_i = \Gamma^{(k)}_j$时，有$C_{ij} = 1$。<br>  假定定义在$G$上的$1$维图信号为$x \in R^{N}$，下面两个式子完成了对图信号的<strong>下采样</strong>(切片)和<strong>上采样</strong>操作</p><script type="math/tex; mode=display">  \begin{aligned}      x^{(K)} & = { C^{(k)} }^T x & 取出包含节点对应维度的图信号 \\      \overline{x} & = C^{(k)} x^{(K)} & 在不包含的节点对应维度处补0 \\  \end{aligned}</script><p>  那么可以通过采样算子<strong>获取子图的邻接矩阵</strong></p><script type="math/tex; mode=display">A^{(k)} = { C^{(k)} }^T A C^{(k)} \tag{41}</script></li></ul><p>通过$(40)$和$(41)$可以确定簇内的邻接关系和簇间的邻接关系。那么如果能够确定簇内信号的融合方法，将结果表示为超级节点上的信号，那么迭代重复上述过程就可以获得越来越全局的图信号。</p><hr><p>如下图所示</p><p><img src="/2020/06/13/Graph-Neural-Network/graph_coarsening.jpg" alt="graph_coarsening"></p><p>那么有邻接矩阵</p><script type="math/tex; mode=display">A = \begin{bmatrix}    0 & 1 & 1 & 0 & 0 & 0 \\    1 & 0 & 1 & 0 & 0 & 0 \\    1 & 1 & 0 & 1 & 0 & 0 \\    0 & 0 & 1 & 0 & 1 & 1 \\    0 & 0 & 0 & 1 & 0 & 1 \\    0 & 0 & 0 & 1 & 1 & 0\end{bmatrix}</script><p>按图中分为两个簇，$\Gamma^{(1)} = {v_1, v_2, v_3}, \Gamma^{(2)} = {v_4, v_5, v_6}$，那么<strong>簇分配矩阵</strong>为</p><script type="math/tex; mode=display">S = \begin{bmatrix}    1 & 0 \\    1 & 0 \\    1 & 0 \\    0 & 1 \\    0 & 1 \\    0 & 1\end{bmatrix}</script><p><strong>采样算子</strong>有</p><script type="math/tex; mode=display">C^{(1)} = \begin{bmatrix}    1 & 0 & 0 \\    0 & 1 & 0 \\    0 & 0 & 1 \\    0 & 0 & 0 \\    0 & 0 & 0 \\    0 & 0 & 0\end{bmatrix}, C^{(2)} = \begin{bmatrix}    0 & 0 & 0 \\    0 & 0 & 0 \\    0 & 0 & 0 \\    1 & 0 & 0 \\    0 & 1 & 0 \\    0 & 0 & 1\end{bmatrix}</script><p>在本例中<strong>超级节点间的邻接矩阵</strong>为</p><script type="math/tex; mode=display">A_{coar} = S^T A S = \begin{bmatrix}6 & 1 \\ 1 & 6 \end{bmatrix}</script><p><strong>子图$G^{(1)}$内的邻接矩阵</strong>为</p><script type="math/tex; mode=display">A^{(1)} = { C^{(1)} }^T A C^{(1)} = \begin{bmatrix}0 & 1 & 1 \\ 1 & 0 & 1 \\ 1 & 1 & 0 \end{bmatrix}</script><h4 id="DIFFPOOL"><a href="#DIFFPOOL" class="headerlink" title="DIFFPOOL"></a>DIFFPOOL</h4><p>DIFFPOOL是首个将图坍塌过程和GNN结合起来进行图层面任务学习的算法。提<strong>出了一个可学习的簇分配矩阵，具体地就是通过GNN对每个节点进行特征学习，然后通过另一个GNN为节点学习出所属各个簇的概率分布</strong></p><script type="math/tex; mode=display">\begin{aligned}    特征学习: & Z^{(l)} = & GNN_{l, embed}(A^{(l)}, H^{(l)}) \\    簇概率分布学习: & S^{(l)} = & softmax \left( GNN_{l, pool}(A^{(l)}, H^{(l)}) \right)\end{aligned} \tag{42.1}</script><p>其中</p><ul><li>$A^{(l)} \in R^{n^{(l)} \times n^{(l)}}, S^{(l)} \in R^{n^{(l)} \times n^{(l + 1)}}$，$n^{(l)}$表示第$l$层的节点数；</li><li>相比较$(40)$的簇分配矩阵，这里的$S$是一个软分配器，值表示节点被分配到任意一个簇的概率，由于概率不为$0$，所以这是一个下层超级节点到上层所有节点之间的全连接结构；</li><li>$GNN_{l, embed}, GNN_{l, pool}$是两个独立的GNN层，输入相同但参数不同，学习任务也不同；</li><li>最后一层的簇分配矩阵，需要将图坍缩成一个超级节点，所以直接将该矩阵固定成全$1$的矩阵。</li></ul><p>基于上述两个GNN层的输出，可以对图进行坍缩，定义<strong>DIFFPOOL层</strong>$\left( (A^{(l)}, Z^{(l)}) \rightarrow (A^{(l+1)}, H^{(l+1)}) \right)$，由以下两部分组成</p><script type="math/tex; mode=display">\begin{aligned}    簇内节点的特征加和处理: & H^{(l+1)} = & { S^{(l)} }^T Z^{(l)} \\    簇间邻接矩阵计算: & A^{(l+1)} = & { S^{(l)} }^T A^{(l)} S^{(l)}\end{aligned} \tag{42.2}</script><h4 id="EigenPooling"><a href="#EigenPooling" class="headerlink" title="EigenPooling"></a>EigenPooling</h4><p>EigenPooling没有对图分类模型引入任何需要学习的参数，<strong>其核心步骤在于作用域的选取以及池化操作。</strong></p><ul><li><p>EigenPooling借用一些<strong>图分区的算法</strong>来实现图的划分，如谱聚类算法，划分后用式$(40)$得到超级节点间的邻接关系</p><script type="math/tex; mode=display">{ A_{coar} }_{K \times K} = S^T A S \tag{40}</script></li><li><p>用子图上的信号在该子图上的<strong>图傅里叶变换</strong>来代表结构信息与属性信息的整合输出(详细略)。</p></li></ul><h3 id="基于TopK的池化机制"><a href="#基于TopK的池化机制" class="headerlink" title="基于TopK的池化机制"></a>基于TopK的池化机制</h3><p>对图中每个节点学习得到一个分数，<strong>基于分数的排序丢弃一些低分数的节点</strong>。这种方法借鉴了最大池化的思路：将更重要的信息筛选出来，但是图数据难以实现局部滑窗，需要依据分数进行全局筛选。</p><p>具体来说，首先设置一个表示池化率的超参数$k \in (0, 1)$，接着学习出一个表示节点重要度的值$z$并对其进行降序排序，然后将全图中$N$个节点下采样至$kN$个，即</p><script type="math/tex; mode=display">i = top-rank(z, kN) \tag{43.1}</script><script type="math/tex; mode=display">X' = X_{i,:} \tag{43.2}</script><script type="math/tex; mode=display">A' = A_{i, i} \tag{43.3}</script><p>其中</p><ul><li>$i$为索引向量，即Topk中的索引；</li><li>$X_{i,:}$表示按向量$i$的值对特征矩阵按行切片；</li><li>$A_{i, i}$表示按向量$i$的值对邻接决战同时进行行切片与列切片。</li></ul><hr><p>关于节点重要度的学习，在<a href="https://arxiv.org/abs/1811.01287" target="_blank" rel="noopener">[1811.01287] Towards Sparse Hierarchical Graph Classifiers</a>一文中，作者为图分类模型设置了全局基向量$p$，<strong>将节点特征向量在该基向量的投影视作重要度</strong></p><script type="math/tex; mode=display">z = X \cdot \frac{p}{||p||} \tag{44.1}</script><p>有以下两个作用</p><ul><li>可以以投影大小确定Topk排序；</li><li>投影大小起到了梯度门限的作用，投影越大其梯度更新增幅越大。</li></ul><p><strong>全部细节如下</strong></p><script type="math/tex; mode=display">z = \frac{Xp}{||p||}, i = top-rank(z, kN) \tag{44.2}</script><script type="math/tex; mode=display">X' = (X \odot tanh(z))_{i, :} \tag{44.3}</script><script type="math/tex; mode=display">A' = A_{i, i} \tag{44.4}</script><p>$(44.3)$中点乘$tanh(z)$相当于利用节点的重要度对节点特征做一次收缩变换，进一步强化了对重要度高的节点的梯度学习，这一操作被称为<strong>gpool层</strong>。这种采取层层丢弃节点的做法，可以提高远距离节点的融合效率，但是会使其缺乏对所有节点进行有效信息融合的手段。因此，作者选择<strong>在每个gpool层后跟随读出层，实现对该尺度下图的全局信息的一次性聚合</strong></p><script type="math/tex; mode=display">s = \underbrace{\frac{1}{N} \sum_{i=1}^N x_i'}_{全局平均池化} || \underbrace{\max_{i=1}^N  x_i'}_{全局最大池化} \tag{44.5}</script><p>最终将各层的$s$相加。得到<strong>全图的表示</strong></p><script type="math/tex; mode=display">s = \sum_{l=1}^L s^{(l)} \tag{44.6}</script><h3 id="基于边收缩的池化机制"><a href="#基于边收缩的池化机制" class="headerlink" title="基于边收缩的池化机制"></a>基于边收缩的池化机制</h3><p><strong>基于边收缩的池化机制EdgePool</strong>，通过迭代式地对每条边上的节点进行两两归并形成新节点，同时保留合并前节点的连接关系到新结点上。有个问题如何在某节点的多条边中选择用于收缩的边，EdgePool的解决方法是对每条边设计一个分数，根据该分数进行非重复式的挑选和合并，具体操作如下</p><ul><li><p>计算每条边的<strong>原始分数</strong>$r$</p><script type="math/tex; mode=display">r_{ij} = w^T [h_i || h_j] + b \tag{45.1}</script></li><li><p>对原始分数沿邻居节点进行<strong>归一化</strong></p><script type="math/tex; mode=display">s_{ij} = softmax_j (r_ij) \tag{45.2}</script></li><li><p>对所有$s_{ij}$进行排序，依次选择<strong>分数最高的且未被选中的两个节点</strong>进行收缩操作，并用求和的方式求取合并之后的节点特征</p><script type="math/tex; mode=display">h_{ij} = s \cdot (h_i + h_j), s = \max(s_{ij}, s_{ji}) \tag{45.3}</script><p>  其中分数$s$用于对节点特征进行收缩处理。</p><blockquote><p>注意：未被选中的两个节点才进行合并，即将节点归并比严格控制在$0.5$。</p></blockquote></li></ul><h1 id="图表示学习"><a href="#图表示学习" class="headerlink" title="图表示学习"></a>图表示学习</h1><p>前面使用邻接矩阵$A \in R^{N \times N}$表示图的结构信息，一般来说$A$是一个高维且稀疏的矩阵，直接用$A$去表示图数据，相关的任务学习难以高效。<strong>图表示学习的主要目标是将图数据转化成低维稠密的向量化表示，同时确保图数据的某些性质在向量空间中也得到对应。</strong></p><h2 id="基于重构损失的GNN"><a href="#基于重构损失的GNN" class="headerlink" title="基于重构损失的GNN"></a>基于重构损失的GNN</h2><p>类比自编码器的思路，可以将节点间的邻接关系进行重构学习，定义<strong>图自编码器</strong>(Graph Auto Encoder)</p><script type="math/tex; mode=display">Z = GNN(X, A) \tag{46.1}</script><script type="math/tex; mode=display">\hat{A} = \sigma(Z Z^T) \tag{46.2}</script><p>其中</p><ul><li>$Z$是所有节点的表示，借助GNN模型同时对图的属性信息和结构信息进行编码学习；</li><li>$\hat{A}$是重构之后的邻接矩阵，这里使用向量内积表示节点之间对的邻接关系。</li></ul><p>图自编码器的重构损失定义为</p><script type="math/tex; mode=display">L_{recon} = || \hat{A} - A ||_2^2 \tag{46.3}</script><p>由于<strong>过平滑问题</strong>，GNN可以轻易将相邻节点学习出相似的表达，导致$\hat{A}$能很快趋近于原始邻接矩阵$A$，模型参数难以有效优化。那么同自编码器一样，对损失函数加上一些约束目标。如对输入数据进行一定扰动，迫使模型从加噪数据中提取有用的信息，包括</p><ul><li>对原图数据的特征矩阵$X$适当增加随机噪声或随机置$0$；</li><li>对原图数据的邻接矩阵$A$删除适当比例的边，或修改边上的权重值。</li></ul><p>还有如基于<strong>变分自编码器</strong>(VAE)的图表示学习方法。</p><h2 id="基于对比损失的GNN"><a href="#基于对比损失的GNN" class="headerlink" title="基于对比损失的GNN"></a>基于对比损失的GNN</h2><p>对比损失是无监督表示学习中一种常见的损失函数。通过设置<strong>评分函数</strong>$D(\cdot)$，在学习过程中将会提高正样本的评分，降低负样本的评分。</p><p>类比词向量，<strong>在图数据中上下文代表与节点有对应关系的对象，从小到大依次可以是节点的邻居、节点所处的子图、全图</strong>。作为节点与上下文之间存在的固有关系，我们希望评分函数提高节点与上下文对的得分、降低节点与非上下文对的得分，即</p><script type="math/tex; mode=display">L_{v_i} = - \log (D(z_i, c)) + \log (D(z_i, \overline{c})) \tag{47}</script><p>其中$c$表示上下文的表示向量，$\overline{c}$表示非上下文的表示向量。</p><h3 id="邻居上下文"><a href="#邻居上下文" class="headerlink" title="邻居上下文"></a>邻居上下文</h3><p><strong>将邻居节点作为上下文，那么就是建模节点与邻居节点的共现关系</strong>。GraphSAGE中描述了这样一种方法，在随机游走时与中心节点$v_i$一起出现在固定长度窗口内的节点$v_j$视作邻居，通过负采样手段将不符合该关系的节点作为负样本</p><script type="math/tex; mode=display">Z = GNN(X, A) \tag{48.1}</script><script type="math/tex; mode=display">L_{v_i} = \log(1 - \sigma(z_i^T z_j)) + E_{v_n \sim p_n(v_i)} \log (\sigma(z_i^T z_{v_n})) \tag{48.2}</script><p>其中</p><ul><li>$p_n(v_i)$是一个关于节点出现概率的<strong>负采样分布</strong>；</li><li><strong>得分函数</strong>使用向量内积加$sigmoid$函数的形式，将分数限制在$[0, 1]$内。</li></ul><p><strong>但是这种方式强调节点之间的共现关系，更多反映了图中节点间的距离远近，缺乏对节点结构相似性的捕捉。</strong></p><h3 id="子图上下文"><a href="#子图上下文" class="headerlink" title="子图上下文"></a>子图上下文</h3><p><a href="https://arxiv.org/abs/1905.12265" target="_blank" rel="noopener">[1905.12265] Pre-training Graph Neural Networks</a>一文中提出这样一种方法，将子图作为节点的上下文进行对比学习。用GNN在节点$v_i$的$K$阶子图上提取<strong>表示向量</strong>；在$r_1-hop$与$r_2-hop$之间的节点定义为$v_i$的上下文锚点，用GNN提取该范围内每个节点作为上下文锚点时的表示向量，然后聚合上下文锚点的表示向量得到一个总的、固定长度的<strong>上下文表示向量</strong>。具体地</p><script type="math/tex; mode=display">Z = GNN(X, A) \tag{49.1}</script><script type="math/tex; mode=display">Z_{context} = GNN_{context}(X, A) \tag{49.2.1}</script><script type="math/tex; mode=display">c_i = R\left( \{ Z_{context}[j], \forall v_j \in C_{v_i} \} \right) \tag{49.2.2}</script><script type="math/tex; mode=display">L_{v_i} = \log(1 - \sigma(z_i^T c_i)) + \log(\sigma(z_i^T c_{j | j \neq i})) \tag{49.3}</script><p>其中$C_{v_i}$表示节点$v_i$的上下文锚点集合，示意图如下<br><img src="/2020/06/13/Graph-Neural-Network/subgraph_context.jpg" alt="subgraph_context"></p><h3 id="全图上下文"><a href="#全图上下文" class="headerlink" title="全图上下文"></a>全图上下文</h3><p>Deep Graph Infmax(DGI)，略。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://github.com/shenweichen/GraphNeuralNetwork" target="_blank" rel="noopener">shenweichen/GraphNeuralNetwork</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Efficient Feature Selection</title>
      <link href="/2020/06/12/Efficient-Feature-Selection/"/>
      <url>/2020/06/12/Efficient-Feature-Selection/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>《数据挖掘》中介绍许多数据处理方法，但对特征选择没有深入介绍，本文对这方面的方法进行汇总介绍，并结合sklearn做一些样例。</p><blockquote><p><a href="TODO:">Data-Mining - LOUIS’ BLOG</a>。</p></blockquote><ul><li><a href="#目录">目录</a></li><li><a href="#过滤方法filter">过滤方法(Filter)</a><ul><li><a href="#方差阈值variance-threshold">方差阈值(Variance Threshold)</a></li><li><a href="#单变量选择univariate-feature-selection">单变量选择(Univariate Feature Selection)</a><ul><li><a href="#相关系数correlation-coefficient">相关系数(Correlation Coefficient)</a></li><li><a href="#卡方检验chi-square-test">卡方检验(Chi-Square Test)</a></li><li><a href="#互信息mutual-information">互信息(Mutual Information)</a></li><li><a href="#最大信息系数maximal-information-coefficient-mic">最大信息系数(Maximal Information Coefficient, MIC)</a></li><li><a href="#信息增益information-gain">信息增益(Information Gain)</a></li></ul></li></ul></li><li><a href="#包裹方法wrapper">包裹方法(Wrapper)</a><ul><li><a href="#递归特征消除recursive-feature-elimination-ref">递归特征消除(Recursive Feature Elimination, REF)</a></li><li><a href="#拉斯维加斯方法las-vegas-wrapper-lvw">拉斯维加斯方法(Las Vegas Wrapper, LVW)</a><ul><li><a href="#lv随机算法">LV随机算法</a></li><li><a href="#lvw特征选择">LVW特征选择</a></li></ul></li></ul></li><li><a href="#嵌入方法embedded">嵌入方法(Embedded)</a><ul><li><a href="#惩罚项方法regularization">惩罚项方法(Regularization)</a><ul><li><a href="#线性回归的最小二乘估计和贝叶斯估计">线性回归的最小二乘估计和贝叶斯估计</a></li><li><a href="#lassol1">LASSO(L1)</a></li><li><a href="#ridgel2">Ridge(L2)</a></li><li><a href="#least-angel-regressionlars">Least Angel Regression(LARS)</a></li></ul></li><li><a href="#基于树的方法tree-based">基于树的方法(Tree-based)</a><ul><li><a href="#决策树decision-tree">决策树(Decision Tree)</a></li><li><a href="#随机森林random-forest-rf">随机森林(Random Forest, RF)</a></li><li><a href="#梯度提升树gbdt">梯度提升树(GBDT)</a></li></ul></li></ul></li><li><a href="#reference">Reference</a></li></ul><p><img src="/2020/06/12/Efficient-Feature-Selection/feature_engineering.jpg" alt="feature_engineering"><br><img src="/2020/06/12/Efficient-Feature-Selection/feature_selection_methods.png" alt="feature_selection_methods"></p><h1 id="过滤方法-Filter"><a href="#过滤方法-Filter" class="headerlink" title="过滤方法(Filter)"></a>过滤方法(Filter)</h1><p>过滤法只用于检验特征向量和目标(响应变量)的相关度，不需要任何的机器学习的算法，不依赖于任何模型，只是应用统计量做筛选：我们根据统计量的大小，设置合适的阈值，将低于阈值的特征剔除。</p><p>所以，从某种程度上来说，过滤法更像是一个数学问题，我们只在过滤之后的特征子集上进行建模和训练。</p><h2 id="方差阈值-Variance-Threshold"><a href="#方差阈值-Variance-Threshold" class="headerlink" title="方差阈值(Variance Threshold)"></a>方差阈值(Variance Threshold)</h2><p>一种最简单的方法，<strong>移除方差较小的特征，</strong>可以用于离散或连续的变量。如下，三列方差分别为$0.13888889, 0.22222222, 0.25$，阈值设置为$0.8 \times (1 - 0.8) = 0.16$，第一列被删除。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> VarianceThreshold</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sel = VarianceThreshold(threshold=(<span class="number">.8</span> * (<span class="number">1</span> - <span class="number">.8</span>)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sel.fit_transform(X)</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>]])</span><br></pre></td></tr></table></figure></p><h2 id="单变量选择-Univariate-Feature-Selection"><a href="#单变量选择-Univariate-Feature-Selection" class="headerlink" title="单变量选择(Univariate Feature Selection)"></a><a href="https://scikit-learn.org/stable/modules/feature_selection.html#univariate-feature-selection" target="_blank" rel="noopener">单变量选择(Univariate Feature Selection)</a></h2><p>分别计算每个特征的某个统计指标，根据该指标来判断哪些指标重要，剔除那些不重要的指标</p><blockquote><p>These objects take as input <strong>a scoring function that returns univariate scores and p-values</strong> (or only scores for <code>SelectKBest</code> and <code>SelectPercentile</code>):</p><ul><li><strong>For regression</strong>: <code>f_regression</code>, <code>mutual_info_regression</code></li><li><strong>For classification</strong>: <code>chi2</code>, <code>f_classif</code>, <code>mutual_info_classif</code></li></ul></blockquote><h3 id="相关系数-Correlation-Coefficient"><a href="#相关系数-Correlation-Coefficient" class="headerlink" title="相关系数(Correlation Coefficient)"></a>相关系数(Correlation Coefficient)</h3><p>单变量选择方法，通过<strong>计每个算特征与标签的相关系数，来评估特征的重要性</strong>，计算方式如下</p><script type="math/tex; mode=display">\rho = \frac{Cov(X, Y)}{\sqrt{D(X)} \sqrt{D(Y)}} =   \frac{\sum_j (X_j - \overline{X}) (Y_j - \overline{Y})}  {    \sqrt{\sum_j (X_j - \overline{X})^2}     \sqrt{\sum_j (Y_j - \overline{Y})^2}  }</script><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> pearsonr</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">corr</span><span class="params">(X, Y)</span>:</span></span><br><span class="line"><span class="meta">... </span>    _corr = <span class="keyword">lambda</span> X, Y: np.array(list(</span><br><span class="line"><span class="meta">... </span>              map(<span class="keyword">lambda</span> x: pearsonr(x, Y), X.T))).T</span><br><span class="line"><span class="meta">... </span>    _tolist = <span class="keyword">lambda</span> x: list(map(list, x))</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> _tolist(_corr(X, Y))</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X, y = load_iris(return_X_y=<span class="keyword">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_new = SelectKBest(corr, k=<span class="number">2</span>).fit_transform(X, y)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X.shape</span><br><span class="line">(<span class="number">150</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_new.shape</span><br><span class="line">(<span class="number">150</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="卡方检验-Chi-Square-Test"><a href="#卡方检验-Chi-Square-Test" class="headerlink" title="卡方检验(Chi-Square Test)"></a>卡方检验(Chi-Square Test)</h3><p>卡方检验用于<strong>统计样本的实际观测值于理论推断值之间的偏离程度</strong>，卡方值越大表示越偏离，假设有两个$0-1$变量$X, Y$，由统计信息可以得到<strong>观测四格表</strong></p><div class="table-container"><table><thead><tr><th></th><th>$X$</th><th>$\overline{X}$</th><th>合计</th></tr></thead><tbody><tr><td>$Y$</td><td>$a$</td><td>$b$</td><td>$a + b$</td></tr><tr><td>$\overline{Y}$</td><td>$c$</td><td>$d$</td><td>$c + d$</td></tr><tr><td>合计</td><td>$a + c$</td><td>$b + d$</td><td>$N$</td></tr></tbody></table></div><p>建立<strong>无关性假设</strong>：$X$与$Y$是独立无关的，那么随机抽取一个样本</p><ul><li>属于$X$的概率是$p = (a + c) / N$</li><li>属于$\overline{X}$的概率是$1 - p = (b + d) / N$</li></ul><p>那么可得<strong>理论值四格表</strong>如下</p><div class="table-container"><table><thead><tr><th></th><th>$X$</th><th>$\overline{X}$</th><th>合计</th></tr></thead><tbody><tr><td>$Y$</td><td>$\overline{a} = (a + b) \times p$</td><td>$\overline{b} = (a + b) \times (1 - p)$</td><td>$a + b$</td></tr><tr><td>$\overline{Y}$</td><td>$\overline{c} = (c + d) \times p$</td><td>$\overline{d} = (c + d) \times (1 - p)$</td><td>$c + d$</td></tr><tr><td>合计</td><td>$N \times p$</td><td>$N \times (1 - p)$</td><td>$N$</td></tr></tbody></table></div><p>那么卡方值可以由下式计算</p><script type="math/tex; mode=display">\chi^2 = \sum_{x \in \{a, b, c, d\}}   \frac{(x - \overline{x})^2}{x}</script><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> chi2</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X, y = load_iris(return_X_y=<span class="keyword">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_new = SelectKBest(chi2, k=<span class="number">2</span>).fit_transform(X, y)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X.shape</span><br><span class="line">(<span class="number">150</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_new.shape</span><br><span class="line">(<span class="number">150</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="互信息-Mutual-Information"><a href="#互信息-Mutual-Information" class="headerlink" title="互信息(Mutual Information)"></a>互信息(Mutual Information)</h3><p>用于评估互信息(Mutual Information)是信息论里一种有用的信息度量，它可以看成是一个随机变量中包含的关于另一个随机变量的信息量，或者说是一个随机变量由于已知另一个随机变量而减少的不肯定性。</p><p>设随机变量$X, Y$得联合分布为$p(x, y)$，边缘分布分别为$p(x), p(y)$，那么互信息是联合分布$p(x, y)$与边缘分布$p(x), p(y)$的相对熵，即</p><script type="math/tex; mode=display">I(X; Y) = \sum_x \sum_y p(x, y) \log \frac{p(x, y)}{p(x) p(y)}</script><p>它有一些<strong>缺点</strong></p><ul><li>不属于度量方式，也不能进行归一化，不同数据集上结果无法比较；</li><li>对于连续变量，需要先进行离散化才能计算。</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> mutual_info_classif</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X, y = load_iris(return_X_y=<span class="keyword">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_new = SelectKBest(mutual_info_classif, k=<span class="number">2</span>).fit_transform(X, y)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X.shape</span><br><span class="line">(<span class="number">150</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_new.shape</span><br><span class="line">(<span class="number">150</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="最大信息系数-Maximal-Information-Coefficient-MIC"><a href="#最大信息系数-Maximal-Information-Coefficient-MIC" class="headerlink" title="最大信息系数(Maximal Information Coefficient, MIC)"></a>最大信息系数(Maximal Information Coefficient, MIC)</h3><p>在计算<a href="#互信息mutual-information">互信息</a>时，联合分布$p(x, y)$很难求解。采用<strong>蒙特卡洛法</strong>估计：将两个随机变量的散点描绘在二维平面上，然后将$X$平均划分为$|X|$个子区间，$Y$平均划分为$|Y|$个子区间，然后就可以得到$p(x, y)$的估计。</p><p>MIC可以用下式计算</p><script type="math/tex; mode=display">MIC(X, Y) = \max_{|X||Y| < B} \frac{I(X; Y)}{\log (\min(|X|, |Y|))}</script><p>其中$B$一般取数据总量$N$的$0.6$或者$0.55$次方。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> minepy <span class="keyword">import</span> MINE</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">minemic</span><span class="params">(x, y)</span>:</span></span><br><span class="line"><span class="meta">... </span>    m = MINE()</span><br><span class="line"><span class="meta">... </span>    m.compute_score(x, y)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> m.mic(), <span class="number">0.5</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">mic</span><span class="params">(X, Y)</span>:</span></span><br><span class="line"><span class="meta">... </span>    _mic = <span class="keyword">lambda</span> X, Y: np.array(list(</span><br><span class="line"><span class="meta">... </span>                map(<span class="keyword">lambda</span> x: minemic(x, Y), X.T))).T</span><br><span class="line"><span class="meta">... </span>    _tolist = <span class="keyword">lambda</span> x: list(map(list, x))</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> _tolist(_mic(X, Y))</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X, y = load_iris(return_X_y=<span class="keyword">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_new = SelectKBest(mic, k=<span class="number">3</span>).fit_transform(X, y)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X.shape</span><br><span class="line">(<span class="number">150</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_new.shape</span><br><span class="line">(<span class="number">150</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><h3 id="信息增益-Information-Gain"><a href="#信息增益-Information-Gain" class="headerlink" title="信息增益(Information Gain)"></a>信息增益(Information Gain)</h3><p>信息增益被用于决策树的分裂中，用于选择当前最优的分裂属性，可以描述某特征对数据集不确定性减少的程度。而在特征选择中，可以<strong>衡量特征能够描述数据集的多少信息量</strong>。</p><p>假设分类问题数据集$D$包含$|D|$个样本，标签列为$Y$，供包含$K$类，即$y \in {c_1, \cdots, c_K}$，那么类别熵为</p><script type="math/tex; mode=display">H(Y) = - \sum_k p(Y = c_k) \log p(Y = c_k) = - \sum_k \frac{|c_k|}{|D|} \log \frac{|c_k|}{|D|}</script><p>假设特征$X$有$A$种取值${x_1, \cdots, x_A}$，那么当$X$取$x_a$时的类别熵为</p><script type="math/tex; mode=display">\begin{aligned}    H(Y | X = x_a) =       - \sum_k p(Y = c_k | X = x_a) \log p(Y = c_k | X = x_a)       = - \sum_k \frac{|c_{ak}|}{|x_a|} \log \frac{|c_{ak}|}{|x_a|}\end{aligned}</script><p>那么</p><script type="math/tex; mode=display">\begin{aligned}    H(Y | X) = \sum_a p(X = x_a) H(Y | X = x_a)    = - \sum_a \frac{|x_a|}{|D|} \sum_k \frac{|c_{ak}|}{|x_a|} \log \frac{|c_{ak}|}{|x_a|}\end{aligned}</script><p>信息增益为</p><script type="math/tex; mode=display">IG(X) = H(Y) - H(Y | X)</script><h1 id="包裹方法-Wrapper"><a href="#包裹方法-Wrapper" class="headerlink" title="包裹方法(Wrapper)"></a>包裹方法(Wrapper)</h1><p>与过滤法不同的是，包裹法采用的是特征搜索的办法。它的基本思路是，<strong>从初始特征集合中不断的选择子集合，根据学习器的性能来对子集进行评价，直到选择出最佳的子集。在搜索过程中，我们会对每个子集做建模和训练。</strong></p><p>包裹法很大程度上变成了一个计算机问题：<strong>在特征子集的搜索问题</strong>(subset search)。我们有多种思路，最容易想到的办法是<strong>穷举</strong>(Brute-force search)，遍历所有可能的子集，但这样的方法适用于特征数较少的情形，特征一旦增多，就会遇到组合爆炸，在计算上并不可行。($N$个特征，则子集会有$x^N - 1$种可能)</p><p>另一个思路是<strong>随机化搜索</strong>，比如<strong>拉斯维加斯算法</strong>(Las Vegas algorithm)，但这样的算法在特征数大的时候，计算开销仍然很大，而且有给不出任何解的风险。所以，我们常使用的是<strong>贪心算法</strong>：</p><ul><li><p><strong>前向搜索</strong>(Forward search)<br>在开始时，按照特征数来划分子集，每个子集只有一个特征，对每个子集进行评价。然后<strong>在最优的子集上逐步增加特征</strong>，使模型性能提升最大，直到增加特征并不能使模型性能提升为止。</p></li><li><p><strong>后向搜索</strong>(Backward search)<br>在开始时，将特征集合分别减去一个特征作为子集，每个子集有N—1个特征，对每个子集进行评价。然后<strong>在最优的子集上逐步减少特征</strong>，使得模型性能提升最大，直到减少特征并不能使模型性能提升为止。</p></li><li><p><strong>双向搜索</strong>(Bidirectional search)<br>将Forward search 和Backward search结合起来。</p></li><li><p><strong>递归剔除</strong>(Recursive elimination)<br>反复的训练模型，并剔除每次的最优或者最差的特征，将剔除完毕的特征集进入下一轮训练，直到所有的特征被剔除，<strong>被剔除的顺序</strong>度量了特征的重要程度。</p></li></ul><h2 id="递归特征消除-Recursive-Feature-Elimination-REF"><a href="#递归特征消除-Recursive-Feature-Elimination-REF" class="headerlink" title="递归特征消除(Recursive Feature Elimination, REF)"></a>递归特征消除(Recursive Feature Elimination, REF)</h2><p>一种典型的递归剔除方法，思路很简单，在sklearn中具体实现如下<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_fit</span><span class="params">(self, X, y, step_score=None)</span>:</span></span><br><span class="line">    <span class="comment"># Parameter step_score controls the calculation of self.scores_</span></span><br><span class="line">    <span class="comment"># step_score is not exposed to users</span></span><br><span class="line">    <span class="comment"># and is used when implementing RFECV</span></span><br><span class="line">    <span class="comment"># self.scores_ will not be calculated when calling _fit through fit</span></span><br><span class="line"></span><br><span class="line">    tags = self._get_tags()</span><br><span class="line">    X, y = self._validate_data(</span><br><span class="line">        X, y, accept_sparse=<span class="string">"csc"</span>,</span><br><span class="line">        ensure_min_features=<span class="number">2</span>,</span><br><span class="line">        force_all_finite=<span class="keyword">not</span> tags.get(<span class="string">'allow_nan'</span>, <span class="keyword">True</span>),</span><br><span class="line">        multi_output=<span class="keyword">True</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># Initialization</span></span><br><span class="line">    n_features = X.shape[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> self.n_features_to_select <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        n_features_to_select = n_features // <span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        n_features_to_select = self.n_features_to_select</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="number">0.0</span> &lt; self.step &lt; <span class="number">1.0</span>:</span><br><span class="line">        step = int(max(<span class="number">1</span>, self.step * n_features))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        step = int(self.step)</span><br><span class="line">    <span class="keyword">if</span> step &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">"Step must be &gt;0"</span>)</span><br><span class="line"></span><br><span class="line">    support_ = np.ones(n_features, dtype=np.bool)</span><br><span class="line">    ranking_ = np.ones(n_features, dtype=np.int)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> step_score:</span><br><span class="line">        self.scores_ = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Elimination</span></span><br><span class="line">    <span class="keyword">while</span> np.sum(support_) &gt; n_features_to_select:</span><br><span class="line">        <span class="comment"># Remaining features</span></span><br><span class="line">        features = np.arange(n_features)[support_]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Rank the remaining features</span></span><br><span class="line">        estimator = clone(self.estimator)</span><br><span class="line">        <span class="keyword">if</span> self.verbose &gt; <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">"Fitting estimator with %d features."</span> % np.sum(support_))</span><br><span class="line"></span><br><span class="line">        estimator.fit(X[:, features], y)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Get coefs</span></span><br><span class="line">        <span class="keyword">if</span> hasattr(estimator, <span class="string">'coef_'</span>):</span><br><span class="line">            coefs = estimator.coef_</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            coefs = getattr(estimator, <span class="string">'feature_importances_'</span>, <span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">if</span> coefs <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">'The classifier does not expose '</span></span><br><span class="line">                               <span class="string">'"coef_" or "feature_importances_" '</span></span><br><span class="line">                               <span class="string">'attributes'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Get ranks</span></span><br><span class="line">        <span class="keyword">if</span> coefs.ndim &gt; <span class="number">1</span>:</span><br><span class="line">            ranks = np.argsort(safe_sqr(coefs).sum(axis=<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ranks = np.argsort(safe_sqr(coefs))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># for sparse case ranks is matrix</span></span><br><span class="line">        ranks = np.ravel(ranks)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Eliminate the worse features</span></span><br><span class="line">        threshold = min(step, np.sum(support_) - n_features_to_select)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Compute step score on the previous selection iteration</span></span><br><span class="line">        <span class="comment"># because 'estimator' must use features</span></span><br><span class="line">        <span class="comment"># that have not been eliminated yet</span></span><br><span class="line">        <span class="keyword">if</span> step_score:</span><br><span class="line">            self.scores_.append(step_score(estimator, features))</span><br><span class="line">        support_[features[ranks][:threshold]] = <span class="keyword">False</span></span><br><span class="line">        ranking_[np.logical_not(support_)] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set final attributes</span></span><br><span class="line">    features = np.arange(n_features)[support_]</span><br><span class="line">    self.estimator_ = clone(self.estimator)</span><br><span class="line">    self.estimator_.fit(X[:, features], y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Compute step score when only n_features_to_select features left</span></span><br><span class="line">    <span class="keyword">if</span> step_score:</span><br><span class="line">        self.scores_.append(step_score(self.estimator_, features))</span><br><span class="line">    self.n_features_ = support_.sum()</span><br><span class="line">    self.support_ = support_</span><br><span class="line">    self.ranking_ = ranking_</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure></p><p>可以看到在每次迭代中会删除一些特征，其中有几个重要的步骤</p><ul><li><strong>用模型对剩余的特征进行评估，得到每个特征相应的评分；</strong><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">features = np.arange(n_features)[support_]</span><br><span class="line">estimator = clone(self.estimator)</span><br><span class="line">estimator.fit(X[:, features], y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get coefs</span></span><br><span class="line"><span class="keyword">if</span> hasattr(estimator, <span class="string">'coef_'</span>):</span><br><span class="line">    coefs = estimator.coef_</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    coefs = getattr(estimator, <span class="string">'feature_importances_'</span>, <span class="keyword">None</span>)</span><br></pre></td></tr></table></figure></li><li><strong>根据评分，对特征进行排序</strong><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Get ranks</span></span><br><span class="line"><span class="keyword">if</span> coefs.ndim &gt; <span class="number">1</span>:</span><br><span class="line">    ranks = np.argsort(safe_sqr(coefs).sum(axis=<span class="number">0</span>))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    ranks = np.argsort(safe_sqr(coefs))</span><br><span class="line"></span><br><span class="line"><span class="comment"># for sparse case ranks is matrix</span></span><br><span class="line">ranks = np.ravel(ranks)</span><br></pre></td></tr></table></figure></li><li><strong>删除本次迭代中评分最低的特征</strong><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Eliminate the worse features</span></span><br><span class="line">threshold = min(step, np.sum(support_) - n_features_to_select)</span><br><span class="line">support_[features[ranks][:threshold]] = <span class="keyword">False</span></span><br><span class="line">ranking_[np.logical_not(support_)] += <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><p>例如将手写字每个像素作为特征维度，对其进行递归特征筛选，<strong><code>ranking</code>越小的特征重要性越大</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_digits</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> RFE</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Load the digits dataset</span></span><br><span class="line"><span class="meta">... </span>digits = load_digits()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = digits.images.reshape((len(digits.images), <span class="number">-1</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = digits.target</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Create the RFE object and rank each pixel</span></span><br><span class="line"><span class="meta">... </span>svc = SVC(kernel=<span class="string">"linear"</span>, C=<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rfe = RFE(estimator=svc, n_features_to_select=<span class="number">1</span>, step=<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rfe.fit(X, y)</span><br><span class="line">RFE(estimator=SVC(C=<span class="number">1</span>, kernel=<span class="string">'linear'</span>), n_features_to_select=<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ranking = rfe.ranking_.reshape(digits.images[<span class="number">0</span>].shape)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Plot pixel ranking</span></span><br><span class="line"><span class="meta">... </span>plt.matshow(ranking, cmap=plt.cm.Blues)</span><br><span class="line">&lt;matplotlib.image.AxesImage object at <span class="number">0x0000019E756CDE48</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plt.colorbar()</span><br><span class="line">&lt;matplotlib.colorbar.Colorbar object at <span class="number">0x0000019E755994E0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plt.title(<span class="string">"Ranking of pixels with RFE"</span>)</span><br><span class="line">Text(<span class="number">0.5</span>, <span class="number">1.05</span>, <span class="string">'Ranking of pixels with RFE'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plt.show()</span><br></pre></td></tr></table></figure></p><p><img src="/2020/06/12/Efficient-Feature-Selection/rfe.png" alt="rfe"></p><h2 id="拉斯维加斯方法-Las-Vegas-Wrapper-LVW"><a href="#拉斯维加斯方法-Las-Vegas-Wrapper-LVW" class="headerlink" title="拉斯维加斯方法(Las Vegas Wrapper, LVW)"></a>拉斯维加斯方法(Las Vegas Wrapper, LVW)</h2><p><strong>LVW</strong>(Las Vegas Wrapper)是一种典型的包裹式特征选择方法，它在拉斯维加斯方法框架下使用<strong>随机策略</strong>来进行子集搜索，并以最终分类器的误差为特征子集评价准则。</p><h3 id="LV随机算法"><a href="#LV随机算法" class="headerlink" title="LV随机算法"></a>LV随机算法</h3><p>拉斯维加斯算法是一种基于随机策略的算法设计方法，与蒙特卡洛方法对比有以下特点</p><ul><li><strong>蒙特卡罗算法</strong>：采样越多，越接近最优解(强调每一个iteration都在进步，提高的过程)；</li><li><strong>拉斯维加斯算法</strong>：采样越多，越有可能找到最优解(强调直接想要最优解)。</li></ul><p>假设随即搜索中，找到问题的解的概率是$p$，那么每次搜索错误的概率是$1 - p$。<strong>经过$n$次搜索命中正确结果的概率，也就是1减去$n$次都未命中的概率</strong>，即</p><script type="math/tex; mode=display">\lim_{n \rightarrow \infty} \left( 1 - (1 - p)^n \right) = 1</script><p>其算法框架可以表示为<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Obstinate</span><span class="params">(InputType x, OutputType &amp;y;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 反复调用拉斯维加斯算法LV(x, y)，直到找到问题的一个解</span></span><br><span class="line">    <span class="keyword">bool</span> success = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!success) </span><br><span class="line">         success = LV(x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>例如用LV方法解决$N$皇后问题<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queen</span>&#123;</span></span><br><span class="line">   <span class="function"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="title">nQueen</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">Place</span><span class="params">(<span class="keyword">int</span> k)</span></span>;              <span class="comment">//测试皇后K置于x[k]列的合法性</span></span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">Backtrack</span><span class="params">(<span class="keyword">int</span> t)</span></span>;          <span class="comment">//解n后问题的回溯法</span></span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">QueenLV</span><span class="params">(<span class="keyword">int</span> stopVegas)</span></span>;    <span class="comment">//随机放置n个皇后的拉斯维加斯算法</span></span><br><span class="line">   <span class="keyword">int</span> n, *x, *y;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Queen::Place(<span class="keyword">int</span> k)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; k; j++)<span class="comment">//第k个皇后是否跟前面的皇后冲突 </span></span><br><span class="line">        <span class="keyword">if</span>((<span class="built_in">abs</span>(k - j) == <span class="built_in">abs</span>(x[j] - x[k])) || (x[j] == x[k]))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Queen::Backtrack(<span class="keyword">int</span> t)&#123;</span><br><span class="line">    <span class="keyword">if</span>(t &gt; n)&#123;        <span class="comment">//存放皇后放置的位置 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            y[i] = x[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            x[t] = i;<span class="comment">//t皇后放在第i列 </span></span><br><span class="line">            <span class="keyword">if</span>(Place(t) &amp;&amp; Backtrack(t+<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Queen::QueenLV(<span class="keyword">int</span> stopVegas)&#123;</span><br><span class="line">    <span class="comment">//随机放置n个皇后的拉斯维加斯算法</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;<span class="comment">//随机数产生器</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//1&lt;=stopVagas=&lt;n表示允许随机放置的皇后数</span></span><br><span class="line">    <span class="keyword">while</span>((k &lt;= stopVegas) &amp;&amp; (count &gt; <span class="number">0</span>))&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            x[k] = i;</span><br><span class="line">            <span class="keyword">if</span>(Place(k))</span><br><span class="line">                y[count++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count &gt; <span class="number">0</span>) <span class="comment">//如果能放置，则在这么多个能放置第k个皇后的位置中选择一个位置 </span></span><br><span class="line">            x[k++] = y[rand() % count];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span>(count&gt;<span class="number">0</span>);<span class="comment">//count&gt;0表示放置成功 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">nQueen</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//与回溯法相结合的接n后问题的拉斯维加斯算法</span></span><br><span class="line">    Queen X;</span><br><span class="line">    X.n = n;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> *q = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        p[i] = <span class="number">0</span>;</span><br><span class="line">        q[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    X.y = p;</span><br><span class="line">    X.x = q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> stop = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">15</span>)</span><br><span class="line">        stop = n - <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(!X.QueenLV(stop));  <span class="comment">//直到能放置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//算法的回溯搜索部分</span></span><br><span class="line">    <span class="keyword">if</span>(X.Backtrack(stop + <span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p[i] &lt;&lt; <span class="string">"  "</span>;</span><br><span class="line">        found = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> [] p; <span class="keyword">delete</span> [] q;</span><br><span class="line">    <span class="keyword">return</span> found; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"n: "</span>; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(!nQueen(n))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"无解"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="LVW特征选择"><a href="#LVW特征选择" class="headerlink" title="LVW特征选择"></a>LVW特征选择</h3><p>设数据集是$D$，特征集是$A$，LVW每次从特征集$A$中随机产生一个特征子集$A’$，用交叉验证的方法估计学习器在$A’$上的误差，在以下情况保留$A’$</p><ul><li>该误差小于之前获得的最小误差；</li><li>与之前最小误差相当，但包含更少的特征</li></ul><p>由于LVW算法每次评价子集$A′$时，都需要重新训练学习器，计算开销很大，设置参数$T$控制停止条件。但当特征数很多(即$|A|$很大)并且$T$设置得很大时，可能算法运行很长时间都不能停止。</p><script type="math/tex; mode=display">\begin{aligned}    输入:   & 数据集D; \\            & 特征集A; \\            & 学习算法L; \\            & 停止条件控制参数T; \\    过程:\\        & \begin{aligned}            & E^* = \infty; \\            & A^* = A; \\            & d^* = |A|; \\            & t = 0; \\            & while \quad t < T \quad do \\                & \qquad \begin{aligned}                    & randomly \quad choose \quad A'; \\                    & d' = |A'|; \\                    & E' = CrossValidation(L(D^{A'})) \\                    & if \quad (E' < E^*) \vee [ (E' \approx E^*) \wedge (d' < d^*) ] \quad then \\                        & \qquad \begin{aligned}                            & t = 0; \\                            & E^* = E'; \\                            & d^* = d'; \\                            & A^* = A';                        \end{aligned} \\                    & else \\                        & \qquad t = t + 1; \\                \end{aligned} \\                & \qquad endif        \end{aligned} \\        & end \quad while \\    输出: & 特征子集A^*\end{aligned}</script><h1 id="嵌入方法-Embedded"><a href="#嵌入方法-Embedded" class="headerlink" title="嵌入方法(Embedded)"></a>嵌入方法(Embedded)</h1><p>过滤法与学习器没有关系，特征选择只是用统计量做筛选，而包裹法则固定了学习器，特征选择只是在特征空间上进行搜索。<strong>而嵌入法最大的突破在于，特征选择会在学习器的训练过程中自动完成</strong>。</p><h2 id="惩罚项方法-Regularization"><a href="#惩罚项方法-Regularization" class="headerlink" title="惩罚项方法(Regularization)"></a>惩罚项方法(Regularization)</h2><h3 id="线性回归的最小二乘估计和贝叶斯估计"><a href="#线性回归的最小二乘估计和贝叶斯估计" class="headerlink" title="线性回归的最小二乘估计和贝叶斯估计"></a>线性回归的最小二乘估计和贝叶斯估计</h3><p>给定样本集合${(X^{(i)}, y^{(i)}), i = 1, \cdots, N, X^{(i)} \in R^d, y^{(i)} \in R}$，增广后组成样本矩阵$X_{N \times (d + 1)}$，线性回归模型参数为$w \in R^{d + 1}$，那么有</p><script type="math/tex; mode=display">\hat{Y} = Xw</script><ol><li><p><strong>基于最小二乘估计</strong>，定义线性回归模型的优化目标</p><script type="math/tex; mode=display">w^* = \arg_w \max \frac{1}{N} || Y - Xw ||_2^2</script></li><li><p><strong>基于贝叶斯估计</strong>，假定参数$w_j$服从分布$p(w_j)$，其优化目标为</p><script type="math/tex; mode=display"> \begin{aligned}     w^* & = \arg_w \max \log \left( \prod_i p(y^{(i)} | X^{(i)}, w) p(w) \right) \\     & = \arg_w \max \sum_i \left( \log p(y^{(i)} | X^{(i)}, w) + \log p(w) \right) \end{aligned}</script><p> 在线性回归模型中，假定$y \sim N(w^T x, \delta)$(<strong>本质是高斯模型</strong>)，那么有</p><script type="math/tex; mode=display">\log p(y^{(i)} | X^{(i)}, w) \propto (y^{(i)} - w^T x^{(i)})^2</script><p> 另外，<strong>假定参数维度间独立</strong>，即</p><script type="math/tex; mode=display">p(w) = \prod_j p(w_j)</script></li></ol><h3 id="LASSO-L1"><a href="#LASSO-L1" class="headerlink" title="LASSO(L1)"></a>LASSO(L1)</h3><p>LASSO是指Least Absolute Shrinkage and Selection Operator，是采用$L1$正则化的线性回归方法。添加$L1$正则项，构成LASSO优化目标</p><script type="math/tex; mode=display">w^* = \arg_w \max \frac{1}{N} || Y - Xw ||_2^2 + \lambda || w ||_1</script><p><strong>该问题等价于</strong></p><script type="math/tex; mode=display">\begin{aligned}    w^*  & = \arg_w \max \frac{1}{N} || Y - Xw ||_2^2 \\    s.t. & \qquad || w ||_1 \leq t(常数)\end{aligned}</script><blockquote><p>用拉格朗日乘子法进行求解时，可以发现两个优化问题等价</p><script type="math/tex; mode=display">L(w, \lambda) = \frac{1}{N} || Y - Xw ||_2^2 + \lambda(|| w ||_1 - t)</script></blockquote><hr><p>从贝叶斯估计角度考虑，<strong>假定参数$w$服从拉普拉斯分布</strong></p><script type="math/tex; mode=display">\begin{aligned}    & p(w_j) & = \frac{1}{2 \alpha} \exp(- \frac{|w_j|}{\alpha}) \\    \Rightarrow \quad & \log p(w) & = - \sum_j \left( \frac{|w_j|}{\alpha} + \log(2 \alpha) \right)\end{aligned}</script><p>那么可以看到是等价的</p><script type="math/tex; mode=display">\begin{aligned}    w^* & = \arg_w \max \sum_i \left( \log p(y^{(i)} | X^{(i)}, w) + \log p(w) \right) \\    & = \arg_w \max \sum_i \left( (y^{(i)} - w^T x^{(i)})^2 - \sum_j ( \frac{|w_j|}{\alpha} + \log(2 \alpha) ) \right)\end{aligned}</script><hr><p>其几何意义如下，入了正则化项，相当于是对参数施加了约束，其中L1正则化将参数限制在一个菱形中，，从图中可以看出，L1正则化施加的约束会使得最优值在菱形顶点处取得，也就是说很多参数取值为$0$，得到<strong>稀疏的参数估计结果</strong><br><img src="/2020/06/12/Efficient-Feature-Selection/L1.jpg" alt="L1"></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Lasso</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectFromModel</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X, y = load_iris(return_X_y=<span class="keyword">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>clf = Lasso()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>clf.fit(X, y)</span><br><span class="line">Lasso()</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>model = SelectFromModel(clf, prefit=<span class="keyword">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_new = model.transform(X)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X.shape</span><br><span class="line">(<span class="number">150</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_new.shape</span><br><span class="line">(<span class="number">150</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>又如在SVM中增加$L1$正则项<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> LinearSVC</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectFromModel</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X, y = load_iris(return_X_y=<span class="keyword">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lsvc = LinearSVC(C=<span class="number">0.01</span>, penalty=<span class="string">"l1"</span>, dual=<span class="keyword">False</span>).fit(X, y)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>model = SelectFromModel(lsvc, prefit=<span class="keyword">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_new = model.transform(X)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X.shape</span><br><span class="line">(<span class="number">150</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_new.shape</span><br><span class="line">(<span class="number">150</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></p><h3 id="Ridge-L2"><a href="#Ridge-L2" class="headerlink" title="Ridge(L2)"></a>Ridge(L2)</h3><p>在线性回归优化目标中添加$L2$正则项，得到Ridge优化目标</p><script type="math/tex; mode=display">w^* = \arg_w \max \frac{1}{N} || Y - Xw ||_2^2 + \lambda || w ||_2^2</script><p><strong>该问题等价于</strong></p><script type="math/tex; mode=display">\begin{aligned}    w^*  & = \arg_w \max \frac{1}{N} || Y - Xw ||_2^2 \\    s.t. & \qquad || w ||_2^2 \leq t(常数)\end{aligned}</script><blockquote><p>用拉格朗日乘子法进行求解时，可以发现两个优化问题等价</p><script type="math/tex; mode=display">L(w, \lambda) = \frac{1}{N} || Y - Xw ||_2^2 + \lambda(|| w ||_2^2 - t)</script></blockquote><p>但是在求取梯度时，$L1$范数不可导，这就带来求解上的问题，后面介绍的LARS可以近似计算LASSO。</p><hr><p>从贝叶斯估计角度考虑，<strong>假定参数$w$服从高斯分布</strong></p><script type="math/tex; mode=display">\begin{aligned}    & p(w_j) & = \frac{1}{\sqrt{2 \pi \alpha}} \exp(- \frac{w_j^2}{2 \alpha}) \\    \Rightarrow \quad & \log p(w) & =     - \sum_j \left( \frac{w_j^2}{2 \alpha} + \frac{1}{2} \log(2 \pi \alpha) \right)\end{aligned}</script><p>那么可以看到是等价的</p><script type="math/tex; mode=display">\begin{aligned}    w^* & = \arg_w \max \sum_i \left( \log p(y^{(i)} | X^{(i)}, w) + \log p(w) \right) \\    & = \arg_w \max \sum_i \left(         (y^{(i)} - w^T x^{(i)})^2 -         \sum_j ( \frac{w_j^2}{2 \alpha} + \frac{1}{2} \log(2 \pi \alpha) )    \right)\end{aligned}</script><hr><p>其几何意义如下，入了正则化项，相当于是对参数施加了约束，其中L2正则化将参数限制在一个圆中，会使得<strong>权重趋向于零</strong>(Weight Decay)，并倾向于在相关特征之间<strong>均匀分布权重</strong><br><img src="/2020/06/12/Efficient-Feature-Selection/L2.jpg" alt="L2"></p><hr><p>由于参数$\lambda$并不是唯一确定的，所以得到的$\hat{w}(\lambda)$是回归参数$w$的一个<strong>估计族</strong>，$\hat{w}_{j}(\lambda) - \lambda$图称为<strong>岭迹图</strong>，根据以下规则可以筛选有效特征</p><ul><li>当$\lambda = 0$时为最小二乘估计，参数$\hat{w}_{j}$<strong>不应趋向无穷</strong>；</li><li>当不存在奇异时，岭迹应<strong>稳定渐进趋向$0$</strong>；</li><li><p>通过岭迹图可以剔除变量解决多重共线性问题(个别情形下适用)</p><ul><li>可以剔除掉标准化岭回归<strong>系数比较稳定且绝对值很小</strong>的自变量;</li><li>随着$\lambda$的增加，回归系数不稳定，<strong>震荡趋于零</strong>的自变量也可以剔除;</li><li>如果依照上述去掉变量的原则，有若干个回归系数不稳定，究竟去掉几个，去掉哪几个，这幵无一般原则可循，这需根据<strong>去掉某个变量后重新进行岭回归分析</strong>的效果来确定。</li></ul></li></ul><p>一些岭迹图<br><img src="/2020/06/12/Efficient-Feature-Selection/ridge_plot.png" alt="ridge_plot"></p><p>通过岭迹图<strong>选择参数$\lambda$的原则</strong></p><ul><li>各回归系数的岭估计基本稳定(如正负)；</li><li>用最小二乘估计时符号不合理的回归系数，其岭估计的符号变得合理；</li><li>回归系数没有不合乎实际意义的绝对值；</li><li>残差平方和增大不太多。</li></ul><blockquote><p>还有<strong>方差扩大因子法</strong>，注意不同方法建议的选择可能不一致。</p></blockquote><p><img src="/2020/06/12/Efficient-Feature-Selection/ridge_param.png" alt="ridge_param"></p><p><strong>存在的问题</strong></p><ul><li>岭参数$\lambda$计算方法太多且差异很大；</li><li>用岭迹图进行变量筛选，随意性太大，且只能一定程度消除多重共线性，而不能解决其他问题；</li><li>岭回归返回的模型若<strong>没有经过特征筛选</strong>，包含全部变量。</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> RidgeClassifier</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectFromModel</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X, y = load_iris(return_X_y=<span class="keyword">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>clf = RidgeClassifier()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>clf.fit(X, y)</span><br><span class="line">RidgeClassifier()</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>model = SelectFromModel(clf, prefit=<span class="keyword">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_new = model.transform(X)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X.shape</span><br><span class="line">(<span class="number">150</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_new.shape</span><br><span class="line">(<span class="number">150</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="Least-Angel-Regression-LARS"><a href="#Least-Angel-Regression-LARS" class="headerlink" title="Least Angel Regression(LARS)"></a>Least Angel Regression(LARS)</h3><p><strong>最小角回归</strong>(Least Angel Regression, LARS)是一种求解线性回归的方法。线性回归模型可以表示为</p><script type="math/tex; mode=display">Y_{N \times 1} = X_{N \times (d + 1)} w_{(d + 1) \times 1}</script><p>根据矩阵乘法，可以将$Y$看作是所有特征$X_j, j = 1, \cdots, d+1$的线性组合，其特征空间内的基向量为${X_1, \cdots, X_{d+1}}$</p><script type="math/tex; mode=display">Y = \sum_{j=1}^{d+1} w_j X_j</script><p>残差$R$定义为</p><script type="math/tex; mode=display">R = Y - \hat{Y}</script><p>以$2$个样本为例($X_j$维度与样本数有关，再高无法可视化)，在图中表示为<br><img src="/2020/06/12/Efficient-Feature-Selection/linear_regression_graph.jpg" alt="linear_regression_graph"></p><p>其中</p><ul><li>$e_1, e_2, e_3$表示自然基；</li><li>$x_1, x_2, (2 \times 1)$为每个维度上的特征；</li><li>$w_1, w_2$为每个维度上的回归系数；</li><li>$y, y’$分别表示真实值和回归值；</li><li>$r$表示残差。</li></ul><p>可以看到$R$与$X_j, j = 1, \cdots, d + 1$都是垂直的，那么线性回归的优化的实质，<strong>从几何角度解释，是找到残差向量$R$与$X_j, j = 1, \cdots, d + 1$垂直，也即线性无关</strong>。</p><hr><p>基于以上几何意义的解释，就可以介绍LARS算法了，<strong>它的基本思想是：线性回归的求解过程，可以看作是$y$从$O(0, 0)$出发，向$\hat{Y}$逐步接近的过程</strong>，那么现在的问题就是如何选择路径。</p><p>首先介绍<strong>相关系数的几何意义</strong>，将$A, B$两个向量<strong>去中心化、单位化</strong>，即</p><script type="math/tex; mode=display">\begin{cases}    \hat{a}_i = (a_i - \overline{A}) / \sigma_A \\    \hat{b}_i = (b_i - \overline{B}) / \sigma_B\end{cases}</script><p>那么相关系数也即这两个向量的<strong>余弦距离</strong></p><script type="math/tex; mode=display">r_{AB} = \frac{\sum_{i=1}^n (a_i - \overline{A})(b_i - \overline{B})}{\sigma_A \sigma_B} = \frac{1}{n} \sum_{i=1}^n \hat{a}_i \hat{b}_i = \hat{A} \cdot \hat{B}= \cos<\hat{A}, \hat{B}></script><p>LAR<strong>具体算法</strong>如下，是一种线性的方法，求解结果与Lasso结果几乎一致(并不完全一致，但近似相同)</p><ol><li><strong>初始化</strong>：计算输出向量$Y$和属性向量$X_j, j = 1, \cdots. (n + 1)$的相关系数$r_j$，并按相关系数从大到小将属性排序；</li><li><strong>第一个特征选择</strong>：从原点开始沿着<em>相关系数最大</em>的属性$X_1$游走，得到的向量作为预测输出$\hat{Y}$，残差对应为$Y - \hat{Y}$，那么在这个过程中残差与$X_1$的相关性降低<script type="math/tex; mode=display">r_1' = (Y - \hat{Y}) \cdot X_1</script></li><li><strong>剩余特征加入</strong>：当步骤2中相关系数降低至<strong>存在特征$X_2$与残差的相关系数与$r_j’$相等</strong>时，即游走到$w_1 X_1$时，将该特征加入，开始沿着$w_1 X_1, X_2 - w_1 X_1$两向量的角平分线$(w_1 X_1 + X_2’)$游走，其中$X_2’ = X_2 - w1 X_1$；</li><li>重复步骤2，直至<strong>所有加入的特征</strong>与残差$Y - \hat{Y}$相关系数小于指定的较小常数$\epsilon$；</li><li>此时<strong>剩余的特征被丢弃</strong>，达到特征筛选的作用。</li></ol><p>如下图，当残差为$R_2$时，$R_2$几乎与$X_1, X_2$垂直，相关系数为$0$，停止游走，特征$X_3$被丢弃。</p><p><img src="/2020/06/12/Efficient-Feature-Selection/lar.jpg" alt="lar"></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Lars</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectFromModel</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X, y = load_iris(return_X_y=<span class="keyword">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>clf = Lars()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>clf.fit(X, y)</span><br><span class="line">Lars()</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>model = SelectFromModel(clf, prefit=<span class="keyword">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_new = model.transform(X)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X.shape</span><br><span class="line">(<span class="number">150</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_new.shape</span><br><span class="line">(<span class="number">150</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LassoLars</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectFromModel</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X, y = load_iris(return_X_y=<span class="keyword">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>clf = LassoLars()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>clf.fit(X, y)</span><br><span class="line">LassoLars()</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>model = SelectFromModel(clf, prefit=<span class="keyword">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_new = model.transform(X)</span><br><span class="line">C:\Apps\Anaconda3\envs\PR\lib\site-packages\sklearn\feature_selection\_base.py:<span class="number">81</span>: UserWarning: No features were selected: either the data <span class="keyword">is</span> too noisy <span class="keyword">or</span> the selection test too strict. UserWarning)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X.shape</span><br><span class="line">(<span class="number">150</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_new.shape</span><br><span class="line">(<span class="number">150</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="基于树的方法-Tree-based"><a href="#基于树的方法-Tree-based" class="headerlink" title="基于树的方法(Tree-based)"></a>基于树的方法(Tree-based)</h2><p>在决策树训练过程中，就存在选择最优分裂特征的问题，这可以用于评估特征重要性(不进行详细介绍)。</p><h3 id="决策树-Decision-Tree"><a href="#决策树-Decision-Tree" class="headerlink" title="决策树(Decision Tree)"></a>决策树(Decision Tree)</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectFromModel</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X, y = load_iris(return_X_y=<span class="keyword">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>clf = DecisionTreeClassifier()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>clf.fit(X, y)</span><br><span class="line">DecisionTreeClassifier()</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>clf.feature_importances_</span><br><span class="line">array([<span class="number">0.01333333</span>, <span class="number">0.01333333</span>, <span class="number">0.55072262</span>, <span class="number">0.42261071</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>model = SelectFromModel(clf, prefit=<span class="keyword">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_new = model.transform(X)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X.shape</span><br><span class="line">(<span class="number">150</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_new.shape</span><br><span class="line">(<span class="number">150</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="随机森林-Random-Forest-RF"><a href="#随机森林-Random-Forest-RF" class="headerlink" title="随机森林(Random Forest, RF)"></a>随机森林(Random Forest, RF)</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectFromModel</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X, y = load_iris(return_X_y=<span class="keyword">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>clf = RandomForestClassifier()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>clf.fit(X, y)</span><br><span class="line">RandomForestClassifier()</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>clf.feature_importances_</span><br><span class="line">array([<span class="number">0.11294047</span>, <span class="number">0.01823962</span>, <span class="number">0.43942899</span>, <span class="number">0.42939091</span>])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>model = SelectFromModel(clf, prefit=<span class="keyword">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_new = model.transform(X)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X.shape</span><br><span class="line">(<span class="number">150</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_new.shape</span><br><span class="line">(<span class="number">150</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="梯度提升树-GBDT"><a href="#梯度提升树-GBDT" class="headerlink" title="梯度提升树(GBDT)"></a>梯度提升树(GBDT)</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> GradientBoostingClassifier</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectFromModel</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X, y = load_iris(return_X_y=<span class="keyword">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>clf = GradientBoostingClassifier()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>clf.fit(X, y)</span><br><span class="line">GradientBoostingClassifier()</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>clf.feature_importances_</span><br><span class="line">array([<span class="number">0.00649375</span>, <span class="number">0.01077262</span>, <span class="number">0.31215818</span>, <span class="number">0.67057545</span>])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>model = SelectFromModel(clf, prefit=<span class="keyword">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_new = model.transform(X)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X.shape</span><br><span class="line">(<span class="number">150</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_new.shape</span><br><span class="line">(<span class="number">150</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://blog.csdn.net/Mr_Lowbee/article/details/86566949" target="_blank" rel="noopener">用遗传算法进行特征选择 - CSDN</a></li><li><a href="https://zhuanlan.zhihu.com/p/95061281" target="_blank" rel="noopener">特征选择之经典三刀 - 知乎</a></li><li><a href="https://www.zhihu.com/question/28641663" target="_blank" rel="noopener">机器学习中，有哪些特征选择的工程方法？ - 知乎</a></li><li><a href="https://www.cnblogs.com/hhh5460/p/5186226.html" target="_blank" rel="noopener">结合Scikit-learn介绍几种常用的特征选择方法 - cnblogs</a></li><li><a href="https://scikit-learn.org/stable/modules/feature_selection.html" target="_blank" rel="noopener">1.13. Feature selection - scikit learn</a></li><li><a href="https://github.com/FeatureLabs/featuretools" target="_blank" rel="noopener">FeatureLabs/featuretools - Github</a></li><li><a href="https://github.com/Yimeng-Zhang/feature-engineering-and-feature-selection" target="_blank" rel="noopener">Yimeng-Zhang/feature-engineering-and-feature-selection - Github</a></li><li><a href="http://www.wutianqi.com/blog/1723.html" target="_blank" rel="noopener">随机化算法(4) — 拉斯维加斯(Las Vegas)算法 - http://www.wutianqi.com</a></li><li><a href="https://zhuanlan.zhihu.com/p/46999826" target="_blank" rel="noopener">从Lasso开始说起 - 知乎</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python函数静态变量</title>
      <link href="/2020/06/08/Python%E5%87%BD%E6%95%B0%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F/"/>
      <url>/2020/06/08/Python%E5%87%BD%E6%95%B0%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#目录">目录</a></li><li><a href="#reference">Reference</a></li></ul><p>Python函数无法通过<code>static</code>关键词定义静态变量，如C/C++中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    counter++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"counter is %d\n"</span>, counter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意到Python的特性，函数也是一种对象<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span> </span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(f.attr)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">'function'</span> object has no attribute <span class="string">'attr'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.attr = <span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(f.attr)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure></p><p>可以通过装饰器，将变量绑定到函数属性中<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">static_vars</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> kwargs:</span><br><span class="line">            setattr(func, k, kwargs[k])</span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line">    <span class="keyword">return</span> decorate</span><br></pre></td></tr></table></figure></p><p>在定义函数时，绑定属性<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@static_vars(counter=0)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    foo.counter += <span class="number">1</span></span><br><span class="line">    print(<span class="string">"Counter is %d"</span> % foo.counter)</span><br></pre></td></tr></table></figure></p><p>成功<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo()</span><br><span class="line">Counter <span class="keyword">is</span> <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo()</span><br><span class="line">Counter <span class="keyword">is</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://stackoverflow.com/questions/279561/what-is-the-python-equivalent-of-static-variables-inside-a-function" target="_blank" rel="noopener">What is the Python equivalent of static variables inside a function?</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Least Recently Used Cache</title>
      <link href="/2020/06/05/Least-Recently-Used-Cache/"/>
      <url>/2020/06/05/Least-Recently-Used-Cache/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#目录">目录</a></li><li><a href="#原理介绍">原理介绍</a></li><li><a href="#算法设计">算法设计</a><ul><li><a href="#putkey-value">put(key, value)</a></li><li><a href="#getkey">get(key)</a></li><li><a href="#注意">注意</a></li></ul></li><li><a href="#代码实现">代码实现</a><ul><li><a href="#基于双向链表和字典">基于双向链表和字典</a></li><li><a href="#基于有序字典ordereddict">基于有序字典OrderedDict</a></li></ul></li><li><a href="#reference">Reference</a></li></ul><h1 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h1><p><strong>最近最少使用缓存</strong>(Least Recently Usd Cache, LRU Cache)是一种常用的页面置换算法，其设计原则是：<strong>如果一个数据在最近一段时间内没有被访问到，那么将来它被访问的几率也很小，那么当限定空间已满时再次存入数据，应当把最久没有访问到的数据删除以提供空间</strong>。</p><p>应当支持以下操作</p><ul><li><strong>获取数据<code>get(key)</code>(查)</strong>：若缓存中存在<code>key</code>，那么获取数据值，否则返回空；</li><li><strong>写入数据<code>set(key, value)</code>(添、改)</strong>：若<code>key</code>不存在缓存中，则写入键值对，当缓存达到上限，需要在写入新数据前删除最近最少使用的数据用于腾出空间。</li></ul><p>例如<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lru = LRUCache(<span class="number">2</span>)</span><br><span class="line">lru.set(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">lru.set(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">lru.get(<span class="number">2</span>)          <span class="comment"># 输出1</span></span><br><span class="line">lru.set(<span class="number">4</span>, <span class="number">1</span>)       <span class="comment"># 键值对(1, 1)被删除</span></span><br><span class="line">lru.get(<span class="number">1</span>)          <span class="comment"># 输出空</span></span><br><span class="line">lru.get(<span class="number">2</span>)          <span class="comment"># 输出1</span></span><br></pre></td></tr></table></figure></p><hr><p>如果用<strong>字典实现</strong></p><ul><li>在每次读写键<code>key</code>时，查找的时间复杂度是$O(1)$；</li><li>需要对<code>key</code>计数，也就说每个键都必须新增<strong>计数变量</strong>；</li><li>在缓存已满时删除访问量最少的键值对，需要$O(n)$的时间复杂度找到该键值对。</li></ul><p>考虑用<strong>链表实现</strong></p><ul><li>在每次读写<code>key</code>时，查找的时间复杂度是$O(n)$；</li><li>若查找成功，<strong>将对应保存该键值对的节点移动到链表头部</strong>，以实现根据访问量排序的功能；</li><li>在缓存已满时删除访问量最少的键值对，<strong>删除链表结尾的元素</strong>：<ul><li>若采用单向链表，删除最后一个节点时，需要进行遍历，以确定<strong>最后一个节点及其前驱节点</strong>的地址，时间复杂度是$O(n)$；</li><li>采用双向链表，并且保存尾节点地址，那么可以直接获取上述两个节点的地址，删除的时间复杂度是$O(1)$。</li></ul></li></ul><p>经上述分析，以上两种方式实现的LRU Cache均不能实现$O(1)$的查找和删除，<strong>那么有什么办法改进呢？考虑用字典辅助双向链表的形式实现，即哈希链表</strong></p><ul><li><strong>键值对</strong>保存在双向链表中，以实现<strong>键值对按访问量排序，快速删除最近最少使用的键值对</strong>；<blockquote><p><strong>关于链表为什么不只保存值，还需保存键</strong>：因为在删除最不常用键值对时，同时需要删除字典中对应的键值对，这就需要在节点中保存键以达到<strong>反向查找</strong>的目的。</p></blockquote></li><li>将<strong>链表地址</strong>映射到字典中，以实现<strong>快速查找键值对</strong>。</li></ul><p><img src="/2020/06/05/Least-Recently-Used-Cache/hashlist.png" alt="hashlist"></p><h1 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h1><h2 id="put-key-value"><a href="#put-key-value" class="headerlink" title="put(key, value)"></a>put(key, value)</h2><p>实现添和改，首先在字典中<strong>索引<code>key</code>对应的链表节点</strong></p><ul><li>若存在于字典中，那么在该节点中替换<code>value</code>，并将其移动到链表头部；</li><li>若不存在，考虑此时<strong>双向链表是否已满</strong><ul><li>若未满，在链表头部创建新节点保存<code>value</code>，并将该节点的地址映射到字典中；</li><li>若已满，删除链表的尾节点，同时删除字典中该键(<strong>这就需要链表元素同时保存键值对</strong>)，然后再在连边头部创建新节点保存<code>value</code>，并将该节点的地址映射到字典中；</li></ul></li></ul><h2 id="get-key"><a href="#get-key" class="headerlink" title="get(key)"></a>get(key)</h2><p>实现查，首先在字典中<strong>索引<code>key</code>对应的链表节点</strong></p><ul><li>若存在于字典中，返回该节点对应的值<code>value</code>，并将其移动到链表头部；</li><li>若不存在，返回空即可。</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>在实现过程中，注意以下几点</p><ul><li>注意双向链表的头尾指针的维护，以及相应的指针操作；</li><li>在对某节点操作(添、查、改)后，需要将节点移动到链表头部；</li><li>在删除链表节点时，同时需要删除字典中对应的键值对；</li><li>注意<code>capcity</code>为$0, 1$及以上三种情况。</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="基于双向链表和字典"><a href="#基于双向链表和字典" class="headerlink" title="基于双向链表和字典"></a>基于双向链表和字典</h2><p>双向链表主要实现两个功能</p><ul><li><code>append</code>：将节点添加到头部；</li><li><code>tohead</code>：将节点移动到链表头部。</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.prev = <span class="keyword">None</span></span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoublyLinkedList</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.head = <span class="keyword">None</span></span><br><span class="line">        self.tail = <span class="keyword">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">""" 将节点添加到头部 """</span></span><br><span class="line">        <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="comment"># 链表为空</span></span><br><span class="line">            self.head = self.tail = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 链表非空，添加到头部</span></span><br><span class="line">            node.prev = <span class="keyword">None</span></span><br><span class="line">            node.next = self.head</span><br><span class="line">            self.head.prev = node</span><br><span class="line">            self.head = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tohead</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">""" 移动节点到头部 """</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">None</span>: <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 已经是头节点</span></span><br><span class="line">        <span class="keyword">if</span> node.prev <span class="keyword">is</span> <span class="keyword">None</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 断开节点</span></span><br><span class="line">        node.prev.next = node.next</span><br><span class="line">        <span class="keyword">if</span> node.next:</span><br><span class="line">            node.next.prev = node.prev</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 当该节点为尾节点，需要更新尾节点</span></span><br><span class="line">            self.tail = node.prev</span><br><span class="line">            self.tail.next = <span class="keyword">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 移动到头部</span></span><br><span class="line">        node.prev = node.next = <span class="keyword">None</span></span><br><span class="line">        self.append(node)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printlist</span><span class="params">(self)</span>:</span></span><br><span class="line">        node = self.head</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            print(node.value, end=<span class="string">'-&gt;'</span>)</span><br><span class="line">            node = node.next</span><br><span class="line">        print()</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capcity)</span>:</span></span><br><span class="line">        self.capcity = capcity</span><br><span class="line"></span><br><span class="line">        self.list = DoublyLinkedList()</span><br><span class="line">        self.dict = dict()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.dict)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        <span class="string">""" 添、改 """</span></span><br><span class="line">        <span class="keyword">if</span> self.capcity == <span class="number">0</span>: <span class="keyword">return</span> </span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 在字典中查找key对应的节点</span></span><br><span class="line">        node = self.dict.get(key, <span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 不存在</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="comment"># 满了</span></span><br><span class="line">            <span class="keyword">if</span> len(self) &gt;= self.capcity:</span><br><span class="line">                tail = self.list.tail</span><br><span class="line">                <span class="comment"># 删除字典中的键</span></span><br><span class="line">                k = tail.value[<span class="number">0</span>]   </span><br><span class="line">                self.dict.pop(k)    <span class="comment"># 反向查找键并删除</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 删除尾节点</span></span><br><span class="line">                <span class="keyword">if</span> tail.prev:</span><br><span class="line">                    tail.prev.next = <span class="keyword">None</span></span><br><span class="line">                    self.list.tail = tail.prev</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.list.head = self.list.tail = <span class="keyword">None</span></span><br><span class="line">                <span class="keyword">del</span> tail</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 新建节点并添加到链表和字典</span></span><br><span class="line">            node = ListNode([key, value])</span><br><span class="line">            self.list.append(node)</span><br><span class="line">            self.dict[key] = node</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 存在</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 修改值，并移动到头部</span></span><br><span class="line">            node.value[<span class="number">-1</span>] = value</span><br><span class="line">            self.list.tohead(node)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="string">""" 查 """</span></span><br><span class="line">        <span class="comment"># 在字典中查找key对应的节点</span></span><br><span class="line">        node = self.dict.get(key, <span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">None</span>: <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 移动到头部</span></span><br><span class="line">        self.list.tohead(node)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 获取对应节点的值</span></span><br><span class="line">        <span class="keyword">return</span> node.value[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>测试如下<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># lru = LRUCache(0)</span></span><br><span class="line">    <span class="comment"># lru = LRUCache(1)</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        lru = LRUCache(c)</span><br><span class="line">        lru.put(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        lru.list.printlist()</span><br><span class="line"></span><br><span class="line">        lru.put(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">        lru.list.printlist()</span><br><span class="line"></span><br><span class="line">        lru.get(<span class="number">1</span>)</span><br><span class="line">        lru.list.printlist()</span><br><span class="line"></span><br><span class="line">        lru.put(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">        lru.list.printlist()</span><br><span class="line"></span><br><span class="line">        lru.get(<span class="number">2</span>)</span><br><span class="line">        lru.list.printlist()</span><br><span class="line"></span><br><span class="line">        lru.get(<span class="number">3</span>)</span><br><span class="line">        lru.list.printlist()</span><br><span class="line">        print(<span class="string">'-----------'</span>)</span><br></pre></td></tr></table></figure></p><p>链表打印输出如下<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------</span><br><span class="line">[1, 1]-&gt;</span><br><span class="line">[2, 2]-&gt;</span><br><span class="line">[2, 2]-&gt;</span><br><span class="line">[3, 3]-&gt;</span><br><span class="line">[3, 3]-&gt;</span><br><span class="line">[3, 3]-&gt;</span><br><span class="line">-----------</span><br><span class="line">[1, 1]-&gt;</span><br><span class="line">[2, 2]-&gt;[1, 1]-&gt;</span><br><span class="line">[1, 1]-&gt;[2, 2]-&gt;</span><br><span class="line">[3, 3]-&gt;[1, 1]-&gt;</span><br><span class="line">[3, 3]-&gt;[1, 1]-&gt;</span><br><span class="line">[3, 3]-&gt;[1, 1]-&gt;</span><br><span class="line">-----------</span><br><span class="line">[1, 1]-&gt;</span><br><span class="line">[2, 2]-&gt;[1, 1]-&gt;</span><br><span class="line">[1, 1]-&gt;[2, 2]-&gt;</span><br><span class="line">[3, 3]-&gt;[1, 1]-&gt;[2, 2]-&gt;</span><br><span class="line">[2, 2]-&gt;[3, 3]-&gt;[1, 1]-&gt;</span><br><span class="line">[3, 3]-&gt;[2, 2]-&gt;[1, 1]-&gt;</span><br><span class="line">-----------</span><br></pre></td></tr></table></figure></p><h2 id="基于有序字典OrderedDict"><a href="#基于有序字典OrderedDict" class="headerlink" title="基于有序字典OrderedDict"></a>基于有序字典OrderedDict</h2><p>实际上Python标准库内<code>OrderedDict</code>即哈希链表，使用一个双链表来动态维护一个字典的key的顺序，那么<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capcity)</span>:</span></span><br><span class="line">        self._ordered_dict = OrderedDict()</span><br><span class="line">        self._capcity = capcity</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_move_to_end_if_exist</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self._ordered_dict.move_to_end(key)</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        self._move_to_end_if_exist(key)</span><br><span class="line">        <span class="keyword">return</span> self._ordered_dict.get(key, <span class="keyword">None</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        self._ordered_dict[key] = value</span><br><span class="line">        self._move_to_end_if_exist(key)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(self._ordered_dict) &gt; self._capcity:</span><br><span class="line">            self._ordered_dict.popitem(last=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://www.lintcode.com/problem/lru-cache/" target="_blank" rel="noopener">134. LRU缓存策略 - lintcode</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Model Ensemble: Bagging, Boosting, Stacking and Blending</title>
      <link href="/2020/06/02/Model-Ensemble-Bagging-Boosting-Stacking-and-Blending/"/>
      <url>/2020/06/02/Model-Ensemble-Bagging-Boosting-Stacking-and-Blending/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#目录">目录</a></li><li><a href="#模型集成">模型集成</a><ul><li><a href="#原理">原理</a></li><li><a href="#策略">策略</a><ul><li><a href="#平均法">平均法</a></li><li><a href="#投票法">投票法</a></li><li><a href="#学习法">学习法</a></li></ul></li></ul></li><li><a href="#bagging">Bagging</a><ul><li><a href="#自助采样法">自助采样法</a></li><li><a href="#随机森林">随机森林</a></li></ul></li><li><a href="#boosting">Boosting</a><ul><li><a href="#adaboost">AdaBoost</a><ul><li><a href="#分类">分类</a></li><li><a href="#回归adaboost-r2">回归：AdaBoost R2</a></li><li><a href="#多分类samme">多分类：SAMME</a></li><li><a href="#带概率输出的多分类sammer">带概率输出的多分类：SAMME.R</a></li></ul></li></ul></li><li><a href="#blending">Blending</a></li><li><a href="#stacking">Stacking</a></li><li><a href="#多样性">多样性</a><ul><li><a href="#误差-分歧分解error-ambiguity-decomposition">误差-分歧分解(Error-Ambiguity Decomposition)</a></li><li><a href="#多样性度量">多样性度量</a></li><li><a href="#多样性增强">多样性增强</a></li></ul></li><li><a href="#reference">Reference</a></li></ul><h1 id="模型集成"><a href="#模型集成" class="headerlink" title="模型集成"></a>模型集成</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>集成学习有以下优点</p><ul><li>学习任务假设空间很大时，可能有多个假设在训练集上达到同等性能，此时单学习器可能导致泛化能力不佳；</li><li>单个学习器可能陷入局部极小值，组合多个学习器可以降低陷入局部极小的风险；</li><li>组合多个学习器可以扩大假设空间，得到更好的近似。</li></ul><h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p>对于$M$个基学习器$h_1, \cdots, h_M$，可以通过三种策略集成结果：平均法、投票法、学习法。</p><h3 id="平均法"><a href="#平均法" class="headerlink" title="平均法"></a>平均法</h3><p><strong>通常用于回归任务中</strong></p><ul><li><p><strong>简单平均法</strong>：求取学习器输出的均值作为输出</p><script type="math/tex; mode=display">H(x) = \frac{1}{M} \sum_{m=1}^M h_m(x)</script></li><li><p><strong>加权平均法</strong>：学习权重$w_m$，加权组合各学习器的输出</p><script type="math/tex; mode=display">\begin{aligned}  H(x) = \frac{1}{M} \sum_{m=1}^M w_m h_m(x) \\  w_m \geq 0, \sum_m w_m = 1\end{aligned}</script><p>加权平均会引入较多参数，对于规模较大的集成学习容易出现过拟合，不一定优于简单平均法，适合个体学习器性能相差较大的场景。</p></li></ul><h3 id="投票法"><a href="#投票法" class="headerlink" title="投票法"></a>投票法</h3><p><strong>通常用于分类任务中</strong></p><ul><li><strong>绝大多数投票</strong>：若某个标记得票数过半，则预测为该标记。可能存在所有标记都未过半的问题，该方法不常用。</li><li><strong>相对多数投票</strong>：取得票最多的标记作为预测，即<script type="math/tex; mode=display">H(x) = \arg \max_{c_j} \sum_{m = 1}^M I(h_m(x) = c_j)</script></li><li><strong>加权投票</strong>：类似加权平均法<script type="math/tex; mode=display">H(x) = \arg \max_{c_j} \sum_{m = 1}^M w_i I(h_m(x) = c_j)</script></li></ul><h3 id="学习法"><a href="#学习法" class="headerlink" title="学习法"></a>学习法</h3><p>通过另一个学习器(<strong>次级学习器或元学习器meta learner</strong>)来组合个体学习器(<strong>初级学习器</strong>)的分类结果。<strong>用初级学习器产生次级数据集，用作次级学习器的训练</strong>，Stacking是一种典型的学习法集成。</p><h1 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a>Bagging</h1><p>Bagging的<strong>基本流程</strong>是</p><ol><li>经过$M$次<strong>自助采样</strong>，得到$M$个包含$N$个训练样本的采样集；</li><li>基于每个训练集训练得到各个基学习器；</li><li>将这$M$个基学习器进行组合(如投票法)，得到集成模型。</li></ol><p>Bagging主要关注<strong>降低方差</strong>，能够平滑强学习器的方差，非剪枝决策树、神经网络等易受样本扰动的学习器。</p><h2 id="自助采样法"><a href="#自助采样法" class="headerlink" title="自助采样法"></a>自助采样法</h2><p>Bagging基于<strong>自助采样法</strong>(Bootstrap Sampling)。<strong>具体操作为</strong>，给定包含$N$个样本的数据集，<strong>有放回地</strong>进行$N$次随机采样，得到包含$N$个样本的采样集。注意到采样集中某些样本可能多次出现，也存在样本未出现。在某次抽样中样本$x_i$被采样到的概率是$1/N$，经过$N$次采样，<strong>不出现在采样集中的概率</strong>为</p><script type="math/tex; mode=display">(1 - \frac{1}{N})^N</script><p>那么当样本集数目趋于无穷时，有</p><script type="math/tex; mode=display">\lim_{N \rightarrow \infty} (1 - \frac{1}{N})^N = \frac{1}{e} \approx 0.368</script><p>因此原训练集中有<strong>大约有$62.8\%$的样本出现在了采样集中</strong>。那么每个基学习器只用初始训练集中$62.8\%$的样本来训练，剩余$36.8\%$的样本可用作验证集来<strong>对泛化性能进行包外估计</strong>。</p><h2 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h2><p><strong>随机森林(</strong>Random Forest)是Bagging的变体。以<strong>决策树</strong>作为基学习器，在每棵决策树训练过程中，除了自助采样引入<strong>随机样本扰动</strong>，还在某节点划分属性时，从所有属性($K$个)中选择一个包含$k$个属性的子集，从中选择最优属性用于划分，从而引入<strong>随机属性扰动</strong>。如果$k=n$，即传统决策树，通常选择$k = \log_2 n$。</p><p><strong>随机森林的优点</strong>是</p><ol><li>可以用于高维数据，无需降维或特征选择；</li><li>可以判断特征的重要程度，用于特征选择；</li><li>可以得到特征间的相互关系；</li><li>不易过拟合；</li><li>决策树实现简单，且可以并行训练，训练速度快；</li><li>对于不平衡数据集，可以平衡误差；</li><li>可以有效应对特征缺失问题。</li></ol><p><strong>缺点</strong>是：</p><ol><li>随着树的数目增加，随机森林可以有效缓解过拟合，<strong>模型的方差会显著降低，但是不会纠正偏差</strong>，在噪音较大的分类或回归问题上会过拟合；</li><li>取值划分较多的属性会对随机森林产生很大影响，所以<strong>属性权值是不可信的</strong>。</li></ol><h1 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h1><p><strong>提升方法</strong>(Boosting)的<strong>基本思想</strong>是：通过调整训练样本的权重，训练多个学习器，并将学习器组合得到更好的能力。其<strong>理论基础</strong>是强可学习和弱可学习是等价的，即弱学习算法可以通过某些方法提升为强学习算法。</p><p>其<strong>基本流程</strong>是</p><ol><li>从初始训练集训练得到一个基学习器；</li><li>根据基学习器表现对训练样本权重进行调整，使分类错误的样本得到更多关注；</li><li>用调整权重后的数据集训练下一个基学习器；</li><li>重复直至得到$M$个基学习器，进行加权组合得到集成学习器。</li></ol><h2 id="AdaBoost"><a href="#AdaBoost" class="headerlink" title="AdaBoost"></a>AdaBoost</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>给定训练数据集$D = { (X^{(i)}, y^{(i)}), i = 1, \cdots, N}, X^{(i)} \in \mathcal{R}^n, y^{(i)} \in { -1, +1 }$</p><ol><li>初始化训练数据的权值分布$W_1 = \begin{bmatrix} w_1^{(1)}, \cdots, w_1^{(N)} \end{bmatrix}^T, w_1^{(i)} = 1 / N$；</li><li><p>对于$m = 1, \cdots, M$</p><ol><li>用权值分布$W_m$评估数据集，训练得到弱学习算法的基本分类器$h_m$；</li><li><p>计算分类器$h_m$在训练数据集上的分类误差率如下，即所有误分类的加权和，<strong>若$e_m \geq 1 / 2$，算法终止</strong>；</p><script type="math/tex; mode=display">e_m = \sum_i w_m^{(i)} I(h_m(X^{(i)}) \neq y^{(i)}) \in (0， 1/2)</script></li><li><p>计算分类器$h_m$的权重系数如下，评估该分类器在集成模型中的重要性，注意到该函数为单调递减函数，说明误差越小的分类器权重越大；</p><script type="math/tex; mode=display">\alpha_m = \frac{1}{2} \log \frac{1 - e_m}{e_m} \in (- \infty, 0)</script><p><img src="/2020/06/02/Model-Ensemble-Bagging-Boosting-Stacking-and-Blending/figure_1.png" alt="figure_1"></p></li><li><p>更新数据集的权重分布$W_{m+1} = \begin{bmatrix} w_{m+1}^{(1)}, \cdots, w_{m+1}^{(N)} \end{bmatrix}^T$</p><script type="math/tex; mode=display">z_m^{(i)} = w_m^{(i)} \exp \left( - \alpha_m y^{(i)} h_m(X^{(i)}) \right)</script><script type="math/tex; mode=display">w_{m+1}^{(i)} = z_m^{(i)} / \sum_j z_m^{(j)}</script><p><strong>注意</strong>：分类正确时，$w_{m+1}^{(i)} = w_m^{(i)} \exp(-\alpha_m) / \sum_j z_m^{(j)}$，分类错误时，$w_{m+1}^{(i)} = w_m^{(i)} \exp(+ \alpha_m) / \sum_j z_m^{(j)}$，因此错误分类样本权重是正确分类样本权重的$\exp(2 \alpha_m)$倍。</p></li></ol></li><li><p>基本分类器线性组合得到集成模型</p><script type="math/tex; mode=display">H(X) = \text{sign} (\sum_{m} \alpha_m h_m(X))</script></li></ol><h3 id="回归：AdaBoost-R2"><a href="#回归：AdaBoost-R2" class="headerlink" title="回归：AdaBoost R2"></a>回归：AdaBoost R2</h3><p>AdaBoost用于<strong>回归任务</strong>的一种推广。给定训练数据集$D = { (X^{(i)}, y^{(i)}), i = 1, \cdots, N}, X^{(i)} \in \mathcal{R}^n, y^{(i)} \in \mathcal{R}$</p><ol><li>初始化训练数据的权值分布$W_1 = \begin{bmatrix} w_1^{(1)}, \cdots, w_1^{(N)} \end{bmatrix}^T, w_1^{(i)} = 1 / N$；</li><li><p>对于$m = 1, \cdots, M$</p><ol><li>用权值分布$W_m$评估数据集，训练得到弱学习算法的基本回归器$h_m$；</li><li><p>计算回归器$h_m$在训练数据集上的分类误差率如下，即所有回归误差的加权和</p><script type="math/tex; mode=display">e_m^{(i)} = y^{(i)} - h_m(X^{(i)})</script><script type="math/tex; mode=display">E_m = \max_i | e_m^{(i)} |</script><script type="math/tex; mode=display">e_m = \sum_i w_m^{(i)} (e_m^{(i)} / E_m)^2</script></li><li><p>计算回归器$h_m$的权重系数如下，评估该回归器在集成模型中的重要性，注意到该函数为单调递减函数，说明误差越小的回归器权重越大；</p><script type="math/tex; mode=display">\alpha_m = \frac{e_m}{1 - e_m}</script></li><li><p>更新数据集的权重分布$W_{m+1} = \begin{bmatrix} w_{m+1}^{(1)}, \cdots, w_{m+1}^{(N)} \end{bmatrix}^T$</p><script type="math/tex; mode=display">z_m^{(i)} = w_m^{(i)} \alpha_m^{1 - (\frac{y^{(i)} - h_m(X^{(i)})}{E_m})^2}</script><script type="math/tex; mode=display">w_{m+1}^{(i)} = z_m^{(i)} / \sum_j z_m^{(j)}</script></li></ol></li><li><p>基本回归器线性组合得到集成模型</p><script type="math/tex; mode=display">H(X) = \sum_{m} (\ln \frac{1}{\alpha_m}) h_m(X)</script></li></ol><h3 id="多分类：SAMME"><a href="#多分类：SAMME" class="headerlink" title="多分类：SAMME"></a>多分类：SAMME</h3><p>AdaBoost在多分类任务中的推广，当$K=2$时退化为AdaBoost。给定训练数据集$D = { (X^{(i)}, y^{(i)}), i = 1, \cdots, N}, X^{(i)} \in \mathcal{R}^n, y^{(i)} \in { c_1, \cdots, c_K }$</p><ol><li>初始化训练数据的权值分布$W_1 = \begin{bmatrix} w_1^{(1)}, \cdots, w_1^{(N)} \end{bmatrix}^T, w_1^{(i)} = 1 / N$；</li><li><p>对于$m = 1, \cdots, M$</p><ol><li>用权值分布$W_m$评估数据集，训练得到弱学习算法的基本分类器$h_m$；</li><li><p>计算分类器$h_m$在训练数据集上的分类误差率如下，即所有误分类的加权和，<strong>若$e_m \geq (K - 1) / K$，算法终止</strong>；</p><script type="math/tex; mode=display">e_m = \sum_i w_m^{(i)} I(h_m(X^{(i)}) \neq y^{(i)})</script></li><li><p>计算分类器$h_m$的权重系数如下，评估该分类器在集成模型中的重要性，注意到该函数为单调递减函数，说明误差越小的分类器权重越大；</p><script type="math/tex; mode=display">\alpha_m = \frac{1}{2} \log \frac{1 - e_m}{e_m} + \log (K - 1)</script></li><li><p>更新数据集的权重分布$W_{m+1} = \begin{bmatrix} w_{m+1}^{(1)}, \cdots, w_{m+1}^{(N)} \end{bmatrix}^T$</p><script type="math/tex; mode=display">z_m^{(i)} = w_m^{(i)} \exp \left( - \alpha_m y^{(i)} h_m(X^{(i)}) \right)</script><script type="math/tex; mode=display">w_{m+1}^{(i)} = z_m^{(i)} / \sum_j z_m^{(j)}</script></li></ol></li><li><p>基本分类器线性组合得到集成模型</p><script type="math/tex; mode=display">H(X) = \arg \max_k (\sum_m \alpha_m I \left( h_m(X) = c_k \right))</script></li></ol><h3 id="带概率输出的多分类：SAMME-R"><a href="#带概率输出的多分类：SAMME-R" class="headerlink" title="带概率输出的多分类：SAMME.R"></a>带概率输出的多分类：SAMME.R</h3><p>给定训练数据集$D = { (X^{(i)}, y^{(i)}), i = 1, \cdots, N}, X^{(i)} \in \mathcal{R}^n, y^{(i)} \in { c_1, \cdots, c_K }$</p><ol><li>初始化训练数据的权值分布$W_1 = \begin{bmatrix} w_1^{(1)}, \cdots, w_1^{(N)} \end{bmatrix}^T, w_1^{(i)} = 1 / N$；</li><li><p>对于$m = 1, \cdots, M$</p><ol><li>用权值分布$W_m$评估数据集，训练得到弱学习算法的基本分类器$h_m$；</li><li><p>计算分类器$h_m$在训练数据集上的加权概率估计，刻画其预测$X^{(i)}$的输出为类别$c_k$的概率的加权和</p><script type="math/tex; mode=display">{p_m^{(i)}}_k = w_m^{(i)} p(y^{(i)} = c_k | X^{(i)})</script></li><li><p>对于$h_m$和类别$c_k$，定义${l_m}_k(X^{(i)})$如下，刻画$\log {p_m^{(i)}}_k$到<strong>所有概率加权均值</strong>$\frac{1}{K} \sum_{k’} \log {p_m^{(i)}}_{k’}$的距离</p><script type="math/tex; mode=display">{l_m (X^{(i)})}_k = (K - 1) \times \left( \log {p_m^{(i)}}_k - \frac{1}{K} \sum_{k'} \log {p_m^{(i)}}_{k'} \right)</script></li><li><p>更新数据集的权重分布$W_{m+1} = \begin{bmatrix} w_{m+1}^{(1)}, \cdots, w_{m+1}^{(N)} \end{bmatrix}^T$</p><script type="math/tex; mode=display">z_m^{(i)} = w_m^{(i)} \exp \left( - \frac{K - 1}{K} \sum_k {\sigma^{(i)}}_k \log {p_m^{(i)}}_k \right)</script><script type="math/tex; mode=display">\sigma^{(i)}_k = \begin{cases}  1 & y^{(i)} = c_k \\ - \frac{1}{K - 1} & \text{otherwise}  \end{cases}</script><script type="math/tex; mode=display">w_{m+1}^{(i)} = z_m^{(i)} / \sum_j z_m^{(j)}</script></li></ol></li><li><p>基本分类器线性组合得到集成模型</p><script type="math/tex; mode=display">H(X) = \arg \max_k (\sum_m {l_m (X^{(i)})}_k)</script></li></ol><h1 id="Blending"><a href="#Blending" class="headerlink" title="Blending"></a>Blending</h1><p>Blending的流程如下</p><ol><li>将数据划分为训练集trainset、验证集validset测试集testset；</li><li>创建第一层模型，这些模型可以是同质的或异质的，用训练集训练这多个模型；</li><li>用上述模型预测验证集和测试集，得到validpred和testpred1；</li><li>创建第二层模型。用validpred作为训练集训练这多个模型；</li><li>用上述模型对testpred1进行预测，作为整个测试集的结果输出testpred。</li></ol><p><img src="/2020/06/02/Model-Ensemble-Bagging-Boosting-Stacking-and-Blending/blending.jpg" alt="blending"></p><h1 id="Stacking"><a href="#Stacking" class="headerlink" title="Stacking"></a>Stacking</h1><p>Stacking涉及<strong>交叉验证</strong>，流程与Blending类似，具体代码参考<a href="https://github.com/log0/vertebral/blob/master/stacked_generalization.py" target="_blank" rel="noopener">log0/vertebral/stacked_generalization.py </a></p><ol><li>数据划分为训练集trainset和测试集testset；</li><li>创建第一层模型，这些模型可以是同质的或异质的；</li><li>上述每个模型以$K$折交叉验证的方式，分别训练<ol><li>将训练集划分为$K$个子集，其中$1$个用作验证集(cvset)，其余$K-1$个用作本次交叉验证的训练集训练模型；</li><li>cvset在训练得到模型上获取输出cvpred，作为第二层模型的训练集；</li><li>testset在训练得到模型上获取输出testpredk，取testpredk的均值testpred1作为第二层模型的测试集；</li></ol></li><li>创建第二层模型，用cvpred训练单个模型；</li><li>用上述模型对testpred1进行预测，作为整个测试集的结果输出testpred。</li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">clfs = [</span><br><span class="line">  RandomForestClassifier(n_estimators = n_trees, criterion = <span class="string">'gini'</span>),</span><br><span class="line">  ExtraTreesClassifier(n_estimators = n_trees * <span class="number">2</span>, criterion = <span class="string">'gini'</span>),</span><br><span class="line">  GradientBoostingClassifier(n_estimators = n_trees),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ready for cross validation</span></span><br><span class="line">skf = list(StratifiedKFold(Y_dev, n_folds))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pre-allocate the data</span></span><br><span class="line">blend_train = np.zeros((X_dev.shape[<span class="number">0</span>], len(clfs))) <span class="comment"># Number of training data x Number of classifiers</span></span><br><span class="line">blend_test = np.zeros((X_test.shape[<span class="number">0</span>], len(clfs))) <span class="comment"># Number of testing data x Number of classifiers</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># For each classifier, we train the number of fold times (=len(skf))</span></span><br><span class="line"><span class="keyword">for</span> j, clf <span class="keyword">in</span> enumerate(clfs):</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Training classifier [%s]'</span> % (j)</span><br><span class="line">    blend_test_j = np.zeros((X_test.shape[<span class="number">0</span>], len(skf))) <span class="comment"># Number of testing data x Number of folds , we will take the mean of the predictions later</span></span><br><span class="line">    <span class="keyword">for</span> i, (train_index, cv_index) <span class="keyword">in</span> enumerate(skf):</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Fold [%s]'</span> % (i)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># This is the training and validation set</span></span><br><span class="line">        X_train = X_dev[train_index]</span><br><span class="line">        Y_train = Y_dev[train_index]</span><br><span class="line">        X_cv = X_dev[cv_index]</span><br><span class="line">        Y_cv = Y_dev[cv_index]</span><br><span class="line">        </span><br><span class="line">        clf.fit(X_train, Y_train)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># This output will be the basis for our blended classifier to train against,</span></span><br><span class="line">        <span class="comment"># which is also the output of our classifiers</span></span><br><span class="line">        blend_train[cv_index, j] = clf.predict(X_cv)</span><br><span class="line">        blend_test_j[:, i] = clf.predict(X_test)</span><br><span class="line">    <span class="comment"># Take the mean of the predictions of the cross validation set</span></span><br><span class="line">    blend_test[:, j] = blend_test_j.mean(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Start blending!</span></span><br><span class="line">bclf = LogisticRegression()</span><br><span class="line">bclf.fit(blend_train, Y_dev)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Predict now</span></span><br><span class="line">Y_test_predict = bclf.predict(blend_test)</span><br><span class="line">score = metrics.accuracy_score(Y_test, Y_test_predict)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Accuracy = %s'</span> % (score)</span><br></pre></td></tr></table></figure><h1 id="多样性"><a href="#多样性" class="headerlink" title="多样性"></a>多样性</h1><h2 id="误差-分歧分解-Error-Ambiguity-Decomposition"><a href="#误差-分歧分解-Error-Ambiguity-Decomposition" class="headerlink" title="误差-分歧分解(Error-Ambiguity Decomposition)"></a>误差-分歧分解(Error-Ambiguity Decomposition)</h2><p>假定有$M$个学习器$h_1, \cdots, h_M$，通过加权平均组合产生集成学习器$H$，即</p><script type="math/tex; mode=display">H(x) = \sum_{m=1}^M w_m h_m(x)</script><hr><p><strong>对于单个样本$x$</strong>，定义<strong>学习器$h_m$的分歧</strong>为</p><script type="math/tex; mode=display">a_m(x) = (h_m(x) - H(x))^2</script><p><strong>集成学习器$H$的分歧</strong>为</p><script type="math/tex; mode=display">a_H(x) = \sum_{m=1}^M w_m a_m(x) = \sum_{m=1}^M w_m (h_m(x) - H(x))^2</script><p><strong>学习器$h_m$的误差</strong>为</p><script type="math/tex; mode=display">e_m(x) = (y - h_m(x))^2</script><p>那么多个学习器的<strong>误差加权平均</strong>为</p><script type="math/tex; mode=display">e_h(x) = \sum_{m=1}^M w_m e_m(x) = \sum_{m=1}^M w_m (y - h_m(x))^2</script><p><strong>集成学习器$H$的误差</strong>为</p><script type="math/tex; mode=display">e_H(x) = (y - H(x))^2</script><hr><p>定义<strong>集成模型的泛化误差</strong>如下，<strong>希望将$e_H(x)$进行分解，用个体学习器的指标$E_m, A_m$表示</strong></p><script type="math/tex; mode=display">E = \int e_H(x) p(x) dx</script><p>设$p(x)$为样本$x$的概率密度分布，定义个体学习器$h_m$在<strong>全体样本</strong>上的<strong>泛化误差与分歧项</strong>，和<strong>相应的加权平均</strong>为</p><script type="math/tex; mode=display">E_m = \int e_m(x) p(x) dx \Rightarrow \overline{E} = \sum_{m=1}^M w_m E_m</script><script type="math/tex; mode=display">A_m = \int a_m(x) p(x) dx \Rightarrow \overline{A} = \sum_{m=1}^M w_m A_m</script><p>又因为</p><script type="math/tex; mode=display">\begin{aligned}    e_h(x) - a_H(x) = \sum_{m=1}^M w_m (y - h_m(x))^2 - \sum_{m=1}^M w_m (h_m(x) - H(x))^2 \\    = \sum_{m=1}^M w_m \left[ (y - h_m(x))^2 - (h_m(x) - H(x))^2 \right] \\    = \sum_{m=1}^M w_m \left[ y^2 + \cancel{h_m^2(x)} - 2yh_m(x) - \cancel{h_m^2(x)} - H^2(x) + 2 h_m(x)H(x) \right] \\    = y^2 \cancel{\sum_{m=1}^M w_m} - 2y \sum_{m=1}^M w_m h_m(x) -       H^2(x) \cancel{\sum_{m=1}^M w_m} + 2H(x) \sum_{m=1}^M w_m h_m(x) \\    = y^2 - H^2(x) + 2 \sum_{m=1}^M w_m h_m(x) (H(x) - y) \\    = y^2 - H^2(x) + 2 H(x) (H(x) - y) \\    = y^2 - H^2(x) + 2 H^2(x) - 2 y H(x) \\    = (y - H(x))^2 = e_H(x)\end{aligned}</script><p>也即</p><script type="math/tex; mode=display">e_H(x) = e_h(x) - a_H(x)</script><p>那么有</p><script type="math/tex; mode=display">\begin{aligned}    \int e_H(x) p(x) dx = \int e_h(x) p(x) dx - \int a_H(x) p(x) dx \\    = \int \sum_{m=1}^M w_m e_m(x) p(x) dx - \int \sum_{m=1}^M w_m a_m(x) p(x) dx \\    = \sum_{m=1}^M w_m \underbrace{\int e_m(x) p(x) dx}_{E_m} -     \sum_{m=1}^M w_m \underbrace{\int a_m(x) p(x) dx}_{A_m} \\\end{aligned}</script><p>那么<strong>集成学习的误差-分歧分解</strong>如下</p><script type="math/tex; mode=display">E = \overline{E} - \overline{A}</script><p>那么集成学习的目标是<strong>使$E$最小化</strong>，即</p><ul><li>降低个体学习器的泛化误差的加权均值，个体准确性要高；</li><li>提高个体学习器的加权分歧值，个体间差异应尽量大。</li></ul><p>但是有以下<strong>两个问题</strong></p><ul><li>只针对回归问题，难以直接推广到分类问题中；</li><li>难以直接作为优化目标进行优化：<ul><li>定义在整体样本空间上；</li><li>$\overline{A}$是需要集成学习器构造后才能进行估计。</li></ul></li></ul><h2 id="多样性度量"><a href="#多样性度量" class="headerlink" title="多样性度量"></a>多样性度量</h2><p><strong>多样性度量</strong>(diversity measure)用于刻画集成模型中个体分类器多样性的程度。给定样本集合${(X^{(i)}, y^{(i)}), i = 1, \cdots, N, y \in {-1, +1}}$，分类器$h_i, h_j$的预测结果表为</p><div class="table-container"><table><thead><tr><th></th><th>$h_i = +1$</th><th>$h_i = -1$</th></tr></thead><tbody><tr><td>$h_j = +1$</td><td>a</td><td>b</td></tr><tr><td>$h_j = -1$</td><td>c</td><td>d</td></tr></tbody></table></div><ul><li><strong>不合度量</strong>(disagreement measure)<script type="math/tex; mode=display">dis_{ij} = \frac{b + c}{N}</script></li><li><strong>相关系数</strong>(correlation coefficient)<script type="math/tex; mode=display">\rho_{ij} = \frac{ad - bc}{\sqrt{(a + b)(a + c)(c + d)(b + d)}}</script><ul><li>若$h_i, h_j$无关，则值为$0$；</li><li>若$h_i, h_j$正相关，则值大于$0$；</li><li>若$h_i, h_j$负相关，则值小于$0$。</li></ul></li><li><p><strong>$Q$统计量</strong></p><script type="math/tex; mode=display">Q_{ij} = \frac{ad - bc}{ad + bc}</script><p>  $Q_{ij}$符号与$\rho_{ij}$相同，且$|Q_{ij} \leq \rho_{ij}|$。</p></li><li><p><strong>$\kappa$统计量</strong></p><script type="math/tex; mode=display">\kappa_{ij} = \frac{p_1 - p_2}{1 - p_2}</script><p>  其中</p><ul><li><strong>$p_1$两个分类器取得一致的概率</strong><script type="math/tex; mode=display">  p_1 = P(h_i = +1, h_j = +1) + P(h_i = -1, h_j = -1) = \frac{a + d}{N}</script></li><li><strong>$p_2$是假设两个分类器预测结果相互独立下，预测达成一致的概率</strong><script type="math/tex; mode=display">  \begin{aligned}      p_2 = P(h_i = +1, h_j = +1) + P(h_i = -1, h_j = -1) \\       = P(h_i = +1)P(h_j = +1) + P(h_i = -1)P(h_j = -1) \\       = \frac{(a + b)(a + c) + (c + d)(b + d)}{N^2}   \end{aligned}</script></li><li>若两个分类器完全一致，则$b=c$，此时$\kappa=1$；</li><li>若两个分类器偶然达成一致，则$p_1 = p_2$，此时$\kappa=0$；</li><li><strong>通常$\kappa$取非负值</strong>，仅在$h_i$和$h_j$达成一致的概率甚至低于偶然性的情况下，才取负值。</li></ul></li></ul><h2 id="多样性增强"><a href="#多样性增强" class="headerlink" title="多样性增强"></a>多样性增强</h2><p>为获得多样性较大的个体学习器，需要在学习过程中引入随机性，常见做法是：<strong>对数数据样本、输入属性、输出表示、算法参数等进行扰动</strong></p><ul><li><strong>数据样本扰动</strong>：从给定初始数据集中产生不同的数据子集(通常基于采样)，利用不同数据子集训练不同的个体学习器；<br>  对决策树、神经网络等受样本影响较大的<strong>不稳定基学习器</strong>很有效，而对于线性学习器、支持向量机、朴素贝叶斯、$k$近邻等<strong>稳定基学习器</strong>效果不大。</li><li><strong>输入属性扰动</strong>：由一组属性描述训练样本，从不同的样本子空间提供观察数据的不同视角；<br>  适合包含大量冗余属性的数据，而属性或冗余属性较少的数据，不宜采用。</li><li><strong>输出表示扰动</strong>：对输出表示进行操纵以增强多样性。<br>  如对训练样本的类标记稍作变动，如翻转法(flipping output)随机改变一些训练样本的标记。</li><li><strong>算法参数扰动</strong>：通过随机设置不同的超参数，产生差异较大的个体学习器；<br>  交叉验证方法是从不同超参数的个体学习其中选择最优的，而集成模型是全部使用。</li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://www.cnblogs.com/zongfa/p/9304353.html" target="_blank" rel="noopener">机器学习—集成学习（Ensemble Learning） - cnblogs</a></li><li><a href="http://www.huaxiaozhuan.com/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0/chapters/6_ensemble_learning.html" target="_blank" rel="noopener">集成学习 - huaxiaozhuan.com</a></li><li><a href="https://zhuanlan.zhihu.com/p/34534004" target="_blank" rel="noopener">ID3、C4.5、CART、RF、boosting、Adaboost、GBDT、xgboost模型 - 知乎</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>grep, sed, awk</title>
      <link href="/2020/05/05/grep-sed-awk/"/>
      <url>/2020/05/05/grep-sed-awk/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#grep-globally-search-a-regular-expression-and-print">grep: Globally search a Regular Expression and Print</a><ul><li><a href="#%e5%9f%ba%e6%9c%ac%e7%94%a8%e6%b3%95">基本用法</a></li><li><a href="#%e5%8f%82%e6%95%b0%e8%af%b4%e6%98%8e">参数说明</a></li></ul></li><li><a href="#sed-stream-editor">sed: Stream Editor</a><ul><li><a href="#%e5%9f%ba%e6%9c%ac%e7%94%a8%e6%b3%95-1">基本用法</a></li><li><a href="#%e5%8f%82%e6%95%b0%e8%af%b4%e6%98%8e-1">参数说明</a></li><li><a href="#%e7%bc%96%e8%be%91%e5%91%bd%e4%bb%a4">编辑命令</a></li><li><a href="#%e5%ae%9e%e4%be%8b">实例</a></li></ul></li><li><a href="#awk-alfred-aho-peter-weinberger-brian-kernighan">awk:  Alfred Aho, Peter Weinberger, Brian Kernighan</a><ul><li><a href="#%e5%9f%ba%e6%9c%ac%e7%94%a8%e6%b3%95-2">基本用法</a></li><li><a href="#%e5%8f%82%e6%95%b0%e8%af%b4%e6%98%8e-2">参数说明</a></li><li><a href="#%e5%b8%b8%e7%94%a8%e5%86%85%e7%bd%ae%e5%8f%98%e9%87%8f">常用内置变量</a></li><li><a href="#%e8%af%ad%e6%b3%95">语法</a><ul><li><a href="#%e8%bf%90%e7%ae%97%e7%ac%a6">运算符</a></li><li><a href="#beginend">BEGIN/END</a></li><li><a href="#%e5%88%86%e6%94%af%e5%be%aa%e7%8e%af%e6%95%b0%e7%bb%84">分支、循环、数组</a><ul><li><a href="#%e5%88%86%e6%94%af-if">分支: if</a></li><li><a href="#%e5%be%aa%e7%8e%af-do-while-for">循环: do while, for</a></li><li><a href="#%e6%95%b0%e7%bb%84">数组</a></li></ul></li></ul></li><li><a href="#%e5%b8%b8%e7%94%a8%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%87%bd%e6%95%b0">常用字符串函数</a></li></ul></li></ul><h1 id="grep-Globally-search-a-Regular-Expression-and-Print"><a href="#grep-Globally-search-a-Regular-Expression-and-Print" class="headerlink" title="grep: Globally search a Regular Expression and Print"></a><a href="https://www.gnu.org/software/grep/" target="_blank" rel="noopener">grep: Globally search a Regular Expression and Print</a></h1><p>强大的文本搜索工具，它能使用特定模式<strong>匹配（包括正则表达式）查找文本</strong>，并默认输出匹配行到STDOUT。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示列数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][--<span class="built_in">help</span>][范本样式][文件或目录...]</span><br></pre></td></tr></table></figure><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">$ grep --<span class="built_in">help</span></span><br><span class="line">Usage: grep [OPTION]... PATTERN [FILE]...</span><br><span class="line">Search <span class="keyword">for</span> PATTERN <span class="keyword">in</span> each FILE.</span><br><span class="line">Example: grep -i <span class="string">'hello world'</span> menu.h main.c</span><br><span class="line"></span><br><span class="line">Pattern selection and interpretation:</span><br><span class="line">  -E, --extended-regexp     PATTERN is an extended regular expression</span><br><span class="line">  -F, --fixed-strings       PATTERN is a <span class="built_in">set</span> of newline-separated strings</span><br><span class="line">  -G, --basic-regexp        PATTERN is a basic regular expression (default)</span><br><span class="line">  -P, --perl-regexp         PATTERN is a Perl regular expression</span><br><span class="line">  -e, --regexp=PATTERN      use PATTERN <span class="keyword">for</span> matching                            <span class="comment"># -e 将PATTERN作为正则表达式</span></span><br><span class="line">  -f, --file=FILE           obtain PATTERN from FILE</span><br><span class="line">  -i, --ignore-case         ignore <span class="keyword">case</span> distinctions                            <span class="comment"># -i 忽略大小写</span></span><br><span class="line">  -w, --word-regexp         force PATTERN to match only whole words</span><br><span class="line">  -x, --line-regexp         force PATTERN to match only whole lines</span><br><span class="line">  -z, --null-data           a data line ends <span class="keyword">in</span> 0 byte, not newline</span><br><span class="line"></span><br><span class="line">Miscellaneous:</span><br><span class="line">  -s, --no-messages         suppress error messages</span><br><span class="line">  -v, --invert-match        select non-matching lines                           <span class="comment"># -v 反向匹配，输出不包含PATTERN的文本行</span></span><br><span class="line">  -V, --version             display version information and <span class="built_in">exit</span></span><br><span class="line">      --<span class="built_in">help</span>                display this <span class="built_in">help</span> text and <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">Output control:</span><br><span class="line">  -m, --max-count=NUM       stop after NUM selected lines</span><br><span class="line">  -b, --byte-offset         <span class="built_in">print</span> the byte offset with output lines</span><br><span class="line">  -n, --line-number         <span class="built_in">print</span> line number with output lines                 <span class="comment"># -n 输出匹配的文本行的行标</span></span><br><span class="line">      --line-buffered       flush output on every line</span><br><span class="line">  -H, --with-filename       <span class="built_in">print</span> file name with output lines</span><br><span class="line">  -h, --no-filename         suppress the file name prefix on output</span><br><span class="line">      --label=LABEL         use LABEL as the standard input file name prefix</span><br><span class="line">  -o, --only-matching       show only the part of a line matching PATTERN</span><br><span class="line">  -q, --quiet, --silent     suppress all normal output</span><br><span class="line">      --binary-files=TYPE   assume that binary files are TYPE;</span><br><span class="line">                            TYPE is <span class="string">'binary'</span>, <span class="string">'text'</span>, or <span class="string">'without-match'</span></span><br><span class="line">  -a, --text                equivalent to --binary-files=text                   <span class="comment"># -a 将二进制文件内容作为text进行搜索</span></span><br><span class="line">  -I                        equivalent to --binary-files=without-match</span><br><span class="line">  -d, --directories=ACTION  how to handle directories;</span><br><span class="line">                            ACTION is <span class="string">'read'</span>, <span class="string">'recurse'</span>, or <span class="string">'skip'</span></span><br><span class="line">  -D, --devices=ACTION      how to handle devices, FIFOs and sockets;</span><br><span class="line">                            ACTION is <span class="string">'read'</span> or <span class="string">'skip'</span></span><br><span class="line">  -r, --recursive           like --directories=recurse                          <span class="comment"># -r 在目录下递归搜索</span></span><br><span class="line">  -R, --dereference-recursive  likewise, but follow all symlinks</span><br><span class="line">      --include=FILE_PATTERN  search only files that match FILE_PATTERN</span><br><span class="line">      --exclude=FILE_PATTERN  skip files and directories matching FILE_PATTERN</span><br><span class="line">      --exclude-from=FILE   skip files matching any file pattern from FILE</span><br><span class="line">      --exclude-dir=PATTERN  directories that match PATTERN will be skipped.</span><br><span class="line">  -L, --files-without-match  <span class="built_in">print</span> only names of FILEs with no selected lines   <span class="comment"># -L 输出不包含能匹配PATTERN内容的文件名</span></span><br><span class="line">  -l, --files-with-matches  <span class="built_in">print</span> only names of FILEs with selected lines       <span class="comment"># -l 输出包含能匹配PATTERN内容的文件名</span></span><br><span class="line">  -c, --count               <span class="built_in">print</span> only a count of selected lines per FILE       <span class="comment"># -c 输出匹配到的文本行的数目</span></span><br><span class="line">  -T, --initial-tab         make tabs line up (<span class="keyword">if</span> needed)</span><br><span class="line">  -Z, --null                <span class="built_in">print</span> 0 byte after FILE name</span><br><span class="line"></span><br><span class="line">Context control:</span><br><span class="line">  -B, --before-context=NUM  <span class="built_in">print</span> NUM lines of leading context                  <span class="comment"># -B 显示查找到的某行字符串外，还显示之前&lt;NUM&gt;行</span></span><br><span class="line">  -A, --after-context=NUM   <span class="built_in">print</span> NUM lines of trailing context                 <span class="comment"># -A 显示查找到的某行字符串外，还显示随后&lt;NUM&gt;行</span></span><br><span class="line">  -C, --context=NUM         <span class="built_in">print</span> NUM lines of output context                   <span class="comment"># -C 显示查找到的某行字符串外，还显示之前和随后&lt;NUM&gt;行</span></span><br><span class="line">  -NUM                      same as --context=NUM</span><br><span class="line">      --color[=WHEN],</span><br><span class="line">      --colour[=WHEN]       use markers to highlight the matching strings;</span><br><span class="line">                            WHEN is <span class="string">'always'</span>, <span class="string">'never'</span>, or <span class="string">'auto'</span></span><br><span class="line">  -U, --binary              <span class="keyword">do</span> not strip CR characters at EOL (MSDOS/Windows)</span><br><span class="line"></span><br><span class="line">When FILE is <span class="string">'-'</span>, <span class="built_in">read</span> standard input.  With no FILE, <span class="built_in">read</span> <span class="string">'.'</span> <span class="keyword">if</span></span><br><span class="line">recursive, <span class="string">'-'</span> otherwise.  With fewer than two FILEs, assume -h.</span><br><span class="line">Exit status is 0 <span class="keyword">if</span> any line is selected, 1 otherwise;</span><br><span class="line"><span class="keyword">if</span> any error occurs and -q is not given, the <span class="built_in">exit</span> status is 2.</span><br><span class="line"></span><br><span class="line">Report bugs to: bug-grep@gnu.org</span><br><span class="line">GNU grep home page: &lt;http://www.gnu.org/software/grep/&gt;</span><br><span class="line">General <span class="built_in">help</span> using GNU software: &lt;http://www.gnu.org/gethelp/&gt;</span><br></pre></td></tr></table></figure><h1 id="sed-Stream-Editor"><a href="#sed-Stream-Editor" class="headerlink" title="sed: Stream Editor"></a>sed: Stream Editor</h1><p>利用脚本来<strong>编辑文本文件</strong>，主要用来自动编辑一个或多个文件，简化对文件的反复操作、编写转换程序等。它执行的操作为</p><ol><li>一次从输入中读取一行数据；</li><li>根据提供的编辑器命令匹配数据；</li><li>按照命令修改流中的数据；</li><li>将新的数据输出到STDOUT，不改变原来的文本文件。</li></ol><h2 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed [-e &lt;script&gt;][-f &lt;script文件&gt;][文本文件]</span><br></pre></td></tr></table></figure><ul><li><code>&lt;script&gt;</code>为字符串格式的编辑命令，多条命令间以<code>;</code>分隔，或者用<code>bash</code>中的次提示符分隔命令；</li><li><code>&lt;script文件&gt;</code>表示记录编辑命令的文件名，为与<code>shell</code>脚本区分，一般用<code>.sed</code>作为文件后缀名</li></ul><h2 id="参数说明-1"><a href="#参数说明-1" class="headerlink" title="参数说明"></a>参数说明</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sed --<span class="built_in">help</span></span></span><br><span class="line">Usage: sed [OPTION]... &#123;script-only-if-no-other-script&#125; [input-file]...</span><br><span class="line"></span><br><span class="line">  -n, --quiet, --silent</span><br><span class="line">                 suppress automatic printing of pattern space</span><br><span class="line">  -e script, --expression=script                                            # -e 从命令行读取执行命令，单条编辑命令时可省略</span><br><span class="line">                 add the script to the commands to be executed</span><br><span class="line">  -f script-file, --file=script-file                                        # -f 从文件中读取执行命令</span><br><span class="line">                 add the contents of script-file to the commands to be executed</span><br><span class="line">  --follow-symlinks</span><br><span class="line">                 follow symlinks when processing in place</span><br><span class="line">  -i[SUFFIX], --in-place[=SUFFIX]                                           # -i 直接修改文本内容</span><br><span class="line">                 edit files in place (makes backup if SUFFIX supplied)</span><br><span class="line">  -l N, --line-length=N</span><br><span class="line">                 specify the desired line-wrap length for the `l' command</span><br><span class="line">  --posix</span><br><span class="line">                 disable all GNU extensions.</span><br><span class="line">  -E, -r, --regexp-extended</span><br><span class="line">                 use extended regular expressions in the script</span><br><span class="line">                 (for portability use POSIX -E).</span><br><span class="line">  -s, --separate</span><br><span class="line">                 consider files as separate rather than as a single,</span><br><span class="line">                 continuous long stream.</span><br><span class="line">      --sandbox</span><br><span class="line">                 operate in sandbox mode.</span><br><span class="line">  -u, --unbuffered</span><br><span class="line">                 load minimal amounts of data from the input files and flush</span><br><span class="line">                 the output buffers more often</span><br><span class="line">  -z, --null-data</span><br><span class="line">                 separate lines by NUL characters</span><br><span class="line">      --help     display this help and exit</span><br><span class="line">      --version  output version information and exit</span><br><span class="line"></span><br><span class="line">If no -e, --expression, -f, or --file option is given, then the first</span><br><span class="line">non-option argument is taken as the sed script to interpret.  All</span><br><span class="line">remaining arguments are names of input files; if no input files are</span><br><span class="line">specified, then the standard input is read.</span><br><span class="line"></span><br><span class="line">GNU sed home page: &lt;http://www.gnu.org/software/sed/&gt;.</span><br><span class="line">General help using GNU software: &lt;http://www.gnu.org/gethelp/&gt;.</span><br><span class="line">E-mail bug reports to: &lt;bug-sed@gnu.org&gt;.</span><br></pre></td></tr></table></figure><h2 id="编辑命令"><a href="#编辑命令" class="headerlink" title="编辑命令"></a>编辑命令</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># `a`: 在指定行后添加行，注意若希望添加多行，行间用`\n`进行分隔，而开头和结尾无需添加`\n`；</span></span><br><span class="line">$ sed -e <span class="string">"FROM[,TO] a [CONTENT]"</span> FILENAME</span><br><span class="line"></span><br><span class="line"><span class="comment"># `i`: 在指定行前添加行</span></span><br><span class="line">$ sed -e <span class="string">"FROM[,TO] i [CONTENT]"</span> FILENAME</span><br><span class="line"></span><br><span class="line"><span class="comment"># `d`: 将指定行删除</span></span><br><span class="line">$ sed -e <span class="string">"FROM[,TO] d"</span> FILENAME</span><br><span class="line"></span><br><span class="line"><span class="comment"># `c`: 取代指定行内容</span></span><br><span class="line">$ sed -e <span class="string">"FROM[,TO] c [CONTENT]"</span> FILENAME</span><br><span class="line"></span><br><span class="line"><span class="comment"># `s`: 部分数据的搜索和取代</span></span><br><span class="line">$ sed -e <span class="string">"FROM[,TO] s/[PATTERN]/[CONTENT]/g"</span> FILENAME</span><br><span class="line"></span><br><span class="line"><span class="comment"># `p`: 打印输出指定行</span></span><br><span class="line">$ sed -n -e <span class="string">"FROM[,TO] p"</span> FILENAME</span><br><span class="line"></span><br><span class="line"><span class="comment"># `q`: 退出，终止命令</span></span><br><span class="line">$ sed -e <span class="string">"[COMMANDS;]q"</span> FILENAME</span><br></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建文本`test_sed.txt`</span></span><br><span class="line">$ <span class="keyword">for</span> (( i=1; i&lt;=5; i++ )) &#123;</span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"line <span class="variable">$i</span>"</span> &gt;&gt; test_sed.txt</span><br><span class="line">&gt; &#125;</span><br><span class="line">$ cat test_sed.txt</span><br><span class="line">line 1</span><br><span class="line">line 2</span><br><span class="line">line 3</span><br><span class="line">line 4</span><br><span class="line">line 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># ================= 基本操作 ==================</span></span><br><span class="line"><span class="comment"># ------------------ 打印行 -------------------</span></span><br><span class="line"><span class="comment"># 输出第3~5行，若不添加`-n`会输出全部内容</span></span><br><span class="line">$ sed -n -e <span class="string">"3,5 p"</span> test_sed.txt</span><br><span class="line"><span class="comment"># ------------------ 添加行 -------------------</span></span><br><span class="line"><span class="comment"># 在第3行后添加一行</span></span><br><span class="line">$ sed -e <span class="string">"3 a newline"</span> test_sed.txt</span><br><span class="line"><span class="comment"># 在3~5每行后添加一行</span></span><br><span class="line">$ sed -e <span class="string">"3,5 a newline"</span> test_sed.txt</span><br><span class="line"><span class="comment"># ------------------ 插入行 -------------------</span></span><br><span class="line"><span class="comment"># 在第3行前添加一行</span></span><br><span class="line">$ sed -e <span class="string">"3 i newline"</span> test_sed.txt</span><br><span class="line"><span class="comment"># 在第3行后添加两行</span></span><br><span class="line">$ sed -e <span class="string">"3 a newline1\nnewline2"</span> test_sed.txt</span><br><span class="line"><span class="comment"># ------------------ 删除行 -------------------</span></span><br><span class="line"><span class="comment"># 删除第3行</span></span><br><span class="line">$ sed -e <span class="string">"3 d"</span> test_sed.txt</span><br><span class="line"><span class="comment"># 删除第3~5行</span></span><br><span class="line">$ sed -e <span class="string">"3,5 d"</span> test_sed.txt</span><br><span class="line"><span class="comment"># 删除第3行到最后行</span></span><br><span class="line">$ sed -e <span class="string">"3,$ d"</span> test_sed.txt</span><br><span class="line"><span class="comment"># ------------------ 替换行 -------------------</span></span><br><span class="line"><span class="comment"># 替换第3行</span></span><br><span class="line">$ sed -e <span class="string">"3 c replace"</span> test_sed.txt</span><br><span class="line"><span class="comment"># 替换第3~5行</span></span><br><span class="line">$ sed -e <span class="string">"3,5 c replace"</span> test_sed.txt</span><br><span class="line"><span class="comment"># ------------- 查找替换部分文本 ---------------</span></span><br><span class="line"><span class="comment"># 替换第3行中的`li`为`LI`</span></span><br><span class="line">$ sed -e <span class="string">"3 s/li/LI/g"</span> test_sed.txt</span><br><span class="line"><span class="comment"># ----------------- 多点编辑 ------------------</span></span><br><span class="line"><span class="comment"># 删除第3行到末尾行内容，并把`line`替换为`LINE`</span></span><br><span class="line">$ sed -e <span class="string">"3,$ d; s/line/LINE/g"</span> test_sed.txt</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ $ sed -e <span class="string">"3,$ d"</span> -e <span class="string">"s/line/LINE/g"</span> test_sed.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># ============== 搜索并执行命令 ===============</span></span><br><span class="line"><span class="comment"># ---------------- 打印匹配行 -----------------</span></span><br><span class="line"><span class="comment"># 输出包含`3`的关键行，若不添加`-n`同时会输出所有行</span></span><br><span class="line">$ sed -n -e <span class="string">"/3/p"</span> test_sed.txt</span><br><span class="line"><span class="comment"># ---------------- 删除匹配行 -----------------</span></span><br><span class="line"><span class="comment"># 删除包含`3`的关键行</span></span><br><span class="line">$ sed -e <span class="string">"/3/d"</span> test_sed</span><br><span class="line"><span class="comment"># ---------------- 替换匹配行 -----------------</span></span><br><span class="line"><span class="comment"># 将包含`3`的关键行中，`line`替换为`this line`</span></span><br><span class="line">$ sed -e <span class="string">"/3/&#123;s/line/this line/&#125;"</span> test_sed.txt</span><br><span class="line"><span class="comment"># 将包含`3`的关键行中，`line`替换为`this line`，并且只输出该行</span></span><br><span class="line">$ sed -n -e <span class="string">"/3/&#123;s/line/this line/; p; &#125;"</span> test_sed.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># =============== in-place操作 ===============</span></span><br><span class="line"><span class="comment"># 直接修改文本内容，`line`替换为`this line`</span></span><br><span class="line">$ sed -i -e <span class="string">"s/line/LINE/g"</span> test_sed.txt</span><br><span class="line"><span class="comment"># 注意重定向操作可能出现错误</span></span><br><span class="line">$ sed -e <span class="string">"s/line/LINE/g"</span> test_sed.txt &gt;  test_sed.txt   <span class="comment"># 导致文本为空</span></span><br><span class="line">$ sed -e <span class="string">"s/line/LINE/g"</span> test_sed.txt &gt;&gt; test_sed.txt   <span class="comment"># 正常追加</span></span><br></pre></td></tr></table></figure><h1 id="awk-Alfred-Aho-Peter-Weinberger-Brian-Kernighan"><a href="#awk-Alfred-Aho-Peter-Weinberger-Brian-Kernighan" class="headerlink" title="awk:  Alfred Aho, Peter Weinberger, Brian Kernighan"></a>awk:  Alfred Aho, Peter Weinberger, Brian Kernighan</h1><p>逐行扫描指定文件，寻<strong>找匹配特定模式的行，并在这些行上进行想要的操作</strong>。若未指定匹配模式，将会对所有行进行操作(即默认全部行)；若未指定处理方法，将会被输出到STDOUT(即默认为<code>print</code>)。</p><h2 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk [选项参数] <span class="string">'script'</span> var=value file(s)</span><br><span class="line">或</span><br><span class="line">awk [选项参数] -f scriptfile var=value file(s)</span><br></pre></td></tr></table></figure><h2 id="参数说明-2"><a href="#参数说明-2" class="headerlink" title="参数说明"></a>参数说明</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">$ awk --<span class="built_in">help</span></span><br><span class="line">Usage: awk [POSIX or GNU style options] -f progfile [--] file ...</span><br><span class="line">Usage: awk [POSIX or GNU style options] [--] <span class="string">'program'</span> file ...</span><br><span class="line">POSIX options:          GNU long options: (standard)</span><br><span class="line">        -f progfile             --file=progfile         <span class="comment"># 从文本读取awk命令</span></span><br><span class="line">        -F fs                   --field-separator=fs    <span class="comment"># 字符分隔符，即改行文本以该符号作为分隔，例如$PATH中的`:`</span></span><br><span class="line">        -v var=val              --assign=var=val</span><br><span class="line">Short options:          GNU long options: (extensions)</span><br><span class="line">        -b                      --characters-as-bytes</span><br><span class="line">        -c                      --traditional</span><br><span class="line">        -C                      --copyright</span><br><span class="line">        -d[file]                --dump-variables[=file]</span><br><span class="line">        -D[file]                --debug[=file]</span><br><span class="line">        -e <span class="string">'program-text'</span>       --<span class="built_in">source</span>=<span class="string">'program-text'</span></span><br><span class="line">        -E file                 --<span class="built_in">exec</span>=file</span><br><span class="line">        -g                      --gen-pot</span><br><span class="line">        -h                      --<span class="built_in">help</span></span><br><span class="line">        -i includefile          --include=includefile</span><br><span class="line">        -l library              --load=library</span><br><span class="line">        -L[fatal|invalid]       --lint[=fatal|invalid]</span><br><span class="line">        -M                      --bignum</span><br><span class="line">        -N                      --use-lc-numeric</span><br><span class="line">        -n                      --non-decimal-data</span><br><span class="line">        -o[file]                --pretty-print[=file]</span><br><span class="line">        -O                      --optimize</span><br><span class="line">        -p[file]                --profile[=file]</span><br><span class="line">        -P                      --posix</span><br><span class="line">        -r                      --re-interval</span><br><span class="line">        -S                      --sandbox</span><br><span class="line">        -t                      --lint-old</span><br><span class="line">        -V                      --version</span><br><span class="line"></span><br><span class="line">To report bugs, see node `Bugs<span class="string">' in `gawk.info'</span>, <span class="built_in">which</span> is</span><br><span class="line">section `Reporting Problems and Bugs<span class="string">' in the printed version.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">gawk is a pattern scanning and processing language.</span></span><br><span class="line"><span class="string">By default it reads standard input and writes standard output.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Examples:</span></span><br><span class="line"><span class="string">        gawk '</span>&#123; sum += <span class="variable">$1</span> &#125;; END &#123; <span class="built_in">print</span> sum &#125;<span class="string">' file</span></span><br><span class="line"><span class="string">        gawk -F: '</span>&#123; <span class="built_in">print</span> <span class="variable">$1</span> &#125;<span class="string">' /etc/passwd</span></span><br></pre></td></tr></table></figure><h2 id="常用内置变量"><a href="#常用内置变量" class="headerlink" title="常用内置变量"></a>常用内置变量</h2><div class="table-container"><table><thead><tr><th>变量名</th><th>说明</th></tr></thead><tbody><tr><td>$0</td><td>当前记录</td></tr><tr><td>$1 ~ $n</td><td>当前记录被FS分隔后，第n个字段</td></tr><tr><td>NF</td><td>当前记录中字段个数</td></tr><tr><td>NR</td><td>已经读出的记录数</td></tr><tr><td>FS</td><td>字段分隔符，默认为空格</td></tr><tr><td>RS</td><td>记录分隔符，默认为换行符</td></tr><tr><td>OFS</td><td>输出字段分隔符，默认为空格</td></tr><tr><td>ORS</td><td>输出记录分隔符，默认为换行符</td></tr></tbody></table></div><blockquote><p>默认情况下，按换行符分隔记录、按空格分隔字段，即记录为单行文本、字段为文本单词。</p></blockquote><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><div class="table-container"><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>=</td><td>赋值</td></tr><tr><td>+=, -=, <em>=, %=, ^=, *</em>=</td><td>赋值运算</td></tr><tr><td>\</td><td>\</td><td>, &amp;&amp;, !</td><td>逻辑或，逻辑与，逻辑非</td></tr><tr><td>~, !~</td><td>匹配和不匹配正则表达式</td></tr><tr><td>&lt;, &lt;=, &gt;=, !=, ==</td><td>关系运算符；可以作为字符串比较，也可以用作数值比较；两个都为数字才为数值比较；字符串按字典序比较</td></tr><tr><td>+, -, *, /</td><td>加减乘除，所有用作算术运算符进行操作，操作数自动转为数值，<strong>所有非数值都变为0</strong></td></tr><tr><td>&amp;</td><td>求余</td></tr><tr><td>^, <em>*</em></td><td>求幂</td></tr><tr><td>++, —</td><td>前缀或后缀自增、自减</td></tr><tr><td>$n</td><td>字段引用</td></tr><tr><td>空格</td><td>字符串连接符</td></tr><tr><td>?:</td><td>三目运算符</td></tr><tr><td>ln</td><td>数组中是否存在某键值</td></tr></tbody></table></div><h3 id="BEGIN-END"><a href="#BEGIN-END" class="headerlink" title="BEGIN/END"></a>BEGIN/END</h3><p>在<code>BEGIN/END</code>代码块内的命令，只会在开始/结束处理输入文件的文本时执行一次。<code>BEGIN</code>块一般用作初始化<code>FS</code>、打印页眉、初始化全局变量等；<code>END</code>一般用于打印计算结果或输出摘要。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 统计`/etc/passwd`记录数</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;count = 0&#125; &#123;count++&#125; END&#123;print count&#125;'</span> /etc/passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计`/etc/passwd`字段数</span></span><br><span class="line">$ awk <span class="string">'BEGIN&#123;count = 0; FS=":"&#125; &#123;count += NF&#125; END&#123;print count&#125;'</span> /etc/passwd</span><br></pre></td></tr></table></figure><h3 id="分支、循环、数组"><a href="#分支、循环、数组" class="headerlink" title="分支、循环、数组"></a>分支、循环、数组</h3><h4 id="分支-if"><a href="#分支-if" class="headerlink" title="分支: if"></a>分支: if</h4><p>类似C的<code>if</code>语句<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.awk</span><br><span class="line">BEGIN &#123;</span><br><span class="line">        FS = <span class="string">":"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$1</span> == <span class="string">"louishsu"</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="variable">$2</span> == <span class="string">"x"</span>)&#123;</span><br><span class="line">                        <span class="built_in">print</span> <span class="string">"louishsu x"</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">print</span> <span class="string">"louishsu _"</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="variable">$1</span> == <span class="string">"mysql"</span>)&#123;</span><br><span class="line">                <span class="built_in">print</span> <span class="string">"mysql"</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ awk -f test.awk /etc/passwd</span><br></pre></td></tr></table></figure></p><h4 id="循环-do-while-for"><a href="#循环-do-while-for" class="headerlink" title="循环: do while, for"></a>循环: do while, for</h4><p>可通过<code>break/continue</code>控制循环</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.awk</span><br><span class="line">BEGIN &#123;</span><br><span class="line">        FS = <span class="string">":"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">print</span> <span class="string">"----------------"</span></span><br><span class="line">        count = 0</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="built_in">print</span> <span class="variable">$count</span></span><br><span class="line">                count++</span><br><span class="line">        &#125; <span class="keyword">while</span> (count &lt; 3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ awk -f test.awk /etc/passwd</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.awk</span><br><span class="line">BEGIN &#123;</span><br><span class="line">        FS = <span class="string">":"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">print</span> <span class="string">"----------------"</span></span><br><span class="line">        <span class="keyword">for</span> (count = 0; count &lt; 3; count++) &#123;</span><br><span class="line">                <span class="built_in">print</span> <span class="variable">$count</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p><code>awk</code>中的数组都是关联数组，数字索引也会转变为字符串索引</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.awk</span><br><span class="line">&#123;</span><br><span class="line">    cities[1] = <span class="string">"beijing"</span></span><br><span class="line">    cities[2] = <span class="string">"shanghai"</span></span><br><span class="line">    cities[<span class="string">"three"</span>] = <span class="string">"guangzhou"</span></span><br><span class="line">    <span class="keyword">for</span>( c <span class="keyword">in</span> cities) &#123;</span><br><span class="line">        <span class="built_in">print</span> cities[c]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span> cities[1]</span><br><span class="line">    <span class="built_in">print</span> cities[<span class="string">"1"</span>]</span><br><span class="line">    <span class="built_in">print</span> cities[<span class="string">"three"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用字符串函数"><a href="#常用字符串函数" class="headerlink" title="常用字符串函数"></a>常用字符串函数</h2><div class="table-container"><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>sub(r, s, [t])</code></td><td>在整个<code>t</code>中，用<code>s</code>代替<code>r</code>；<code>t</code>缺省为<code>$0</code>；返回替换数量</td></tr><tr><td><code>gsub(r, s, [t])</code></td><td><code>r</code>被作为正则表达式，其余同<code>sub</code>函数</td></tr><tr><td><code>index(s1, s2)</code></td><td>查找并返回<code>s2</code>在<code>s1</code>中的位置(从1开始编号)；若不存在则返回0</td></tr><tr><td><code>match(s, r)</code></td><td>在<code>s</code>中匹配正则表达式<code>r</code>(从1开始编号)；若未找到匹配返回-1</td></tr><tr><td><code>length [(s)]</code></td><td>返回<code>s</code>字符串长度，缺省为<code>$0</code></td></tr><tr><td><code>substr(s, m, [n])</code></td><td>返回从<code>m</code>开始，长度为<code>n</code>的子字符串；不指定<code>n</code>截取到字符串末尾</td></tr><tr><td><code>split(s, a, [r])</code></td><td>根据<code>r</code>指定的拓展正则表达式或<code>FS</code>，将字符串<code>s</code>分割为数组元素<code>a[1], a[2], ..., a[n]</code>；返回<code>n</code></td></tr><tr><td><code>tolower(s), toupper(s)</code></td><td>全部转换为小写/大写字母，大小写映射由当前语言环境的<code>LC_CTYPE</code>范畴定义</td></tr><tr><td><code>sprintf(fmt, ...)</code></td><td>根据<code>fmt</code>格式化字符串并返回</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Shell Programming</title>
      <link href="/2020/05/04/Shell-Programming/"/>
      <url>/2020/05/04/Shell-Programming/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#目录">目录</a></li><li><a href="#shell基础">Shell基础</a><ul><li><a href="#常用指令">常用指令</a></li><li><a href="#父子shell">父子shell</a></li><li><a href="#环境变量">环境变量</a></li><li><a href="#输入输出重定向">输入/输出重定向</a><ul><li><a href="#执行时重定向">执行时重定向</a><ul><li><a href="#输入重定向">输入重定向</a></li><li><a href="#输出重定向">输出重定向</a></li><li><a href="#错误重定向">错误重定向</a></li></ul></li><li><a href="#脚本中重定向">脚本中重定向</a><ul><li><a href="#输入输出">输入/输出</a></li><li><a href="#自定义文件描述符">自定义文件描述符</a></li><li><a href="#重定向到已有文件描述符">重定向到已有文件描述符</a></li></ul></li></ul></li><li><a href="#管道">管道</a></li></ul></li><li><a href="#变量">变量</a><ul><li><a href="#字符串">字符串</a></li><li><a href="#变量参数">变量参数</a></li><li><a href="#数组参数">数组参数</a></li></ul></li><li><a href="#参数传递">参数传递</a><ul><li><a href="#位置参数">位置参数</a></li><li><a href="#命名参数">命名参数</a></li></ul></li><li><a href="#用户输入">用户输入</a><ul><li><a href="#基本输入-read">基本输入: read</a></li><li><a href="#文件输入-cat--read">文件输入: cat | read</a></li></ul></li><li><a href="#脚本退出-exit">脚本退出: exit</a></li><li><a href="#命令替换--command-">命令替换: ( command )</a></li><li><a href="#运算和测试">运算和测试</a><ul><li><a href="#数学运算">数学运算</a><ul><li><a href="#-expr-expression-">$( expr expression )</a></li><li><a href="#-expression-">$[ expression ]</a></li><li><a href="#let-expression--expression-">let expression, $(( expression ))</a></li><li><a href="#内建计算器bc">内建计算器bc</a></li></ul></li><li><a href="#测试命令-test-expression--expression-">测试命令: test expression, [ expression ]</a><ul><li><a href="#数值测试--eq--ne--gt--ge--lt--le">数值测试: -eq, -ne, -gt, -ge, -lt, -le</a></li><li><a href="#字符测试------n--z">字符测试: =, !=, &lt;, &gt;, -n  -z</a></li><li><a href="#文件测试--e--d--f-">文件测试: -e, -d, -f, …</a></li><li><a href="#复合条件测试---o----a--">复合条件测试: !, -o / ||, -a / &amp;&amp;</a></li></ul></li></ul></li><li><a href="#结构化命令">结构化命令</a><ul><li><a href="#分支">分支</a><ul><li><a href="#if-then-elif-else-fi">if-then-elif-else-fi</a></li><li><a href="#case-in">case-in</a></li></ul></li><li><a href="#循环">循环</a><ul><li><a href="#for-do-done">for-do-done</a></li><li><a href="#while-do-done">while-do-done</a></li><li><a href="#until-do-done">until-do-done</a></li><li><a href="#循环控制-break-continue">循环控制: break, continue</a></li></ul></li></ul></li><li><a href="#函数">函数</a><ul><li><a href="#创建和调用函数">创建和调用函数</a></li><li><a href="#参数传递-1">参数传递</a><ul><li><a href="#作用域-local">作用域: local</a></li><li><a href="#变量参数-1">变量参数</a></li><li><a href="#数组参数-1">数组参数</a></li></ul></li><li><a href="#返回值-return-echo">返回值: return, echo</a></li></ul></li><li><a href="#文件包含-source">文件包含: source</a></li><li><a href="#总结">总结</a></li></ul><h1 id="Shell基础"><a href="#Shell基础" class="headerlink" title="Shell基础"></a>Shell基础</h1><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><p><a href="https://www.runoob.com/linux/linux-command-manual.html" target="_blank" rel="noopener">Linux 命令大全 - 菜鸟教程</a></p><h2 id="父子shell"><a href="#父子shell" class="headerlink" title="父子shell"></a>父子shell</h2><p>在当前shell中打开其他shell时，会创建新的shell程序，称为子shell(chile shell)。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ ps --forest</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">    6 tty1     00:00:00 bash</span><br><span class="line">   66 tty1     00:00:00  \_ ps</span><br><span class="line">$ bash          <span class="comment"># 子shell1</span></span><br><span class="line">$ ps --forest</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">    6 tty1     00:00:00 bash</span><br><span class="line">   75 tty1     00:00:00  \_ bash</span><br><span class="line">  125 tty1     00:00:00      \_ ps</span><br><span class="line">$ bash          <span class="comment"># 子shell1的子shell</span></span><br><span class="line">$ ps --forest</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">    6 tty1     00:00:00 bash</span><br><span class="line">   75 tty1     00:00:00  \_ bash</span><br><span class="line">  126 tty1     00:00:00      \_ bash</span><br><span class="line">  174 tty1     00:00:00          \_ ps</span><br><span class="line">$ <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">$ <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure></p><p>通过<strong>进程列表</strong>调用命令可创建子shell，将多条命令以<code>&#39;;&#39;</code>作为间隔，放置在<code>&#39;()&#39;</code>中执行。进程列表是一种命令分组，另一种命令分组是在<code>&#39;{}&#39;</code>中执行，但不会创建子shell。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">pwd</span>; ls; ps -f; <span class="built_in">echo</span> <span class="variable">$BASH_SUBSHELL</span></span><br><span class="line">/home/louishsu</span><br><span class="line">Downloads  anaconda3  backup</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">louishsu     6     5  0 09:35 tty1     00:00:00 -bash</span><br><span class="line">louishsu   176     6  0 09:48 tty1     00:00:00 ps -f</span><br><span class="line">0</span><br><span class="line">$ <span class="comment"># 进程列表</span></span><br><span class="line">$ (<span class="built_in">pwd</span>; ls; ps -f; <span class="built_in">echo</span> <span class="variable">$BASH_SUBSHELL</span>)</span><br><span class="line">/home/louishsu</span><br><span class="line">Downloads  anaconda3  backup</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">louishsu     6     5  0 09:35 tty1     00:00:00 -bash</span><br><span class="line">louishsu   177     6  0 09:49 tty1     00:00:00 -bash   <span class="comment"># 创建了子shell</span></span><br><span class="line">louishsu   179   177  0 09:49 tty1     00:00:00 ps -f</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p><p>在shell脚本中，经常使用子shell进行<strong>多进程处理</strong>，但是会明显拖慢处理速度，一种高效的使用方法是<strong>后台模式</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="comment"># 将命令置入后台模式</span></span><br><span class="line">$ sleep 10 &amp;    <span class="comment"># 置入后台，终端仍可I/O</span></span><br><span class="line">[1] 191</span><br><span class="line">$ ps -f</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">louishsu     6     5  0 09:35 tty1     00:00:00 -bash</span><br><span class="line">louishsu   191     6  0 09:51 tty1     00:00:00 sleep 10</span><br><span class="line">louishsu   192     6  0 09:51 tty1     00:00:00 ps -f</span><br><span class="line">$ <span class="built_in">jobs</span></span><br><span class="line">[1]+  Running                 sleep 10 &amp;</span><br><span class="line"></span><br><span class="line">$ <span class="comment"># 将进程列表置入后台模式</span></span><br><span class="line">$ (sleep 10 ; <span class="built_in">echo</span> <span class="variable">$BASH_SUBSHELL</span> ; sleep 10) &amp;</span><br><span class="line">[2] 193</span><br><span class="line">[1]   Done                    sleep 10</span><br><span class="line">$ ps -f</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">louishsu     6     5  0 09:35 tty1     00:00:00 -bash</span><br><span class="line">louishsu   193     6  0 09:53 tty1     00:00:00 -bash   <span class="comment"># 创建了子shell</span></span><br><span class="line">louishsu   194   193  1 09:53 tty1     00:00:00 sleep 10</span><br><span class="line">louishsu   195     6  0 09:53 tty1     00:00:00 ps -f</span><br><span class="line">$ <span class="built_in">jobs</span></span><br><span class="line">[2]+  Running                 ( sleep 10; <span class="built_in">echo</span> <span class="variable">$BASH_SUBSHELL</span>; sleep 10 ) &amp;</span><br></pre></td></tr></table></figure></p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p><strong>环境变量</strong>(environment variable)用于存储有关shell会话和工作环境的信息，分为<strong>局部变量</strong>和<strong>全局变量</strong>。<strong>局部变量</strong>只对创建它们的shell可见；<strong>全局变量</strong>对shell会话和所生成的子shell都是可见的，用<code>printenv</code>或<code>env</code>输出全局变量<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ env | less</span><br><span class="line">CONDA_SHLVL=1</span><br><span class="line">LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:<span class="keyword">do</span>=01;35:bd=40;33;01:<span class="built_in">cd</span>=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:</span><br><span class="line">CONDA_EXE=/home/louishsu/anaconda3/bin/conda</span><br><span class="line">HOSTTYPE=x86_64</span><br><span class="line">LESSCLOSE=/usr/bin/lesspipe %s %s</span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line">$ printenv  <span class="comment"># 同上</span></span><br><span class="line">$ printenv HOME <span class="comment"># 显示单个变量只能用printenv</span></span><br><span class="line">/home/louishsu</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$HOME</span>    <span class="comment"># 需加上$符</span></span><br><span class="line">/home/louishsu</span><br></pre></td></tr></table></figure></p><p>注意变量的<strong>作用域</strong></p><ol><li>局部环境变量在各进程内是独立的，即父子进程间变量无关联；</li><li>设定全局环境变量的进程所创建的子进程中，全局环境变量可见；</li><li>子进程只能暂时修改变量(包括删除)，退出后父进程内变量不改变。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="comment"># 在子shell中该变量不可见</span></span><br><span class="line">$ bash</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">$ <span class="comment"># 子shell中定义局部变量，在退出后父shell内也不可见</span></span><br><span class="line">$ var=5</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">5</span><br><span class="line">$ <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">$ <span class="comment"># 且父shell变量未改变</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">hello world!</span><br><span class="line"></span><br><span class="line">$ <span class="comment"># 设置为全局变量</span></span><br><span class="line">$ <span class="built_in">export</span> var   <span class="comment"># 注意无需`$`</span></span><br><span class="line">$ <span class="comment"># 在子shell中该变量可见</span></span><br><span class="line">$ bash</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">hello world!</span><br><span class="line">$ <span class="comment"># 子shell中修改全局变量，父shell变量未改变</span></span><br><span class="line">$ var=5</span><br><span class="line">$ <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure><p>以设置环境变量<code>PATH</code>变量为例，用<code>&#39;$&#39;</code>读取变量值，<code>&#39;:&#39;</code>作为分割符进行拼接<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line">[...]:/home/louishsu/Downloads/kibana-6.6.0-linux-x86_64/bin</span><br><span class="line">$ <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/home/louishsu/Downloads</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line">[...]:/home/louishsu/Downloads/kibana-6.6.0-linux-x86_64/bin:/home/louishsu/Downloads</span><br></pre></td></tr></table></figure></p><blockquote><p>若<strong>希望<code>PATH</code>变量持久化</strong>，将<code>export</code>命令记录在以下几个文件中(无需全部记录)。<br>以下是shell默认的主启动文件，在每次登录Linux时执行(<strong>系统级</strong>)，在Ubuntu系统中，该文件内部执行调用文件<code>/etc/bash.bashrc</code></p><ul><li><code>/etc/profile</code></li></ul><p>以下四个文件作用相同，都是<strong>用户级</strong>的启动文件，一般大多数Linux发行版都只用到一到两个。shell会按照<code>.bash_profile</code>、<code>.bash_login</code>、<code>.profile</code>的顺序，<strong>执行第一个找到的文件(其余的被省略)</strong>。注意<code>.bashrc</code>是在以上三个文件中被执行的。</p><ul><li><code>$HOME/.bash_profile</code></li><li><code>$HOME/.bash_login</code></li><li><code>$HOME/.profile</code></li><li><code>$HOME/.bashrc</code></li></ul><p>但是如果bash是作为<strong>交互式shell</strong>启动，只会检查执行<code>$HOME/.bashrc</code>，而<code>/etc/profile</code>和<code>$HOME/.profile</code>等均被忽略。</p></blockquote><h2 id="输入-输出重定向"><a href="#输入-输出重定向" class="headerlink" title="输入/输出重定向"></a>输入/输出重定向</h2><p>通过输入/输出重定向，可将标准输入/标准输出重定向到另一个位置(如文件)。Linux将每个对象视作文件处理，用<strong>文件描述符</strong>(file descriptor)来标识文件对象。文件描述符是一个非负整数，每个进程一次最多可以有9个文件描述符。其中比较特殊的是标准输入(STDIN, 0)、标准输出(STDOUT, 1)、标准错误(STDERR, 2)。</p><h3 id="执行时重定向"><a href="#执行时重定向" class="headerlink" title="执行时重定向"></a>执行时重定向</h3><h4 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h4><p>输入重定向是<strong>将文件内容重定向到命令</strong>，符号是<code>&#39;&lt;&#39;</code>，例如用<code>wc</code>对文本进行计数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wc &lt; .bashrc</span><br><span class="line">157  636 5119   <span class="comment"># 文本行数、词数、字节数</span></span><br></pre></td></tr></table></figure></p><p>还有一种是<strong>内联输入重定向</strong>(inline input redirection)，符号是<code>&#39;&lt;&lt;&#39;</code>，无需使用文件进行重定向，直接从stdin读取数据，必须指定一个文本标记来标记输入的开始和结尾。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ wc &lt;&lt; EOF     <span class="comment"># 标记符，也可定义为其他文本</span></span><br><span class="line">&gt; this is</span><br><span class="line">&gt; inline</span><br><span class="line">&gt; input redirection</span><br><span class="line">&gt; EOF</span><br><span class="line">3  5 34</span><br></pre></td></tr></table></figure></p><h4 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h4><p><strong>将命令输出发送到文件中</strong>，符号是<code>&#39;&gt;&#39;</code>，会覆盖已有数据，可以用<code>&#39;&gt;&gt;&#39;</code>进行内容追加而不覆盖</p><blockquote><p>注意，错误信息未被重定向。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"hello!"</span> &gt; inputRedirection. txt</span><br><span class="line">$ cat inputRedirection. txt</span><br><span class="line">hello!</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"world"</span> &gt; inputRedirection. txt</span><br><span class="line">$ cat inputRedirection. txt</span><br><span class="line">world</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"hello"</span> &gt;&gt; inputRedirection. txt</span><br><span class="line">$ cat inputRedirection. txt</span><br><span class="line">world</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><h4 id="错误重定向"><a href="#错误重定向" class="headerlink" title="错误重定向"></a>错误重定向</h4><p>一般错误输出和正常输出都会显示在屏幕上，但如果需要将错误信息重定向，则可通过指定文件描述符。例如重定向错误到文本<code>err.logs</code>，而其余正常输出，可通过<code>2&gt;</code>指定文本文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ wget 2&gt; err.logs</span><br><span class="line">$ cat err.logs      <span class="comment"># 查看文本内容</span></span><br><span class="line">wget: missing URL</span><br><span class="line">Usage: wget [OPTION]... [URL]...</span><br><span class="line"></span><br><span class="line">Try `wget --<span class="built_in">help</span><span class="string">' for more options.</span></span><br></pre></td></tr></table></figure><p>同时将正常输出重定向到文本<code>out.logs</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ wget 1&gt; out.logs 2&gt; err.logs </span><br><span class="line">$ cat out.logs  <span class="comment"># 空</span></span><br><span class="line">$ cat err.logs</span><br><span class="line">wget: missing URL</span><br><span class="line">Usage: wget [OPTION]... [URL]...</span><br><span class="line"></span><br><span class="line">Try `wget --<span class="built_in">help</span><span class="string">' for more options.</span></span><br></pre></td></tr></table></figure></p><p>若想同时重定向输出和错误到文本<code>outerr.logs</code>，通过<code>&amp;&gt;</code>指定<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ wget &amp;&gt; outerr.logs</span><br><span class="line">$ cat outerr.logs</span><br><span class="line">wget: missing URL</span><br><span class="line">Usage: wget [OPTION]... [URL]...</span><br><span class="line"></span><br><span class="line">Try `wget --<span class="built_in">help</span><span class="string">' for more options.</span></span><br></pre></td></tr></table></figure></p><h3 id="脚本中重定向"><a href="#脚本中重定向" class="headerlink" title="脚本中重定向"></a>脚本中重定向</h3><h4 id="输入-输出"><a href="#输入-输出" class="headerlink" title="输入/输出"></a>输入/输出</h4><p>在脚本中向文本描述符<code>desc</code>输人/输出的命令如下，注意空格。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> &gt;&amp;desc</span><br><span class="line"><span class="built_in">command</span> &lt;&amp;desc</span><br></pre></td></tr></table></figure></p><p>例如向标准错误<code>STDERR</code>输出数据<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"[Error]: to file err.logs"</span> &gt;&amp;2    <span class="comment"># STDERR</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"[Warining]: to file out.logs"</span>     <span class="comment"># default STDOUT</span></span><br></pre></td></tr></table></figure></p><p>如果执行时不指定错误重定向，将被默认打印到屏幕上(默认错误与输出打印到同一位置，即屏幕上)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./test.sh</span><br><span class="line">[Error]: to file err.logs</span><br><span class="line">[Warining]: to file out.logs</span><br></pre></td></tr></table></figure></p><p>若指定错误重定向，即可输出到文本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./test.sh 2&gt; err.logs</span><br><span class="line">[Warining]: to file out.logs</span><br><span class="line">$ cat err.logs</span><br><span class="line">[Error]: to file err.logs</span><br></pre></td></tr></table></figure></p><h4 id="自定义文件描述符"><a href="#自定义文件描述符" class="headerlink" title="自定义文件描述符"></a>自定义文件描述符</h4><p>可通过<code>exec</code>自定义文件描述符<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> desc&lt; filename     <span class="comment"># 从文件创建输入重定向</span></span><br><span class="line"><span class="built_in">exec</span> desc&gt; filename     <span class="comment"># 从文件创建输出重定向</span></span><br><span class="line"><span class="built_in">exec</span> desc&lt;&gt; filename    <span class="comment"># 从文件创建输入输出重定向</span></span><br><span class="line"><span class="built_in">exec</span> desc&gt;&amp;-            <span class="comment"># 重定向到`-`，关闭文件描述符</span></span><br></pre></td></tr></table></figure></p><p>例如<code>in.logs</code>原始文件内容如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat in.logs</span><br><span class="line">Do not go gentle into that good night,</span><br><span class="line">Old age should burn and rave at close of day;</span><br><span class="line">Rage, rage against the dying of the light.</span><br></pre></td></tr></table></figure></p><p>编写脚本，从<code>in.logs</code>创建输入输出重定向，并将文件描述符定义为3<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">exec</span> 3&lt;&gt; in.logs</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Read poem:"</span>       <span class="comment"># stdout</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line &lt;&amp;3; <span class="keyword">do</span> <span class="comment"># get line from descriptor 3</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$line</span>      <span class="comment"># stdout</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Write poem:"</span>      <span class="comment"># stdout</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Excellent!"</span> &gt;&amp;3   <span class="comment"># write line to descriptor 3</span></span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./test.sh</span><br><span class="line">Read poem:</span><br><span class="line">Do not go gentle into that good night,</span><br><span class="line">Old age should burn and rave at close of day;</span><br><span class="line">Rage, rage against the dying of the light.</span><br><span class="line">Write poem:</span><br></pre></td></tr></table></figure><p>再次查看<code>in.logs</code>文件内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat in.logs</span><br><span class="line">Do not go gentle into that good night,</span><br><span class="line">Old age should burn and rave at close of day;</span><br><span class="line">Rage, rage against the dying of the light.</span><br><span class="line">Excellent!            <span class="comment"># 追加内容</span></span><br></pre></td></tr></table></figure></p><p>又如，将<code>STDIN, STDOUT, STDERR</code>均重定向到各自文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入重定向</span></span><br><span class="line"><span class="built_in">exec</span> 0&lt; in.logs</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line; <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$line</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出重定向</span></span><br><span class="line"><span class="built_in">exec</span> 1&gt; out.logs</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"[Warining]: to file out.logs"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误重定向</span></span><br><span class="line"><span class="built_in">exec</span> 2&gt; err.logs</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"[Error]: to file err.logs"</span> &gt;&amp;2</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ cat in.logs</span><br><span class="line">Do not go gentle into that good night,</span><br><span class="line">Old age should burn and rave at close of day;</span><br><span class="line">Rage, rage against the dying of the light.</span><br><span class="line"></span><br><span class="line">$ ./test.sh</span><br><span class="line">Do not go gentle into that good night,</span><br><span class="line">Old age should burn and rave at close of day;</span><br><span class="line">Rage, rage against the dying of the light.</span><br><span class="line"></span><br><span class="line">$ cat out.logs</span><br><span class="line">[Warining]: to file out.logs</span><br><span class="line">$ cat err.logs</span><br><span class="line">[Error]: to file err.logs</span><br></pre></td></tr></table></figure><h4 id="重定向到已有文件描述符"><a href="#重定向到已有文件描述符" class="headerlink" title="重定向到已有文件描述符"></a>重定向到已有文件描述符</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> descNew&gt;&amp;desc      <span class="comment"># 创建输出重定向</span></span><br><span class="line"><span class="built_in">exec</span> descNew&lt;&amp;desc      <span class="comment"># 创建输入重定向</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 重定向3到STDOUT3</span></span><br><span class="line"><span class="built_in">exec</span> 3&gt;&amp;1               </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"To STDOUT"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"To desc 3"</span> &gt;&amp;3    <span class="comment"># 输出到文本描述符3</span></span><br></pre></td></tr></table></figure><p>可以看到执行后，输出到3的数据也被显示到STDOUT中<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./test.sh</span><br><span class="line">To STDOUT</span><br><span class="line">To desc 3</span><br></pre></td></tr></table></figure></p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道可将一个命令的输出作为另一个命令的输入，是将第一个命令重定向到第二个命令，称为<strong>管道连接</strong>(piping)。Linux系统会同时调用多个命令，在内部将他们连接，而不是依次执行(管道通信)。例如，用<code>apt-get</code>搜索<code>openssl</code>安装包，排序<code>sort</code>后通过<code>less</code>查看<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ apt search openssl | grep openssl* | sort | less</span><br><span class="line">  Asynchronous event notification library (openssl)</span><br><span class="line">  D version of the C headers <span class="keyword">for</span> openssl</span><br><span class="line">  Loadable module <span class="keyword">for</span> openssl implementing GOST algorithms</span><br><span class="line">  Puppet module <span class="keyword">for</span> managing openssl configuration</span><br><span class="line">aolserver4-nsopenssl/bionic,bionic 3.0beta26-6 amd64</span><br><span class="line">bruteforce-salted-openssl/bionic,bionic 1.4.0-1build1 amd64</span><br><span class="line">dlang-openssl/bionic,bionic 1.1.5+1.0.1g-1 all</span><br><span class="line">jruby-openssl/bionic-updates,bionic-security 0.9.21-2~18.04 all</span><br><span class="line">lcmaps-openssl-interface/bionic,bionic 1.6.6-2build1 all</span><br><span class="line">libcrypt-openssl-bignum-perl/bionic,bionic 0.09-1build1 amd64</span><br><span class="line">libcrypt-openssl-dsa-perl/bionic,bionic 0.19-1build2 amd64</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure></p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>除了环境变量，shell支持在脚本中定义和使用<strong>用户变量</strong>，临时存储数据。</p><ul><li>变量名可以由字母、数字和下划线组成，长度不超过20，首个字符不能以数字开头，区分大小写，不可使用保留关键字；</li><li>在赋值时同样地，赋值符两侧不能出现空格；</li><li>shell脚本会自动决定变量值的数据类型，在脚本结束时所有用户变量被删除；</li><li>注意<code>&#39;$&#39;</code>的使用：引用变量值时需要，而引用变量进行赋值等操作时不需要。  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ var1=1; var2=2</span><br><span class="line">$ <span class="built_in">echo</span> var1     <span class="comment"># var1被视作字符串</span></span><br><span class="line">var1</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var1</span></span><br><span class="line">1</span><br><span class="line">$ var1=var2     <span class="comment"># var1内容更改为字符串var2</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var1</span></span><br><span class="line">var2</span><br><span class="line">$ var1=<span class="variable">$var2</span>    <span class="comment"># var1内容更改为变量var2的值</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var1</span></span><br><span class="line">2</span><br></pre></td></tr></table></figure></li><li>变量名外面的花括号界定符，加花括号是为了帮助解释器识别变量的边界，比如  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">for</span> name <span class="keyword">in</span> Jack Tom Bob; <span class="keyword">do</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"This is <span class="variable">$nameBoy</span>"</span>   <span class="comment"># nameBoy被视作变量名</span></span><br><span class="line">&gt; <span class="keyword">done</span></span><br><span class="line">This is</span><br><span class="line">This is</span><br><span class="line">This is</span><br><span class="line">$ <span class="keyword">for</span> name <span class="keyword">in</span> Jack Tom Bob; <span class="keyword">do</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"This is <span class="variable">$&#123;name&#125;</span>Boy"</span> <span class="comment"># name被视作变量名，自动拼接字符串</span></span><br><span class="line">&gt; <span class="keyword">done</span></span><br><span class="line">This is JackBoy</span><br><span class="line">This is TomBoy</span><br><span class="line">This is BobBoy</span><br></pre></td></tr></table></figure></li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是shell编程中最常用最有用的数据类型，定义字符串时，可以选择单引号、双引号、无引号，但是有部分限制：<strong>单引号内引用变量值无效，且不能使用转义字符</strong>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ name=louishsu</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'This is \"$name\"'</span>      <span class="comment"># 单引号内引用变量值无效，且不能使用转义字符</span></span><br><span class="line">This is \<span class="string">"<span class="variable">$name</span>\"</span></span><br><span class="line"><span class="string">$ echo "</span>This is \<span class="string">"<span class="variable">$name</span>\""</span>      <span class="comment"># 双引号则反之</span></span><br><span class="line">This is <span class="string">"louishsu"</span></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">'This is \"$name\"'</span>   <span class="comment"># echo开启转义也无效</span></span><br><span class="line">This is \<span class="string">"<span class="variable">$name</span>\"</span></span><br><span class="line"><span class="string">$ echo -e "</span>This is \<span class="string">"<span class="variable">$name</span>\""</span>   <span class="comment"># echo开启转义有效</span></span><br><span class="line">This is <span class="string">"louishsu"</span></span><br></pre></td></tr></table></figure></p><p>字符串可进行拼接<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ name=louishsu</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"Hello, "</span><span class="variable">$name</span><span class="string">"!"</span></span><br><span class="line">Hello, louishsu!</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"Hello, <span class="variable">$name</span>!"</span></span><br><span class="line">Hello, louishsu!</span><br></pre></td></tr></table></figure></p><p>字符串长度、子字符串、查找字符串<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="comment"># 字符串长度</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;#name&#125;</span>     </span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">$ <span class="comment"># 尝试使用下标</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;name[0]&#125;</span>   </span><br><span class="line">louishsu</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;name[1]&#125;</span></span><br><span class="line">            <span class="comment"># 输出回车</span></span><br><span class="line"></span><br><span class="line">$ <span class="comment"># 截取子字符串</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;name:0:5&#125;</span>  <span class="comment"># 从0开始，截取5个字符</span></span><br><span class="line">louis</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;name:5:3&#125;</span>  <span class="comment"># 从5开始，截取3个字符</span></span><br><span class="line">hsu</span><br><span class="line"></span><br><span class="line">$ <span class="comment"># 查找字符串</span></span><br><span class="line">$ <span class="built_in">echo</span> `expr index <span class="variable">$name</span> su` <span class="comment"># 查找s或u</span></span><br><span class="line">3</span><br></pre></td></tr></table></figure></p><h2 id="变量参数"><a href="#变量参数" class="headerlink" title="变量参数"></a>变量参数</h2><p>以下介绍如何<strong>定义变量</strong>及<strong>删除变量</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="comment"># 未创建变量</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">            <span class="comment"># 输出回车</span></span><br><span class="line"></span><br><span class="line">$ <span class="comment"># 创建变量var，注意赋值符两侧不能有空格</span></span><br><span class="line">$ var=/home/louishsu</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">/home/louishsu</span><br><span class="line">$ <span class="comment"># 变量可用作路径等</span></span><br><span class="line">$ ls <span class="variable">$var</span></span><br><span class="line">Downloads  anaconda3  backup</span><br><span class="line"></span><br><span class="line">$ <span class="comment"># 创建带空格的字符串变量</span></span><br><span class="line">$ var=<span class="string">"hello world!"</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">hello world!</span><br><span class="line"></span><br><span class="line">$ <span class="comment"># 删除变量</span></span><br><span class="line">$ <span class="built_in">unset</span> var <span class="comment"># 注意无需`$`</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">            <span class="comment"># 输出回车</span></span><br><span class="line"></span><br><span class="line">$ <span class="comment"># 只读变量</span></span><br><span class="line">$ var=1</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">1</span><br><span class="line">$ <span class="built_in">readonly</span> var  <span class="comment"># 设置为只读</span></span><br><span class="line">$ var=2         <span class="comment"># 不可更改</span></span><br><span class="line">-bash: var: <span class="built_in">readonly</span> variable</span><br><span class="line">$ <span class="built_in">unset</span> var     <span class="comment"># 不可删除</span></span><br><span class="line">-bash: <span class="built_in">unset</span>: var: cannot <span class="built_in">unset</span>: <span class="built_in">readonly</span> variable</span><br></pre></td></tr></table></figure></p><h2 id="数组参数"><a href="#数组参数" class="headerlink" title="数组参数"></a>数组参数</h2><p>shell可使用<strong>数组</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="comment"># 定义数组变量</span></span><br><span class="line">var=(1 2 3 4 5)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var</span> <span class="comment"># 无法全部打印输出</span></span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">$ <span class="comment"># 以下标获取数组元素(0开始)</span></span><br><span class="line">$ <span class="comment"># 缺少`&#123;&#125;`界定符</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var</span>[1]  </span><br><span class="line">1[1]        <span class="comment"># 失败</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;var[1]&#125;</span></span><br><span class="line">2           <span class="comment"># 成功</span></span><br><span class="line"></span><br><span class="line">$ <span class="comment"># 打印输出全部元素</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;var[*]&#125;</span></span><br><span class="line">1 2 3 4 5</span><br><span class="line"></span><br><span class="line">$ <span class="comment"># 获取数组长度</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;#var&#125;</span></span><br><span class="line">1           <span class="comment"># 失败</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;#var[*]&#125;</span></span><br><span class="line">5           <span class="comment"># 成功</span></span><br><span class="line"></span><br><span class="line">$ <span class="comment"># 删除数组元素后，令人疑惑的地方，需注意</span></span><br><span class="line">$ <span class="built_in">unset</span> var[1]</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;var[1]&#125;</span></span><br><span class="line">            <span class="comment"># 输出回车</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;var[*]&#125;</span></span><br><span class="line">1 3 4 5</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;#var[*]&#125;</span></span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">$ <span class="comment"># 删除数组</span></span><br><span class="line">$ <span class="built_in">unset</span> var</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;var[*]&#125;</span></span><br><span class="line">            <span class="comment"># 输出回车</span></span><br></pre></td></tr></table></figure></p><h1 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h1><h2 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h2><p>在执行脚本时，可将命令行参数传递给脚本使用，通过位置参数调用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印输出参数</span></span><br><span class="line"><span class="comment"># $0: 脚本文件名</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The filename of script is <span class="variable">$0</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The basename is <span class="variable">$( basename $0 )</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># $#: 参数个数</span></span><br><span class="line"><span class="comment"># $1, ..., $&#123;10&#125;, ...: 位置参数</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">"There are <span class="variable">$#</span> parameters supplied， which are:"</span></span><br><span class="line"><span class="keyword">for</span> ((i = 1; i &lt;= <span class="variable">$#</span>; i++)); <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> -n <span class="variable">$&#123;!i&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 若不加引号，则以下两种输出结果相同</span></span><br><span class="line"><span class="comment"># 获取参数列表</span></span><br><span class="line"><span class="comment"># $*: 将参数视作字符串整体</span></span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> <span class="string">"$*"</span>; <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$param</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># $@: 将参数视作字符串内独立的单词</span></span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span>; <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$param</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取最后一个变量</span></span><br><span class="line"><span class="comment"># echo "The last parameter is $&#123;$#&#125;"    # 错误，&#123;&#125;内不能带$</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The last parameter is <span class="variable">$&#123;!#&#125;</span>"</span></span><br><span class="line">argc=<span class="variable">$#</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The last parameter is <span class="variable">$argc</span>"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ./test.sh 1 2 3</span><br><span class="line">The filename of script is ./test.sh</span><br><span class="line">The basename is test.sh</span><br><span class="line">There are 3 parameters supplied， <span class="built_in">which</span> are:123</span><br><span class="line">1 2 3</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">The last parameter is 3</span><br><span class="line">The last parameter is 3</span><br></pre></td></tr></table></figure><h2 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h2><ol><li><p>通过<code>shift</code>命令处理<br> 调用一次<code>shift</code>命令，<code>$1</code>参数被删除，其余所有参数向左移动，即<code>$2</code>移动到<code>$1</code>，<code>$3</code>移动到<code>$2</code>中，以此类推。例如，某脚本需处理命令行参数<code>-a -b 3 -c -d</code>，其中<code>-b</code>为命名参数，则脚本如下编写</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">while</span> [ -n <span class="string">"<span class="variable">$1</span>"</span> ]       <span class="comment"># 不可缺少引号""</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span></span><br><span class="line">        -a) <span class="built_in">echo</span> <span class="string">"Option -a"</span> ;;</span><br><span class="line">        -b)</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"Option -b"</span></span><br><span class="line">            <span class="built_in">shift</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"Value of option -b is: <span class="variable">$1</span>"</span></span><br><span class="line">        ;;</span><br><span class="line">        -c) <span class="built_in">echo</span> <span class="string">"Option -c"</span>;;</span><br><span class="line">        *) <span class="built_in">echo</span> <span class="string">"Invalid parameters"</span>;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./test.sh -a -b 5 -c</span><br><span class="line">Option -a</span><br><span class="line">Option -b</span><br><span class="line">Value of option -b is: 5</span><br><span class="line">Option -c</span><br></pre></td></tr></table></figure></li><li><p>通过<code>getopt</code>命令处理</p><p> <code>getopt</code>命令简单使用格式如下</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getopt optstring parameters</span><br></pre></td></tr></table></figure><p> 例如解析<code>-a -b 3 -c -d</code>，指定<code>optsting</code>为<code>ab:cd</code>，其中<code>:</code>表示该处包含参数值，在输出<code>--</code>后的参数均视作位置参数</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ getopt ab:<span class="built_in">cd</span> -a -b 5 -c -d 1 2 3</span><br><span class="line">-a -b 5 -c -d -- 1 2 3</span><br></pre></td></tr></table></figure><p> 配合<code>set</code>命令，将脚本原始的命令行参数解析</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> -- $( getopt -q ab:<span class="built_in">cd</span> <span class="string">"<span class="variable">$@</span>"</span> )</span><br></pre></td></tr></table></figure><p> 脚本如下</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -- $( getopt ab:<span class="built_in">cd</span> <span class="string">"<span class="variable">$@</span>"</span> )</span><br><span class="line"><span class="keyword">while</span> [ -n <span class="string">"<span class="variable">$1</span>"</span> ]       <span class="comment"># 不可缺少引号""</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span></span><br><span class="line">                -a) <span class="built_in">echo</span> <span class="string">"Option -a"</span> ;;</span><br><span class="line">                -b)</span><br><span class="line">                        <span class="built_in">echo</span> <span class="string">"Option -b"</span></span><br><span class="line">                        <span class="built_in">shift</span></span><br><span class="line">                        <span class="built_in">echo</span> <span class="string">"Value of option -b is: <span class="variable">$1</span>"</span></span><br><span class="line">                        ;;</span><br><span class="line">                -c) <span class="built_in">echo</span> <span class="string">"Option -c"</span>;;</span><br><span class="line">                --) <span class="built_in">break</span> ;;</span><br><span class="line">                *) <span class="built_in">echo</span> <span class="string">"Invalid parameter: <span class="variable">$1</span>"</span>;;</span><br><span class="line">        <span class="keyword">esac</span></span><br><span class="line">        <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ ./test.sh -a -b 5 -c -d</span><br><span class="line">Option -a</span><br><span class="line">Option -b</span><br><span class="line">Value of option -b is: 5</span><br><span class="line">Option -c</span><br><span class="line">Invalid parameter: -d</span><br><span class="line"></span><br><span class="line">$ ./test.sh -a -b5 -<span class="built_in">cd</span></span><br><span class="line">Option -a</span><br><span class="line">Option -b</span><br><span class="line">Value of option -b is: 5</span><br><span class="line">Option -c</span><br><span class="line">Invalid parameter: -d</span><br><span class="line"></span><br><span class="line">$ ./test.sh -ab5 -<span class="built_in">cd</span></span><br><span class="line">Option -a</span><br><span class="line">Option -b</span><br><span class="line">Value of option -b is: 5</span><br><span class="line">Option -c</span><br><span class="line">Invalid parameter: -d</span><br><span class="line"></span><br><span class="line">$ <span class="comment"># 但是如下失败</span></span><br><span class="line">$ ./test.sh -ab5cd</span><br><span class="line">Option -a</span><br><span class="line">Option -b</span><br><span class="line">Value of option -b is: 5cd</span><br></pre></td></tr></table></figure></li></ol><h1 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a>用户输入</h1><p><code>read</code>命令可提供用户输入接口，从标准输入或文件描述符中接受输入，实现脚本可交互。</p><h2 id="基本输入-read"><a href="#基本输入-read" class="headerlink" title="基本输入: read"></a>基本输入: read</h2><p><code>read</code>可指定多个变量，将输入的每个数据依次分配给各个变量，若变量数目不够则将剩余数据全部放入最后一个变量，如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">read</span> first last age</span><br><span class="line">louis hsu 25</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"<span class="variable">$first</span> <span class="variable">$last</span>, aged <span class="variable">$age</span>"</span></span><br><span class="line">louis hsu, aged 25</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">read</span> first last age</span><br><span class="line">louis hsu 25 coolman</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"<span class="variable">$age</span>"</span></span><br><span class="line">25 coolman</span><br></pre></td></tr></table></figure></p><p>指定<code>-p</code>，可输出命令提示符<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">read</span> -p <span class="string">"Who are you? "</span> first last age</span><br><span class="line">Who are you? louis hsu 25</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"<span class="variable">$first</span> <span class="variable">$last</span>, aged <span class="variable">$age</span>"</span></span><br><span class="line">louis hsu, aged 25</span><br></pre></td></tr></table></figure></p><p>指定<code>-t</code>进行超时处理<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">read</span> -t 5 first last age      <span class="comment"># 5秒</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"<span class="variable">$first</span> <span class="variable">$last</span>, aged <span class="variable">$age</span>"</span></span><br><span class="line"> , aged</span><br></pre></td></tr></table></figure></p><p>指定<code>-s</code>，隐藏输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">read</span> -s -p <span class="string">"Enter your passwd: "</span> passwd</span><br><span class="line">Enter your passwd:      <span class="comment"># 输入`______`</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$passwd</span></span><br><span class="line">______</span><br></pre></td></tr></table></figure></p><h2 id="文件输入-cat-read"><a href="#文件输入-cat-read" class="headerlink" title="文件输入: cat | read"></a>文件输入: cat | read</h2><p>配合<code>cat</code>指令，通过管道，实现文件输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.txt | <span class="keyword">while</span> <span class="built_in">read</span> line; <span class="keyword">do</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$line</span></span><br><span class="line">&gt; <span class="keyword">done</span></span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">louishu</span><br><span class="line">25</span><br><span class="line">coolman</span><br></pre></td></tr></table></figure></p><p>或者通过重定向实现。</p><h1 id="脚本退出-exit"><a href="#脚本退出-exit" class="headerlink" title="脚本退出: exit"></a>脚本退出: exit</h1><p>shell中运行的命令都使用<strong>退出状态码</strong>(exit status)作为运行结果标识符，为0~255的整数，可通过<code>$?</code>查看上个执行命令的退出状态码。按照惯例成功运行命令后的退出状态码为0，常用的如下</p><div class="table-container"><table><thead><tr><th>状态码</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>命令成功执行</td></tr><tr><td>1</td><td>一般性未知错误</td></tr><tr><td>2</td><td>不适合的shell命令</td></tr><tr><td>126</td><td>命令不可执行</td></tr><tr><td>127</td><td>未查找到命令</td></tr><tr><td>128</td><td>无效的退出参数</td></tr><tr><td>128+x</td><td>与linux信号x相关的严重错误</td></tr><tr><td>130</td><td>通过ctrl+c终止的命令</td></tr><tr><td>255</td><td>正常范围之外的退出状态码</td></tr></tbody></table></div><p>shell脚本会以最后一个命令的退出码退出，用户也可通过<code>exit</code>命令指定。注意若退出结果超过255，会返回该值对256的模。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="comment"># 正常退出</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"hello world!"</span>; <span class="built_in">echo</span> $?</span><br><span class="line">hello world!</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">$ <span class="comment"># 未查找到命令</span></span><br><span class="line">$ unknown <span class="built_in">command</span>; <span class="built_in">echo</span> $?</span><br><span class="line"></span><br><span class="line">Command <span class="string">'unknown'</span> not found, but can be installed with:</span><br><span class="line"></span><br><span class="line">sudo apt install fastlink</span><br><span class="line"></span><br><span class="line">127</span><br><span class="line"></span><br><span class="line">$ <span class="comment"># 一般性未知错误</span></span><br><span class="line">$ wget; <span class="built_in">echo</span> $?</span><br><span class="line">wget: missing URL</span><br><span class="line">Usage: wget [OPTION]... [URL]...</span><br><span class="line"></span><br><span class="line">Try `wget --<span class="built_in">help</span><span class="string">' for more options.</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$ # 用户指定退出码</span></span><br><span class="line"><span class="string">$ cat test.sh</span></span><br><span class="line"><span class="string">#!/bin/bash</span></span><br><span class="line"><span class="string">echo "hello world!"</span></span><br><span class="line"><span class="string">exit 777</span></span><br><span class="line"><span class="string">$ bash test.sh ; echo $?</span></span><br><span class="line"><span class="string">hello world!</span></span><br><span class="line"><span class="string">9       # 777 % 256</span></span><br></pre></td></tr></table></figure><h1 id="命令替换-command"><a href="#命令替换-command" class="headerlink" title="命令替换: ( command )"></a>命令替换: ( command )</h1><p>shell脚本最有用的特性是<strong>将命令输出赋值给变量</strong>，有两种方法可以实现</p><ol><li>反引号字符<code>&#39;</code></li><li><code>( command )</code>格式，<code>$</code>进行取值</li></ol><p>例如，以时间信息创建文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ time=$(date +%y%m%d)  <span class="comment"># 或 time=`date +%y%m%d`</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$time</span></span><br><span class="line">200505</span><br><span class="line">$ touch <span class="variable">$&#123;time&#125;</span>.txt</span><br><span class="line">$ ls</span><br><span class="line">200505.txt</span><br></pre></td></tr></table></figure></p><h1 id="运算和测试"><a href="#运算和测试" class="headerlink" title="运算和测试"></a>运算和测试</h1><h2 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h2><h3 id="expr-expression"><a href="#expr-expression" class="headerlink" title="$( expr expression )"></a>$( expr expression )</h3><p><strong>仅支持整数运算</strong>。支持逻辑操作符<code>|, &amp;</code>、比较操作符<code>&lt;, &lt;=, &gt;, &gt;=, =, !=</code>、运算操作符<code>+, -, *, /, %</code>(注意乘号符需进行转义<code>\*</code>)。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ var1=4; var2=5</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> $(expr <span class="variable">$var1</span> + <span class="variable">$var2</span>)</span><br><span class="line">9</span><br><span class="line">$ <span class="built_in">echo</span> $(expr <span class="variable">$var1</span> - <span class="variable">$var2</span>)</span><br><span class="line">-1</span><br><span class="line">$ <span class="built_in">echo</span> $(expr <span class="variable">$var1</span> / <span class="variable">$var2</span>)</span><br><span class="line">0</span><br><span class="line">$ <span class="built_in">echo</span> $(expr <span class="variable">$var1</span> * <span class="variable">$var2</span>)</span><br><span class="line">expr: syntax error</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> $(expr <span class="variable">$var1</span> \* <span class="variable">$var2</span>)</span><br><span class="line">20</span><br></pre></td></tr></table></figure></p><p>此外还支持部分字符串操作</p><h3 id="expression"><a href="#expression" class="headerlink" title="$[ expression ]"></a>$[ expression ]</h3><p>用<code>[ operation ]</code>格式将数学表达式包围，<code>$</code>进行取值，此时乘号符无需进行转义。支持高级运算，如幂运算<code>**</code>、移位运算<code>&gt;&gt;, &lt;&lt;</code>、位运算<code>&amp;, |, ~</code>、逻辑运算<code>&amp;&amp;, ||, !</code>等<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ var1=4; var2=5</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> $(expr <span class="variable">$var1</span> \* <span class="variable">$var2</span>)</span><br><span class="line">20</span><br><span class="line">$ <span class="built_in">echo</span> $[ <span class="variable">$var1</span> + <span class="variable">$var2</span> ]</span><br><span class="line">9</span><br><span class="line">$ <span class="built_in">echo</span> $[ <span class="variable">$var1</span> - <span class="variable">$var2</span> ]</span><br><span class="line">-1</span><br><span class="line">$ <span class="built_in">echo</span> $[ <span class="variable">$var1</span> / <span class="variable">$var2</span> ]</span><br><span class="line">0</span><br><span class="line">$ <span class="built_in">echo</span> $[ <span class="variable">$var1</span> * <span class="variable">$var2</span> ]</span><br><span class="line">20</span><br><span class="line">$ <span class="built_in">echo</span> $[ <span class="variable">$var1</span> ** <span class="variable">$var2</span> ]</span><br><span class="line">1024</span><br><span class="line">$ <span class="built_in">echo</span> $[ <span class="variable">$var1</span> &lt;&lt; <span class="variable">$var2</span> ]</span><br><span class="line">128</span><br><span class="line">$ <span class="built_in">echo</span> $[ <span class="variable">$var1</span> &gt;&gt; <span class="variable">$var2</span> ]</span><br><span class="line">0</span><br><span class="line">$ <span class="built_in">echo</span> $[ <span class="variable">$var1</span> &amp; <span class="variable">$var2</span> ]</span><br><span class="line">4</span><br><span class="line">$ <span class="built_in">echo</span> $[ <span class="variable">$var1</span> | <span class="variable">$var2</span> ]</span><br><span class="line">5</span><br><span class="line">$ <span class="built_in">echo</span> $[ <span class="variable">$var1</span> &amp;&amp; <span class="variable">$var2</span> ]</span><br><span class="line">1</span><br><span class="line">$ <span class="built_in">echo</span> $[ <span class="variable">$var1</span> || <span class="variable">$var2</span> ]</span><br><span class="line">1$ <span class="built_in">echo</span> $[ ! <span class="variable">$var1</span> ]</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p><h3 id="let-expression-expression"><a href="#let-expression-expression" class="headerlink" title="let expression, $(( expression ))"></a>let expression, $(( expression ))</h3><p><code>let expression</code>等价于<code>(( expression ))</code>，都支持一次性计算多个表达式，以最后一个表达式的值作为整个命令的执行结果。不同之处是，<code>let</code>以空格作为分隔符，<code>(())</code>以<code>,</code>作为分隔符。显然前者没有后者灵活。  同样的，<code>(( expression ))</code>用<code>$</code>进行表达式的取值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ var1=4; var2=5</span><br><span class="line">$ <span class="built_in">echo</span> <span class="built_in">let</span> <span class="variable">$var1</span>+<span class="variable">$var2</span></span><br><span class="line"><span class="built_in">let</span> 4+5         <span class="comment"># 被视作字符串</span></span><br><span class="line">$ <span class="built_in">let</span> sum=<span class="variable">$var1</span>+<span class="variable">$var2</span>; <span class="built_in">echo</span> <span class="variable">$sum</span>     <span class="comment"># sum保存变量</span></span><br><span class="line">9</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> $(( <span class="variable">$var1</span>+<span class="variable">$var2</span> ))</span><br><span class="line">9</span><br></pre></td></tr></table></figure></p><p>可快速实现变量自增、自减操作<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ i=0</span><br><span class="line">$ <span class="built_in">let</span> i+=1; <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">1</span><br><span class="line">$ (( i++ )); <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">2</span><br><span class="line">$ (( i-- )); <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">1</span><br><span class="line">$ (( ++i )); <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">2</span><br><span class="line">$ (( --i )); <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure></p><h3 id="内建计算器bc"><a href="#内建计算器bc" class="headerlink" title="内建计算器bc"></a>内建计算器bc</h3><p>内建计算器支持浮点运算，实际上是一种编程语言，bash计算器能识别</p><ul><li>数字(整数、浮点数)</li><li>变量(简单变量、数组)</li><li>注释(<code>#</code>或<code>/* */</code>格式)</li><li>表达式</li><li>编程语句(如<code>if-then</code>)</li><li>函数</li></ul><p>浮点运算的精度通过内建变量<code>scale</code>控制，表示保留的小数位数，默认值是0<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ bc</span><br><span class="line">bc 1.07.1</span><br><span class="line">Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006, 2008, 2012-2017 Free Software Foundation, Inc.</span><br><span class="line">This is free software with ABSOLUTELY NO WARRANTY.</span><br><span class="line">For details <span class="built_in">type</span> `warranty<span class="string">'.</span></span><br><span class="line"><span class="string">scale       # 显示当前scale</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">var1=4; var2=5</span></span><br><span class="line"><span class="string">var1 / var2</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">scale=2     # scale指定为2</span></span><br><span class="line"><span class="string">var1 / var2</span></span><br><span class="line"><span class="string">.80</span></span><br><span class="line"><span class="string">quit        # 退出</span></span><br></pre></td></tr></table></figure></p><p>在脚本中使用<code>bc</code>命令有两种方式</p><ol><li><p>单行运算：<br> 通过<strong>命令替换</strong>和<strong>管道</strong>实现，格式为<br> <code>variable=$( echo &quot;options; expression&quot; | bc )</code><br> 例如</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ var1=4; var2=5</span><br><span class="line">$ var3=$( <span class="built_in">echo</span> <span class="string">"scale=2; <span class="variable">$var1</span> / <span class="variable">$var2</span>"</span> | bc )</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var3</span></span><br><span class="line">.80</span><br></pre></td></tr></table></figure></li><li><p>多行运算：<br> 通过<strong>命令替换</strong>和<strong>内联输入重定向</strong>实现，格式为</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">variable=$(bc &lt;&lt; EOF</span><br><span class="line">options</span><br><span class="line">statements</span><br><span class="line">expressions</span><br><span class="line">EOF</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p> 需要注意的是，<code>bc</code>内部变量和shell变量是独立的，变量名可重复使用，例如</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ var3=$(bc &lt;&lt; EOF</span><br><span class="line">&gt; scale=2</span><br><span class="line">&gt; <span class="variable">$var1</span> / <span class="variable">$var2</span>     <span class="comment"># 引用shell变量</span></span><br><span class="line">&gt; EOF</span><br><span class="line">&gt; )</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var3</span></span><br><span class="line">.80                 <span class="comment"># 输出shell变量运算结果</span></span><br><span class="line"></span><br><span class="line">$ var3=$(bc &lt;&lt; EOF</span><br><span class="line">&gt; scale=2</span><br><span class="line">&gt; var1=5; var2=4    <span class="comment"># 重新定义变量</span></span><br><span class="line">&gt; var1 / var2</span><br><span class="line">&gt; EOF</span><br><span class="line">&gt; )</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var3</span></span><br><span class="line">1.25                <span class="comment"># 输出bc变量运算结果</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var1</span>        <span class="comment"># 不会修改shell变量</span></span><br><span class="line">4</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var2</span></span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">$ var3=$(bc &lt;&lt; EOF</span><br><span class="line">&gt; scale=2</span><br><span class="line">&gt; var1=5; var2=4    <span class="comment"># 重新定义变量</span></span><br><span class="line">&gt; <span class="variable">$var1</span> / <span class="variable">$var2</span>     <span class="comment"># 引用shell变量</span></span><br><span class="line">&gt; EOF</span><br><span class="line">&gt; )</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var3</span></span><br><span class="line">.80                 <span class="comment"># 输出shell变量运算结果</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var1</span>        <span class="comment"># 不会修改shell变量</span></span><br><span class="line">4</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var2</span></span><br><span class="line">5</span><br></pre></td></tr></table></figure></li></ol><h2 id="测试命令-test-expression-expression"><a href="#测试命令-test-expression-expression" class="headerlink" title="测试命令: test expression, [ expression ]"></a>测试命令: test expression, [ expression ]</h2><p>测试命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试，还可进行复合测试，可通过<code>test</code>命令或<code>[ option ]</code>实现</p><h3 id="数值测试-eq-ne-gt-ge-lt-le"><a href="#数值测试-eq-ne-gt-ge-lt-le" class="headerlink" title="数值测试: -eq, -ne, -gt, -ge, -lt, -le"></a>数值测试: -eq, -ne, -gt, -ge, -lt, -le</h3><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-eq</td><td>等于则为真</td></tr><tr><td>-ne</td><td>不等于则为真</td></tr><tr><td>-gt</td><td>大于则为真</td></tr><tr><td>-ge</td><td>大于等于则为真</td></tr><tr><td>-lt</td><td>小于则为真</td></tr><tr><td>-le</td><td>小于等于则为真</td></tr></tbody></table></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ var1=4; var2=5</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">if</span> <span class="built_in">test</span> <span class="variable">$var1</span> -le <span class="variable">$var2</span>; <span class="keyword">then</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"less"</span></span><br><span class="line">&gt; <span class="keyword">else</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"greater"</span></span><br><span class="line">&gt; <span class="keyword">fi</span></span><br><span class="line">less</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">if</span> [ <span class="variable">$var1</span> -le <span class="variable">$var2</span> ]; <span class="keyword">then</span>      <span class="comment"># 注意空格</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"less"</span></span><br><span class="line">&gt; <span class="keyword">else</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"greater"</span></span><br><span class="line">&gt; <span class="keyword">fi</span></span><br><span class="line">less</span><br></pre></td></tr></table></figure><h3 id="字符测试-lt-gt-n-z"><a href="#字符测试-lt-gt-n-z" class="headerlink" title="字符测试: =, !=, &lt;, &gt;, -n  -z"></a>字符测试: =, !=, &lt;, &gt;, -n  -z</h3><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>=</td><td>等于则为真</td></tr><tr><td>!=</td><td>不等于则为真</td></tr><tr><td>&lt;</td><td>小于则为真</td></tr><tr><td>&gt;</td><td>大于则为真</td></tr><tr><td>-n</td><td>长度非0或未定义，则为真</td></tr><tr><td>-z</td><td>长度为0则为真</td></tr></tbody></table></div><p>注意：</p><ul><li>大于号<code>&gt;</code>和小于号<code>&lt;</code>必须转义，否则被视作重定向符，字符串值视作文件名；</li><li>大写字母被认为是小于小写字母的。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ var1=<span class="string">"Test"</span>; var2=<span class="string">"test"</span></span><br><span class="line"></span><br><span class="line">$ <span class="keyword">if</span> <span class="built_in">test</span> <span class="variable">$var1</span> \&lt; <span class="variable">$var2</span>; <span class="keyword">then</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"less"</span></span><br><span class="line">&gt; <span class="keyword">else</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"greater"</span></span><br><span class="line">&gt; <span class="keyword">fi</span></span><br><span class="line">less</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">if</span> [ <span class="variable">$var1</span> \&lt; <span class="variable">$var2</span> ]; <span class="keyword">then</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"less"</span></span><br><span class="line">&gt; <span class="keyword">else</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"greater"</span></span><br><span class="line">&gt; <span class="keyword">fi</span></span><br><span class="line">less</span><br></pre></td></tr></table></figure><p>注意，若在比较数值时采用<code>&lt;, &gt;</code>等符号，会将数值视作字符串，同样也存在未转义识别为重定向符的问题<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">if</span> [ 4 &gt; 5 ]; <span class="keyword">then</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"4 is greater than 5"</span></span><br><span class="line">&gt; <span class="keyword">elif</span> [ 4 = 5 ]; <span class="keyword">then</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"4 is equal to 5"</span></span><br><span class="line">&gt; <span class="keyword">else</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"4 is less than 5"</span></span><br><span class="line">&gt; <span class="keyword">fi</span></span><br><span class="line">4 is greater than 5</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">if</span> [ 4 -gt 5 ]; <span class="keyword">then</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"4 is greater than 5"</span></span><br><span class="line">&gt; <span class="keyword">elif</span> [ 4 -eq 5 ]; <span class="keyword">then</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"4 is equal to 5"</span></span><br><span class="line">&gt; <span class="keyword">else</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"4 is less than 5"</span></span><br><span class="line">&gt; <span class="keyword">fi</span></span><br><span class="line">4 is less than 5</span><br><span class="line"></span><br><span class="line">$ ls</span><br><span class="line">5       <span class="comment"># 新建文件5</span></span><br></pre></td></tr></table></figure></p><h3 id="文件测试-e-d-f-…"><a href="#文件测试-e-d-f-…" class="headerlink" title="文件测试: -e, -d, -f, …"></a>文件测试: -e, -d, -f, …</h3><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-e file</td><td>如果文件存在则为真</td></tr><tr><td>-d file</td><td>如果文件存在且为目录则为真</td></tr><tr><td>-f file</td><td>如果文件存在且为普通文件则为真</td></tr><tr><td>-s file</td><td>如果文件存在且至少有一个字符则为真</td></tr><tr><td>-c file</td><td>如果文件存在且为字符型特殊文件则为真</td></tr><tr><td>-b file</td><td>如果文件存在且为块特殊文件则为真</td></tr><tr><td>-r file</td><td>如果文件存在且可读则为真</td></tr><tr><td>-w file</td><td>如果文件存在且可写则为真</td></tr><tr><td>-x file</td><td>如果文件存在且可执行则为真</td></tr><tr><td>-O file</td><td>如果文件存在且属于当前用户所有则为真</td></tr><tr><td>-G file</td><td>如果文件存在且默认组与当前用户相同则为真</td></tr><tr><td>file1 -nt file2</td><td>文件1比文件2新则为真</td></tr><tr><td>file1 -ot file2</td><td>文件1比文件2旧则为真</td></tr></tbody></table></div><h3 id="复合条件测试-o-a-amp-amp"><a href="#复合条件测试-o-a-amp-amp" class="headerlink" title="复合条件测试: !, -o / ||, -a / &amp;&amp;"></a>复合条件测试: !, -o / ||, -a / &amp;&amp;</h3><div class="table-container"><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>!</td><td>非运算，表达式为 true 则返回 false，否则返回 true。</td><td>[ ! false ] 返回 true。</td></tr><tr><td>-o / `</td><td></td><td>`</td><td>或运算，有一个表达式为 true 则返回 true，满足就近原则，即运算符前表达式为真则跳过后一表达式</td><td>[ condition1 -o condition1 ] 或 [ condition1 ] `</td><td></td><td>` [ condition1 ]</td></tr><tr><td>-a / &amp;&amp;</td><td>与运算，两个表达式都为 true 才返回 true。</td><td>[ condition1 -a condition1 ] 或 [ condition1 ] &amp;&amp; [ condition1 ]</td></tr></tbody></table></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">if</span> [ <span class="variable">$var1</span> -le <span class="variable">$var2</span> -o <span class="variable">$var3</span> -le <span class="variable">$var4</span> ]; <span class="keyword">then</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"condition 1"</span></span><br><span class="line">&gt; <span class="keyword">else</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"condition 2"</span></span><br><span class="line">&gt; <span class="keyword">fi</span></span><br><span class="line">condition 1</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">if</span> [ <span class="variable">$var1</span> -le <span class="variable">$var2</span> ] || [ <span class="variable">$var3</span> -le <span class="variable">$var4</span> ]; <span class="keyword">then</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"condition 1"</span></span><br><span class="line">&gt; <span class="keyword">else</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"condition 2"</span></span><br><span class="line">&gt; <span class="keyword">fi</span></span><br><span class="line">condition 1</span><br></pre></td></tr></table></figure><h1 id="结构化命令"><a href="#结构化命令" class="headerlink" title="结构化命令"></a>结构化命令</h1><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><h3 id="if-then-elif-else-fi"><a href="#if-then-elif-else-fi" class="headerlink" title="if-then-elif-else-fi"></a>if-then-elif-else-fi</h3><p>完整的<code>if-then</code>语句如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition/<span class="built_in">command</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    commands    <span class="comment"># 多个命令</span></span><br><span class="line"><span class="keyword">elif</span> condition/<span class="built_in">command</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    commands</span><br><span class="line">[...]           <span class="comment"># 多个elif分支</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p><p>注意，<code>if</code>后可<strong>接命令或测试语句</strong>，当所接命令退出码为0时判定为真，测试语句逻辑为真时判定为真。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">if</span> <span class="built_in">pwd</span>; <span class="keyword">then</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"pwd successfully exit"</span></span><br><span class="line">&gt; <span class="keyword">fi</span></span><br><span class="line">/home/louishsu</span><br><span class="line"><span class="built_in">pwd</span> successfully <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">$ <span class="keyword">if</span> [ 4 -gt 5 ]; <span class="keyword">then</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"4 is greater than 5"</span></span><br><span class="line">&gt; <span class="keyword">elif</span> [ 4 -eq 5 ]; <span class="keyword">then</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"4 is equal to 5"</span></span><br><span class="line">&gt; <span class="keyword">else</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"4 is less than 5"</span></span><br><span class="line">&gt; <span class="keyword">fi</span></span><br><span class="line">4 is less than 5</span><br></pre></td></tr></table></figure><p>支持<strong>针对字符串比较的高级特性</strong>，如模式匹配，使用<code>[[ expression ]]</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">if</span> [[ <span class="variable">$USER</span> == l* ]]; <span class="keyword">then</span> <span class="comment"># 双等号</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"This is louishsu!"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">This is louishsu!</span><br></pre></td></tr></table></figure></p><h3 id="case-in"><a href="#case-in" class="headerlink" title="case-in"></a>case-in</h3><p>多选择语句，可以用<code>case</code>匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。完整格式如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> variable <span class="keyword">in</span></span><br><span class="line">pattern1)       <span class="comment"># 以右括号结束</span></span><br><span class="line">    commands</span><br><span class="line">    ;;          <span class="comment"># 以;;结束，表示 break</span></span><br><span class="line">pattern2)</span><br><span class="line">    commands</span><br><span class="line">    ;;</span><br><span class="line">[...]</span><br><span class="line">patternN)</span><br><span class="line">    commands</span><br><span class="line">    ;;</span><br><span class="line">*)              <span class="comment"># 无一匹配模式</span></span><br><span class="line">    commands</span><br><span class="line">    ;;</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ var=3</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">case</span> <span class="variable">$var</span> <span class="keyword">in</span></span><br><span class="line">&gt; 1) <span class="built_in">echo</span> <span class="string">"1"</span></span><br><span class="line">&gt; ;;</span><br><span class="line">&gt; 2) <span class="built_in">echo</span> <span class="string">"2"</span></span><br><span class="line">&gt; ;;</span><br><span class="line">&gt; 3) <span class="built_in">echo</span> <span class="string">"3"</span></span><br><span class="line">&gt; ;;</span><br><span class="line">&gt; 4) <span class="built_in">echo</span> <span class="string">"4"</span></span><br><span class="line">&gt; ;;</span><br><span class="line">&gt; *) <span class="built_in">echo</span> <span class="string">"others"</span></span><br><span class="line">&gt; <span class="keyword">esac</span></span><br><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="for-do-done"><a href="#for-do-done" class="headerlink" title="for-do-done"></a>for-do-done</h3><ol><li><p>迭代</p><p> 用于迭代列表，<code>in</code>列表是可选的，如果不用它，for循环使用命令行的位置参数。在迭代结束后，<code>variable</code>保存<code>itemN</code>的值且在不修改的情况下一直有效。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> variable <span class="keyword">in</span> item1 item2 ... itemN   <span class="comment"># 注意无`()`</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p> 以输出数字列表为例</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">for</span> number <span class="keyword">in</span> 1 2 3; <span class="keyword">do</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"The number is <span class="variable">$number</span>"</span></span><br><span class="line">&gt; <span class="keyword">done</span></span><br><span class="line">The number is 1</span><br><span class="line">The number is 2</span><br><span class="line">The number is 3</span><br><span class="line"></span><br><span class="line">$ nums=(1 2 3)</span><br><span class="line"><span class="comment"># $ for number in $nums; do     # 一种错误做法，只会输出1</span></span><br><span class="line">$ <span class="keyword">for</span> number <span class="keyword">in</span> <span class="variable">$&#123;nums[*]&#125;</span>; <span class="keyword">do</span>  <span class="comment"># 迭代数组</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"The number is <span class="variable">$number</span>"</span></span><br><span class="line">&gt; <span class="keyword">done</span></span><br><span class="line">The number is 1</span><br><span class="line">The number is 2</span><br><span class="line">The number is 3</span><br></pre></td></tr></table></figure><p> 迭代字符串与数组有所不同</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ str=<span class="string">"I am louishsu"</span></span><br><span class="line">$ <span class="keyword">for</span> wd <span class="keyword">in</span> <span class="variable">$str</span>; <span class="keyword">do</span>        <span class="comment"># 迭代字符串</span></span><br><span class="line"><span class="comment"># $ for wd in $&#123;str[*]&#125;; do # 同上，也可迭代字符串</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$wd</span></span><br><span class="line">&gt; <span class="keyword">done</span></span><br><span class="line">I</span><br><span class="line">am</span><br><span class="line">louishsu</span><br></pre></td></tr></table></figure><p> 还可迭代输出命令结果、通配符等，<code>in</code>后可接多个命令或目录</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">for</span> file <span class="keyword">in</span> $( ls; <span class="built_in">pwd</span> ); <span class="keyword">do</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"<span class="variable">$file</span>"</span></span><br><span class="line">&gt; <span class="keyword">done</span></span><br><span class="line">Downloads</span><br><span class="line">anaconda3</span><br><span class="line">backup</span><br><span class="line">/home/louishsu</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">for</span> file <span class="keyword">in</span> /home/louishsu/*; <span class="keyword">do</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$file</span></span><br><span class="line">&gt; <span class="keyword">done</span></span><br><span class="line">/home/louishsu/Downloads</span><br><span class="line">/home/louishsu/anaconda3</span><br><span class="line">/home/louishsu/backup</span><br></pre></td></tr></table></figure></li><li><p>C/C++风格</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (( variable assignment ; condition ; iteration process ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p> 注意</p><ul><li>变量赋值可带等号；</li><li><code>condition</code>中变量不需<code>$</code>；</li><li><p>可同时定义两个变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (( i=0, j=0; i&lt;3 &amp;&amp; j&lt;4; i++, j+=2 )); <span class="keyword">do</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$i</span>, <span class="variable">$j</span></span><br><span class="line">&gt; <span class="keyword">done</span></span><br><span class="line">0, 0</span><br><span class="line">1, 2</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="while-do-done"><a href="#while-do-done" class="headerlink" title="while-do-done"></a>while-do-done</h3><p>基本格式如下，在<code>condition</code>为假时停止循环<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ var=0</span><br><span class="line">$ <span class="keyword">while</span> <span class="built_in">echo</span> <span class="variable">$var</span> &amp;&amp; [ <span class="variable">$var</span> -le 3 ]; <span class="keyword">do</span> </span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"loop"</span></span><br><span class="line">&gt; (( var++ ))</span><br><span class="line">&gt; <span class="keyword">done</span></span><br><span class="line">0</span><br><span class="line">loop</span><br><span class="line">1</span><br><span class="line">loop</span><br><span class="line">2</span><br><span class="line">loop</span><br><span class="line">3</span><br><span class="line">loop</span><br><span class="line">4       <span class="comment"># 注意$var为4时，`echo $var`执行了一次</span></span><br></pre></td></tr></table></figure><h3 id="until-do-done"><a href="#until-do-done" class="headerlink" title="until-do-done"></a>until-do-done</h3><p>基本格式如下，与<code>while</code>相反，在<code>condition</code>为真时停止循环<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ var=0</span><br><span class="line">$ until <span class="built_in">echo</span> <span class="variable">$var</span> &amp;&amp; [ <span class="variable">$var</span> -le 3 ]; <span class="keyword">do</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"loop"</span></span><br><span class="line">&gt; (( var++ ))</span><br><span class="line">&gt; <span class="keyword">done</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="循环控制-break-continue"><a href="#循环控制-break-continue" class="headerlink" title="循环控制: break, continue"></a>循环控制: break, continue</h3><p>循环控制语句，包括<code>break/continue</code>，作用同C/C++或Python，不做过多介绍<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">"输入 1 到 5 之间的数字:"</span></span><br><span class="line">    <span class="built_in">read</span> aNum</span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$aNum</span> <span class="keyword">in</span></span><br><span class="line">        1|2|3|4|5) <span class="built_in">echo</span> <span class="string">"你输入的数字为 <span class="variable">$aNum</span>!"</span></span><br><span class="line">        ;;</span><br><span class="line">        *) <span class="built_in">echo</span> <span class="string">"你输入的数字不是 1 到 5 之间的! 游戏结束"</span></span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">"输入 1 到 5 之间的数字: "</span></span><br><span class="line">    <span class="built_in">read</span> aNum</span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$aNum</span> <span class="keyword">in</span></span><br><span class="line">        1|2|3|4|5) <span class="built_in">echo</span> <span class="string">"你输入的数字为 <span class="variable">$aNum</span>!"</span></span><br><span class="line">        ;;</span><br><span class="line">        *) <span class="built_in">echo</span> <span class="string">"你输入的数字不是 1 到 5 之间的!"</span></span><br><span class="line">            <span class="built_in">continue</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"游戏结束"</span>     <span class="comment"># 永远不会执行</span></span><br><span class="line">        ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="创建和调用函数"><a href="#创建和调用函数" class="headerlink" title="创建和调用函数"></a>创建和调用函数</h2><p>创建函数格式如下，注意函数名唯一，且shell中的函数支持<strong>递归调用</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> func &#123;</span><br><span class="line">    commands</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用函数时，在行中指定函数即可，但是函数定义必须在调用之前<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">commands</span><br><span class="line">[...]</span><br><span class="line">func</span><br><span class="line">[...]</span><br><span class="line">commands</span><br></pre></td></tr></table></figure></p><h2 id="参数传递-1"><a href="#参数传递-1" class="headerlink" title="参数传递"></a>参数传递</h2><h3 id="作用域-local"><a href="#作用域-local" class="headerlink" title="作用域: local"></a>作用域: local</h3><p>默认情况下，脚本中定义的任何变量都是<strong>全局变量</strong>(包括函数体内定义的变量)，可以在函数体中读取全局变量进行操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> func &#123;</span><br><span class="line">        var1=3  <span class="comment"># 修改全局变量</span></span><br><span class="line">        var2=4  <span class="comment"># 定义全局变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅定义var1</span></span><br><span class="line">var1=2</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$var1</span>, <span class="variable">$var2</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数中定义var2，仍为全局变量</span></span><br><span class="line">func</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$var1</span>, <span class="variable">$var2</span>"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./test.sh</span><br><span class="line">2,</span><br><span class="line">3, 4</span><br></pre></td></tr></table></figure><p>在函数体内可定义局部变量，使用<code>local</code>关键字，注意</p><ol><li>局部变量在函数体外不可见；</li><li>即使声明相同名称的局部变量，shell也会保证两个变量是分离的。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> func &#123;</span><br><span class="line">        <span class="built_in">local</span> var1=3    <span class="comment"># 定义局部变量</span></span><br><span class="line">        <span class="built_in">local</span> var2=4    <span class="comment"># 定义局部变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅定义var1</span></span><br><span class="line">var1=2</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$var1</span>, <span class="variable">$var2</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数中定义var2</span></span><br><span class="line">func</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$var1</span>, <span class="variable">$var2</span>"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./test.sh</span><br><span class="line">2,</span><br><span class="line">2,</span><br></pre></td></tr></table></figure><h3 id="变量参数-1"><a href="#变量参数-1" class="headerlink" title="变量参数"></a>变量参数</h3><p>类似shell脚本的参数传递，函数同样使用标准的参数环境变量进行参数传递，用<code>$0</code>表示函数名，<code>$1, $2, ...</code>表示参数，用<code>$#</code>获取参数数目，用<code>$*/$@</code>获取全部参数。</p><p>由于函数使用特殊参数环境变量进行参数传递，因此无法直接获取脚本在命令行中的参数值，两者不关联。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> func &#123;</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"These are function parameters: $*"</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"There are <span class="variable">$#</span> parameters"</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"The last parameter is: <span class="variable">$&#123;!#&#125;</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"These are script parameters: $*\n"</span></span><br><span class="line">func 5 6 7</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./test.sh 1 2 3</span><br><span class="line">These are script parameters: 1 2 3</span><br><span class="line"></span><br><span class="line">These are <span class="keyword">function</span> parameters: 5 6 7</span><br><span class="line">There are 3 parameters</span><br><span class="line">The last parameter is: 7</span><br></pre></td></tr></table></figure><h3 id="数组参数-1"><a href="#数组参数-1" class="headerlink" title="数组参数"></a>数组参数</h3><p>与函数传递数组，不能简单通过数组名进行；利用命令替换获取返回数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> func &#123;</span><br><span class="line">        <span class="built_in">local</span> array=( $(<span class="built_in">echo</span> <span class="string">"<span class="variable">$@</span>"</span>) )</span><br><span class="line">        <span class="keyword">for</span> (( i = 0; i &lt; <span class="variable">$&#123;#array[*]&#125;</span>; i++ )) &#123;</span><br><span class="line">                (( array[<span class="variable">$i</span>]++ ))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;array[*]&#125;</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">array=(1 2 3)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Input: <span class="variable">$&#123;array[*]&#125;</span>"</span></span><br><span class="line"></span><br><span class="line">ret=( $( func $(<span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;array[*]&#125;</span>"</span>) ) )</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Output: <span class="variable">$&#123;ret[*]&#125;</span>"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./test.sh</span><br><span class="line">Input: 1 2 3</span><br><span class="line">Output: 2 3 4</span><br></pre></td></tr></table></figure><h2 id="返回值-return-echo"><a href="#返回值-return-echo" class="headerlink" title="返回值: return, echo"></a>返回值: return, echo</h2><ol><li><p><strong>默认退出状态码</strong><br> 若函数<strong>未指定返回语句<code>return</code></strong>，则执行结束后标准变量<code>$?</code>内存储函数最后一条命令的退出码状态。</p></li><li><p><strong>指定返回值</strong><br> 使用<code>return</code>退出函数并<strong>返回指定的退出状态码</strong>，同样地保存在标准变量<code>$?</code>中，但是用这种方式获取返回值需要注意以下两点</p><ul><li>函数退出后立即取返回值，<strong>防止被覆盖</strong>；</li><li><strong>退出码范围</strong>是0~255；</li><li><p>若函数中命令执行错误导致提前退出函数，则此时<code>$?</code>中为错误状态码，不可作为函数输出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> add &#123;</span><br><span class="line">        <span class="built_in">return</span> $[ <span class="variable">$1</span> + <span class="variable">$2</span> ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var1=4; var2=5</span><br><span class="line">add <span class="variable">$var1</span> <span class="variable">$var2</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$var1</span> + <span class="variable">$var2</span> = $?"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./test.sh</span><br><span class="line">4 + 5 = 9</span><br></pre></td></tr></table></figure></li></ul></li><li><p>用命令替换<strong>获取函数输出</strong>作为返回值<br> 这种方式可以避免与状态码复用，还可以返回如浮点、字符串等类型</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> add &#123;</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"$[ <span class="variable">$1</span> + <span class="variable">$2</span> ]"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var1=4; var2=5</span><br><span class="line">sum=$( add <span class="variable">$var1</span> <span class="variable">$var2</span> )</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$var1</span> + <span class="variable">$var2</span> = <span class="variable">$sum</span>"</span></span><br></pre></td></tr></table></figure><p> 注意到，函数中的<code>echo</code>并没有输出到<code>STDOUT</code>中</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    $ ./test.sh</span><br><span class="line">    4 + 5 = 9</span><br><span class="line">    ```    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件包含: source</span></span><br><span class="line"></span><br><span class="line">用`<span class="built_in">source</span>`命令在当前shell上下文中执行命令，而不是创建新shell，其快捷别名为**点操作符**(dot operator)</span><br><span class="line"></span><br><span class="line">例如创建函数脚本`funcs.sh`</span><br><span class="line">``` bash</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> add &#123;</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"$[ <span class="variable">$1</span> + <span class="variable">$2</span> ]"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> sub &#123;</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"$[ <span class="variable">$1</span> - <span class="variable">$2</span>  ]"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>在<code>test.sh</code>中调用函数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># source funcs.sh</span></span><br><span class="line">. funcs.sh</span><br><span class="line"></span><br><span class="line">var1=4; var2=5</span><br><span class="line">sum=$( add <span class="variable">$var1</span> <span class="variable">$var2</span> )</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Sum of <span class="variable">$var1</span> and <span class="variable">$var2</span> is <span class="variable">$sum</span>."</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./test.sh</span><br><span class="line">Sum of 4 and 5 is 9.</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>注意区分各类括号的使用<ul><li>变量取值：<code>${ variable }</code></li><li>命令替换：<code>$( command )</code></li><li>整数计算：<code>$[ expression ]</code></li><li>多行整数计算：<code>$(( expression1, expression2, ... ))</code></li><li>测试：<code>[ expression ]</code></li><li>高级字符串比较测试：<code>[[ expression ]]</code></li></ul></li><li>注意数值比较和字符串比较的差异</li><li>重定向中符号的使用</li><li>注意函数参数的传递</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】KMP</title>
      <link href="/2020/04/22/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91KMP/"/>
      <url>/2020/04/22/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91KMP/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>字符串匹配问题是指，给定<code>source</code>字符串和一个<code>target</code>字符串，你应该在<code>source</code>字符串中找出<code>target</code>字符串出现的第一个位置(从$0$开始)。如果不存在，则返回$-1$，例如<br>输入：<code>source = &quot;abcaabaabcaabcacabaa&quot;</code>，<code>target = &quot;abcacab&quot;</code><br>输出；$11$</p><h1 id="朴素模式匹配"><a href="#朴素模式匹配" class="headerlink" title="朴素模式匹配"></a>朴素模式匹配</h1><p>暴力匹配是指依次对<code>source</code>中的子字符串进行匹配，以<a href="#%e5%89%8d%e8%a8%80">前言</a>中case为例，匹配流程如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">注：&#39;[]&#39;表示已匹配字符串，&#39;&lt;&gt;&#39;表示不匹配字符</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">第1次匹配：从souce第1个字符开始，&#39;a&#39;与&#39;c&#39;不匹配，中断</span><br><span class="line">[abca]&lt;a&gt;baabcaabcacabaa</span><br><span class="line">[abca]&lt;c&gt;ab</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">第2次匹配：从souce第2个字符开始，&#39;b&#39;与&#39;a&#39;不匹配，中断</span><br><span class="line">a&lt;b&gt;caabaabcaabcacabaa</span><br><span class="line"> &lt;a&gt;bcacab</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">第3次匹配：从souce第3个字符开始，&#39;c&#39;与&#39;a&#39;不匹配，中断</span><br><span class="line">ab&lt;c&gt;aabaabcaabcacabaa</span><br><span class="line">  &lt;a&gt;bcacab</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">...</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">最后一次匹配：从source第12个字符开始，匹配成功，返回索引11</span><br><span class="line">abcaabaabca[abcacab]aa</span><br><span class="line">           [abcacab]</span><br></pre></td></tr></table></figure></p><p>以上算法的时间复杂度为$O(mn)$(最坏为$O((n - m + 1) \times m)$)，其中$m,n$表示两字符串的长度。</p><h1 id="KMP匹配"><a href="#KMP匹配" class="headerlink" title="KMP匹配"></a>KMP匹配</h1><p>KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，简称KMP算法。它解决的问题是，<strong>在某次匹配过程中出现不匹配字符时，应如何跳转模板指针以减少重复匹配</strong>。在长度为$n$的字符串中寻找长度为$m$的字符串，时间复杂度为$O(m + n)$。</p><p>在第一次匹配失败时，已知的信息是前$4$个字符成功匹配，且最后一个匹配字符为<code>a</code>，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[abca]&lt;a&gt;baabcaabcacabaa</span><br><span class="line">[abca]&lt;c&gt;ab</span><br></pre></td></tr></table></figure></p><p>注意到字符串<code>&quot;abca&quot;</code>存在相同的前缀和后缀<code>&#39;a&#39;</code>，那么只需将<code>target</code>后移$3$位，使前缀处于“已匹配”状态，然后从两字符串相应位置继续匹配。即可减少匹配，即<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source: abc&#123;a&#125;abaabcaabcacabaa</span><br><span class="line">target: abc&#123;a&#125;cab</span><br><span class="line">moved:     &#123;a&#125;bcacab</span><br></pre></td></tr></table></figure></p><h2 id="前缀、后缀"><a href="#前缀、后缀" class="headerlink" title="前缀、后缀"></a>前缀、后缀</h2><p>对于的字符串<code>&quot;abcdefgh&quot;</code>，其具有的前缀(prefix)、后缀(suffix)集合分别为</p><div class="table-container"><table><thead><tr><th>类别</th><th>集合</th></tr></thead><tbody><tr><td>前缀</td><td><code>&quot;a&quot;, &quot;ab&quot;, &quot;abc&quot;, &quot;abcd&quot;, &quot;abcde&quot;, &quot;abcdef&quot;, &quot;abcdefg&quot;</code></td></tr><tr><td>后缀</td><td><code>&quot;bcdefgh&quot;, &quot;cdefgh&quot;, &quot;defgh&quot;, &quot;efgh&quot;, &quot;fgh&quot;, &quot;gh&quot;, &quot;h&quot;</code></td></tr></tbody></table></div><h2 id="部分匹配值"><a href="#部分匹配值" class="headerlink" title="部分匹配值"></a>部分匹配值</h2><p>给定字符串<code>target</code>后，可计算其子字符串的部分匹配值，即<strong>子字符串前后缀集合交集中，最长的字符串长度</strong>。例如<code>&quot;abcacab&quot;</code>的部分匹配值计算如下</p><div class="table-container"><table><thead><tr><th>子字符串</th><th>前缀集合</th><th>后缀集合</th><th>部分匹配值</th></tr></thead><tbody><tr><td><code>&quot;a&quot;</code></td><td></td><td></td><td>0</td></tr><tr><td><code>&quot;ab&quot;</code></td><td><code>&quot;a&quot;</code></td><td><code>&quot;b&quot;</code></td><td>0</td></tr><tr><td><code>&quot;abc&quot;</code></td><td><code>&quot;a&quot;, &quot;ab&quot;</code></td><td><code>&quot;bc&quot;, &quot;c&quot;</code></td><td>0</td></tr><tr><td><code>&quot;abca&quot;</code></td><td><code>&quot;a&quot;, &quot;ab&quot;, &quot;abc&quot;</code></td><td><code>&quot;bca&quot;, &quot;ca&quot;, &quot;a&quot;</code></td><td>1</td></tr><tr><td><code>&quot;abcac&quot;</code></td><td><code>&quot;a&quot;, &quot;ab&quot;, &quot;abc&quot;, &quot;abca&quot;</code></td><td><code>&quot;bcac&quot;, &quot;cac&quot;, &quot;ac&quot;, &quot;c&quot;</code></td><td>0</td></tr><tr><td><code>&quot;abcaca&quot;</code></td><td><code>&quot;a&quot;, &quot;ab&quot;, &quot;abc&quot;, &quot;abca&quot;, &quot;abcac&quot;</code></td><td><code>&quot;bcaca&quot;, &quot;caca&quot;, &quot;aca&quot;, &quot;ca&quot;, &quot;a&quot;</code></td><td>1</td></tr><tr><td><code>&quot;abcacab&quot;</code></td><td><code>&quot;a&quot;, &quot;ab&quot;, &quot;abc&quot;, &quot;abca&quot;, &quot;abcac&quot;, &quot;abcaca&quot;</code></td><td><code>&quot;bcacab&quot;, &quot;bcacab&quot;, &quot;cacab&quot;, &quot;acab&quot;, &quot;cab&quot;, &quot;ab&quot;, &quot;b&quot;</code></td><td>2</td></tr></tbody></table></div><h2 id="匹配过程"><a href="#匹配过程" class="headerlink" title="匹配过程"></a>匹配过程</h2><p>如下图，当<code>ababab&lt;a&gt;bca</code>与<code>ababab&lt;c&gt;a</code>失配时，<code>ababab</code>是匹配的部分，也就是匹配串、模板串中的子串，该子串的部分匹配值是$4$，是指相同的最长前缀、后缀是<code>abab</code>，如图中阴影部分所示。</p><p>当前匹配子串后缀<code>ab[abab]|abca</code>与模板子串后缀<code>ab[abab]|ca</code>是已匹配的，那么也就是说当前匹配子串后缀<code>ab[abab]|abca</code>与模板子串前缀<code>[abab]ab|ca</code>也是已匹配的，可以直接跳过从<code>ab[abab]&lt;a&gt;bca</code>、<code>[abab]&lt;a&gt;bca</code>开始匹配。</p><p><img src="/.com//kmp.jpg" alt="kmp"></p><p>经过上述说明后，<code>target</code><strong>后移位数</strong>可由下式计算</p><script type="math/tex; mode=display">后移位数 = 已匹配位数(也即\rm{target}指针位置) - 已匹配子字符串的部分匹配值</script><p>实际编程中，修改<code>target</code>指针位置为<strong>已匹配子字符串的部分匹配值</strong>即可</p><script type="math/tex; mode=display">指针位置 := 指针位置 - 后移位数 = 已匹配子字符串的部分匹配值</script><p>匹配流程如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">注：用i, j分别作为source, target的下标指针；&#39;|&#39;表示匹配开始的位置</span><br><span class="line">i &#x3D; 0, j &#x3D; 0 (初始化)</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">第1次匹配：从souce第1(i+1)个字符开始，&#39;a&#39;与&#39;c&#39;不匹配，中断</span><br><span class="line">|[abca]&lt;a&gt;baabcaabcacabaa</span><br><span class="line">|[abca]&lt;c&gt;ab</span><br><span class="line">i &#x3D; 4, j &#x3D; 4</span><br><span class="line">已匹配4(j)个字符，子字符串&quot;abca&quot;的部分匹配值为1 &#x3D;&gt; target后移3位，更新 j &#x3D; 1</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">第2次匹配：从souce第5(i+1)个字符开始，&#39;a&#39;与&#39;b&#39;不匹配，中断</span><br><span class="line">abc[a]|&lt;a&gt;baabcaabcacabaa</span><br><span class="line">   [a]|&lt;b&gt;cacab</span><br><span class="line">i &#x3D; 4, j &#x3D; 1</span><br><span class="line">已匹配1(j)个字符，子字符串&quot;a&quot;的部分匹配值为0 &#x3D;&gt; target后移1位，更新 j &#x3D; 0</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">第3次匹配：从souce第5(i+1)个字符开始，&#39;a&#39;与&#39;c&#39;不匹配，中断</span><br><span class="line">abca|[ab]&lt;a&gt;abcaabcacabaa</span><br><span class="line">    |[ab]&lt;c&gt;acab</span><br><span class="line">i &#x3D; 6, j &#x3D; 2</span><br><span class="line">已匹配2(j)个字符，子字符串&quot;ab&quot;的部分匹配值为0 &#x3D;&gt; target后移2位，更新 j &#x3D; 0</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">第4次匹配：从souce第7(i+1)个字符开始，&#39;a&#39;与&#39;b&#39;不匹配，中断</span><br><span class="line">abcaab|[a]&lt;a&gt;bcaabcacabaa</span><br><span class="line">      |[a]&lt;b&gt;cacab</span><br><span class="line">i &#x3D; 7, j &#x3D; 1</span><br><span class="line">已匹配1(j)个字符，子字符串&quot;a&quot;的部分匹配值为0 &#x3D;&gt; target后移1位，更新 j &#x3D; 0</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">第5次匹配：从souce第8(i+1)个字符开始，&#39;a&#39;与&#39;c&#39;不匹配，中断</span><br><span class="line">abcaaba|[abca]&lt;a&gt;bcacabaa</span><br><span class="line">       |[abca]&lt;c&gt;ab</span><br><span class="line">i &#x3D; 11, j &#x3D; 4</span><br><span class="line">已匹配4(j)个字符，子字符串&quot;abca&quot;的部分匹配值为1 &#x3D;&gt; target后移3位，更新 j &#x3D; 1</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">第6次匹配：从souce第12(i+1)个字符开始，&#39;a&#39;与&#39;b&#39;不匹配，中断</span><br><span class="line">abcaabaabc[a]|&lt;a&gt;bcacabaa</span><br><span class="line">          [a]|&lt;b&gt;cacab</span><br><span class="line">i &#x3D; 11, j &#x3D; 1</span><br><span class="line">已匹配1(j)个字符，子字符串&quot;a&quot;的部分匹配值为0 &#x3D;&gt; target后移1位，更新 j &#x3D; 0</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">第7次匹配：从souce第12(i+1)个字符开始，匹配完成</span><br><span class="line">abcaabaabca|[abcacab]aa</span><br><span class="line">           |[abcacab]</span><br><span class="line">i &#x3D; 18, j &#x3D; 7</span><br><span class="line">返回 j - i &#x3D; 11</span><br></pre></td></tr></table></figure></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; source, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = source.size();</span><br><span class="line">    <span class="keyword">int</span> n = target.size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ======================= 计算部分匹配值 ======================= </span></span><br><span class="line">    <span class="keyword">int</span>* next = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        next[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 截取子字符串</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> subPattern = target.substr(<span class="number">0</span>, i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> _n = subPattern.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> _len = <span class="number">1</span>; _len &lt; i + <span class="number">1</span>; _len++) &#123;<span class="comment">// 串前/后缀长度</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> prefix = subPattern.substr(<span class="number">0</span>, _len);<span class="comment">// 前缀</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> suffix = subPattern.substr(_n - _len, _len);<span class="comment">// 后缀</span></span><br><span class="line">            <span class="keyword">if</span> (prefix == suffix) &#123;</span><br><span class="line">                next[i] = _len;<span class="comment">// 共有元素的长度</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========================== 开始匹配 ========================== </span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123;</span><br><span class="line">        <span class="comment">// --- 字符相同，两个指针共同前进 --- </span></span><br><span class="line">        <span class="keyword">if</span> (source[i] == target[j]) &#123;</span><br><span class="line">            i++; j++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// ------ 字符不相同需要跳转 -------</span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>];<span class="comment">// 后缀不匹配，但前缀可能匹配，移动到相同前缀后一位的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> [] next;</span><br><span class="line">    <span class="comment">// source到达末尾，target未到达末尾</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j != n) <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="comment">// 同时到达末尾；source未到达末尾，target到达末尾</span></span><br><span class="line">    <span class="keyword">return</span> i - j;<span class="comment">// 开始索引</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">字符串匹配的KMP算法 - 阮一峰的网络日志</a>。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markov Chain Monte Carlo</title>
      <link href="/2020/04/15/Markov-Chain-Monte-Carlo/"/>
      <url>/2020/04/15/Markov-Chain-Monte-Carlo/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>马尔科夫链蒙特卡罗法(Markov Chain Monte Carlo, MCMC)是以马尔可夫链为概率模型的蒙特卡罗法。通过构建马尔可夫链，基于该马尔可夫链进行随机游走，产生样本序列，并使用这些样本进行<strong>近似数值计算</strong>。</p><h1 id="蒙特卡罗法"><a href="#蒙特卡罗法" class="headerlink" title="蒙特卡罗法"></a>蒙特卡罗法</h1><p>蒙特卡罗法可应用在<strong>随机抽样、数学期望估计、定积分计算</strong>等方面。</p><h2 id="随机抽样"><a href="#随机抽样" class="headerlink" title="随机抽样"></a>随机抽样</h2><p>蒙特卡罗法<strong>需要解决的问题</strong>是，假设概率分布定义已知，通过抽样获得概率分布的随机样本，用这些随机样本对概率分布特征进行分析。核心是<strong>随机抽样</strong>(random sampling)，例如</p><ul><li>从样本得到经验分布，从而估计总体分布；</li><li>从样本计算样本均值，从而估计总体期望；</li><li>……</li></ul><p>蒙特卡罗法有：</p><ul><li>直接抽样法；</li><li>接受-拒绝抽样法；</li><li>重要性抽样法；</li><li>……</li></ul><p><strong>接受-拒绝抽样法</strong>基本思想如下：假设$p(x)$不可以直接抽样，寻找<strong>建议分布</strong>(proposal distribution)$q(x)$，使下式成立</p><script type="math/tex; mode=display">c \cdot q(x) \geq p(x), \quad c > 0 \tag{1.1}</script><p>按照$q(x)$进行抽样，假设得到结果$x$，设置阈值$t \in [0, 1]$，在下式成立时接受该抽样</p><script type="math/tex; mode=display">\frac{p(x)}{c \cdot q(x)} > t \tag{1.2}</script><h2 id="数学期望估计"><a href="#数学期望估计" class="headerlink" title="数学期望估计"></a>数学期望估计</h2><p>假设有随机变量$X \in \mathcal{X}$，概率密度为$p(x)$，定义$Y = f(X)$为在定义域$\mathcal{X}$上的函数，求$Y$的数学期望$EY$。</p><p>回想一下学习概率论时这种问题的求解方法，通过代换$Y$的分布函数$F_Y(y)$，利用映射$Y = f(X)$将其转换到$X$的分布函数$F_X(x)$中进行求解，即</p><script type="math/tex; mode=display">\begin{aligned}    F_Y(y) = P(Y \leq y) = P\{f(X) \leq y\} \\    \Rightarrow P\{X \leq f^{-1}(y)\} = F_X(f^{-1}(y))\end{aligned} \tag{2.1}</script><p>其中$F_X(x) = \int p(x) dx$，$f^{-1}(y)$已知，求取$F_Y(y)$后，有</p><script type="math/tex; mode=display">p(y) = \frac{d}{dy} F_Y(y) \tag{2.2}</script><p>那么随机变量$Y$的期望是</p><script type="math/tex; mode=display">EY = \int y p(y) dy \tag{2.3}</script><hr><p>在计算$(2.2)$时，若$p(x)$是非标准的，则难以求取积分，需通过数值方法求解近似。蒙特卡罗法可用于求取<strong>数学期望估计</strong>(estimation of mathematical expectation)：按照概率分布$p(x)$<strong>独立同分布</strong>地在定义域$\mathcal{X}$多次抽取，得到样本集${ x^{(1)}, x^{(2)}, \cdots, x^{(n)} }$，由下式<strong>计算样本均值作为期望的估计</strong></p><script type="math/tex; mode=display">EY \approx \frac{1}{n} \sum_{i = 1}^{n} f(x^{(i)}), x^{(i)} \sim p(x) \tag{3}</script><h2 id="积分计算"><a href="#积分计算" class="headerlink" title="积分计算"></a>积分计算</h2><p>假设有函数$f(x)$，需求取其在区间$\mathcal{X}$上的定积分</p><script type="math/tex; mode=display">I = \int_{\mathcal{X}} f(x) dx \tag{4.1}</script><p>可将$f(x)$分解为一个函数$g(x)$与某概率密度$p(x)$的乘积</p><script type="math/tex; mode=display">f(x) = g(x) \cdot p(x) \tag{4.2}</script><blockquote><p><strong>实际上，可指定任意概率密度函数$p(x)$得到$g(x)$，即任意定积分都可以表示为某函数的数学期望的形式</strong></p><script type="math/tex; mode=display">g(x) = \frac{f(x)}{p(x)}</script></blockquote><p>那么用<strong>计算期望</strong>的方法，有</p><script type="math/tex; mode=display">I = \int_{\mathcal{X}} f(x) dx =  \int_{\mathcal{X}} g(x) \cdot p(x) dx = E[g(x)] \approx \rm{mean}(f(x^{(i)})) \tag{4.3}</script><h1 id="马尔可夫链"><a href="#马尔可夫链" class="headerlink" title="马尔可夫链"></a>马尔可夫链</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>设一随机变量$X$(<strong>离散或连续均可</strong>)，其取值集合称为<strong>状态空间</strong>$\mathcal{S}$，经过$T$次采样得到<strong>时间序列</strong>如下，该序列构成<strong>随机过程</strong>(stochastic process)</p><script type="math/tex; mode=display">X = \{X^{(1)}, X^{(2)}, \cdots, X^{(t)}, \cdots, X^{(T)}\} \tag{5.1}</script><p>假设在时刻$0$，$X^{(0)}$服从<strong>初始状态分布</strong></p><script type="math/tex; mode=display">P(X^{(0)}) = \pi(0) \tag{5.2}</script><p><strong>马尔可夫性</strong>：时刻$t(t \geq 1)$采样$X^{(t)}$只依赖于前一时刻$X^{(t - 1)}$，即</p><script type="math/tex; mode=display">P(X^{(t)} | X^{(0)}, X^{(1)}, \cdots, X^{(t - 1)}) = P(X^{(t)} | X^{(t - 1)}) \tag{5.3}</script><p>具有马尔可夫性的随机序列称为<strong>马尔可夫链</strong>(Markov chain)，或<strong>马尔可夫过程</strong>(Markov process)，条件概率分布$P(X^{(t)} | X^{(t - 1)})$称作<strong>马尔可夫链的转移概率分布</strong>。拓展为$n$阶马尔可夫链，满足$n$阶马尔可夫性，则有</p><script type="math/tex; mode=display">P(X^{(t)} | X^{(0)}X^{(1)} \cdots X^{(t-2)}X^{(t-1)}) = P(X^{(t)} | X^{(t-n)}X^{(t-n-1)} \cdots X^{(t-2)}X^{(t-1)}) \tag{5.4}</script><p>若马尔可夫链满足$P(X^{(t)} | X^{(t - 1)})$与时间$t$无关(常数)，称该马尔可夫链是<strong>时间齐次的</strong>(time homogeneous Markov chain)，即</p><script type="math/tex; mode=display">P(X^{(t)} | X^{(t - 1)}) = P(X^{(t + s)} | X^{(t - 1 + s)}), \quad t = 1, 2, \cdots, \quad s = 1, 2, \cdots \tag{5.5}</script><blockquote><p>关于马尔可夫模型的概念的可参考<a href="https://louishsu.xyz/2018/11/13/Hidden-Markov-Model/" target="_blank" rel="noopener">隐马尔可夫模型</a>。</p></blockquote><h2 id="离散与连续描述"><a href="#离散与连续描述" class="headerlink" title="离散与连续描述"></a>离散与连续描述</h2><h3 id="离散状态"><a href="#离散状态" class="headerlink" title="离散状态"></a>离散状态</h3><p><strong>离散状态的马尔可夫链，其概率转移分布可以用矩阵表示</strong>。记时刻$(t-1)$处于状态$s_j$转移到$t$时刻处于状态$s_i$的转移概率为</p><script type="math/tex; mode=display">\begin{aligned}    p_{ij} = P(X^{(t)} = s_i | X^{(t - 1)} = s_j), \quad i, j = 1, 2, \cdots \\    s.t. \quad p_{ij} \geq 0, \quad \sum_i p_{ij} = 1\end{aligned} \tag{6.1}</script><p>记作<strong>转移概率矩阵</strong>$P$，注意列和为$1$(转移到状态$s_i$概率和为$1$)</p><script type="math/tex; mode=display">P_{|\mathcal{S}| \times |\mathcal{S}|} = \begin{bmatrix}    p_{11} & p_{12} & \cdots \\    p_{21} & p_{22} & \cdots \\    \vdots & \vdots & \ddots \\\end{bmatrix} \tag{6.2}</script><p>在时刻$t$时，有$X^{(t)}$的<strong>状态分布</strong>$\pi(t)$，其中元素$\pi_i(t)$表示$X^{(t)}$位于状态$s_i$的概率$P(X^{(t)} = s_i)$</p><script type="math/tex; mode=display">\pi(t) = \begin{bmatrix}    \pi_1(t) \\ \pi_2(t) \\ \vdots\end{bmatrix} \tag{7.1}</script><p>特别地，通常初始分布$\pi(0)$只有一个元素为$1$，其余都是$0$，<strong>表示马尔可夫链从某一具体状态开始</strong>。</p><script type="math/tex; mode=display">\pi(0) = \begin{bmatrix}    \vdots \\ 1 \\ \vdots\end{bmatrix} \tag{7.2}</script><p>那么有递推公式</p><script type="math/tex; mode=display">\pi(t) = P \cdot \pi(t - 1) \tag{8.1}</script><p>或者是定义$t$步转移概率矩阵$P^t$，使得下式成立</p><script type="math/tex; mode=display">\pi(t) = P^t \cdot \pi(0) \tag{8.2}</script><p>若存在某分布$\pi$使下式成立，则称$\pi$为马尔可夫链的<strong>平稳分布</strong></p><script type="math/tex; mode=display">\pi = P \cdot \pi \tag{8.3}</script><p>注意，当离散状态马尔可夫链有无穷个状态时，可能不存在平稳分布。</p><h3 id="连续状态"><a href="#连续状态" class="headerlink" title="连续状态"></a>连续状态</h3><p><strong>连续状态的马尔可夫链，其概率转移分布可以用概率转移核(transition kernel)表示</strong>。设$\mathcal{S}$为连续状态空间，对任意$x \in \mathcal{S}, A \in \mathcal{S}$，从$x$转移到$A$的转移概率$P(X^{(t)} = A | X^{(t - 1)} = x)$，称为转移核</p><script type="math/tex; mode=display">P(x, A) = P(X^{(t)} = A | X^{(t - 1)} = x) = \int_A p(x, y) dy \tag{9.1}</script><p>其中$p(x, y)$为概率密度函数(有时也被称为转移核)，且满足</p><script type="math/tex; mode=display">p(x, y) \geq 0, \quad P(x, \mathcal{S}) = \int_{\mathcal{S}} p(x, y) dy = 1 \tag{9.2}</script><p>同样的，连续状态也存在平稳分布描述。若$\pi(x)$满足以下条件，称$\pi(x)$为该马尔可夫链的平稳分布</p><script type="math/tex; mode=display">\pi(y) = \int p(x, y) \pi(x) dx, \quad \forall y \in \mathcal{S} \tag{10.1}</script><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>以下均采用离散状态马尔可夫链进行性质描述，可推广至连续状态。</p><h3 id="可约-不可约"><a href="#可约-不可约" class="headerlink" title="可约/不可约"></a>可约/不可约</h3><p>对于任意状态$s_i, s_j \in \mathcal{S}$，时刻$0$从$s_j$出发，时刻$t(t&gt;0)$到达状态$s_i$的概率$P(X^{(t)} = s_j | X^{(0)} = s_i) &gt; 0$，那么称此马尔可夫链是<strong>不可约的</strong>(irreducible)，否则称<strong>可约的</strong>(reducible)。</p><blockquote><p>不可约马尔可夫链，概率值恒不为$0$，从任意状态出发，<strong>充分长时间</strong>后可到达任意状态。</p></blockquote><p>例如以下转移概率矩阵对应的马尔可夫链，存在平稳分布$\pi = \begin{bmatrix}0 &amp; 0 &amp; 1\end{bmatrix}^T$，循环停留在状态$3$，故可约</p><script type="math/tex; mode=display">P = \begin{bmatrix}    0 & 1/2 & 0 \\    1 & 0 & 0 \\    0 & 1/2 & 1 \\\end{bmatrix} \tag{11}</script><h3 id="周期-非周期"><a href="#周期-非周期" class="headerlink" title="周期/非周期"></a>周期/非周期</h3><p>时刻$0$从任意状态$s \in \mathcal{S}$出发，返回状态$s$的时刻$t$构成集合${t | P(X^{(t)} = s | X^{(0)} = s) &gt; 0}$，其元素的最大公约数为$1$，则称该马尔可夫链是<strong>非周期的</strong>(aperiodic)，否则是<strong>周期的</strong>(periodic)。</p><blockquote><p>非周期马尔可夫链，不存在状态$s$，使从该状态出发回到该状态经历时间呈现一定的周期性。</p></blockquote><p>例如以下转移概率矩阵对应的马尔可夫链，存在平稳分布$\pi = \begin{bmatrix}1/3 &amp; 1/3 &amp; 1/3\end{bmatrix}^T$，从任意状态出发返回该状态的时刻为${3, 6, 9, \cdots}$，呈现周期性</p><script type="math/tex; mode=display">P = \begin{bmatrix}    0 & 0 & 1 \\    1 & 0 & 0 \\    0 & 1 & 0 \\\end{bmatrix} \tag{12}</script><h3 id="正常返-非正常返"><a href="#正常返-非正常返" class="headerlink" title="正常返/非正常返"></a>正常返/非正常返</h3><p>对于任意状态$s_i, s_j \in \mathcal{S}$，时刻$0$从$s_j$出发，在时刻$t$<strong>首次</strong>转移到状态$s_i$的概率记作$p_{ij}^t$，若对<strong>所有状态</strong>都满足$\lim_{t \rightarrow \infty} p_{ij}^t &gt; 0$，则称该马尔可夫链是<strong>正常返的</strong>(recurrent)。</p><blockquote><p>正常返马尔可夫链，从某一状态出发，<strong>时间趋于无穷时</strong>，到达其他任意状态的概率不为$0$。</p></blockquote><hr><p>根据上述三条性质，可得以下两条定理</p><ol><li><strong>不可约</strong>、<strong>非周期</strong>的<strong>有限状态</strong>马尔可夫链，存在唯一平稳分布；</li><li><strong>不可约</strong>、<strong>非周期</strong>、<strong>正常返</strong>的马尔可夫链，存在唯一平稳分布；</li></ol><hr><h3 id="可逆-不可逆"><a href="#可逆-不可逆" class="headerlink" title="可逆/不可逆"></a>可逆/不可逆</h3><p>若某马尔可夫链$X$存在状态分布$\pi$，对于任意状态$s_i, s_j \in \mathcal{S}$，在任意时刻满足下式，则称此马尔可夫链是<strong>可逆的</strong>(reversible)</p><script type="math/tex; mode=display">P(X^{(t)} = s_i | X^{(t-1)} = s_j) \cdot \pi_j = P(X^{(t-1)} = s_j | X^{(t)} = s_i) \cdot \pi_i, \quad i, j = 1, 2, \cdots \tag{12.1}</script><p>也即</p><script type="math/tex; mode=display">p_{ji} \cdot \pi_j = p_{ij} \cdot \pi_i \tag{12.2}</script><p>$(13.2)$也被称作<strong>细致平衡方程</strong>(detailed balance equation)，并且<strong>满足细致平衡方程的状态分布$\pi$就是该马尔可夫链的平稳分布</strong>。也说明可逆马尔可夫链一定存在唯一平稳分布(充分条件)。</p><p>证明：</p><script type="math/tex; mode=display">(P \cdot \pi)_i = \sum_j p_{ij} \cdot \pi_j = \sum_j p_{ji} \cdot \pi_i = \pi_i \Rightarrow P \cdot \pi = \pi \tag{12.3}</script><blockquote><p>以可逆马尔可夫链的平稳分布作为初始分布，进行随机状态转移，那么在过去或未来任意时刻的状态分布都是该平稳分布。</p></blockquote><h3 id="遍历定理"><a href="#遍历定理" class="headerlink" title="遍历定理"></a>遍历定理</h3><p>设有一<strong>不可约、非周期且正常返</strong>的马尔可夫链$X$，有<strong>唯一平稳分布</strong>$\pi$，那么<strong>转移概率的极限分布</strong>是马尔可夫链的平稳分布</p><script type="math/tex; mode=display">\lim_{t \rightarrow \infty} P(X^{(t)} = s_i | X^{(0)} = s_j) = \pi_i > 0, \quad i, j = 1, 2, \cdots \tag{13.1}</script><blockquote><p>该马尔可夫链在时间趋于无穷时，其状态分布趋向于平稳分布；<strong>不可约、非周期且正常返</strong>保证时间趋于无穷时，达到任意状态的概率不为$0$。</p></blockquote><p>若$f(X)$是定义在状态空间$\mathcal{S}$上的函数，且$E_{\pi}[f(x)] &lt; \infty$，那么依据<strong>大数定理</strong>，有</p><script type="math/tex; mode=display">P\{\hat{f}^{(t)} \rightarrow E_{\pi}[f(x)]\} = 1 \tag{13.2}</script><blockquote><p>在该马尔可夫链下，随机变量的函数的样本均值以概率$1$收敛于该函数的数学期望。</p></blockquote><p>其中$\hat{f}^{(t)}$为样本均值，$E_{\pi}[f(x)]$为待估期望，即</p><script type="math/tex; mode=display">\begin{cases}    \hat{f}^{(t)} = \frac{1}{t} \sum_{s=1}^t f(x^{(s)}) \\    E_{\pi}[f(x)] = \sum_i f(s_i) \pi_i\end{cases} \tag{13.3}</script><blockquote><p>该马尔可夫链可以用样本均值作为<strong>时间均值</strong>的估计，而数学期望是<strong>空间均值</strong>。</p></blockquote><p>可取<strong>足够大</strong>的整数$m$，认为满足要求的马尔可夫链经过$m$次迭代后，其状态分布即平稳分布，然后进行$n$次采样，<strong>计算样本均值作为期望的估计</strong></p><script type="math/tex; mode=display">\hat{E}f = \frac{1}{n} \sum_{i=1}^n f(x^{(i)}) \tag{13.4}</script><h1 id="马尔可夫链蒙特卡罗法"><a href="#马尔可夫链蒙特卡罗法" class="headerlink" title="马尔可夫链蒙特卡罗法"></a>马尔可夫链蒙特卡罗法</h1><p>MCMC是蒙特卡罗法的一种，适用于<strong>随机变量是多元的、密度函数是非标准的、<u>随机变量各分量不独立</u>等</strong>情况。</p><p>再次描述<strong>待求解问题</strong>：假设有多元随机变量$X \in \mathcal{X}$，概率密度为$p(x)$，定义$Y = f(X)$为在定义域$\mathcal{X}$上的函数，求$Y$的数学期望$EY$。</p><p><strong>用MCMC解决该问题的方法</strong>是：在随机变量$X$的状态空间$\mathcal{S}$上定义满足<a href="#%e9%81%8d%e5%8e%86%e5%ae%9a%e7%90%86">遍历定理</a>要求(<strong>不可约、非周期、正常返的</strong>)的马尔可夫链$X$，<strong>使其平稳分布为抽样的目标分布</strong>。<strong>时间趋于无穷时</strong>，样本分布趋近平稳分布，<strong>根据<a href="#%e9%81%8d%e5%8e%86%e5%ae%9a%e7%90%86">遍历定理</a>可求解数学期望</strong>。</p><blockquote><p><strong>注意</strong>：马尔可夫链蒙特卡罗法中得到的样本序列，相邻的样本点是相关的，因此在需要独立样本时，可以在样本序列中再次抽样(如每隔一段时间抽样)，将子样本集作为独立样本集合。</p></blockquote><p>那么现在的<strong>关键问题</strong>是如何构建具体的马尔可夫链，即<strong>确定转移概率矩阵或转移核函数</strong>。可通过定义特殊的转移概率矩阵或转移核函数保证遍历定理成立。常用方法有<strong>Metropolis-Hastings算法、吉布斯抽样</strong>。</p><h2 id="Metropolis-Hastings算法"><a href="#Metropolis-Hastings算法" class="headerlink" title="Metropolis-Hastings算法"></a>Metropolis-Hastings算法</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>假设要抽样的概率分布为$p(x)$，MH算法采用转移核为$p(x, x’)$的马尔可夫链</p><script type="math/tex; mode=display">p(x, x') = q(x, x') \cdot \alpha(x, x') \tag{14.1}</script><p>其中</p><ul><li>$q(x, x’)$：称<strong>建议分布</strong>(proposal distribution)，是另一个马尔可夫链的转移核，且<strong>不可约</strong>(概率值恒不为$0$)，同时<strong>易采样</strong>；</li><li>$\alpha(x, x’)$：称<strong>接受分布</strong>(acceptance distribution)，定义为<script type="math/tex; mode=display">  \alpha(x, x') = \min\left\{1,       \frac{p(x') \cdot q(x', x)} {p(x) \cdot q(x, x')}  \right\} \tag{14.2}</script></li></ul><blockquote><p><strong>定理</strong>：由$(14.1 \sim 14.2)$构建的马尔可夫链是可逆的，且$p(x)$是其平稳分布<br><strong>证明</strong>：<br>由$(12.2)$可证得可逆</p><script type="math/tex; mode=display">\begin{aligned}    p(x) \cdot p(x, x') & =      p(x) \cdot q(x, x')     \min\left\{1, \frac{p(x') \cdot q(x', x)} {p(x) \cdot q(x, x')} \right\} \\    & = \min\left\{p(x) \cdot q(x, x'), p(x') \cdot q(x', x) \right\} \\    & = p(x') \cdot q(x', x)    \min\left\{\frac{p(x) \cdot q(x, x')} {p(x') \cdot q(x', x)}, 1\right\} \\    & = p(x') \cdot p(x', x)\end{aligned} \Rightarrow 可逆</script><p>那么由$(10.1)$，$p(x)$为平稳分布</p><script type="math/tex; mode=display">\int p(x) \cdot p(x, x') dx = \int p(x') \cdot p(x', x) dx = p(x') \int p(x', x) dx = p(x')</script></blockquote><p>如果在时刻$(t-1)$处于状态$x$，先按建议分布$q(x, x’)$产生候选$x’$，按接受分布$\alpha(x, x’)$抽样，<strong>以概率$\alpha(x, x’)$接受$x’$，否则拒绝，时刻$t$仍停留在$x$</strong>。即在区间$(0, 1)$上的均匀分布中抽取随机数$u$，当$u \leq \alpha(x, x’)$时接受。</p><h3 id="建议分布的选择及接受分布的确定"><a href="#建议分布的选择及接受分布的确定" class="headerlink" title="建议分布的选择及接受分布的确定"></a>建议分布的选择及接受分布的确定</h3><p>根据$(14.1 \sim 2)$，在选择建议分布$q(x, x’)$后，$\alpha(x, x’)$也随之确定</p><script type="math/tex; mode=display">p(x, x') = q(x, x') \cdot \alpha(x, x') \tag{14.1}</script><script type="math/tex; mode=display">\alpha(x, x') = \min\left\{1,     \frac{p(x') \cdot q(x', x)} {p(x) \cdot q(x, x')}\right\} \tag{14.2}</script><p>已证明以上两式构建的马尔可夫链是可逆的，存在唯一平稳分布$\pi = p(x)$。只需通过选择一个<strong>不可约、易采样</strong>的分布作为建议分布，有如下两种选择：</p><ol><li><p><strong>Metropolis-Hastings选择</strong>：假设分布是对称的，即对任意$x, x’$，有</p><script type="math/tex; mode=display"> \begin{aligned}     q(x, x') = q(x', x) \\     \Rightarrow      \alpha(x, x') = \min\left\{1,          \frac{p(x')} {p(x)}     \right\} \end{aligned} \tag{15.1}</script><p> 特点是当$x’$与$x$接近时，$q(x, x’)$概率高，即状态转移在附近点的可能性更大。有以下<strong>两个特例</strong>：</p><ul><li>$q(x, x’) = q(x’ | x)$，即条件概率分布，定义为均值为$x$，协方差矩阵是常数矩阵的多元正态分布；</li><li>$q(x, x’) = q(|x, x’|)$，称<strong>随机游走Metropolis算法</strong>，例如<script type="math/tex; mode=display">q(x, x') \propto \exp(- \frac{(x' - x)^2}{2}) \tag{15.2}</script></li></ul></li><li><p><strong>独立抽样</strong>：假设$q(x, x’)$与当前状态$x$无关，即</p><script type="math/tex; mode=display"> \begin{aligned}     q(x, x') = q(x') \\     \Rightarrow      \alpha(x, x') = \min\left\{1,          \frac{p(x') / q(x')} {p(x) / q(x)}     \right\} \end{aligned} \tag{15.3}</script><p> 独立抽样实现简单，但收敛速度慢，通常选择接近目标分布$p(x)$的分布作为建议分布。</p></li></ol><h2 id="吉布斯抽样"><a href="#吉布斯抽样" class="headerlink" title="吉布斯抽样"></a>吉布斯抽样</h2><p><strong>吉布斯抽样</strong>(Gibbs sampling)可视作Metropolis-Hastings算法的特殊情况，用于多元变量联合分布的抽样和估计。</p><h3 id="满条件分布"><a href="#满条件分布" class="headerlink" title="满条件分布"></a>满条件分布</h3><p>首先介绍<strong>满条件分布</strong>(full conditional distribution)：MCMC的目标分布通常是多元联合概率分布$p(x)$，其中$x$为$k$维度随机变量，对于</p><script type="math/tex; mode=display">\begin{aligned}    I \subset K = \{1, 2, \cdots, k\} \\    \begin{cases}        x_I = \{x_i, i \in I\} \\        x_{-I} = \{x_i, i \notin I\}    \end{cases}\end{aligned} \tag{16.1}</script><p><strong>若条件概率分布$p(x_I | x_{-I})$中$k$个维度全部出现，则称这种条件概率分布为满条件分布</strong>，有以下性质</p><script type="math/tex; mode=display">p(x_I | x_{-I}) = \frac{p(x)}{\int p(x) dx_I} \propto p(x) \tag{16.2}</script><blockquote><script type="math/tex; mode=display">p(x_{i \in I} | x_{i \notin I}) \propto p(x_1, x_2, \cdots, x_k)</script></blockquote><p>那么相应地</p><script type="math/tex; mode=display">\frac{ p(x_I' | x_{-I}')}{p(x_I | x_{-I})} = \frac{p(x')}{p(x)} \tag{16.3}</script><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>吉布斯抽样是MH算法的特殊情况，假设多元变量$x$的联合概率密度为$p(x)$，<strong>定义建议分布为当前抽样维度$x_j, j = 1, 2, \cdots, k$的满条件分布</strong>，即</p><script type="math/tex; mode=display">\begin{aligned}    q(x, x') = p(x_J' | x_{-J}) \\     \begin{cases}        x_J = \{x_j\} \\        x_{-J} = \{x_1, \cdots, x_{j-1}, x_{j+1}, \cdots, x_k\}    \end{cases}\end{aligned} \tag{17.1}</script><p>相应地，此时<strong>接受概率分布</strong>为</p><script type="math/tex; mode=display">\begin{aligned}    \alpha(x, x') & = \min\left\{1,         \frac{p(x') \cdot q(x', x)} {p(x) \cdot q(x, x')}    \right\} \\    & = \min\left\{1,         \frac{p(x') \cdot p(x_J | x_{-J}')} {p(x) \cdot p(x_J' | x_{-J})}    \right\} \\    & = \min\left\{1,         \frac{p(x')} {p(x)} \cdot \frac{p(x)}{p(x)'}    \right\} \\    & = 1 \end{aligned}\tag{17.2}</script><p>吉布斯抽样具体是这样的，从某个初始样本$x^{(0)}$出发，不断进行迭代，每次迭代得到$x^{(i)}$，从而获得样本序列${x^{(0)}, \cdots, x^{(i)}, \cdots}$。在第$i(i &gt; 0)$次迭代时，对其第$j$个维度按以下满条件概率分布进行随机抽样</p><script type="math/tex; mode=display">\begin{cases}    p(x_j | \underbrace{x^{(i-1)}_{j+1}, \cdots, x^{(i-1)}_k}_{x^{(i-1)}_{-J}}) & j = 1 \\    p(x_j | \underbrace{x^{(i)}_1, \cdots, x^{(i)}_{j-1}}_{x^{(i)}_{-J} },         \underbrace{x^{(i-1)}_{j+1}, \cdots, x^{(i-1)}_k}_{x^{(i-1)}_{-J} }) & j = 2, \cdots, k -1 \\    p(x_j | \underbrace{x^{(i)}_1, \cdots, x^{(i)}_{j-1}}_{x^{(i)}_{-J}}) & j = k \end{cases} \tag{17.3}</script><p>与MH算法不同之处是，MH算法需要进行接受/拒绝判断，可能两次相邻的采样停留在同一状态。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p><strong>例</strong>：用吉布斯抽样从以下二元正态分布中抽取随机样本</p><script type="math/tex; mode=display">x = \begin{bmatrix} x_1 \\ x_2 \end{bmatrix} \sim \mathcal{N}( \begin{bmatrix} 0 \\ 0 \end{bmatrix}, \begin{bmatrix} 1 & 0.5 \\ 0.5 & 1 \end{bmatrix})</script><p><strong>解</strong>：定义建议分布为维度$x_k, k = 1, 2$的条件概率分布，为一元正态分布</p><script type="math/tex; mode=display">p(x_1 | x_2) = \frac{p(x_1, x_2)}{p(x_2)} = \frac{p(x)}{\int p(x) dx_1}</script><p>其中</p><script type="math/tex; mode=display">p(x) = \frac{1}{\sqrt{3} \pi} \exp \left( - \frac{2}{3} (x_1^2 - x_1 x_2 + x_2^2) \right)</script><blockquote><p>多维正态分布$x \sim \mathcal{N}(\mu, \Sigma)$</p><script type="math/tex; mode=display">p(x) = \frac{1}{(2\pi)^{n/2} |\Sigma|^{1/2}} \exp \left( -\frac{1}{2} (x - \mu)^T \Sigma^{-1} (x - \mu) \right)</script></blockquote><p>那么</p><script type="math/tex; mode=display">\begin{cases}    p(x_1 | x_2) \sim \mathcal{N}(0.5 x_2, 0.75) \\     p(x_2 | x_1) \sim \mathcal{N}(0.5 x_1, 0.75)\end{cases}</script><p>假设初始样本$x^{(0)} = \begin{bmatrix}0 &amp; 0\end{bmatrix}^T$，那么由下程序可获得相应序列<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gaussian</span><span class="params">(x, mu, sigma)</span>:</span></span><br><span class="line"></span><br><span class="line">    a = np.sqrt(<span class="number">2</span> * np.pi) * sigma</span><br><span class="line">    b = (x - mu) / sigma</span><br><span class="line">    c = (<span class="number">1.</span> / a) * np.exp(<span class="number">-0.5</span> * (b**<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c / sum(c)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">egGibbs</span><span class="params">(m = <span class="number">2000</span>, n = <span class="number">100</span>, rho = <span class="number">0.1</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">        state_space=[<span class="number">-10</span>, <span class="number">10</span>], init_state=[<span class="number">0</span>, <span class="number">0</span>])</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 状态空间</span></span><br><span class="line">    S = np.linspace(*state_space, num=<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 采样</span></span><br><span class="line">    samples = []</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> range(m + n):</span><br><span class="line">        <span class="keyword">if</span> t == <span class="number">0</span>:</span><br><span class="line">            samples += [init_state]</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 两个维度采样</span></span><br><span class="line">        mu = rho * samples[<span class="number">-1</span>][<span class="number">-1</span>]</span><br><span class="line">        sigma = np.sqrt(<span class="number">1</span> - rho ** <span class="number">2</span>)</span><br><span class="line">        p = gaussian(S, mu, sigma)</span><br><span class="line">        x1 = np.random.choice(S, p=p)    </span><br><span class="line">        </span><br><span class="line">        mu = rho * x1</span><br><span class="line">        sigma = np.sqrt(<span class="number">1</span> - rho ** <span class="number">2</span>)</span><br><span class="line">        p = gaussian(S, mu, sigma)</span><br><span class="line">        x2 = np.random.choice(S, p=p)</span><br><span class="line"></span><br><span class="line">        samples += [[x1, x2]]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> np.array(samples)[m:]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">    </span><br><span class="line">    samples = egGibbs()</span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.scatter(*samples.T, c=<span class="string">'r'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure></p><p>样本点作图如下</p><p><img src="/2020/04/15/Markov-Chain-Monte-Carlo/egGibbs.png" alt="egGibbs"></p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【算法】位运算的应用</title>
      <link href="/2020/04/12/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2020/04/12/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>位运算在编程中有不少的应用，但没必要记太多的“奇淫巧计”。</p><h1 id="英文字符转换"><a href="#英文字符转换" class="headerlink" title="英文字符转换"></a>英文字符转换</h1><ol><li>字符转小写 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#39;a&#39; | &#39; &#39; &#x3D; &#39;a&#39;</span><br><span class="line">&#39;A&#39; | &#39; &#39; &#x3D; &#39;a&#39;</span><br></pre></td></tr></table></figure></li><li>字符转大写 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#39;a&#39; &amp; &#39;_&#39; &#x3D; &#39;A&#39;</span><br><span class="line">&#39;A&#39; &amp; &#39;_&#39; &#x3D; &#39;A&#39;</span><br></pre></td></tr></table></figure></li><li>大小写互换 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#39;a&#39; ^ &#39; &#39; &#x3D; &#39;A&#39;</span><br><span class="line">&#39;A&#39; ^ &#39; &#39; &#x3D; &#39;a&#39;</span><br></pre></td></tr></table></figure></li></ol><h1 id="单个数字的操作"><a href="#单个数字的操作" class="headerlink" title="单个数字的操作"></a>单个数字的操作</h1><ol><li><p>奇偶性<br> 判断末位即可。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> isOdd = x &amp; <span class="number">0x01</span>;</span><br></pre></td></tr></table></figure></li><li><p>判断是否为$2$的整数幂<br> $2$的整数幂，其二进制表示中只有一个<code>1</code>，如</p><script type="math/tex; mode=display"> \begin{aligned}     2^0 = 1 = 0b0001 \\     2^1 = 2 = 0b0010 \\     2^2 = 4 = 0b0100 \end{aligned}</script><p> <code>x &amp; (x - 1)</code>可将<code>x</code>最右侧<code>1</code>置<code>0</code></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPowOf2</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> !(x &amp; (x - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>该数字二进制表示中<code>1</code>的个数</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bCountOne</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x)&#123;      <span class="comment">// x != 0x0000</span></span><br><span class="line">        x = x &amp; (x - <span class="number">1</span>);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>求一个符号数的绝对值</p><p> <strong>数字按位取反后加$1$得到该数的相反数(补码)</strong>。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bAbs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mask = x &gt;&gt; (<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">8</span> - <span class="number">1</span>); <span class="comment">// `&gt;&gt;`为算术位移，此时`mask = 0x0000 = 0`或`mask = 0xFFFF = -1`</span></span><br><span class="line">    <span class="comment">// return (x ^ mask) - mask;</span></span><br><span class="line">    <span class="comment">// 分解：</span></span><br><span class="line">    x ^= mask;  <span class="comment">// `mask = 0x0000`时不变，`mask = 0xFFFF`时按位取反</span></span><br><span class="line">    x -= mask;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="两个数字的操作"><a href="#两个数字的操作" class="headerlink" title="两个数字的操作"></a>两个数字的操作</h1><ol><li><p>实现两个数字的交换</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bExch</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a ^= b;</span><br><span class="line">    b ^= a;</span><br><span class="line">    a ^= b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现两个数字的加法</p><ul><li><strong>位的加法</strong>与“异或”一致、<strong>进位</strong>与“与”一致；</li><li>注意<strong>进位位</strong>的处理。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bAdd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">        sum = a ^ b;            <span class="comment">// 先求每位和</span></span><br><span class="line">        carry = (a &amp; b) &lt;&lt; <span class="number">1</span>;   <span class="comment">// 每位相加后的进位</span></span><br><span class="line">        a = sum; b = carry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>判断两个数字是否异号</p><ul><li>如果用乘法判断<code>a * b &lt; 0</code>，可能会导致溢出；</li><li>用异或对符号位进行判断，若异号则符号位异或后为<code>1</code>，两数异或结果小于$0$。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasSameSign</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a ^ b) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h1 id="多个数字的操作"><a href="#多个数字的操作" class="headerlink" title="多个数字的操作"></a>多个数字的操作</h1><ol><li>某数组除一个数字只有$1$个外，其余数字都有$2$个，找到这个数字<br> 数组异或，相同的数字被抵消 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numAlone</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">"Invalid Input! "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        num ^= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li>《剑指offer》；</li><li><a href="https://blog.csdn.net/qq_16137569/article/details/82790378" target="_blank" rel="noopener">位运算在算法中的应用小结 - CSDN</a>；</li><li><a href="https://labuladong.github.io/ebook/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BD%8D%E6%93%8D%E4%BD%9C.html" target="_blank" rel="noopener">labuladong的算法小抄</a>；</li><li><a href="http://graphics.stanford.edu/~seander/bithacks.html" target="_blank" rel="noopener">Bit Twiddling Hacks</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【算法】回溯法与分支定界法</title>
      <link href="/2020/03/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%9B%9E%E6%BA%AF%E6%B3%95%E4%B8%8E%E5%88%86%E6%94%AF%E5%AE%9A%E7%95%8C%E6%B3%95/"/>
      <url>/2020/03/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%9B%9E%E6%BA%AF%E6%B3%95%E4%B8%8E%E5%88%86%E6%94%AF%E5%AE%9A%E7%95%8C%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h1><p><strong>回溯法</strong>(backtracking)是对候选集进行系统检查的两种方法，该算法策略有以下几步</p><ol><li>定义问题的<strong>解空间</strong>(solution space)，这个空间至少包含一个问题的(最优的)解；</li><li><strong>组织解空间</strong>，使解空间便于搜索，典型的组织方法是图和树；<br> 例如<strong>迷宫老鼠问题</strong>：指定$3 \times 3$的迷宫，部分位置不可通行，求解最短的通行路径。该问题如果用树描述，那么不考虑是否能通行，每个节点处有$4$个抉择，树结构较大，用图描述较为简便，如下<br> <img src="/2020/03/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%9B%9E%E6%BA%AF%E6%B3%95%E4%B8%8E%E5%88%86%E6%94%AF%E5%AE%9A%E7%95%8C%E6%B3%95/【算法】回溯法与分支定界法/maze_eg.jpg" alt="maze_eg"></li><li>在确定解空间的组织方法后，这个空间可以按<strong>深度优先方式</strong>进行搜索。<ol><li>初始化<strong>E-结点</strong>(expansion node)为起始点，标记搜索过程中经过的节点为<strong>活动节点</strong>(live node)，那么起始点也是一个活动节点；</li><li>在E-节点处，尝试可能的选择节点并移动：1) <strong>若存在这样的节点</strong>，将当前E-节点新到达节点成为E-节点，并标记新节点也为活动节点；2)<strong>若不存在这样的节点</strong>(<strong>没有可供选择的节点，或超过约束限制</strong>)，将当前E-节点标记为死节点(用来杀死该节点的策略称为<strong>界定函数</strong>(bounding function))，并将E-节点返回至最近的活动节点(<strong>回溯</strong>)；</li><li>循环步骤2直至遍历节空间，在搜索过程中，实时更新最优解。</li></ol></li></ol><blockquote><p>以迷宫老鼠为例，初始节点$(1, 1)$标记为活动节点，同时也为E-节点，在该节点处可达节点为$(1,2),(2,1)$，那么标记$(1,2)$为活动节点，E-节点更新为$(1,2)$。当E-节点为$(1,3)$时，该节点无可达节点(即界定函数)，标记为死结点，并更新E-节点为最近的活动节点，即$(1,2)$，此时该节点也被标记为死结点，E-节点更新为$(1,1)$。此时存在可达节点$(2,1)$，将其标记为活动节点，并更新E-节点。以此类推，当E-节点为出口$(3,3)$时，结束算法。<br>注：此时活动节点有$(1,1), (2,1), (3,1), (3,2), (3,3)$。<br><img src="/2020/03/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%9B%9E%E6%BA%AF%E6%B3%95%E4%B8%8E%E5%88%86%E6%94%AF%E5%AE%9A%E7%95%8C%E6%B3%95/【算法】回溯法与分支定界法/maze_dfs.jpg" alt="maze_dfs"></p></blockquote><p>注意区别回溯法和动态规划，两者有一定程度的相似性。动态规划是自底向上的，回溯法是自顶向下的。</p><p><strong>例(旅行商问题, TSP)：给定一个$n$顶点的有权网络(有向或无向)，找出一个包含$n$个顶点且具有最小耗费的环路，例如给定下图的网络：</strong><br><img src="/2020/03/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%9B%9E%E6%BA%AF%E6%B3%95%E4%B8%8E%E5%88%86%E6%94%AF%E5%AE%9A%E7%95%8C%E6%B3%95/【算法】回溯法与分支定界法/tsp_eg.jpg" alt="tsp_eg"></p><p>该问题的<strong>约束条件</strong>是：1) 环路包含$n$个节点；2) 节点间拓扑结构已确定。<strong>优化目标</strong>是环路耗费最低，用矩阵描述该图为</p><script type="math/tex; mode=display">\begin{bmatrix}    \infty & 30 & 35 & \infty & 20 \\    30 & \infty & 20 & 10 & \infty \\    35 & 20 & \infty & 5 & 15 \\    \infty & 10 & 5 & \infty & 25 \\    20 & \infty & 15 & 25 & \infty \\\end{bmatrix}</script><p>考虑分支问题可以用栈来解决，用递归的形式<strong>借助函数调用栈</strong>，求解指定节点$i$所能到达死结点的路径。考虑到已经过节点不能再次经过，<strong>将能到达$i$的路径全部删除(置为无穷大)</strong>。但采用函数调用栈可能导致函数调用层级很深而溢出。</p><blockquote><p>用下列函数求解得<code>(80.0, [0, 1, 3, 2, 4])</code>，即路径为$1 \rightarrow 2 \rightarrow 4 \rightarrow 3 \rightarrow 5 \rightarrow 1$，最小耗费为$80$。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solveTSP</span><span class="params">(A)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取从节点0开始的，所有最深路径</span></span><br><span class="line">    path = getPath(A, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 删除不包含所有节点的路径</span></span><br><span class="line">    path = list(filter(<span class="keyword">lambda</span> x: len(x) == <span class="number">5</span>, path))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算每条路径的成本</span></span><br><span class="line">    cost = list(map(<span class="keyword">lambda</span> x: getCost(A, x), path))</span><br><span class="line">    </span><br><span class="line">    minCost = min(cost)</span><br><span class="line">    minPath = path[cost.index(minCost)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> minCost, minPath</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPath</span><span class="params">(A, i)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Params:</span></span><br><span class="line"><span class="string">        A: &#123;ndarray(n, n)&#125;</span></span><br><span class="line"><span class="string">        i: &#123;int&#125;</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        path: &#123;list[list]&#125;</span></span><br><span class="line"><span class="string">    Notes:</span></span><br><span class="line"><span class="string">        - 深度优先遍历；</span></span><br><span class="line"><span class="string">        - 返回A为图下，以节点i为起始的最深路径，包含i；</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    n = A.shape[<span class="number">0</span>]</span><br><span class="line">    path = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算i能到达的每个节点的最深路径</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">if</span> np.isinf(A[i, j]): <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        B = A.copy(); </span><br><span class="line">        B[:, i] = float(<span class="string">'inf'</span>)      <span class="comment"># 把所有能到达i的路径删除，使i不重复经过</span></span><br><span class="line">        path += getPath(B, j)       <span class="comment"># 在不能到达i节点的情况下，求解j节点到达死结点的路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加节点i</span></span><br><span class="line">    <span class="keyword">if</span> len(path) == <span class="number">0</span>:              <span class="comment"># i不能到达任何节点，那么只返回1条包含i的路径</span></span><br><span class="line">        path = [[i]]</span><br><span class="line">    <span class="keyword">else</span>:                           <span class="comment"># i能到达其他死结点，那么每条路径前添加i节点</span></span><br><span class="line">        path = list(map(<span class="keyword">lambda</span> x: [i] + x, path))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> path</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCost</span><span class="params">(A, path)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Params:</span></span><br><span class="line"><span class="string">        A: &#123;ndarray(n, n)&#125;</span></span><br><span class="line"><span class="string">        path: &#123;list&#125;</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        cost</span></span><br><span class="line"><span class="string">    Notes:</span></span><br><span class="line"><span class="string">        - 计算环路的耗费；</span></span><br><span class="line"><span class="string">        - path路径不包含头节点，即不为环路</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    cost = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(path) - <span class="number">1</span>):</span><br><span class="line">        cost += A[path[i], path[i+<span class="number">1</span>]]</span><br><span class="line">    cost += A[path[<span class="number">-1</span>], path[<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">return</span> cost</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    </span><br><span class="line">    A = np.array([</span><br><span class="line">        [float(<span class="string">'inf'</span>), <span class="number">30</span>, <span class="number">35</span>, float(<span class="string">'inf'</span>), <span class="number">20</span>],</span><br><span class="line">        [<span class="number">30</span>, float(<span class="string">'inf'</span>), <span class="number">20</span>, <span class="number">10</span>, float(<span class="string">'inf'</span>)],</span><br><span class="line">        [<span class="number">35</span>, <span class="number">20</span>, float(<span class="string">'inf'</span>), <span class="number">5</span>, <span class="number">15</span>],</span><br><span class="line">        [float(<span class="string">'inf'</span>), <span class="number">10</span>, <span class="number">5</span>, float(<span class="string">'inf'</span>), <span class="number">25</span>],</span><br><span class="line">        [<span class="number">20</span>, float(<span class="string">'inf'</span>), <span class="number">15</span>, <span class="number">25</span>, float(<span class="string">'inf'</span>)]</span><br><span class="line">    ])</span><br><span class="line">    print(solveTSP(A))</span><br></pre></td></tr></table></figure><p>下面是用<strong>栈</strong>实现的<strong>深度优先搜索</strong>，需保存当前图、E-节点和当前已加入的路径</p><p><div id="dfs"></div><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._data = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._data)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self._data += [x]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._data.pop(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Params:</span></span><br><span class="line"><span class="string">        A: &#123;ndarray(n, n)&#125; 原始图</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    n = A.shape[<span class="number">0</span>]</span><br><span class="line">    path = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从0号结点开始</span></span><br><span class="line">    stack = Stack()</span><br><span class="line">    stack.push((A, <span class="number">0</span>, [<span class="number">0</span>]))  <span class="comment"># 栈内元素：(当前图，当前节点，当前路径)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(len(stack) &gt; <span class="number">0</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># E-节点出栈</span></span><br><span class="line">        a, i, p = stack.pop()</span><br><span class="line">        <span class="comment"># 已经过所有节点，保存退出</span></span><br><span class="line">        <span class="keyword">if</span> len(p) == n:</span><br><span class="line">            path += [p]</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 删除可达E-节点的路径</span></span><br><span class="line">        b = a.copy(); b[:, i] = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="comment"># E-节点的可达节点入栈，这些节点即活动节点</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> np.isinf(b[i, j]): <span class="keyword">continue</span></span><br><span class="line">            stack.push((b, j, p + [j]))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 取最小耗费的路径</span></span><br><span class="line">    cost = list(map(<span class="keyword">lambda</span> x: getCost(A, x), path))</span><br><span class="line">    index = cost.index(min(cost))</span><br><span class="line">    <span class="keyword">return</span> cost[index], path[index]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    </span><br><span class="line">    A = np.array([</span><br><span class="line">        [float(<span class="string">'inf'</span>), <span class="number">30</span>, <span class="number">35</span>, float(<span class="string">'inf'</span>), <span class="number">20</span>],</span><br><span class="line">        [<span class="number">30</span>, float(<span class="string">'inf'</span>), <span class="number">20</span>, <span class="number">10</span>, float(<span class="string">'inf'</span>)],</span><br><span class="line">        [<span class="number">35</span>, <span class="number">20</span>, float(<span class="string">'inf'</span>), <span class="number">5</span>, <span class="number">15</span>],</span><br><span class="line">        [float(<span class="string">'inf'</span>), <span class="number">10</span>, <span class="number">5</span>, float(<span class="string">'inf'</span>), <span class="number">25</span>],</span><br><span class="line">        [<span class="number">20</span>, float(<span class="string">'inf'</span>), <span class="number">15</span>, <span class="number">25</span>, float(<span class="string">'inf'</span>)]</span><br><span class="line">    ])</span><br><span class="line">    print(solveTSP2(A))</span><br></pre></td></tr></table></figure></p><h1 id="分支定界法"><a href="#分支定界法" class="headerlink" title="分支定界法"></a>分支定界法</h1><p>和回溯法类似，分支定界法也经常把解空间组织成树或图的结构然后进行搜搜。<strong>回溯法使用先深搜索，而分支定界法采用先广搜索</strong>。每个节点只有一次机会成为E-节点，E-节点的可达节点都是生成的新节点，那些不可能到处(最优)可行解的节点被舍弃(死结点)。分支定界法也可采用<strong>定界函数</strong>提前结束搜索。</p><p>有两种常用的方法选择E-节点：</p><ol><li>先进先出(FIFO)：借助队列，可参考二叉树的层次遍历。将首个节点加入队列，然后依次出队列作为E-节点，将E-节点可达节点全部加入队列，直至队列为空；</li><li>最小耗费或最大收益法：借助小根堆/大根堆，将堆顶节点弹出作为E-节点，并将其可达节点全部加入堆。</li></ol><blockquote><p>那么迷宫老鼠问题中，迷宫的路径搜索节点顺序如下<br><img src="/2020/03/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%9B%9E%E6%BA%AF%E6%B3%95%E4%B8%8E%E5%88%86%E6%94%AF%E5%AE%9A%E7%95%8C%E6%B3%95/【算法】回溯法与分支定界法/maze_bfs.jpg" alt="maze_bfs"></p></blockquote><p>以下借助<strong>队列</strong>实现<strong>广先搜索</strong>解决TSP问题，将<a href="#dfs">回溯法</a>中栈修改为队列即可</p><p><div id="bfs"></div><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._data = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._data)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self._data += [x]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._data.pop(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Params:</span></span><br><span class="line"><span class="string">        A: &#123;ndarray(n, n)&#125; 原始图</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    n = A.shape[<span class="number">0</span>]</span><br><span class="line">    path = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从0号结点开始</span></span><br><span class="line">    queue = Queue()</span><br><span class="line">    queue.push((A, <span class="number">0</span>, [<span class="number">0</span>]))  <span class="comment"># 栈内元素：(当前图，当前节点，当前路径)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(len(queue) &gt; <span class="number">0</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># E-节点出栈</span></span><br><span class="line">        a, i, p = queue.pop()</span><br><span class="line">        <span class="comment"># 已经过所有节点，保存退出</span></span><br><span class="line">        <span class="keyword">if</span> len(p) == n:</span><br><span class="line">            path += [p]</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 删除可达E-节点的路径</span></span><br><span class="line">        b = a.copy(); b[:, i] = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="comment"># E-节点的可达节点入栈，这些节点即活动节点</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> np.isinf(b[i, j]): <span class="keyword">continue</span></span><br><span class="line">            queue.push((b, j, p + [j]))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 取最小耗费的路径</span></span><br><span class="line">    cost = list(map(<span class="keyword">lambda</span> x: getCost(A, x), path))</span><br><span class="line">    index = cost.index(min(cost))</span><br><span class="line">    <span class="keyword">return</span> cost[index], path[index]</span><br></pre></td></tr></table></figure></p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>回溯法的求解目标是找出满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【算法】分而治之</title>
      <link href="/2020/03/21/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B/"/>
      <url>/2020/03/21/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>分治算法</strong>是将一个问题的大实例分成若干个更小的实例，分别解决后将小实例的解组合成原始大实例的解。一般来说，大实例分解前是用重复的步骤进行求解的，分解后的子问题也可通过同一种算法解决，用<strong>递归</strong>解决。</p><p><strong>例(金块问题)：有$n$个金块，从中找出最重与最轻的金块。</strong></p><p>如果用顺序查找的方式，先通过$n-1$次比较选出最重的，再通过$n-2$次比较选出最轻的，共进行$2n-3$次比较，时间复杂度为$O(n)$。</p><p>通过分治的方式，<strong>将金块分为若干份，每份中选取最大和最小的金块</strong>，如递归二分，将$n$个金块分为$n/2 + n/2$，$n/2$又可划分为$n/4 + n/4$，以此类推，直至划分集合中剩余$1$或$2$个金块，选出最大和最小，在合并过程中<strong>比较每份中的最大和最小</strong>即可，最终得到全部金块中的最大和最小。</p><p>共划分为$\lceil n/2 \rceil$个小组，第$1$次需进行$\lceil n/2 \rceil$次比较，第$i(i \geq 2)$次在$\lceil n / 2^{i} \rceil$份金子间，进行$\lceil n / 2^{i} \rceil \times 2$次比较(最大、最小比较)，共需进行$\lceil \log_2 n \rceil$层的比较，总比较次数为</p><script type="math/tex; mode=display">\lceil n/2 \rceil + 2 \times \sum_{i=2}^{\lceil \log_2 n \rceil} \lceil n / 2^{i} \rceil</script><p>以$n=17$为例，共进行$9 + 2 \times (5 + 3 + 2 + 1) = 22$次，而顺序比较时进行了$2 \times 17 - 3 = 31$次比较，减少超过$25\%$的比较次数。</p><p><strong>例(递归排序)：利用分治思想设计排序。</strong></p><p>将$n$个数进行<strong>二路划分</strong>，对每个子集合进行排(如插入、冒泡等)，再依次组合归并有序集合得到整个有序集合，可以看作是别的排序算法的递归实现。注意到将两个子集合归并时，两子集和已有序，故改进合并算法为<strong>直接归并排序</strong>(straight merge sort)，不采用其他排序算法进行合并，减少时间复杂度，相应的会增加空间空间复杂度。</p><p>如下图，对${8, 4, 7, 3, 6, 1, 2, 9, 10, 5}$进行排序，归并排序共进行$22$次比较，而使用冒泡排序时，需进行$39$次比较。</p><p><img src="/2020/03/21/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B/【算法】分而治之/merge_sort.jpg" alt="merge_sort"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(T a[], <span class="keyword">int</span> begin, <span class="keyword">int</span> middle, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T* b = <span class="keyword">new</span> T[end];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将有序子数组合并到b</span></span><br><span class="line">    <span class="keyword">int</span> i = begin, j = middle, k = begin;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == middle)</span><br><span class="line">            idx = j++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j == end)</span><br><span class="line">            idx = i++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            idx = a[i] &lt; a[j] ? i++ : j++;</span><br><span class="line">        &#125;</span><br><span class="line">        b[k++] = a[idx]; mvCnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝至原数组</span></span><br><span class="line">    <span class="keyword">for</span> (i = begin; i &lt; end; a[i] = b[i++]);</span><br><span class="line">    <span class="keyword">delete</span> [] b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(T a[], <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end - begin &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> middle = (begin + end) / <span class="number">2</span>;</span><br><span class="line">    mergeSort(a, begin, middle);</span><br><span class="line">    mergeSort(a, middle, end);</span><br><span class="line"></span><br><span class="line">    merge(a, begin, middle, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(T a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mergeSort(a, <span class="number">0</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例(快速排序)：一种不稳定但速度很快的排序算法</strong></p><p>快速排序是在待排序数组中寻找一个<strong>支点</strong>(pivot)，将当前待排序数组进行划分，使支点左侧的数据均小于支点，右侧的数据均大于支点，然后再分别对两侧进行迭代的排序进行<strong>分治</strong>，子数组排序完成后依次<strong>回溯</strong>使整个数组完成排序，示意图如下</p><p>与冒泡等不同，<strong>当有序数组输入时为最坏情况</strong>。此时支点始终在最左侧或最右侧，时间复杂度为$O(n)$。为改善上述情况，可将用<strong>三值取中原则</strong>(median-of-three rule)进行支点的选择，在$a[begin], a[(begin + end)/2], a[end]$三个元素中选择大小居中的元素。</p><p><img src="/2020/03/21/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B/【算法】分而治之/quicksort.jpg" alt="quicksort"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(T a[], <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span>   <span class="comment">// a[begin] ~ a[end - 1]</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cmpCnt = <span class="number">0</span>; <span class="keyword">int</span> mvCnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (end - begin &lt; <span class="number">2</span>) <span class="keyword">return</span>;    <span class="comment">// 仅包含1个数，无需排序</span></span><br><span class="line"></span><br><span class="line">    T pivot = a[begin];<span class="comment">// 当前子数组的头元素视作支点</span></span><br><span class="line">    <span class="keyword">int</span> left = begin, right = end - <span class="number">1</span>;<span class="comment">// 左右索引</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (a[left] &lt;= pivot &amp;&amp; left &lt; end) left++;<span class="comment">// 搜索从左至右大于支点的元素a[left]</span></span><br><span class="line">        <span class="keyword">while</span> (a[right] &gt;= pivot &amp;&amp; right &gt; <span class="number">0</span>) right--;<span class="comment">// 搜索从右至左小于支点的元素a[right]</span></span><br><span class="line"></span><br><span class="line">        cmpCnt++;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; right) &#123;<span class="comment">// 交换a[left]与a[right]</span></span><br><span class="line">            mvCnt++;</span><br><span class="line">            T temp = a[left];</span><br><span class="line">            a[left] = a[right];</span><br><span class="line">            a[right] = temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时索引为`begin + 1 ~ left - 1`的数都小于支点，索引为`left ~ end - 1`的数都大于支点；</span></span><br><span class="line">    <span class="comment">// 将支点调整至left - 1处，使支点左侧元素都小于支点，右侧都大于支点</span></span><br><span class="line">    mvCnt++;</span><br><span class="line">    a[begin] = a[left - <span class="number">1</span>];</span><br><span class="line">    a[left - <span class="number">1</span>] = pivot;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 划分子数组，递归</span></span><br><span class="line">    quickSort(a, begin, left - <span class="number">1</span>);  <span class="comment">// a[left-1]位置已确定</span></span><br><span class="line">    quickSort(a, left, end);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"比较"</span> &lt;&lt; cmpCnt &lt;&lt; <span class="string">"次 移动"</span> &lt;&lt; mvCnt &lt;&lt; <span class="string">"次"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(T a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    quickSort(a, <span class="number">0</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例：将快速排序应用到寻找数组中升序排序中，次序为$k$的数</strong></p><p>在快速排序的某次递归中，支点左侧均小于支点，右侧均大于支点，那么支点的位置在整个数组中已确定。在寻找次序为$k$的数时，不在最坏情况下，不需要等排序结束就可解决。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findK</span><span class="params">(T a[], <span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="keyword">int</span> k)</span> <span class="comment">// a[begin] ~ a[end - 1]</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end - begin &lt; <span class="number">2</span>) <span class="keyword">return</span> a[begin];<span class="comment">// 仅包含1个数，一定为查找的数</span></span><br><span class="line"></span><br><span class="line">    T pivot = a[begin];<span class="comment">// 当前子数组的头元素视作支点</span></span><br><span class="line">    <span class="keyword">int</span> left = begin, right = end - <span class="number">1</span>;<span class="comment">// 左右索引</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (a[left] &lt;= pivot &amp;&amp; left &lt; end) left++;<span class="comment">// 搜索从左至右大于支点的元素a[left]</span></span><br><span class="line">        <span class="keyword">while</span> (a[right] &gt;= pivot &amp;&amp; right &gt; <span class="number">0</span>) right--;<span class="comment">// 搜索从右至左小于支点的元素a[right]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;<span class="comment">// 交换a[left]与a[right]</span></span><br><span class="line">            T temp = a[left];</span><br><span class="line">            a[left] = a[right];</span><br><span class="line">            a[right] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时索引为`begin + 1 ~ left - 1`的数都小于支点，索引为`left ~ end - 1`的数都大于支点；</span></span><br><span class="line">    <span class="comment">// 将支点调整至left - 1处，使支点左侧元素都小于支点，右侧都大于支点</span></span><br><span class="line">    a[begin] = a[left - <span class="number">1</span>];</span><br><span class="line">    a[left - <span class="number">1</span>] = pivot;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 划分子数组，递归</span></span><br><span class="line">    <span class="keyword">if</span> (k &lt; left)</span><br><span class="line">        findK(a, begin, left - <span class="number">1</span>, k);<span class="comment">// 在左侧寻找第`k`大的数</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        findK(a, left, end, k);<span class="comment">// 在右侧寻找第`k-left`大的数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findK</span><span class="params">(T a[], <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findK(a, <span class="number">0</span>, n, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例(<a href="https://www.lintcode.com/problem/fast-power/description" target="_blank" rel="noopener">快速幂</a>)：设计时间复杂度为$\log(n)$的算法，计算$a^n \% b$。</strong></p><p>有以下处理方法</p><ul><li>$(a \times b) \% c = (a \% c) \times b \% c$</li><li>$a^n = \begin{cases} a^{\lfloor n / 2 \rfloor} \times a^{\lfloor n / 2 \rfloor} \times a^{n \% 2 } &amp; n &gt; 1 \ 1 &amp; n = 0 \ a &amp; n = 1 \end{cases}$</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param a: A 32bit integer</span></span><br><span class="line"><span class="comment">     * @param b: A 32bit integer</span></span><br><span class="line"><span class="comment">     * @param n: A 32bit integer</span></span><br><span class="line"><span class="comment">     * @return: An integer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">fastPower</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span> % b;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> temp = fastPower(a, b, n / <span class="number">2</span>);</span><br><span class="line">        temp = (temp * temp) % b;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">              temp = (temp * a) % b;</span><br><span class="line">              </span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【算法】贪婪算法</title>
      <link href="/2020/03/21/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/"/>
      <url>/2020/03/21/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>在<strong>贪婪算法</strong>(greedy method)中，逐步构造一个最优解，每一步都是在<strong>贪婪准则</strong>(greedy criterion)下做出的最优决策。</p><p><strong>例($0/1$背包问题)：有$n$个物品和一个容量为$c$的背包，第$i$个物品重量为$w_i$、价值为$p_i$，求取物品总价值最高的可行的背包装载，即</strong></p><script type="math/tex; mode=display">\begin{aligned}    \max \sum_{i=1}^n p_i x_i \\    s.t. \quad \sum_{i=1}^n w_i x_i \leq c \\    x_i \in \{0, 1\} \quad 1 \leq i \leq n\end{aligned}</script><p>该问题是$NP$-复杂问题，难以求取最优解，有以下几种<strong>简单的贪婪策略</strong></p><ol><li><strong>价值贪婪准则</strong>：从剩余物品中选出可以装入背包的价值最大的物品，但如$n=3, w = [10, 10, 10], p = [20, 15, 15], c = 15$时，该准则选取的装载$x = [1, 0, 0]$不是最优的；</li><li><strong>重量贪婪准则</strong>：从剩余物品中选出可以装入背包的重量最小的物品，但如$n=3, w = [20, 10, 10], p = [20, 5, 5], c = 25$时，该准则选取的装载$x = [0, 1, 1]$不是最优的；</li><li><strong>价值密度贪婪准则</strong>：从剩余物品中选出可以装入背包的$p_i/w_i$最大的物品，但如$n=3, w = [20, 15, 15], p = [40, 25, 25], c = 25$时，$p/w = [2, 1.67, 1.67]$，该准则选取的装载$x = [1, 0, 0]$不是最优的。</li></ol><p>价值密度贪婪法则不能保证最优解，但这是一个好的启发式算法，在很多时候接近最优解。对其进行改进，使解的结果与最优解之差在最优值的$x\%(x &lt; 100)$之内：选择<strong>至多$k$件物品</strong>放入背包(构成子集)，<strong>首先选择价值最高的可行物品集合，再将剩余子集按$p_i/w_i$的递减顺序装入背包</strong>，如$n=4, w = [2, 4, 6, 7], p = [6, 10, 12, 13], c = 11$，选择$k=2$，有以下子集<br>| 子集($k \leq 2$) | 重量 | 价值 | 价值密度 |<br>| —- | —- | —- | ——— |<br>| 1 | 2 | 6 | 3 |<br>| 2 | 4 | 10 | 2.5 |<br>| 3 | 6 | 12 | 2 |<br>| 4 | 7 | 13 | 1.86 |<br>| 1, 2 | 6 | 16 | 2.67 |<br>| 1, 3 | 8 | 18 | 2.25 |<br>| 1, 4 | 9 | 19 | 2.11 |<br>| 2, 3 | 10 | 22 | 2.2 |<br>| 2, 4 | 11 | 23 | 2.09 |<br>| 3, 4 | 13 | 25 | 1.92 |</p><p>根据价值，首先选择装载$3, 4$，但该方案重量为$13$不可行，选择$2, 4$可行，此时背包剩余空间$2$，剩余方案$1, 3, 1+3$按价值密度降序为$1, 1+3, 3$，但重量均超过$c$，故不继续装入背包，该方案最终为$x = [0, 1, 0, 1], w_x = 11, p_x = 23$。</p><p><strong>例(最小成本生成树)：给出加权图，求取最小生成树，使得成本(选取路径的成本之和)最低。</strong></p><p>$n$个节点的最小生成树有$n-1$条边，有三种不同的贪婪策略，产生两个算法：Kruskal、Prim。</p><p><img src="/2020/03/21/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/【算法】贪婪算法/kruskal_prim_sollin_eg.jpg" alt="kruskal_prim_sollin_eg"></p><ol><li><p>Kruskal<br> 分步选择$n-1$条边，从剩下的边中选择<strong>成本最小</strong>且不<strong>会产生回路</strong>的边，加入已选择的边集。<br> “不会产生回路”可通过检查<strong>待加入边两个顶点是否在已选定边组成的图中已连通</strong>判定，判断连通可通过<strong>检查其中一个顶点通过的路径中是否包含另一个顶点</strong>。用该算法对上图进行的生成树选择示意图如下<br> <img src="/2020/03/21/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/【算法】贪婪算法/kruskal_prim_sollin_kruskal.jpg" alt="kruskal_prim_sollin_kruskal"></p></li><li><p>Prim<br> 分步选择$n-1$条边，从剩下的边中选择<strong>成本最小</strong>的边，加入已选择的边集，<strong>使该边集构成一棵树</strong>。<br> 即选择<strong>与已选边集的顶点关联的、成本最小的边</strong>加入边集。<br> <img src="/2020/03/21/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/【算法】贪婪算法/kruskal_prim_sollin_prim.jpg" alt="kruskal_prim_sollin_prim"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】图</title>
      <link href="/2020/03/16/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%9B%BE/"/>
      <url>/2020/03/16/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="定义与概念"><a href="#定义与概念" class="headerlink" title="定义与概念"></a>定义与概念</h1><p><strong>定义</strong>：<strong>图</strong>(graph)是有限集$V$和$E$的<strong>有序对</strong>$G(V, E)$，其中$V$中的元素称为<strong>顶点</strong>(也称节点或点)，$E$的元素称为<strong>边</strong>(也称弧或线)。每一条边连接两个不同的顶点，可以用元组$(v_i, v_j)$来表示，$v_i, v_j$表示边所连接的两个顶点；当且仅当$(v_i, v_j)$是图的边，称顶点$v_i, v_j$是<strong>邻接的</strong>(adjacent)、边$(v_i, v_j)$<strong>关联</strong>(incident)于顶点$v_i, v_j$。</p><p>根据定义，一个图<strong>不能有重复的边</strong>；无向图任意两个节点间，<strong>最多有一条边</strong>，而有向图任意两个节点间<strong>每个方向最多有一条边</strong>；一个图不可能包含<strong>自连边</strong>(self-edge)或<strong>环</strong>(loop)，即$(v_i, v_i)$。</p><p>带方向的边叫<strong>有向边</strong>(directed edge)，不带方向的边叫<strong>无向边</strong>(undirected edge)；有向边$(v_i, v_j)$是<strong>关联至</strong>(incident to)顶点$v_j$而<strong>关联于</strong>(incident from)顶点$v_i$、顶点$v_i$<strong>邻接至</strong>(adjacent to)$v_j$，顶点$v_j$<strong>邻接于</strong>(adjacent from)$v_i$。</p><p>如果图的所有边都是无向边，那么该图叫做<strong>无向图</strong>(undirected graph)，如果所有的边都是有向边，那么该图叫做<strong>有向图</strong>(directed graph或digraph)。</p><p>若每条边被赋予一个表示成本的值，该值被称之为<strong>权</strong>，则此时图称为<strong>加权有向图</strong>(weighted digraph)和<strong>加权无向图</strong>(weighted undirected graph)。</p><p><strong>概念</strong>：</p><ul><li><strong>简单路径</strong>是除始点和终点外，其余顶点都不相同的路径。</li><li><strong>环路</strong>(cycle)是<strong>始点和终点相同</strong>的<strong>简单路径</strong>。</li><li>一个无向图$G = (V, E)$当且仅当$G$的<strong>每一对节点</strong>之间都有一条<strong>路径</strong>时，$G$是<strong>连通的</strong>(connected)，具有$n$个顶点的连通无向图至少有$n-1$条边。</li><li>没有环路的连通无向图是一棵<strong>树</strong>。</li><li>$G$的子图，如果包含$G$的所有顶点，且是一棵树，则称该子图为$G$的<strong>生成树</strong>(spanning tree)。</li></ul><blockquote><p>生成树可将网络建设成本减至最小，且保证网络的连通。</p></blockquote><p><img src="/2020/03/16/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%9B%BE/【数据结构】图/graph_eg.jpg" alt="graph_eg"></p><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p><strong>特性</strong>：设$G = (V, E)$是一个无向图，与顶点$v_i$相关联的边数称为该顶点的<strong>度</strong>(degree)$d_i$。则有</p><ol><li>$\sum_{i=1}^{|V|} d_i = 2 |E|$</li><li>$0 \leq |E| \leq \frac{|V|(|V| - 1)}{2}$</li></ol><p><strong>特性</strong>：设$G = (V, E)$是一个有向图中，顶点$v_i$的<strong>入度</strong>(in-degree)$d_i^{in}$是指关联至该顶点的边数，<strong>出度</strong>(out-degree)$d_i^{out}$是指关联于该顶点的边数，则有</p><ol><li>$\sum_{i=1}^{|V|} d_i^{in} = \sum_{i=1}^{|V|} d_i^{out} = |E|$</li><li>$0 \leq |E| \leq |V|(|V| - 1)$</li></ol><h1 id="图的描述"><a href="#图的描述" class="headerlink" title="图的描述"></a>图的描述</h1><h2 id="无权图"><a href="#无权图" class="headerlink" title="无权图"></a>无权图</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>一个$n$个顶点图$G = (V, E)$的<strong>邻接矩阵</strong>(adjacent matrix)是一个$n \times n$的矩阵$A$。对于无权无向图，元素定义如下</p><script type="math/tex; mode=display">A[i, j] = \begin{cases}    1 & (v_i, v_j) \in E 或 (v_j, v_i) \in E \\    0 & 其他 \end{cases}</script><p>对于无权有向图</p><script type="math/tex; mode=display">A[i, j] = \begin{cases}    1 & (v_i, v_j) \in E \\    0 & 其他 \end{cases}</script><p>如下图，两个图与其对应矩阵<br><img src="/2020/03/16/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%9B%BE/【数据结构】图/description_unweighted.jpg" alt="description_unweighted"></p><script type="math/tex; mode=display">\begin{aligned}    A_1 = \begin{bmatrix}        0 & 1 & 1 & 1 \\        1 & 0 & 1 & 0 \\        1 & 1 & 0 & 1 \\        1 & 0 & 1 & 0    \end{bmatrix}; &    A_2 = \begin{bmatrix}        0 & 1 & 1 & 1 \\        0 & 0 & 1 & 0 \\        0 & 0 & 0 & 1 \\        0 & 0 & 0 & 0    \end{bmatrix}\end{aligned}</script><p>以下改进可<strong>减少邻接矩阵存储空间</strong></p><ol><li>省略左对角线元素；</li><li>存储为稀疏矩阵；</li><li>无向图只存储上三角/下三角元素。</li></ol><h3 id="邻接链表-数组"><a href="#邻接链表-数组" class="headerlink" title="邻接链表/数组"></a>邻接链表/数组</h3><p>顶点$v_i$的<strong>邻接表</strong>(adjacent list)是一个线性表，可以用链表或数组描述，<strong>存储所有邻接与顶点$v_i$的顶点</strong>。一个图的邻接链表描述中，每个顶点都有一个邻接表。</p><p><img src="/2020/03/16/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%9B%BE/【数据结构】图/description_unweighted_linked_array.jpg" alt="description_unweighted_linked_array"></p><h2 id="有权图"><a href="#有权图" class="headerlink" title="有权图"></a>有权图</h2><p>将无权图的描述进行扩充，可得到加权图的描述。</p><ul><li>用<strong>成本邻接矩阵</strong>(cost-adjacency matrix)$C$描述加权图。$C[i, j]$表示边$(v_i. v_j)$的边的权，如果不存在需指定一个值，一般是很大的值；</li><li><strong>链表/数组描述</strong>中，节点元素用<strong>数对</strong>表示，添加成员权<code>weight</code>，可从相应的无权图的邻接链表/数组得到加权图的邻接链表/数组；</li></ul><p><img src="/2020/03/16/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%9B%BE/【数据结构】图/description_weighted.jpg" alt="description_weighted"></p><p>上图对应矩阵为</p><script type="math/tex; mode=display">\begin{aligned}    A_1 = \begin{bmatrix}         0 & 10 & 20 & 30 \\        10 &  0 & 40 &  0 \\        20 & 40 &  0 & 50 \\        30 &  0 & 50 &  0    \end{bmatrix}; &    A_2 = \begin{bmatrix}         0 & 10 & 20 & 30 \\         0 &  0 & 40 &  0 \\         0 &  0 &  0 & 50 \\         0 &  0 &  0 &  0    \end{bmatrix}\end{aligned}</script><p><img src="/2020/03/16/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%9B%BE/【数据结构】图/description_weighted_linked_array.jpg" alt="description_weighted_linked_array"></p><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><p>图的遍历有两种常用的方法：广度优先搜索(breadth-first search, BFS)和深度优先搜索(depth-first search, DFS)，可用于搜索从某个顶点开始可达到的所有顶点。</p><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p><strong>广度优先搜索</strong>借助<strong>队列</strong>实现，算法描述如下</p><ol><li>从某个指定顶点$v$出发，初始化队列$Q$，将$v$<strong>入队</strong>，初始化；</li><li>从$Q$<strong>出队</strong>一个顶点$w$，若$w$存在邻接顶点，将所有邻接顶点入队，并将这些顶点标记为可达到顶点；否则跳过；</li><li>循环2直至$Q$为空。</li></ol><p><strong>广度优先生成树</strong>(breadth-first spanning tree)是按BFS所得到的生成树。</p><h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><p><strong>深度优先搜索</strong>用递归的方式实现，算法描述如下</p><ol><li>从某个指定顶点$v$出发，若$v$存在邻接顶点，对所有邻接顶点标记，并<strong>依次进行</strong>深度优先搜索；</li><li>直至递归完成。</li></ol><p><strong>深度优先生成树</strong>(depth-first spanning tree)是按DFS所得到的生成树。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>用Python语言简单实现上述两种遍历方式，并返回下图中的有向无权图的生成树<br><img src="/2020/03/16/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%9B%BE/【数据结构】图/bfs_dfs_eg.jpg" alt="bfs_dfs_eg"></p><p>该图用矩阵描述，为</p><script type="math/tex; mode=display">A = \begin{bmatrix}    0 & 1 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\    0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\    0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\    0 & 0 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 0 \\    0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\    0 & 0 & 1 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\    0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 \\    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\    0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 \end{bmatrix}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(A, v)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Params:</span></span><br><span class="line"><span class="string">        A: &#123;ndarray(n, n)&#125; 邻接矩阵</span></span><br><span class="line"><span class="string">        v: &#123;int&#125; 起始点标号</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        T: &#123;ndarray(n, n)&#125; 最小生成树</span></span><br><span class="line"><span class="string">        V: &#123;list&#125; 所有可达到的顶点</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    Q = [v]                 <span class="comment"># 用列表实现队列</span></span><br><span class="line">    T = np.zeros_like(A)    <span class="comment"># 最小生成树</span></span><br><span class="line">    V = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> len(Q) &gt; <span class="number">0</span>:</span><br><span class="line">        u = Q[<span class="number">0</span>]; Q.pop(<span class="number">0</span>)  <span class="comment"># 出队列</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(A.shape[<span class="number">1</span>]):</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> != A[u, j] <span class="keyword">and</span> j <span class="keyword">not</span> <span class="keyword">in</span> V:</span><br><span class="line">                T[u, j] = A[u, j]; V += [j]    <span class="comment"># 标记节点</span></span><br><span class="line">                Q += [j]    <span class="comment"># 入队列</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> T, V</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(A, v)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Params:</span></span><br><span class="line"><span class="string">        A: &#123;ndarray(n, n)&#125; 邻接矩阵</span></span><br><span class="line"><span class="string">        v: &#123;int&#125; 起始点标号</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        T: &#123;ndarray(n, n)&#125; 最小生成树</span></span><br><span class="line"><span class="string">        V: &#123;list&#125; 所有可达到的顶点</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_dfs</span><span class="params">(u, T, V)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(A.shape[<span class="number">1</span>]):</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> != A[u, j] <span class="keyword">and</span> j <span class="keyword">not</span> <span class="keyword">in</span> V:</span><br><span class="line">                T[u, j] = A[u, j]; V += [j]</span><br><span class="line">                _dfs(j, T, V)       <span class="comment"># 迭代</span></span><br><span class="line"></span><br><span class="line">    T = np.zeros_like(A); V = []</span><br><span class="line">    _dfs(v, T, V)   <span class="comment"># 从v开始搜索</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> T, V</span><br></pre></td></tr></table></figure><p>主函数如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    A = [</span><br><span class="line">        [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">    T1, V1 = bfs(np.array(A), <span class="number">0</span>)</span><br><span class="line">    T2, V2 = dfs(np.array(A), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    print(T1, V1, T2, V2)</span><br></pre></td></tr></table></figure></p><p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[[0 1 1 1 0 0 0 0 0 0]</span><br><span class="line"> [0 0 0 0 1 0 0 0 0 0]</span><br><span class="line"> [0 0 0 0 0 0 0 0 0 0]</span><br><span class="line"> [0 0 0 0 0 1 1 0 0 0]</span><br><span class="line"> [0 0 0 0 0 0 0 1 0 0]</span><br><span class="line"> [0 0 0 0 0 0 0 0 0 0]</span><br><span class="line"> [0 0 0 0 0 0 0 0 1 0]</span><br><span class="line"> [0 0 0 0 0 0 0 0 0 0]</span><br><span class="line"> [0 0 0 0 0 0 0 0 0 0]</span><br><span class="line"> [0 0 0 0 0 0 0 0 0 0]] </span><br><span class="line"> [1, 2, 3, 4, 5, 6, 7, 8] </span><br><span class="line"> </span><br><span class="line"> [[0 1 1 1 0 0 0 0 0 0]</span><br><span class="line"> [0 0 0 0 1 0 0 0 0 0]</span><br><span class="line"> [0 0 0 0 0 0 0 0 0 0]</span><br><span class="line"> [0 0 0 0 0 1 1 0 0 0]</span><br><span class="line"> [0 0 0 0 0 0 0 1 0 0]</span><br><span class="line"> [0 0 0 0 0 0 0 0 0 0]</span><br><span class="line"> [0 0 0 0 0 0 0 0 1 0]</span><br><span class="line"> [0 0 0 0 0 0 0 0 0 0]</span><br><span class="line"> [0 0 0 0 0 0 0 0 0 0]</span><br><span class="line"> [0 0 0 0 0 0 0 0 0 0]] </span><br><span class="line"> [1, 4, 7, 2, 3, 5, 6, 8]</span><br></pre></td></tr></table></figure></p><p>在本例中，两种方式生成树相同，示意图如下<br><img src="/2020/03/16/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%9B%BE/【数据结构】图/bfs_dfs_result.jpg" alt="bfs_dfs_result"></p><h1 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h1><p>可用<strong>Floyd算法</strong>计算每对节点间的最短路径：递推产生一个<strong>矩阵序列</strong>$A_1, \cdots, A_k, \cdots, A_n$，其中矩阵$A_k$的第$i$行第$j$列元素$A_k(i, j)$表示从顶点$v_i$到顶点$v_j$的路径上所经过的<strong>顶点个数不大于$k$的最短路径长度</strong>，计算时利用迭代公式</p><script type="math/tex; mode=display">\begin{aligned}    A_k(i, j) = \min \{ A_{k-1}(i, j), \quad A_{k-1}(i, t) + A_{k-1}(t, j) \}\\ 其中 k > 1, t = 1, \cdots, n\end{aligned}</script><p>应有</p><script type="math/tex; mode=display">A_1 = W</script><blockquote><p>即从$v_i$到$v_j$途中，依次经过最多$0, 1, 2, \cdots, k$个<strong>中转点</strong>，保存这些路径中最小的距离。</p></blockquote><p>下面是改进的Floyd算法，除了可求解每对节点间最短路径，还可将最短路径保存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">floyd</span><span class="params">(W)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Params:</span></span><br><span class="line"><span class="string">        W: &#123;ndarray(N, N)&#125; 邻接矩阵</span></span><br><span class="line"><span class="string">    Notes:</span></span><br><span class="line"><span class="string">        A: &#123;ndarray(N, N)&#125; 两两之间最短路</span></span><br><span class="line"><span class="string">        R: &#123;list[list[list(k)](N)](N)&#125; 从节点`v_i`到节点`v_j`的最短路中间节点，保存在`R[i][j]`中</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    A = W.copy(); N = A.shape[<span class="number">0</span>]</span><br><span class="line">    R = [[[] <span class="keyword">for</span> i <span class="keyword">in</span> range(N)] <span class="keyword">for</span> j <span class="keyword">in</span> range(N)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, N):       <span class="comment"># 第k次中间节点寻找</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(N):</span><br><span class="line">                <span class="comment"># 比较经过中转前后路径长度</span></span><br><span class="line">                d = np.minimum(A[i, j], A[i, :] + A[:, j])   <span class="comment"># i -&gt; t -&gt; j, t = 1, ..., N</span></span><br><span class="line">                min_d = np.min(d)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 保存最短路径</span></span><br><span class="line">                <span class="keyword">if</span> min_d &lt; A[i, j]:</span><br><span class="line">                    idx = np.argmin(d)</span><br><span class="line">                    R[i][j] = R[i][idx] + [idx] + R[idx][j]</span><br><span class="line">                <span class="comment"># 保存最短路径的长度</span></span><br><span class="line">                A[i, j] = min_d</span><br><span class="line">    <span class="keyword">return</span> A, R</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】平衡搜索树——分裂树和B树</title>
      <link href="/2020/03/15/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91%E2%80%94%E2%80%94%E5%88%86%E8%A3%82%E6%A0%91%E5%92%8CB%E6%A0%91/"/>
      <url>/2020/03/15/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91%E2%80%94%E2%80%94%E5%88%86%E8%A3%82%E6%A0%91%E5%92%8CB%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="分裂树"><a href="#分裂树" class="headerlink" title="分裂树"></a>分裂树</h1><h2 id="定义与概念"><a href="#定义与概念" class="headerlink" title="定义与概念"></a>定义与概念</h2><p>在字典的很多实际应用中，令我们更感兴趣的不是一个单独操作所需时间，而是一个操作序列所需时间，此时<strong>应用的时间复杂度取决于一个字典操作序列而不是任意一个操作</strong>。</p><p>伸展树基于以下<strong>假设</strong>：想要对一个二叉查找树执行<strong>一系列的查找操作</strong>，为了使整个查找时间更小，根据每次的搜索关键字对树的结构进行<strong>自调整</strong>，使得<strong>被查频率高</strong>的那些条目就应当经常处于<strong>靠近树根的位置</strong>。</p><p><strong>定义</strong>：<strong>分裂树</strong>(splay tree)，又叫伸展树，<strong>是一种二叉搜索树</strong>，对一个单独的字典操作，其时间复杂度是$O(n)$，而对于$f$个查找、$i$个插入、$d$个删除所组成的操作序列，其时间复杂度是$O((f + i + d) \log i)$，与使用AVL树或RB树的渐近时间复杂度相同，编码更容易。</p><p><strong>定义</strong>：<strong>分裂节点</strong>(slay node)是在字典操作中所检查的最深层的节点。<strong>插入操作</strong>时，可能生成新节点，或覆盖已存在节点。此时新<strong>生成的节点</strong>或<strong>被覆盖节点</strong>即分裂节点；<strong>删除操作</strong>时，被删除节点不在树中，不可能为分裂节点，所以<strong>被删除节点的父节点</strong>成为分裂节点。</p><p><strong>分裂操作</strong>是通过一个<strong>分裂步骤</strong>序列，将<strong>分裂节点</strong>移动到<strong>根节点的位置</strong>上。分裂步骤可将指定节点向上移动一层或两层，移动一层的可分为$L, R 2$种，移动两层的可分为$LL, LR, RR, RL 4$种。记$q$分别为分裂节点、$p, g$分别为$q$的父节点、祖父节点，<strong>当$g$存在时选用移动两层的分裂操作</strong>。分裂操作示意图如下，<strong>注意分裂步骤与AVL树的相似性和区别，子树$\mathcal{T}_g$的$LL/RR$型分裂操作是指自顶向下的，$LR/RL$型分裂操作是自底向上的。</strong></p><p><img src="/.com//slay_options.jpg" alt="slay_options"></p><p>AVL树在插入时遇到$LL$型不平衡时，旋转矫正前后对比图如下</p><p><img src="/.com//avl_insert_ll.jpg" alt="avl_insert_ll"></p><p>以下图所示的二叉搜索树为例，展示<strong>对节点$2$与节点$3$两次查询</strong>后，树的结构变化</p><p><img src="/.com//splay_tree_eg.jpg" alt="splay_tree_eg"></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>由<code>BinarySearchTree&lt;K, V&gt;</code>公有派生，添加分裂操作<code>slay</code>，重写插入<code>insert</code>、删除<code>erase</code>函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SplayTree</span> :</span> <span class="keyword">public</span> BinarySearchTree&lt;K, V&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">SplayTree() : BinarySearchTree&lt;K, V&gt;() &#123;&#125;</span><br><span class="line">~SplayTree()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> K&amp;, <span class="keyword">const</span> V&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">const</span> K&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slay</span><span class="params">(BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;*)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>分裂操作实现时有以下<strong>注意点</strong></p><ul><li>用$3bit$内存对$6$种情况进行编码：最高位为<code>0</code>表示一层的分裂操作，次高位表示$g$与$p$的位置关系，最低位表示$p$与$q$的位置关系；</li><li>若$L/R$型分裂时父节点为根节点，或$LL/LR/RR/RL$分裂时祖父节点为根节点，则需<strong>修改整棵树的根节点</strong>为分裂节点；</li><li>在$LR/RL$操作时，为<strong>自底向上</strong>操作，$p$节点地址为<code>node-&gt;parent</code>，第一次旋转结束后，$q$的父节点已经变为$g$，所以对$g$进行旋转时，该节点地址也为<code>node-&gt;parent</code>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;K, V&gt;::slay(BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;* node)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 分裂操作</span></span><br><span class="line"><span class="keyword">while</span> (node-&gt;parent) &#123;</span><br><span class="line"><span class="keyword">int</span> type = node-&gt;parent-&gt;isRoot() &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (type) &#123;<span class="comment">// 无祖父节点，即父节点为根节点</span></span><br><span class="line">type += node-&gt;isLeft();</span><br><span class="line"><span class="keyword">this</span>-&gt;m_tnRoot = node;<span class="comment">// 修改根节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">// 有祖父节点</span></span><br><span class="line">type += (node-&gt;parent-&gt;isLeft() &lt;&lt; <span class="number">1</span>) + node-&gt;isLeft();</span><br><span class="line"><span class="keyword">if</span> (node-&gt;parent-&gt;parent-&gt;isRoot())</span><br><span class="line"><span class="keyword">this</span>-&gt;m_tnRoot = node;<span class="comment">// 修改根节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (type)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0b0101</span>:<span class="comment">// L</span></span><br><span class="line">SplayTree&lt;K, V&gt;::leftRotate(node-&gt;parent);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0b0100</span>:<span class="comment">// R</span></span><br><span class="line">SplayTree&lt;K, V&gt;::rightRotate(node-&gt;parent);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0b0011</span>:<span class="comment">// LL</span></span><br><span class="line">SplayTree&lt;K, V&gt;::leftRotate(node-&gt;parent-&gt;parent);</span><br><span class="line">SplayTree&lt;K, V&gt;::leftRotate(node-&gt;parent);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0b0010</span>:<span class="comment">// LR</span></span><br><span class="line">SplayTree&lt;K, V&gt;::rightRotate(node-&gt;parent);</span><br><span class="line">SplayTree&lt;K, V&gt;::leftRotate (node-&gt;parent);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0b0000</span>:<span class="comment">// RR</span></span><br><span class="line">SplayTree&lt;K, V&gt;::rightRotate(node-&gt;parent-&gt;parent);</span><br><span class="line">SplayTree&lt;K, V&gt;::rightRotate(node-&gt;parent);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0b0001</span>:<span class="comment">// RL</span></span><br><span class="line">SplayTree&lt;K, V&gt;::leftRotate(node-&gt;parent);</span><br><span class="line">SplayTree&lt;K, V&gt;::rightRotate(node-&gt;parent);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在搜索二叉树的插入、删除基础上，添加分类操作<code>slay()</code>即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;K, V&gt;::insert(<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> V&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;* node = <span class="keyword">this</span>-&gt;find(key, <span class="literal">true</span>);</span><br><span class="line">Pair&lt;K, V&gt;* p = node-&gt;get();</span><br><span class="line"><span class="keyword">if</span> (p-&gt;getKey() != key)</span><br><span class="line">p-&gt;setKey(key);</span><br><span class="line">p-&gt;setVal(value);</span><br><span class="line"></span><br><span class="line">slay(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;K, V&gt;::erase(<span class="keyword">const</span> K&amp; key)</span><br><span class="line">&#123;</span><br><span class="line">BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;* node = <span class="keyword">this</span>-&gt;find(key, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;* slayNode = node-&gt;parent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------ 重新组织二叉树 ------------------</span></span><br><span class="line"><span class="comment">// 查找左子树的最大值，或右子树的最小值</span></span><br><span class="line">BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;* replace = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">while</span> (!node-&gt;isLeaf()) &#123;<span class="comment">// 直到搜索到叶节点为止</span></span><br><span class="line"><span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">replace = <span class="keyword">this</span>-&gt;max(node-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">replace = <span class="keyword">this</span>-&gt;min(node-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (replace) &#123;<span class="comment">// 找到可替换子节点</span></span><br><span class="line">Pair&lt;K, V&gt;* np = node-&gt;get();</span><br><span class="line">Pair&lt;K, V&gt;* rp = replace-&gt;get();</span><br><span class="line">np-&gt;setKey(rp-&gt;getKey());</span><br><span class="line">np-&gt;setVal(rp-&gt;getVal());</span><br><span class="line">node = replace;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (node-&gt;parent) &#123;<span class="comment">// 修改父节点信息</span></span><br><span class="line"><span class="keyword">if</span> (node == node-&gt;parent-&gt;left)</span><br><span class="line">node-&gt;parent-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">node-&gt;parent-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">// 无父节点，即整棵树只有一个根节点，则修改根节点为空</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_tnRoot = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------ 释放资源 ------------------</span></span><br><span class="line">Pair&lt;K, V&gt;* pair = node-&gt;get();</span><br><span class="line"><span class="keyword">delete</span> pair; <span class="keyword">delete</span> node;</span><br><span class="line"></span><br><span class="line">slay(slayNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> names[<span class="number">6</span>] = &#123;</span><br><span class="line"><span class="string">"甲"</span>, <span class="string">"乙"</span>, <span class="string">"丙"</span>, <span class="string">"丁"</span>, <span class="string">"戊"</span>, <span class="string">"己"</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> numbers[<span class="number">6</span>] = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line">SplayTree&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入键值对</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"插入"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">tree.insert(numbers[i], names[i]);</span><br><span class="line">&#125;</span><br><span class="line">tree.print();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询2</span></span><br><span class="line">tree.insert(<span class="number">6</span>, <span class="string">"乙"</span>);</span><br><span class="line">tree.print();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询3</span></span><br><span class="line">tree.insert(<span class="number">3</span>, <span class="string">"丙"</span>);</span><br><span class="line">tree.print();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除2</span></span><br><span class="line">tree.erase(<span class="number">2</span>);</span><br><span class="line">tree.print();</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下均为<strong>层级遍历</strong>输出，可以看到对指定关键字进行字典操作后，分裂节点将被调整至根节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">插入</span><br><span class="line">[6]己 [5]戊 [4]丙 [1]丁 [2]甲 [3]乙</span><br><span class="line">[6]乙 [5]戊 [4]丙 [1]丁 [2]甲 [3]乙</span><br><span class="line">[3]丙 [2]甲 [6]乙 [1]丁 [4]丙 [5]戊</span><br><span class="line">[3]丙 [1]丁 [6]乙 [4]丙 [5]戊</span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure><h1 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h1><p>当字典足够小时，AVL树和RB树都能保证良好的时间性能。而对于存储在磁盘上的大型字典(外部字典或文件)，则<strong>需要度数更高的搜索树</strong>来改善字典操作性能。</p><h2 id="定义与概念-1"><a href="#定义与概念-1" class="headerlink" title="定义与概念"></a>定义与概念</h2><h3 id="索引顺序访问方法-ISAM"><a href="#索引顺序访问方法-ISAM" class="headerlink" title="索引顺序访问方法(ISAM)"></a>索引顺序访问方法(ISAM)</h3><p><strong>索引顺序访问方法</strong>(indexed sequential access method, ISAM)本质上是一种数组描述方法。在该方法中，可用的磁盘空间被划分为很多块，<strong>字典元素以升序存储在块中</strong>。</p><p>在<strong>顺序访问</strong>时，块按序输入，每一个块中元素按升序搜索；若要支持<strong>随机访问</strong>，就要维持一个索引，索引包括每个块的最大关键字，且组成的<strong>块索引表</strong>足以驻留在内存中，在访问关键字为$k$的元素时，先查找索引表确定<strong>块索引</strong>，然后把相应的块从磁盘中读取进行内部搜索，这样仅需一次磁盘访问即可完成。</p><p>若同时存在多个磁盘，每个磁盘存在一个<strong>磁盘索引</strong>，保存该磁盘中的最大关键字，全部磁盘索引组成<strong>磁盘索引表</strong>。在查找元素时，按<strong>磁盘索引、块索引、内部搜索的顺序进行元素查找</strong>，此时需要两次磁盘访问(读取磁盘索引、磁盘中读取块)。</p><blockquote><ul><li><strong>磁盘的块</strong>是磁盘空间中用来<strong>输入或输出的最小单位</strong>，一般具有和此道一样的长度，且<strong>可以在一次搜索和延迟中完成输入或输出</strong>，按照一种顺序来组织，使得从一块到另一块的延时最短；</li><li>为减少块与块之间的元素拷贝，可在每块中预留一些空间供少量元素的插入，删除时可将闲置空间保留，不必进行元素移动操作。</li></ul></blockquote><p>对于存储在磁盘上的数据，B-树是一种适合于索引方法的数据结构。</p><h3 id="m-叉搜索树"><a href="#m-叉搜索树" class="headerlink" title="$m$叉搜索树"></a>$m$叉搜索树</h3><p><strong>定义</strong>：<strong>$m$叉搜索树</strong>(m-way search tree)可以是一棵空树，如果非空，需满足以下特征：</p><ol><li>进行扩充(外部节点替换空指针)后的搜索树，每个<strong>内部节点</strong>最多包含$m$个孩子、$1 \sim m-1$个元素；</li><li>包含$p$个元素($k_1, \cdots, k_p$)的节点有$p + 1$个孩子($c_0, c_1, \cdots, c_p$)；</li><li>对于包含$p$个元素的节点，<strong>元素关键字</strong>满足$k_i &lt; k_{i + 1}, 1 \leq i \leq p - 1$；</li><li>对于包含$p$个元素的节点，<strong>子树的元素关键字</strong>满足：<ul><li>子树$\mathcal{T}_{c_0}$的元素关键字都小于$k_1$；</li><li>子树$\mathcal{T}_{c_p}$的元素关键字都大于$k_p$；</li><li>$\mathcal{T}_{c_i}(0 &lt; i &lt; p)$中的元素关键字大于$k_i$而小于$k_{i+1}$。</li></ul></li></ol><p>下图为省略外部节点的$7$叉搜索树</p><p><img src="/.com//m_way_search_tree_eg.jpg" alt="m_way_search_tree_eg"></p><p>一棵高度为$h$的$m$叉搜索树(不包含外部节点)，最少有$h$个元素，最多有$m^h-1$个元素。</p><blockquote><ul><li>当每层仅有$1$个节点，且每个节点只有$1$个元素时，这棵树元素个数最少；</li><li>第$i(i=1, …, h)$层最多有$m^{h-1}$个节点，而每个节点最多有$m-1$个元素，则总的元素个数为$(m - 1) \times \sum_{i=1}^h m^{j-1} = m^h - 1$。</li></ul></blockquote><p>对$m$叉搜索树进行<strong>查找</strong>时，类似二叉搜索树。从根节点开始搜索关键字$k$，若根节点中不存在查找关键字，则根据特征4，在对应的子节点中进行搜索，直至找到对应关键字或空节点(外部节点)为止。</p><blockquote><p>例如在上图中查找关键字为$33$的数值对时，从根节点出发，在根结点中不存在$33$，在其$10-18$间的子节点内搜索，而该子节点中也不存在$33$，在$30-40$间的子节点内搜索，还是不存在，于是在$32-36$的子节点中查找，但此时为外部节点，故整棵树中$33$不存在，退出算法。</p></blockquote><p><strong>插入操作</strong>时，首先查找指定的关键字$k$，<strong>若$k$存在</strong>，则将值修改后退出算法；<strong>若$k$不存在</strong>，并且<strong>搜索路径上存在元素个数少于$m$、满足特征4的节点</strong>，将其插入，如果找不到这样的节点，则在最后一个节点内，根据元素大小，选择合适的节点位置<strong>创建新节点</strong>，然后将数值对插入。</p><blockquote><p>例如，插入键为$33$的数值对时，用查找算法搜索确定不存在相同键的元素，每个节点可容纳$6$个元素，此时节点$[10, 18]$元素未满，但$33$比子节点$[20, 30, 40, 50, 60, 70]$中元素小，故不满足特征$4$，子节点$[20, 30, 40, 50, 60, 70]$元素已满，第$3$层$[32, 36]$符合要求，故将数值对插入该节点，成为第$2$个元素，即$[32, 33, 36]$。</p></blockquote><p><strong>删除</strong>某个元素时，若该元素相邻子节点空，可直接删除，否则将该元素与<strong>相邻</strong>的<strong>左子节点中的键最大元素</strong>，或<strong>右子节点中最键小元素</strong>替换，再将元素删除。</p><h3 id="m-阶B-树"><a href="#m-阶B-树" class="headerlink" title="$m$阶B-树"></a>$m$阶B-树</h3><p><strong>定义</strong>：$m$阶B-树(B-Tree of order $m$)是一棵$m$叉搜索树，如果B-树非空，那么相应的<strong>扩充树满足</strong>以下特征：</p><ol><li>根节点至少有$2$个孩子，$1$个元素；</li><li>除根节点外，内部节点至少有$d = \lceil m/2 \rceil$个孩子，$d-1$个元素；</li><li>外部节点在同一层。</li></ol><ul><li>$2$阶B-树，内部节点(包括根节点)都恰好有$2$个孩子，且外部节点在同一层，所以$2$阶B-树是满二叉树；</li><li>$3$阶B-树，内部节点(除根节点)有$2 \sim 3$个孩子，也称$2-3$树；</li><li>$4$阶B-树，内部节点(除根节点)有$2 \sim 4$个孩子，也称$2-3-4$树；</li></ul><blockquote><p>疑问：$2$阶B-树特征2：$\lceil m/2 \rceil = 1$，为什么内部节点至少有$2$个孩子？</p></blockquote><p>下图为一棵$2-3$树，当插入$14,16$到$[10]$节点后，该树又变成了$2-3-4$树</p><p><img src="/.com//3_order.jpg" alt="3_order"></p><p><strong>定理</strong>：设$\mathcal{T}$是一棵高度为$h$的$m$阶B-树。令$d = \lceil m/2 \rceil$，$n$是$\mathcal{T}$的元素个数，那么</p><ol><li>$2d^{h-1} - 1 \leq n \leq m^h - 1$</li><li>$\log_m (n + 1) \leq h \leq \log_d(\frac{n + 1}{2}) + 1$</li></ol><blockquote><ol><li>第$1, 2$层的节点最少个数为$1, 2$，第$3, 4, \cdots, h$层的节点的父节点至少有$d$个孩子，那么这些层的节点最少个数为$2d, 2d^2, \cdots, 2d^{h-2}$，每个节点有$d-1$个元素，故下限为$(1 + 2 + 2d + 2d^2 + \cdots + 2d^{h-2}) \times (d - 1) = 2d^{h-1} - 1$；上限由$m$叉搜索树决定；</li><li>由1可推得2。</li></ol></blockquote><p><strong>B-树的搜索与$m$叉搜索树算法相同</strong>，<strong>插入操作</strong>有所区别，首先搜索相同关键字的元素，若不存在，可将元素插入在搜索路径中<strong>最后一个内部节点</strong>中，但<strong>如果该节点已饱和，对节点进行元素插入时需要分裂该节点</strong>。</p><p>现将<strong>带有空指针</strong>的新元素$e$插入饱和节点$P$，得到具有$m$个元素和$m+1$个孩子的<strong>溢出节点</strong>，$(e_i, c_i)$表示元素与该元素的右子节点，那么溢出节点可用序列表示如下</p><script type="math/tex; mode=display">m, (c_0), (e_1, c_1), \cdots, (e_m, c_m)</script><p><strong>使该节点在元素$e_d, d = \lceil m/2 \rceil$处分裂，将右边的节点保存在新节点$Q$中，再将$(e_d, Q)$插入$P$的父节点，使$e_d$成为$P$父节点的元素，$Q$成为$P$的兄弟节点</strong>，完成分裂，此时两节点序列为</p><script type="math/tex; mode=display">\begin{aligned}    P: d-1, (c_0), (e_1, c_1), \cdots, (e_{d-1}, c_{d-1}) \\    Q: m-d, (c_d), (e_{d+1}, c_{d+1}), \cdots, (e_m, c_m)\end{aligned}</script><p><strong>若$e_d$插入父节点导致父节点满，则需要对父节点进行分裂操作，以此类推直到至根节点路径上没有饱和节点</strong>。</p><p>当插入操作引起$s$个节点分裂时，磁盘访问的次数为$h + 2s + 1$(读取搜索路径上的节点 + 回写分裂出的两个新节点 + 回写新的根节点火插入后没有导致分裂的节点)，最多可达到$3h + 1$。</p><blockquote><p>以下图$7$阶B-树为例，插入$3$时，在最后一个内部节点节点$[2, 4, 6]$处搜索失败，且该节点未饱和，将其插入该节点得到$[2, 3, 4, 6]$<br><img src="/.com//insert_3.jpg" alt="insert_3"></p><hr><p>而插入元素$25$时，节点$[20, 30, 40, 50, 60, 70]$是最后一个内部节点，但已饱和，需要进行分裂操作。将新元素插入后溢出节点序列为</p><script type="math/tex; mode=display">7, (0), (20, 0), (25, 0), (30, 0), (40, 0), (50, 0), (60, 0), (70, 0)</script><p>此时$d = 4$，在元素$40$处进行分裂，得到两个新节点序列</p><script type="math/tex; mode=display">\begin{aligned}    P: 3, (0), (20, 0), (25, 0), (30, 0) \\    Q: 3, (0), (50, 0), (60, 0), (70, 0)\end{aligned}</script><p>将$(40, Q)$插入父节点，此时父节点为($L, R$表示$10$左边的节点，$R$表示$80$右边的节点)</p><script type="math/tex; mode=display">3, (L), (10, P), (40, Q), (80, R)</script><p>如下图<br><img src="/.com//insert_25.jpg" alt="insert_25"></p></blockquote><p><strong>删除操作</strong>可分为两种情况：</p><ol><li>该元素位于<strong>非叶子节点</strong><br> 用被删除元素的<strong>左相邻子树的最大元素</strong>，或<strong>右相邻子树的最小元素</strong>替换被删除元素，<strong>替换元素必在叶节点</strong>，此时转化为第2种情况；</li><li>该元素位于<strong>叶子节点</strong><ol><li>被删除元素所在叶节点的元素个数大于最少数(性质1)，那么<strong>直接删除</strong>；</li><li>被删除元素在非根节点且该节点元素个数最少，可用其<strong>最近邻的左兄弟节点中最大元素</strong>或<strong>最近邻的右兄弟中的最小元素</strong>替换；</li><li>最近邻兄弟节点不包含额外元素时，<strong>将删除元素的节点($d-2$个元素)、最近邻兄弟节点($d-1$个元素)、父节点中介于两兄弟间的元素</strong>合并成一个节点($2d-2$个元素)；</li><li>若合并导致父节点元素个数低于最小元素个数，<strong>对该父节点重复上述操作</strong>，直至根节点(最坏情况下)。</li></ol></li></ol><blockquote><p>以$7$阶B-树为例，删除元素$90$<br><img src="/.com//delete_90.jpg" alt="delete_90"><br>首先，寻找可以替换的叶子节点中的元素，可选择左近邻节点中的$86$，或右近邻中的$92$。</p><ul><li>当选择$86$作为替换元素时，节点$2, (0), (82, 0), (84, 0)$缺少一个元素，此时可从该节点的最近邻左兄弟节点取择元素$70$加入<br><img src="/.com//delete_90_86.jpg" alt="delete_90_86"></li><li>当选择$96$作为替换元素时，节点$2, (0), (92, 0), (94, 0)$缺少一个元素，且$3, (0), (82, 0), (84, 0), (84, 0)$不包含多余元素，那么将这两个节点与父节点中的$92$合并为$6, (0), (82, 0), (84, 0), (84, 0), (86, 0), (92, 0), (94, 0), (96, 0)$<br><img src="/.com//delete_90_96.jpg" alt="delete_90_96"><br>以上两种方式都不会使根节点少于$2$个孩子。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】平衡搜索树——AVL树与RB树</title>
      <link href="/2020/03/14/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91%E2%80%94%E2%80%94AVL%E6%A0%91%E4%B8%8ERB%E6%A0%91/"/>
      <url>/2020/03/14/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91%E2%80%94%E2%80%94AVL%E6%A0%91%E4%B8%8ERB%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>定义</strong>：最坏情况下高度为$O(\log n)$的树称为<strong>平衡树</strong>(balanced tree)。如果搜索树的高度总是$O(\log n)$，就能保证查找、插入和删除的时间为$O(\log n)$。</p><p>在实际应用中，当操作是以关键字进行查找、插入和删除时，散列技术在性能方面超过了平衡搜索树。但以下情况提倡使用平衡搜索树</p><ol><li><strong>按照关键字</strong>实施字典操作，而且<strong>操作时间</strong>不能超过指定的范围；<br>2.<strong> 按名次</strong>实施查找和删除；</li><li><strong>不按精确的关键字匹配</strong>进行的字典操作(如寻找关键字大于$k$的最小元素)。</li></ol><p>本节包含两种平衡二叉树结构——AVL和红-黑树(适合内部存储的应用)，下一节介绍B-树(度数更大，高度更小，适合外部存储的应用，如磁盘上的大型词典)。<strong>这些平衡树结构能在最坏情况下用时$O(\log n)$实现字典操作和按名次操作。</strong></p><h1 id="搜索二叉树的旋转"><a href="#搜索二叉树的旋转" class="headerlink" title="搜索二叉树的旋转"></a>搜索二叉树的旋转</h1><p>记对子树$\mathcal{T_N}$进行的左旋操作为$lr(\mathcal{N})$，右旋操作为$rr(\mathcal{N})$</p><ul><li>搜索二叉树进行左旋或右旋后，该树根节点发生变化，仍满足搜索二叉树结构，可用于平衡搜索树的不平衡矫正；</li><li><strong>单旋转</strong>(single rorating)是对子树的根节点进行一次旋转；</li><li><strong>双旋转</strong>(double rotating)是对根节点进行旋转前，先对其中一棵子树进行旋转。</li></ul><p>下图为对以$\mathcal{A}$为根节点的树$\mathcal{T_A}$进行<strong>左旋、右旋</strong>的示意图，</p><p><img src="/2020/03/14/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91%E2%80%94%E2%80%94AVL%E6%A0%91%E4%B8%8ERB%E6%A0%91/【数据结构】平衡搜索树——AVL树与RB树/rotating.jpg" alt="rotating"></p><blockquote><p>巧记：以旋转的树的根节点$\mathcal{N}$与$\mathcal{N_L}, \mathcal{N_R}$作圆，<strong>右旋时，该圆下方向右</strong>。</p></blockquote><p><code>BinarySearchTree&lt;K, V&gt;</code>添加静态成员函数如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> :</span> </span><br><span class="line"><span class="keyword">public</span> LinkedBinaryTree&lt;Pair&lt;K, V&gt;*&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">(BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">(BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;*)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">void</span> BinarySearchTree&lt;K, V&gt;::leftRotate(BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;* A)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 修改根节点</span></span><br><span class="line"><span class="keyword">if</span> (A-&gt;parent) &#123;</span><br><span class="line"><span class="keyword">if</span> (A == A-&gt;parent-&gt;left)</span><br><span class="line">A-&gt;parent-&gt;left = A-&gt;left;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">A-&gt;parent-&gt;right = A-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line">A-&gt;left-&gt;parent = A-&gt;parent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改A为Al右孩</span></span><br><span class="line">BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;* Alr = A-&gt;left-&gt;right;</span><br><span class="line">A-&gt;parent = A-&gt;left;</span><br><span class="line">A-&gt;parent-&gt;right = A;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改Alr为A左孩</span></span><br><span class="line">A-&gt;left = Alr;</span><br><span class="line"><span class="keyword">if</span> (Alr) Alr-&gt;parent = A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">void</span> BinarySearchTree&lt;K, V&gt;::rightRotate(BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;* A)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 修改根节点</span></span><br><span class="line"><span class="keyword">if</span> (A-&gt;parent) &#123;</span><br><span class="line"><span class="keyword">if</span> (A == A-&gt;parent-&gt;left)</span><br><span class="line">A-&gt;parent-&gt;left = A-&gt;right;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">A-&gt;parent-&gt;right = A-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">A-&gt;right-&gt;parent = A-&gt;parent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改A为Ar左孩</span></span><br><span class="line">BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;* Arl = A-&gt;right-&gt;left;</span><br><span class="line">A-&gt;parent = A-&gt;right;</span><br><span class="line">A-&gt;parent-&gt;left = A;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改Arl为A右孩</span></span><br><span class="line">A-&gt;right = Arl;</span><br><span class="line"><span class="keyword">if</span> (Arl) Arl-&gt;parent = A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h1><p>AVL树是<strong>通过限制左右子节点高度差</strong>进行整棵树的高度限制。</p><h2 id="定义及概念"><a href="#定义及概念" class="headerlink" title="定义及概念"></a>定义及概念</h2><p><strong>定义</strong>：<strong>AVL树</strong>由Adelson-Velskii和Landis在1962年提出。<strong>一棵空的二叉树是AVL树</strong>；若$\mathcal{T}$是一棵非空二叉树，$\mathcal{T_L}$和$\mathcal{T_R}$是其左子树和右子树，那么<strong>满足以下条件</strong>时，$\mathcal{T}$是一棵AVL树：</p><ol><li>$\mathcal{T_L}$和$\mathcal{T_R}$是AVL树；</li><li>$|h_{\mathcal{L}} - h_{\mathcal{R}}| \leq 1$，其中$|h_{<em>}|$是子树$\mathcal{T_</em>}$的高。</li></ol><p>既是二叉搜索树，也是AVL树的树称为<strong>AVL搜索树</strong>；既是索引二叉搜索树，也是AVL树的树称为<strong>索引AVL搜索树</strong>。下图为一棵AVL搜索树</p><p><img src="/2020/03/14/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91%E2%80%94%E2%80%94AVL%E6%A0%91%E4%B8%8ERB%E6%A0%91/【数据结构】平衡搜索树——AVL树与RB树/avl_tree_eg.jpg" alt="avl_tree_eg"></p><p>AVL树具有以下<strong>特征</strong></p><ol><li>一棵$n$个元素的AVL树，其<strong>高度</strong>是$O(\log n)$，最坏情况下，AVL树的高度是搜索树中最小的；</li><li>对于每一个$n$，$n \geq 0$，都<strong>存在</strong>一棵AVL树；</li><li>对一棵$n$个元素的AVL搜索树，在$O(height) = O(\log n)$的时间内可以实现<strong>查找</strong>；</li><li>将一个元素<strong>插入</strong>一棵$n$个元素的AVL搜索树，可以得到$n+1$个元素的AVL树，且插入用时为$O(\log n)$；</li><li>将一个元素从一棵$n$个元素的AVL搜索树中<strong>删除</strong>，可以得到$n-1$个元素的AVL树，且删除用时为$O(\log n)$。</li></ol><blockquote><p><strong>关于AVL树的高度</strong>，对一棵高度为$h$的AVL树，令$N_h$是其最少的结点数。在最坏情况下，根的一棵子树高度为$h-1$，另一棵子树高度为$h-2$，那么</p><script type="math/tex; mode=display">N_h = N_{h-1} + N_{h-2} + 1, N_0 = 0 且 N_1 = 1</script><p>注意由斐波那契数列定义</p><script type="math/tex; mode=display">F_n = F_{n-1} + F_{n-2}, F_0 = 0且F_1 = 1</script><p>可证得</p><script type="math/tex; mode=display">N_h = F_{h+2} - 1 , h \geq 0</script><p>由斐波那契定理</p><script type="math/tex; mode=display">F_h \approx \Phi^h / \sqrt{5}, 其中\Phi = (1 + \sqrt{5}) / 2</script><p>那么</p><script type="math/tex; mode=display">\begin{aligned}    N_h \approx \Phi^{h+2} / \sqrt{5} - 1 \\    \Rightarrow h = \log_{\Phi} \left[ \sqrt{5}(N_h + 1) \right] - 2 \\    \approx 1.44 \log_2(n + 2) = O(\log n)\end{aligned}</script></blockquote><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>AVL树的节点$\mathcal{N}$增加<strong>平衡因子</strong></p><script type="math/tex; mode=display">bf(\mathcal{N}) = h(\mathcal{T_L}) - h(\mathcal{T_L})</script><p>其中$h(\mathcal{<em>})$为树$\mathcal{T_{</em>}}$的高度，由平衡搜索定义可知，<strong>平衡因子取值范围</strong>为${ 0, \pm 1, \pm 2 }$，$bf = \pm2$时表示以该节点为根节点的子树不平衡。</p><p><img src="/2020/03/14/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91%E2%80%94%E2%80%94AVL%E6%A0%91%E4%B8%8ERB%E6%A0%91/【数据结构】平衡搜索树——AVL树与RB树/balanced_factor.jpg" alt="balanced_factor"></p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>AVL搜索树的搜索，沿用二叉搜索树的搜索方式即可，搜索时间与高度成正比，为$O(\log n)$。</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>记</p><ul><li>$\mathcal{X}$为<strong>寻找插入节点位置路径上最后一个具有平衡因子$\pm 1$的节点</strong></li><li>$\mathcal{A}$为距新插入节点$\mathcal{N}$<strong>最近的、平衡因子为$\pm 2$的祖先节点</strong></li></ul><p>以下图为例，插入关键字为$36$的新节点$\mathcal{N}$，导致右子树失去AVL树的平衡结构<br><img src="/2020/03/14/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91%E2%80%94%E2%80%94AVL%E6%A0%91%E4%B8%8ERB%E6%A0%91/【数据结构】平衡搜索树——AVL树与RB树/insert1.jpg" alt="insert1"></p><h4 id="插入时有以下特性"><a href="#插入时有以下特性" class="headerlink" title="插入时有以下特性"></a>插入时有以下特性</h4><ol><li>只有从根节点到新插入节点的<strong>路径上的节点</strong>，其平衡因子在插入后会改变；</li><li>插入操作只会使平衡因子<strong>增减$0$或$1$</strong>，平衡因子为$\pm 2$的节点在插入前，平衡因子为$\pm 1$，插入操作后$bf(\mathcal{X})$从$\pm 1$变为$\pm 2$是<strong>导致AVL失去平衡的唯一过程</strong>；</li><li>从$\mathcal{A}$到$\mathcal{N}$的路径上，<strong>在插入操作前</strong>，所有节点的平衡因子都是$0$。</li></ol><h4 id="节点-mathcal-A-的不平衡情况"><a href="#节点-mathcal-A-的不平衡情况" class="headerlink" title="节点$\mathcal{A}$的不平衡情况"></a>节点$\mathcal{A}$的不平衡情况</h4><ul><li>可分为$L$型不平衡($\mathcal{N}$在$\mathcal{A}$左子树中)与$R$型不平衡($\mathcal{N}$在$\mathcal{A}$右子树中)两类；</li><li>根据$\mathcal{A}$的<strong>孙节点</strong>情况，又可分为$LL$(孙节点在$\mathcal{A}$左子树的左子树中), $LR$(孙节点在$\mathcal{A}$左子树的右子树中)，$RL$，$RR$不平衡。</li></ul><p><img src="/2020/03/14/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91%E2%80%94%E2%80%94AVL%E6%A0%91%E4%B8%8ERB%E6%A0%91/【数据结构】平衡搜索树——AVL树与RB树/insert2.jpg" alt="insert2"></p><h4 id="不平衡的矫正"><a href="#不平衡的矫正" class="headerlink" title="不平衡的矫正"></a>不平衡的矫正</h4><ul><li><strong>LL型不平衡的矫正</strong>，只需将$\mathcal{T_A}$进行左旋；<strong>RR型同理</strong>；</li><li><strong>LR型不平衡的矫正</strong>，，对$LR$型不平衡所作的<strong>双旋转</strong>可视作$\mathcal{T_{A_L}}$的右旋，再进行$\mathcal{T_A}$的左旋，<strong>RL型同理</strong>；</li><li>由于插入前子树的高度与插入并矫正后的子树高度相同，故在一次旋转后，整棵树是平和的，<strong>不需要继续向根节点搜索不平衡节点</strong>；</li></ul><div class="table-container"><table><thead><tr><th>不平衡类型</th><th>LL</th><th>LR</th><th>RR</th><th>RL</th></tr></thead><tbody><tr><td>矫正</td><td>$lr(\mathcal{T_{A}})$</td><td>$rr(\mathcal{T_{A_L}}) + lr(\mathcal{T_{A}})$</td><td>$rr(\mathcal{T_{A}})$</td><td>$lr(\mathcal{T_{A_R}}) + rr(\mathcal{T_{A}})$</td></tr></tbody></table></div><p><img src="/2020/03/14/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91%E2%80%94%E2%80%94AVL%E6%A0%91%E4%B8%8ERB%E6%A0%91/【数据结构】平衡搜索树——AVL树与RB树/insert3.jpg" alt="insert3"><br><img src="/2020/03/14/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91%E2%80%94%E2%80%94AVL%E6%A0%91%E4%B8%8ERB%E6%A0%91/【数据结构】平衡搜索树——AVL树与RB树/insert4.jpg" alt="insert4"></p><h4 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h4><ol><li>给定元素的关键字$\mathcal{K}$，从根结点出发查找，若<strong>找到具有相同关键字的节点</strong>$\mathcal{N}$，则返回该节点，否则进入2；</li><li>从根结点出发查找插入位置，并在该位置创建新节点$\mathcal{N}$，更新$\mathcal{N}$至根节点的路径上的节点的<strong>平衡因子</strong>，若不存在$bf=\pm 2$的节点，返回$\mathcal{N}$退出算法，否则进入3；</li><li>记距离$\mathcal{N}$最近的、且$bf = \pm 2$的祖先节点为$\mathcal{A}$，确定$\mathcal{A}$的<strong>不平衡类型</strong>，并执行相应旋转；</li><li>更新$\mathcal{N}$相关节点的平衡因子，返回$\mathcal{N}$退出算法。</li></ol><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>记</p><ul><li>删除节点$\mathcal{N}$的父节点为$\mathcal{P}$；</li><li>从$\mathcal{P}$至根节点的路径上第一个平衡因子变为$\pm 2$的节点记作$\mathcal{A}$。</li></ul><p>如下图，删除关键字为$25$的结点后，该树不满足平衡搜索树条件<br><img src="/2020/03/14/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91%E2%80%94%E2%80%94AVL%E6%A0%91%E4%B8%8ERB%E6%A0%91/【数据结构】平衡搜索树——AVL树与RB树/delete1.jpg" alt="delete1"></p><h4 id="删除时有以下特性"><a href="#删除时有以下特性" class="headerlink" title="删除时有以下特性"></a>删除时有以下特性</h4><ul><li>节点$\mathcal{N}$删除后，从根节点到$\mathcal{P}$路径上的<strong>一些节点或全部节点的平衡因子都改变</strong>了，故要从$\mathcal{P}$原路返回；</li><li>如删除发生在$\mathcal{P_L}$(左子节点)，那么$bf(\mathcal{P})$减$1$，发生在$\mathcal{P_R}$(右子节点)时，$bf(\mathcal{P})$加$1$；</li><li>$bf(\mathcal{P})$更新后记作$bf_*(\mathcal{P})$，则有<script type="math/tex; mode=display">  \begin{cases}      bf_*(\mathcal{P}) = 0 && \mathcal{T_P}高度减少1，需改变它的祖先节点的平衡因子 \\      bf_*(\mathcal{P}) = \pm 1 && \mathcal{T_P}高度不变，无需改变它的祖先节点的平衡因子 \\      bf_*(\mathcal{P}) = \pm 2 && \mathcal{P}不平衡  \end{cases}</script></li></ul><h4 id="节点-mathcal-A-的不平衡情况-1"><a href="#节点-mathcal-A-的不平衡情况-1" class="headerlink" title="节点$\mathcal{A}$的不平衡情况"></a>节点$\mathcal{A}$的不平衡情况</h4><ul><li>可分为$L$型不平衡($\mathcal{N}$在$\mathcal{A}$左子树中，$bf(\mathcal{P}) = -2$)与$R$型不平衡($\mathcal{N}$在$\mathcal{A}$右子树中，$bf(\mathcal{P}) = 2$)<strong>两类</strong>；</li><li>若发生$R$型不平衡，考察$\mathcal{P}$的左子节点$\mathcal{P_L}$，根据$bf(\mathcal{P_L})$又<strong>可分为$R0, R1, R-1$型不平衡</strong>；$L$型同理；</li></ul><p><img src="/2020/03/14/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91%E2%80%94%E2%80%94AVL%E6%A0%91%E4%B8%8ERB%E6%A0%91/【数据结构】平衡搜索树——AVL树与RB树/delete2.jpg" alt="delete2"></p><h4 id="不平衡的矫正-1"><a href="#不平衡的矫正-1" class="headerlink" title="不平衡的矫正"></a>不平衡的矫正</h4><ul><li><strong>R0型不平衡的矫正</strong>，将$\mathcal{T_A}$左旋，注意平衡后$bf(\mathcal{A_L})=-1$，子树高度仍为$h+2$未改变，故<strong>无需改变根节点途径上的平衡因子</strong>；</li><li><strong>R1型不平衡的矫正</strong>，同$R0$型不平衡矫正，将$\mathcal{T_A}$进行左旋，区别是平衡后$bf(\mathcal{A_L})=0$，子树高度减少为$h+1$，<strong>某些祖先平衡因子改变，可能需要进行旋转保持平衡</strong>；</li><li><strong>R-1型不平衡的矫正</strong>，先将$\mathcal{T_{A_L}}$右旋，再将$\mathcal{T_A}$左旋，调整后该树高度为$h+1$，<strong>某些祖先平衡因子改变，可能需要进行旋转保持平衡</strong>；</li><li><strong>L1型不平衡与L-1型不平衡矫正分别与R-1型不平衡、R1型不平衡对应</strong>，即<strong>L1为双旋转</strong>。</li></ul><div class="table-container"><table><thead><tr><th>不平衡类型</th><th>R-1</th><th>R0</th><th>R1</th><th>L-1</th><th>L0</th><th>L1</th></tr></thead><tbody><tr><td>矫正</td><td>$rr(\mathcal{T_{A_L}}) + lr(\mathcal{T_{A}})$</td><td>$lr(\mathcal{T_{A}})$</td><td>$lr(\mathcal{T_{A}})$</td><td>$rr(\mathcal{T_{A}})$</td><td>$rr(\mathcal{T_{A}})$</td><td>$lr(\mathcal{T_{A_R}}) + rr(\mathcal{T_{A}})$</td></tr></tbody></table></div><p><img src="/2020/03/14/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91%E2%80%94%E2%80%94AVL%E6%A0%91%E4%B8%8ERB%E6%A0%91/【数据结构】平衡搜索树——AVL树与RB树/delete3.jpg" alt="delete3"></p><h4 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h4><ol><li>给定元素的关键字$\mathcal{K}$，从根结点出发查找，若<strong>未找到具有相同关键字的节点</strong>$\mathcal{N}$，退出算法，否则进入2；</li><li>从根结点出发查找删除节点$\mathcal{N}$，其父节点为$\mathcal{P}$，记距离$\mathcal{P}$最近的、且$bf = \pm 2$的祖先节点为$\mathcal{A}$，确定$\mathcal{A}$的<strong>不平衡类型</strong>，并执行相应旋转；</li><li>根据$bf(\mathcal{P})$判断是否需要<strong>向根节点进行平衡树结构调整</strong>，不需要或调整后，退出算法。</li></ol><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>由<code>BinarySearchTree&lt;K, V&gt;</code>派生为<code>AVLTree&lt;K, V&gt;</code>，重载<code>insert</code>与<code>erase</code>函数，<code>find</code>无需重载，相应添加部分功能性函数.声明如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVLTree</span> :</span></span><br><span class="line"><span class="keyword">public</span> BinarySearchTree&lt;K, V&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">AVLTree() : BinarySearchTree&lt;K, V&gt;() &#123;&#125;</span><br><span class="line">~AVLTree() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> K&amp;, <span class="keyword">const</span> V&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">const</span> K&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">balancedFactor</span><span class="params">(BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;*)</span></span>;</span><br><span class="line"><span class="keyword">static</span> BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;* findImbalancedAncestor(</span><br><span class="line">BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;*, LinkedStack&lt;<span class="keyword">bool</span>&gt;**);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ol><li><p>节点平衡因子<br> 为减少代码改动，节点的平衡因子通过调用函数的方式,动态求解</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">int</span> AVLTree&lt;K, V&gt;::balancedFactor(BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;* node)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> AVLTree&lt;K, V&gt;::heightofNode(node-&gt;left) - \</span><br><span class="line">        AVLTree&lt;K, V&gt;::heightofNode(node-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 由节点$\mathcal{N}$向上搜索最近的不平衡因子，并<strong>将路径保存在栈内</strong></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line">BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;* AVLTree&lt;K, V&gt;::\</span><br><span class="line">    findImbalancedAncestor(BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;* node, </span><br><span class="line">                            LinkedStack&lt;<span class="keyword">bool</span>&gt;** routine)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 向上查找节点A，并记录路径</span></span><br><span class="line">    BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;* A = node;</span><br><span class="line">    <span class="keyword">int</span> bf = balancedFactor(A);</span><br><span class="line">    <span class="keyword">while</span> (bf &gt; <span class="number">-2</span> &amp;&amp; bf &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!A-&gt;parent) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (routine) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A == A-&gt;parent-&gt;left)</span><br><span class="line">                (*routine)-&gt;push(<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                (*routine)-&gt;push(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        A = A-&gt;parent;</span><br><span class="line">        bf = balancedFactor(A);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>插入</p><p> 插入时，首先调用<code>find</code>进行位置查找，若不存在该节点则创建；由新建节点向根节点查找最近的不平衡祖先并记录路径；根据路径判断不平衡类型做相应旋转</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;K, V&gt;::insert(<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> V&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 查找插入位置</span></span><br><span class="line">    BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;* node = <span class="keyword">this</span>-&gt;find(key, <span class="literal">true</span>);</span><br><span class="line">    Pair&lt;K, V&gt;* p = node-&gt;get();</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;getKey() != key)</span><br><span class="line">        p-&gt;setKey(key);</span><br><span class="line">    p-&gt;setVal(value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找最近的不平衡祖先，并记录路径</span></span><br><span class="line">    LinkedStack&lt;<span class="keyword">bool</span>&gt;* routine = <span class="keyword">new</span> LinkedStack&lt;<span class="keyword">bool</span>&gt;;<span class="comment">// 向左为false</span></span><br><span class="line">    BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;* A = findImbalancedAncestor(node, &amp;routine);</span><br><span class="line">    <span class="keyword">if</span> (!A) &#123;</span><br><span class="line">        <span class="keyword">delete</span> routine;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断不平衡类型，并相应旋转</span></span><br><span class="line">    <span class="keyword">int</span> type = (routine-&gt;pop() &lt;&lt; <span class="number">1</span>) + routine-&gt;pop();</span><br><span class="line">    <span class="keyword">switch</span> (type)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:<span class="comment">// LL</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;leftRotate(A);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:<span class="comment">// LR</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;rightRotate(A-&gt;left);</span><br><span class="line">        <span class="keyword">this</span>-&gt;leftRotate(A);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:<span class="comment">// RL</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;leftRotate(A-&gt;right);</span><br><span class="line">        <span class="keyword">this</span>-&gt;rightRotate(A);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:<span class="comment">// RR</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;rightRotate(A);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若A为根节点，旋转后需改变根节点指针</span></span><br><span class="line">    <span class="keyword">if</span> (!A-&gt;parent-&gt;parent) <span class="keyword">this</span>-&gt;m_tnRoot = A-&gt;parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> routine;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除<br> 删除时，首先进行节点查找，若找到，记录其父节点信息(在搜索树结构重组织时会失去该节点信息，故先进行保存)；重新组织搜索二叉树结构后，维持平衡二叉树，</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;K, V&gt;::erase(<span class="keyword">const</span> K&amp; key)</span><br><span class="line">&#123;</span><br><span class="line">    BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;* node = <span class="keyword">this</span>-&gt;find(key, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录父节点与其兄弟节点</span></span><br><span class="line">    BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;* P = node-&gt;parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------ 重新组织二叉树 ------------------</span></span><br><span class="line">    <span class="comment">// 查找左子树的最大值，或右子树的最小值</span></span><br><span class="line">    BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;* replace = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (!node-&gt;isLeaf()) &#123;<span class="comment">// 直到搜索到叶节点为止</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">            replace = <span class="keyword">this</span>-&gt;max(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">            replace = <span class="keyword">this</span>-&gt;min(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (replace) &#123;<span class="comment">// 找到可替换子节点</span></span><br><span class="line">            Pair&lt;K, V&gt;* np = node-&gt;get();</span><br><span class="line">            Pair&lt;K, V&gt;* rp = replace-&gt;get();</span><br><span class="line">            np-&gt;setKey(rp-&gt;getKey());</span><br><span class="line">            np-&gt;setVal(rp-&gt;getVal());</span><br><span class="line">            node = replace;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;parent) &#123;<span class="comment">// 修改父节点信息</span></span><br><span class="line">        <span class="keyword">if</span> (node == node-&gt;parent-&gt;left)</span><br><span class="line">            node-&gt;parent-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            node-&gt;parent-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 无父节点，即整棵树只有一个根节点，则修改根节点为空</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_tnRoot = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ------------------ 维持平衡二叉树 ------------------</span></span><br><span class="line">    <span class="comment">// 查找最近的不平衡祖先，并记录路径</span></span><br><span class="line">    LinkedStack&lt;<span class="keyword">bool</span>&gt;* routine = <span class="keyword">new</span> LinkedStack&lt;<span class="keyword">bool</span>&gt;;<span class="comment">// 向左为false</span></span><br><span class="line">    BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;* A = findImbalancedAncestor(P, &amp;routine);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向根节点进行</span></span><br><span class="line">    <span class="keyword">while</span> (A) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断类型并矫正</span></span><br><span class="line">        <span class="keyword">bool</span> deleteRight = <span class="literal">false</span>;<span class="comment">// 若为`true`，表示R类型。否则L类型</span></span><br><span class="line">        <span class="keyword">if</span> (routine-&gt;empty()) &#123;<span class="comment">// P即为A，此时必有一子节点为空</span></span><br><span class="line">            <span class="keyword">if</span> (!A-&gt;left) <span class="comment">// 左节点为空</span></span><br><span class="line">                deleteRight = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!A-&gt;right) <span class="comment">// 右节点为空</span></span><br><span class="line">                deleteRight = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            deleteRight = routine-&gt;pop();</span><br><span class="line">        &#125;</span><br><span class="line">        BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;* B = \</span><br><span class="line">            deleteRight ? A-&gt;left : A-&gt;right;<span class="comment">// 不平衡节点的另一侧子树</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> type = (deleteRight &lt;&lt; <span class="number">2</span>) + balancedFactor(B);</span><br><span class="line">        <span class="keyword">switch</span> (type)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:<span class="comment">// L-1</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;rightRotate(A);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:<span class="comment">// L0</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;rightRotate(A);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:<span class="comment">// L1</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;leftRotate(A-&gt;right);</span><br><span class="line">            <span class="keyword">this</span>-&gt;rightRotate(A);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:<span class="comment">// R-1</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;rightRotate(A-&gt;left);</span><br><span class="line">            <span class="keyword">this</span>-&gt;leftRotate(A);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:<span class="comment">// R0</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;leftRotate(A);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:<span class="comment">// R1</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;leftRotate(A);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改整棵树的根节点</span></span><br><span class="line">        <span class="keyword">if</span> (!A-&gt;parent-&gt;parent) <span class="keyword">this</span>-&gt;m_tnRoot = A-&gt;parent;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向根节点搜索不平衡节点，更新A</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; routine-&gt;size(); i++) routine-&gt;pop();<span class="comment">// 清除栈</span></span><br><span class="line">        A = findImbalancedAncestor(A, &amp;routine);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------ 释放资源 ------------------</span></span><br><span class="line">    <span class="keyword">delete</span> routine;</span><br><span class="line">    Pair&lt;K, V&gt;* pair = node-&gt;get();</span><br><span class="line"> <span class="keyword">delete</span> pair; <span class="keyword">delete</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h4><p>按顺序插入以下关键字</p><div class="table-container"><table><thead><tr><th>序号</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td>关键字</td><td>20</td><td>15</td><td>25</td><td>12</td><td>10</td><td>23</td><td>24</td><td>19</td></tr></tbody></table></div><p>在插入$10$以前，该树无不平衡情况。在插入$10$之后导致键为$15$的节点$LL$不平衡，需进行左旋调整，如下</p><p><img src="/2020/03/14/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91%E2%80%94%E2%80%94AVL%E6%A0%91%E4%B8%8ERB%E6%A0%91/【数据结构】平衡搜索树——AVL树与RB树/test_insert_ll.jpg" alt="test_insert_ll"></p><p>此时二叉树按<strong>层次遍历</strong>输出如下，结果正确<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">插入10: [20]甲 [12]丁 [25]丙 [10]戊 [15]乙</span><br></pre></td></tr></table></figure></p><p>在插入$24$时，节点$25$形成$LR$不平衡，调整过程如下</p><p><img src="/2020/03/14/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91%E2%80%94%E2%80%94AVL%E6%A0%91%E4%B8%8ERB%E6%A0%91/【数据结构】平衡搜索树——AVL树与RB树/test_insert_lr.jpg" alt="test_insert_lr"></p><p><strong>层次遍历</strong>输出结果正确<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">插入24: [20]甲 [12]丁 [24]庚 [10]戊 [15]乙 [23]己 [25]丙</span><br></pre></td></tr></table></figure></p><p>全部插入后形成平衡二叉树与搜索二叉树对比如下</p><p><img src="/2020/03/14/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91%E2%80%94%E2%80%94AVL%E6%A0%91%E4%B8%8ERB%E6%A0%91/【数据结构】平衡搜索树——AVL树与RB树/test_insert_all.jpg" alt="test_insert_all"></p><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><p>在上述最终生成的AVL中，删除节点$10$导致节点$12$出现$L-1$不平衡，进行单旋转矫正，<strong>层次遍历</strong>输出结果正确<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[20]甲 [15]乙 [24]庚 [12]丁 [19]辛 [23]己 [25]丙</span><br></pre></td></tr></table></figure></p><p><img src="/2020/03/14/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91%E2%80%94%E2%80%94AVL%E6%A0%91%E4%B8%8ERB%E6%A0%91/【数据结构】平衡搜索树——AVL树与RB树/test_erase_l_1.jpg" alt="test_erase_l_1"></p><p>继续删除$12, 15, 19$导致节点$20$出现$L0$不平衡，进行单旋转矫正，<strong>层次遍历</strong>输出结果正确<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[24]庚 [20]甲 [25]丙 [23]己</span><br></pre></td></tr></table></figure></p><p><img src="/2020/03/14/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91%E2%80%94%E2%80%94AVL%E6%A0%91%E4%B8%8ERB%E6%A0%91/【数据结构】平衡搜索树——AVL树与RB树/test_erase_l0.jpg" alt="test_erase_l0"></p><p>重新初始化该树，依次删除$25, 12, 10, 15, 19$导致节点$20$出现$L1$不平衡，进行双旋转矫正，<strong>层次遍历</strong>输出结果正确<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[23]己 [20]甲 [24]庚</span><br></pre></td></tr></table></figure></p><p><img src="/2020/03/14/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91%E2%80%94%E2%80%94AVL%E6%A0%91%E4%B8%8ERB%E6%A0%91/【数据结构】平衡搜索树——AVL树与RB树/test_erase_l1.jpg" alt="test_erase_l1"></p><h4 id="主函数与输出"><a href="#主函数与输出" class="headerlink" title="主函数与输出"></a>主函数与输出</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> names[<span class="number">8</span>] = &#123;</span><br><span class="line"><span class="string">"甲"</span>, <span class="string">"乙"</span>, <span class="string">"丙"</span>, <span class="string">"丁"</span>, <span class="string">"戊"</span>, <span class="string">"己"</span>, <span class="string">"庚"</span>, <span class="string">"辛"</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> numbers[<span class="number">8</span>] = &#123; <span class="number">20</span>, <span class="number">15</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">10</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">19</span> &#125;;</span><br><span class="line"></span><br><span class="line">AVLTree&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入键值对</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"插入"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"插入"</span> &lt;&lt; numbers[i] &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">tree.insert(numbers[i], names[i]);</span><br><span class="line">tree.print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除键值对</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"删除"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">tree.erase(<span class="number">10</span>); </span><br><span class="line">tree.print();<span class="comment">// 12 L-1不平衡</span></span><br><span class="line"></span><br><span class="line">tree.erase(<span class="number">12</span>); </span><br><span class="line">tree.erase(<span class="number">15</span>);</span><br><span class="line">tree.erase(<span class="number">19</span>); </span><br><span class="line">tree.print();<span class="comment">// L0不平衡</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入键值对</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"重新插入"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">tree.insert(numbers[i], names[i]);</span><br><span class="line">&#125;</span><br><span class="line">tree.print();</span><br><span class="line"></span><br><span class="line">tree.erase(<span class="number">25</span>); </span><br><span class="line">tree.erase(<span class="number">12</span>); </span><br><span class="line">tree.erase(<span class="number">10</span>); </span><br><span class="line">tree.erase(<span class="number">15</span>); </span><br><span class="line">tree.erase(<span class="number">19</span>); </span><br><span class="line">tree.print();<span class="comment">// L1不平衡</span></span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">插入</span><br><span class="line">插入20: [20]甲</span><br><span class="line">插入15: [20]甲 [15]乙</span><br><span class="line">插入25: [20]甲 [15]乙 [25]丙</span><br><span class="line">插入12: [20]甲 [15]乙 [25]丙 [12]丁</span><br><span class="line">插入10: [20]甲 [12]丁 [25]丙 [10]戊 [15]乙</span><br><span class="line">插入23: [20]甲 [12]丁 [25]丙 [10]戊 [15]乙 [23]己</span><br><span class="line">插入24: [20]甲 [12]丁 [24]庚 [10]戊 [15]乙 [23]己 [25]丙</span><br><span class="line">插入19: [20]甲 [12]丁 [24]庚 [10]戊 [15]乙 [23]己 [25]丙 [19]辛</span><br><span class="line"></span><br><span class="line">删除</span><br><span class="line">[20]甲 [15]乙 [24]庚 [12]丁 [19]辛 [23]己 [25]丙</span><br><span class="line">[24]庚 [20]甲 [25]丙 [23]己</span><br><span class="line"></span><br><span class="line">重新插入</span><br><span class="line">[20]甲 [12]丁 [24]庚 [10]戊 [15]乙 [23]己 [25]丙 [19]辛</span><br><span class="line">[23]己 [20]甲 [24]庚</span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure><h1 id="红-黑树-RB树"><a href="#红-黑树-RB树" class="headerlink" title="红-黑树(RB树)"></a>红-黑树(RB树)</h1><p>红黑树通过节点颜色的限制，进行整棵树的高度限制。</p><h2 id="定义及概念-1"><a href="#定义及概念-1" class="headerlink" title="定义及概念"></a>定义及概念</h2><p><strong>定义</strong>：<strong>红-黑树</strong>(red-black tree)是一棵<strong>二叉搜索树</strong>，将每个空指针用外部节点来代替，得到<strong>扩充二叉树</strong>，<strong>树中每个节点的颜色是黑色或是红色</strong>，如下图，图中外部节点(扩充)为黑色正方形。</p><p><img src="/2020/03/14/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91%E2%80%94%E2%80%94AVL%E6%A0%91%E4%B8%8ERB%E6%A0%91/【数据结构】平衡搜索树——AVL树与RB树/red_black_tree_eg.jpg" alt="red_black_tree_eg"></p><p>红-黑树具有以下性质</p><ol><li><strong>根节点、外部节点都是黑色</strong>；</li><li>根节点$\rightarrow$外部节点路径上，<strong>没有连续两个节点是红色</strong>；</li><li>根节点$\rightarrow$外部节点路径上，<strong>黑色节点数目相同</strong>。</li></ol><blockquote><p>由2，<strong>每个红色节点的子节点必定是黑色节点</strong>；</p></blockquote><p>红-黑树的另一种<strong>等价</strong>，<strong>取决于父子节点间指针颜色</strong>，</p><ol><li><strong>父节点$\rightarrow$黑色孩子</strong>指针是<strong>黑色</strong>的；</li><li><strong>父节点$\rightarrow$红色孩子</strong>指针是<strong>红色</strong>的；</li><li><strong>内部节点$\rightarrow$外部节点的指针为黑色</strong>；</li><li>根节点$\rightarrow$外部节点路径上，<strong>没有连续两个指针是红色</strong>；</li><li>根节点$\rightarrow$外部节点路径上，<strong>黑色指针数目相同</strong>。</li></ol><p><strong>定义</strong>：某节点的<strong>阶</strong>(rank)，是从<strong>该节点$\rightarrow$外部节点路径上黑色指针的数目(或黑色内部节点个数)</strong>，一个外部节点的阶是$0$。</p><p><strong>定理1</strong>：设根节点$\rightarrow$外部节点的<strong>路径长度</strong>(length),是为该路径的<strong>指针数量(或内部节点个数)</strong>，$P, Q$是红-黑树中两条根节点$\rightarrow$外部节点的路径，那么</p><script type="math/tex; mode=display">\rm{length}(P) \leq 2 \times \rm{length}(Q)</script><blockquote><p>根节点$\rightarrow$外部节点路径上，黑色内部节点数目即阶$N_b =   r$；且红色节点子节点必定为黑色节点，而黑色节点子节点颜色未定，故红色节点的数目$0 \leq N_r\leq r$，那么</p><script type="math/tex; mode=display">r \leq \rm{length} = N_r + N_b \leq 2 \times r</script><p>所以对于任意两条根节点$\rightarrow$外部节点的路径$P, Q$，长度都满足</p><script type="math/tex; mode=display">\rm{length}(P) \leq 2 \times \rm{length}(Q)</script></blockquote><p><strong>定理2</strong>：令$h$是一棵红-黑树的高度(不包括外部节点)，$n$是内部节点数目，$r$是根节点的阶，那么</p><ol><li>$h \leq 2r$；</li><li>$n \geq 2^r - 1$；</li><li>$h \leq 2 \times \log_2 (n + 1)$。</li></ol><blockquote><p>$h$即根节点$\rightarrow$外部节点的路径长度</p><ol><li>见定理1的证明；</li><li><strong>树的第$1 \sim r$层均为内部节点</strong>，且数目为$2^r - 1$，那么总内部节点数目$n \geq 2^r - 1$；</li><li>联立1，2可得3，略。</li></ol></blockquote><h2 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h2><h3 id="搜索-1"><a href="#搜索-1" class="headerlink" title="搜索"></a>搜索</h3><p>同样的，红-黑树搜索仍可沿用二叉搜索树的搜索方法。</p><h3 id="插入-2"><a href="#插入-2" class="headerlink" title="插入"></a>插入</h3><p>首先确定<strong>新节点插入时的颜色</strong>。若新节点为黑色，插入后必定违反<strong>性质3(黑色节点数目约束)</strong>；若新节点为红色，可能违反<strong>性质2(红色节点不连续约束)</strong>，故新节点颜色确定为<strong>红</strong>。</p><p>记红色新节点为$\mathcal{U}$，插入后违反<strong>性质2</strong>，此时$\mathcal{U}$<strong>必存在红色父节点</strong>$\mathcal{P}$；由<strong>性质1(根节点与外部节点颜色约束)</strong>，$\mathcal{U}$<strong>必存在黑色祖父节点</strong>$\mathcal{G}$。</p><p>此时不平衡情况可<strong>分为$8$种情况，命名为$XYc$</strong>，其中$X, Y$取值${L, R}$表示 $\mathcal{U}$为$\mathcal{G}$的$X$子节点的$Y$子节点；$c$取值${r, b}$，表示$\mathcal{G}$右子节点的颜色。</p><blockquote><p>例如$LLr$表示 $\mathcal{U}$为$\mathcal{G}$左子节点($L$)的左子节点($L$)，且$\mathcal{G}$右子节点$\mathcal{G_R}$为红色($r$)。</p></blockquote><p><strong>根据$\mathcal{G_R}$颜色</strong>分为两大类进行<strong>树的平衡</strong></p><ol><li><p>$XYr$</p><p> 当$\mathcal{G_R}$为红色时，该类不平衡可通过<strong>颜色调整</strong>来处理。将$\mathcal{P}$与$\mathcal{G_R}$的颜色调整为黑色；<strong>若$\mathcal{G}$不是根节点，需调整为红色，并将$\mathcal{G}$作为$\mathcal{U}$向根节点进行判别是否违反性质2</strong>。如下图</p><p> <img src="/2020/03/14/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91%E2%80%94%E2%80%94AVL%E6%A0%91%E4%B8%8ERB%E6%A0%91/【数据结构】平衡搜索树——AVL树与RB树/insert5.jpg" alt="insert5"></p></li><li><p>$XYb$</p><p> 当$\mathcal{G_R}$为黑色时，此类不平衡需通过<strong>旋转操作</strong>进行平衡，<strong>操作类似AVL树</strong>，除此之外，<strong>改变$\mathcal{G}$和$\mathcal{P}$节点的颜色</strong>。重新平衡后，该子树从根节点到外部节点的路径上，黑色节点数目不变，且向根节点搜索路径上，不存在连续的红色节点，故<strong>不需要继续平衡</strong>。</p><p> 如下图示意，$LLb$不平衡时，将子树$\mathcal{T_G}$左旋，并修改该子树根节点$\mathcal{G}$与不平衡端子树根节点$\mathcal{P}$，$LRb$同理。</p><p> <img src="/2020/03/14/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91%E2%80%94%E2%80%94AVL%E6%A0%91%E4%B8%8ERB%E6%A0%91/【数据结构】平衡搜索树——AVL树与RB树/insert6.jpg" alt="insert6"></p></li></ol><h3 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h3><p>用常规搜索二叉树的删除算法进行节点$\mathcal{N}$的物理删除，记$\mathcal{N}’$为替代$\mathcal{N}$的节点，<strong>当且仅当</strong>$\mathcal{N}$为黑色，且$\mathcal{N}’$不是树根节点时，会<strong>违反性质3(黑色节点数目约束)</strong>；$\mathcal{N}$为红色时，该树维持平衡。</p><p>记$\mathcal{N}’$的父节点为$\mathcal{P}$，$\mathcal{N}’$的同胞节点为$\mathcal{B}$，<strong>注意$\mathcal{N}’$在替代后，必定为黑色</strong>。根据$\mathcal{P, B}$的情况，<strong>不平衡情况可分为$4$类，命名为$Xc$，</strong>$X$取值为${L, R}$，表示$\mathcal{N}’$是$\mathcal{P}$的左孩或右孩；$c$取值为${r, b}$，表示$\mathcal{B}$的颜色。</p><ol><li><p>$Xb$型</p><p> <strong>根据$\mathcal{B}$的红色子节点个数</strong>，可分为$Xb0, Xb1, Xb2$三种。</p><ol><li><p>$Xb0$</p><p> <strong>修改$\mathcal{B}$(黑色)为红色节点$\mathcal{B}’$，$\mathcal{P}$(颜色待定)为黑色节点$\mathcal{P}’$</strong>，根节点$\mathcal{R}$至$\mathcal{N}’$的路径上增加了一个黑色节点，解决该路不平衡问题。但是考虑$\mathcal{P}$颜色：</p><ul><li><strong>若$\mathcal{P}$为红色节点</strong>，而根节点$\mathcal{R}$至$\mathcal{B}$路径上，黑色节点数目不变，保持该路平衡状态；</li><li><p><strong>若$\mathcal{P}$为黑色节点</strong>，将使得该路上缺少一个黑色节点，$\mathcal{P}$为根节点时无需改动，否则将$\mathcal{P}$视作新的$\mathcal{N}’$直至根节点为止，继续修改路径上节点的颜色。</p><p><img src="/2020/03/14/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91%E2%80%94%E2%80%94AVL%E6%A0%91%E4%B8%8ERB%E6%A0%91/【数据结构】平衡搜索树——AVL树与RB树/delete4.jpg" alt="delete4"></p></li></ul></li><li><p>$Xb1$与$Xb2$</p><p> 又可根据$\mathcal{B}$红色子孩的位置分为$Xb1(i)$和$Xb1(ii)$两类。可通过旋转的方式进行矫正，可以证明旋转后，整棵树保持平衡。</p><ul><li><p>$Xb1(i)$</p><p>  将树$\mathcal{T_P}$左旋，并修改$\mathcal{B}’$颜色与$\mathcal{P}$一致，$\mathcal{P}$修改为黑色。</p><p>  <img src="/2020/03/14/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91%E2%80%94%E2%80%94AVL%E6%A0%91%E4%B8%8ERB%E6%A0%91/【数据结构】平衡搜索树——AVL树与RB树/delete5.jpg" alt="delete5"></p></li><li><p>$Xb1(ii)$与$Xb2$</p><p>  将树$\mathcal{T_B}$右旋后，将树$\mathcal{T_P}$左旋，并修改$\mathcal{B_R}$颜色与$\mathcal{P}$一致，$\mathcal{P}$修改为黑色，$\mathcal{B_L}$颜色保持不变。</p><p>  <img src="/2020/03/14/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91%E2%80%94%E2%80%94AVL%E6%A0%91%E4%B8%8ERB%E6%A0%91/【数据结构】平衡搜索树——AVL树与RB树/delete6.jpg" alt="delete6"></p></li></ul></li></ol></li><li><p>$Xr$型</p><p> $Xr$型可<strong>根据$\mathcal{B_R}$红色孩子数目</strong>，分为$Xr0, Xr1, Xr2$三种类型。与$Xb$型不同，<strong>此时$\mathcal{P}$必定为黑色节点</strong>。该类型都可通过旋转后保持平衡，无需向根节点搜索不平衡节点，</p><ul><li><p>$Xr0$<br>  将树$\mathcal{T_P}$进行左旋，修改$\mathcal{B}$为黑色，$\mathcal{B_R}$为红色</p><p>  <img src="/2020/03/14/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91%E2%80%94%E2%80%94AVL%E6%A0%91%E4%B8%8ERB%E6%A0%91/【数据结构】平衡搜索树——AVL树与RB树/delete7.jpg" alt="delete7"></p></li><li><p>$Xr1$与$Xr2$</p><p>  又可根据$\mathcal{B_R}$红色子孩的位置分为$Xr1(i)$和$Xr1(ii)$两类。</p><ul><li><p>$Xr1(i)$<br>  将树$\mathcal{T_B}$进行右旋，再将树$\mathcal{T_P}$进行左旋，修改$\mathcal{B_{R_L}}$为黑色</p><p>  <img src="/2020/03/14/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91%E2%80%94%E2%80%94AVL%E6%A0%91%E4%B8%8ERB%E6%A0%91/【数据结构】平衡搜索树——AVL树与RB树/delete8.jpg" alt="delete8"></p></li><li><p>$Xr1(ii)$与$Xr2$</p><p>  将树$\mathcal{T_{B_R}}$进行右旋后，再将树$\mathcal{T_B}$进行右旋，再将树$\mathcal{T_P}$进行左旋，修改$\mathcal{B_{R_R}}$为黑色</p><p>  <img src="/2020/03/14/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91%E2%80%94%E2%80%94AVL%E6%A0%91%E4%B8%8ERB%E6%A0%91/【数据结构】平衡搜索树——AVL树与RB树/delete9.jpg" alt="delete9"></p></li></ul></li></ul></li></ol><h1 id="AVL树与红黑树的对比"><a href="#AVL树与红黑树的对比" class="headerlink" title="AVL树与红黑树的对比"></a>AVL树与红黑树的对比</h1><ul><li>AVL树通过子树高度限制进行<strong>严格平衡</strong>，而红黑树通过节点添加颜色的方式进行平衡，<strong>不追求严格的平衡</strong>；</li><li>在插入与删除操作时，两种维持平衡的方式也不相同，AVL树可通过$1 \sim 2$次旋转使子树获得平衡，RB树通过修改颜色或$1 \sim 3$次旋转来矫正。如下表；</li><li>AVL树在$L-1, R1, L1, R-1$(删除)时，需要对至根节点路径上的不平衡子树继续矫正；而RB树只有在$XYr$(插入)与$Rb0$(删除)时继续搜索不平衡子树，这两种情况都可以通过修改节点颜色来矫正；</li><li><strong>平均情况下，AVL树总的旋转次数比RB树多</strong>，RB树统计性能高于AVL。</li></ul><p>C++的STL标准库中<code>map</code>采用的时RB树实现。</p><table border="0" cellpadding="0" cellspacing="0" width="979" style="border-collapse: collapse;table-layout:fixed;width:733pt"> <col class="xl65" width="68" span="2" style="width:51pt"> <col class="xl65" width="228" style="mso-width-source:userset;mso-width-alt:7782; width:171pt"> <col class="xl65" width="82" style="mso-width-source:userset;mso-width-alt:2781; width:61pt"> <col class="xl65" width="287" style="mso-width-source:userset;mso-width-alt:9796; width:215pt"> <col class="xl65" width="246" style="mso-width-source:userset;mso-width-alt:8379; width:184pt"> <tr height="19" style="height:13.9pt">  <td height="19" class="xl66" width="68" style="height:13.9pt;width:51pt">树</td>  <td class="xl66" width="68" style="width:51pt">操作</td>  <td class="xl66" width="228" style="width:171pt">判别</td>  <td class="xl66" width="82" style="width:61pt">类型</td>  <td class="xl66" width="287" style="width:215pt">矫正</td>  <td class="xl66" width="246" style="width:184pt">备注</td> </tr> <tr height="19" style="height:13.9pt">  <td rowspan="10" height="190" class="xl66" width="68" style="height:139.0pt;  width:51pt">AVL</td>  <td rowspan="4" class="xl66" width="68" style="width:51pt">插入</td>  <td rowspan="4" class="xl66" width="228" style="width:171pt">查找插入节点N最近的不平衡祖先A(bf=-2/2)；根据N所在A子树的子树位置，分为4种不平衡类型(如N在A左子树的左子树则记作LL)</td>  <td class="xl66" width="82" style="width:61pt">LL</td>  <td class="xl65" width="287" style="width:215pt">A左旋</td>  <td rowspan="4" class="xl66" width="246" style="width:184pt">矫正后子树高度不变，整棵树平衡</td> </tr> <tr height="19" style="height:13.9pt">  <td height="19" class="xl66" width="82" style="height:13.9pt;width:61pt">RR</td>  <td class="xl65" width="287" style="width:215pt">A右旋</td> </tr> <tr height="19" style="height:13.9pt">  <td height="19" class="xl66" width="82" style="height:13.9pt;width:61pt">LR</td>  <td class="xl65" width="287" style="width:215pt">AL右旋，A左旋</td> </tr> <tr height="19" style="height:13.9pt">  <td height="19" class="xl66" width="82" style="height:13.9pt;width:61pt">RL</td>  <td class="xl65" width="287" style="width:215pt">AR左旋，A右旋</td> </tr> <tr height="19" style="height:13.9pt">  <td rowspan="6" height="114" class="xl66" width="68" style="height:83.4pt;width:51pt">删除</td>  <td rowspan="6" class="xl66" width="228" style="width:171pt">查找删除节点N最近的不平衡祖先A(bf=-2/2)；根据N所在A的子树位置，可分为L,  R两种；考察A另一棵子树平衡因子，L(R)型又可分为0, 1, -1三种，共2×3=6种类型</td>  <td class="xl66" width="82" style="width:61pt">L0</td>  <td class="xl65" width="287" style="width:215pt">A右旋</td>  <td rowspan="2" class="xl66" width="246" style="width:184pt">矫正后子树高度不变，整棵树平衡</td> </tr> <tr height="19" style="height:13.9pt">  <td height="19" class="xl66" width="82" style="height:13.9pt;width:61pt">R0</td>  <td class="xl65" width="287" style="width:215pt">A左旋</td> </tr> <tr height="19" style="height:13.9pt">  <td height="19" class="xl66" width="82" style="height:13.9pt;width:61pt">L-1</td>  <td class="xl65" width="287" style="width:215pt">A右旋</td>  <td rowspan="4" class="xl66" width="246" style="width:184pt">矫正后子树高度减1，某些祖先节点可能不平衡，需要对在至根节点的路径上的不平衡子树继续矫正</td> </tr> <tr height="19" style="height:13.9pt">  <td height="19" class="xl66" width="82" style="height:13.9pt;width:61pt">R1</td>  <td class="xl65" width="287" style="width:215pt">A左旋</td> </tr> <tr height="19" style="height:13.9pt">  <td height="19" class="xl66" width="82" style="height:13.9pt;width:61pt">L1</td>  <td class="xl65" width="287" style="width:215pt">AR左旋，A右旋</td> </tr> <tr height="19" style="height:13.9pt">  <td height="19" class="xl66" width="82" style="height:13.9pt;width:61pt">R-1</td>  <td class="xl65" width="287" style="width:215pt">AL右旋，A左旋</td> </tr> <tr height="61" style="mso-height-source:userset;height:45.75pt">  <td rowspan="12" height="306" class="xl66" width="68" style="height:226.35pt;  width:51pt">RB树</td>  <td rowspan="5" class="xl66" width="68" style="width:51pt">插入</td>  <td rowspan="5" class="xl65" width="228" style="width:171pt">插入节点N初始为红，其父节点P为红时不平衡，祖父节点G必为黑色；根据N与G的节点关系(LL,  RR, LR, RL)、G的另一孩子颜色(r, b)，可分为4×2=8种类型XYc</td>  <td class="xl66" width="82" style="width:61pt">XYr</td>  <td class="xl65" width="287" style="width:215pt">修改P与GR为黑色节点，若G不为根节点修改为红否则为黑</td>  <td class="xl65" width="246" style="width:184pt">G颜色改变，能导致G的父节点不平衡(红-红)，故需要对至根节点的路径上不平衡子树继续矫正</td> </tr> <tr height="19" style="mso-height-source:userset;height:13.9pt">  <td height="19" class="xl66" width="82" style="height:13.9pt;width:61pt">LLb</td>  <td class="xl65" width="287" style="width:215pt">G左旋，修改P为黑，G为红</td>  <td rowspan="4" class="xl66" width="246" style="width:184pt">重新平衡后，该子树从根节点到外部节点的路径上，黑色节点数目不变，且向根节点搜索路径上，不存在连续的红色节点，整棵树平衡</td> </tr> <tr height="19" style="height:13.9pt">  <td height="19" class="xl66" width="82" style="height:13.9pt;width:61pt">RRb</td>  <td class="xl65" width="287" style="width:215pt">G右旋，修改P为黑，G为红</td> </tr> <tr height="19" style="height:13.9pt">  <td height="19" class="xl66" width="82" style="height:13.9pt;width:61pt">LRb</td>  <td class="xl65" width="287" style="width:215pt">AL右旋，A左旋，修改U为黑，G为红</td> </tr> <tr height="19" style="height:13.9pt">  <td height="19" class="xl66" width="82" style="height:13.9pt;width:61pt">RLb</td>  <td class="xl65" width="287" style="width:215pt">AR左旋，A右旋，修改U为黑，G为红</td> </tr> <tr height="19" style="mso-height-source:userset;height:13.9pt">  <td rowspan="7" height="169" class="xl66" width="68" style="height:125.0pt;  width:51pt">删除</td>  <td rowspan="7" class="xl66" width="228" style="width:171pt">删除节点N(黑色时不平衡)后，由搜索树算法找到替换节点N'(修改为黑)，N'的父节点为P(Xb型时颜色不定，Xr型时必为黑)、同胞节点为B；根据N'与P的位置关系(L,  R)、B的颜色(r, b)、B的红色子节点个数(0, 1, 2)、B红色结点数为1时该红色子节点相对于B位置(i&lt;左&gt;,  ii&lt;右&gt;)分别矫正；共2×2×(1+2+1)=16种类型</td>  <td class="xl66" width="82" style="width:61pt">Rb0</td>  <td class="xl65" width="287" style="width:215pt">修改B为红，P为黑</td>  <td class="xl65" width="246" style="width:184pt">P为红色时，整棵树平衡；否则向跟节点继续矫正</td> </tr> <tr height="19" style="height:13.9pt">  <td height="19" class="xl66" width="82" style="height:13.9pt;width:61pt">Rb1(i)</td>  <td class="xl65" width="287" style="width:215pt">P左旋，修改B与P一致，再修改P为黑</td>  <td rowspan="2" class="xl66" width="246" style="width:184pt">矫正后，整棵树平衡</td> </tr> <tr height="37" style="height:27.75pt">  <td height="37" class="xl66" width="82" style="height:27.75pt;width:61pt">Rb1(ii),  Rb2</td>  <td class="xl65" width="287" style="width:215pt">B右旋，P左旋，修改BR与P一致(BL不变)，再修改P为黑</td> </tr> <tr height="19" style="height:13.9pt">  <td height="19" class="xl66" width="82" style="height:13.9pt;width:61pt">Rr0</td>  <td class="xl65" width="287" style="width:215pt">P左旋，修改B为黑，BR为红</td>  <td rowspan="3" class="xl66" width="246" style="width:184pt">矫正后，整棵树平衡</td> </tr> <tr height="19" style="height:13.9pt">  <td height="19" class="xl66" width="82" style="height:13.9pt;width:61pt">Rr1(i)</td>  <td class="xl65" width="287" style="width:215pt">B右旋，P左旋，修改BRL(红)为黑</td> </tr> <tr height="37" style="height:27.75pt">  <td height="37" class="xl66" width="82" style="height:27.75pt;width:61pt">Rr1(ii),  Rr2</td>  <td class="xl65" width="287" style="width:215pt">BR右旋，B右旋，P左旋，修改BRR(红，此时为子树跟节点)为黑</td> </tr> <tr height="19" style="height:13.9pt">  <td height="19" class="xl66" width="82" style="height:13.9pt;width:61pt">Lcn</td>  <td colspan="2" class="xl66" width="533" style="width:399pt">与之类似，略</td> </tr> <![if supportMisalignedColumns]> <tr height="0" style="display:none">  <td width="68" style="width:51pt"></td>  <td width="68" style="width:51pt"></td>  <td width="228" style="width:171pt"></td>  <td width="82" style="width:61pt"></td>  <td width="287" style="width:215pt"></td>  <td width="246" style="width:184pt"></td> </tr> <![endif]></table>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】搜索树</title>
      <link href="/2020/03/08/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/2020/03/08/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="定义与概念"><a href="#定义与概念" class="headerlink" title="定义与概念"></a>定义与概念</h1><p>考虑用散列表述的字典，字典插入、查找和删除等操作所需要的平均时间为$\Theta(1)$，最坏情况下时间与元素个数呈线性关系。若给字典添加如下操作，那么散列便不再具有良好的平均性能</p><ul><li>按关键字的升序输出字典元素；</li><li>按升序找到第$k$各元素；</li><li>删除第$k$个元素。</li></ul><p><strong>定义</strong>：<strong>二叉搜索树</strong>(binary search tree)是一棵二叉树，可能为空；一棵非空的二叉搜索树满足以下特征</p><ol><li>每个元素对应一个关键字，且所有<strong>关键字都唯一</strong>；</li><li>根节点的<strong>左子树</strong>中，元素关键字都<strong>小于</strong>根节点的关键字；</li><li>根节点的<strong>右子树</strong>中，元素关键字都<strong>大于</strong>根节点的关键字；</li><li>根节点的<strong>左、右子树</strong>也是二叉搜索树。</li></ol><blockquote><ul><li>由$2, 3$可知，某节点$\mathcal{N}$的键，<strong>大于</strong>该节点的左子树元素的键，<strong>小于</strong>该节点的右子树的键；</li><li>以节点$\mathcal{N}$为根节点的树的<strong>最小值</strong>位于最左端的叶子节点，<strong>最大值</strong>位于最右端的叶子节点；</li><li>当节点$\mathcal{N}$的<strong>左子树的键最大节点或右子树的键最小节点</strong>替换该结点时，该树仍满足二叉搜索树的特性。</li></ul></blockquote><p>若条件$1$弱化，即不同元素可包含相同的关键字，且$2, 3$中小于/大于改为不大于/不小于，这样的树称为<strong>有重复值的二叉搜索树</strong>(binary search tree with duplicates)。</p><p><strong>定义</strong>：<strong>索引二叉搜索树</strong>(indexed binary search tree)源于普通二叉搜索树，是在每个节点中添加$leftSize$域，记录<strong>该节点左子树的元素个数</strong>。</p><blockquote><ul><li>节点$\mathcal{N}$的$leftSize$与索引$index$比较大小，判断<strong>向左或向右</strong>搜索；</li><li>某节点$\mathcal{N}$的$leftSize$视为<strong>该节点在以该节点为根节点的树$\mathcal{T}_{\mathcal{N}}$中的索引</strong>，如下图$20$在树中索引为$5$，$15$在左子树中，索引为$1$等，以此类推；</li></ul><p>下图中元素按照升序排列时$12, 15, 16, 18, 19, 20, 25, 30$<br><img src="/2020/03/08/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%90%9C%E7%B4%A2%E6%A0%91/【数据结构】搜索树/indexed_binary_search_tree.jpg" alt="indexed_binary_search_tree"></p></blockquote><h1 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">抽象数据类型 BSTree</span><br><span class="line">&#123;</span><br><span class="line">    实例:</span><br><span class="line">        二叉树，每个节点包含数值对；满足二叉搜索树的特征；</span><br><span class="line">    操作：</span><br><span class="line">        find(k)：返回关键字为k的数对</span><br><span class="line">        insert(p)：插入数对p</span><br><span class="line">        erase(k)：删除关键字为k的数对</span><br><span class="line">        ascend()：按关键字升序输出所有数对</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>索引二叉搜索树支持二叉搜索树的所有操作，另外它还支持按名字进行的查找和删除操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">抽象数据类型 IndexedBSTree</span><br><span class="line">&#123;</span><br><span class="line">    实例:</span><br><span class="line">        二叉树，每个节点包含数值对；满足二叉搜索树的特征；</span><br><span class="line">    操作：</span><br><span class="line">        find(k)：返回关键字为k的数对</span><br><span class="line">        get(index)：返回第index个数对</span><br><span class="line">        insert(p)：插入数对p</span><br><span class="line">        erase(k)：删除关键字为k的数对</span><br><span class="line">        ascend()：按关键字升序输出所有数对</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> :</span> </span><br><span class="line"><span class="keyword">public</span> LinkedBinaryTree&lt;Pair&lt;K, V&gt;*&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">BinarySearchTree() : LinkedBinaryTree&lt;Pair&lt;K, V&gt;*&gt;() &#123;&#125;</span><br><span class="line">~BinarySearchTree() &#123;&#125;</span><br><span class="line"></span><br><span class="line">BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;* find(<span class="keyword">const</span> K&amp;, <span class="keyword">bool</span> insert=<span class="literal">false</span>);</span><br><span class="line"><span class="function">V&amp; <span class="title">get</span><span class="params">(<span class="keyword">const</span> K&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> K&amp;, <span class="keyword">const</span> V&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">const</span> K&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;<span class="comment">// 注意</span></span><br><span class="line"><span class="comment">// - 不能声明为const，否则无法调用非const的printPairNode；</span></span><br><span class="line"><span class="comment">// - 类的静态成员无法声明为const。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ascending</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printPairNode</span><span class="params">(BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;*)</span></span>;</span><br><span class="line"><span class="keyword">static</span> BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;* max(BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;*);</span><br><span class="line"><span class="keyword">static</span> BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;* min(BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;*);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ol><li><p>查找</p><p> 根据搜索二叉树特性，当搜索到达节点$\mathcal{N}$时，<strong>若查找值小于当前节点的键，则向其左子树搜索，否则向右子树搜索</strong>，直至找到对应键(找到)，或直至叶子节点(未找到)；在<strong>插入模式</strong>(<code>bool insert=true</code>)下查找时，若不存在则创建新节点并返回。</p><p> <img src="/2020/03/08/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%90%9C%E7%B4%A2%E6%A0%91/【数据结构】搜索树/find.jpg" alt="find"></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line">BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;* BinarySearchTree&lt;K, V&gt;::find(<span class="keyword">const</span> K&amp; key, <span class="keyword">bool</span> insert)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 若树为空</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;m_tnRoot) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!insert) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        Pair&lt;K, V&gt;* p = <span class="keyword">new</span> Pair&lt;K, V&gt;;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_tnRoot = <span class="keyword">new</span> BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_tnRoot-&gt;<span class="built_in">set</span>(p); <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_tnRoot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 树不为空</span></span><br><span class="line">    BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;* node = <span class="keyword">this</span>-&gt;m_tnRoot;</span><br><span class="line">    <span class="keyword">bool</span> toLeft = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        <span class="comment">// 找到对应键的数值对</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;get()-&gt;getKey() == key) <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前节点的键比搜查键更大，则向左子树搜索</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;get()-&gt;getKey() &gt; key) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!node-&gt;left) &#123;<span class="comment">// 左子树为空</span></span><br><span class="line">                toLeft = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前节点的键比搜查键更小，则向右子树搜索</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!node-&gt;right) &#123;<span class="comment">// 右子树为空</span></span><br><span class="line">                toLeft = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未找到</span></span><br><span class="line">    <span class="keyword">if</span> (!insert) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新节点n</span></span><br><span class="line">    Pair&lt;K, V&gt;* p = <span class="keyword">new</span> Pair&lt;K, V&gt;;</span><br><span class="line">    BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;* n = \</span><br><span class="line">        <span class="keyword">new</span> BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;(node);</span><br><span class="line">    n-&gt;<span class="built_in">set</span>(p);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将节点加入搜索树</span></span><br><span class="line">    <span class="keyword">if</span> (toLeft)</span><br><span class="line">        node-&gt;left = n;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        node-&gt;right = n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line">V&amp; BinarySearchTree&lt;K, V&gt;::get(<span class="keyword">const</span> K&amp; key)</span><br><span class="line">&#123;</span><br><span class="line">    BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;* node = find(key, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node-&gt;get()-&gt;getVal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>插入</p><p> 调用函数<code>find</code>(插入模式)查找结果，设置搜查到的节点的数值对即可。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">void</span> BinarySearchTree&lt;K, V&gt;::insert(<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> V&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;* node = find(key, <span class="literal">true</span>);</span><br><span class="line">    Pair&lt;K, V&gt;* p = node-&gt;get();</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;getKey() != key)</span><br><span class="line">        p-&gt;setKey(key);</span><br><span class="line">    p-&gt;setVal(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除</p><p> 删除结点时，需考虑剩余节点的重组织问题，与<a href="https://louishsu.xyz/2020/03/03/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/" target="_blank" rel="noopener">最大堆</a>不同，二叉搜索树具有良好的结构特性，故删除某节点$\mathcal{N}$时，只需将其<strong>左子树元素中键最大的，或右子树中元素键最小的</strong>与该节点位置替换即可。考虑到节点间拓扑关系修改复杂，以下仅<strong>修改</strong>节点$\mathcal{N}$的键值对，且继续搜索直至找到叶子节点作为<strong>替换节点</strong>并释放节点内存。</p><p> 例如删除键为$20$的节点$\mathcal{N}_{20}$时，查找左子树中键最大的节点$\mathcal{N}_{19}$，或右子树中键最小的节点$\mathcal{N}_{25}$(<strong>由于$\mathcal{N}_{25}$非叶子节点</strong>，需查找$\mathcal{N}_{25}$为根节点的树$\mathcal{T}_{\mathcal{N}_{25}}$中最大左子树节点或最小右子树节点进行替换)，代替$\mathcal{N}_{20}$，如下图</p><p> <img src="/2020/03/08/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%90%9C%E7%B4%A2%E6%A0%91/【数据结构】搜索树/erase.jpg" alt="erase"></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">void</span> BinarySearchTree&lt;K, V&gt;::erase(<span class="keyword">const</span> K&amp; key)</span><br><span class="line">&#123;</span><br><span class="line">    BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;* node = find(key, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------ 重新组织二叉树 ------------------</span></span><br><span class="line">    <span class="comment">// 查找左子树的最大值，或右子树的最小值</span></span><br><span class="line">    BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;* replace = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (!node-&gt;isLeaf())&#123;<span class="comment">// 直到搜索到叶节点为止</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">            replace = max(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">            replace = min(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (replace) &#123;<span class="comment">// 找到可替换子节点</span></span><br><span class="line">            Pair&lt;K, V&gt;* np = node-&gt;get();</span><br><span class="line">            Pair&lt;K, V&gt;* rp = replace-&gt;get();</span><br><span class="line">            np-&gt;setKey(rp-&gt;getKey());</span><br><span class="line">            np-&gt;setVal(rp-&gt;getVal());</span><br><span class="line">            node = replace;             <span class="comment">// 替换节点node</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;parent) &#123;<span class="comment">// 修改父节点信息</span></span><br><span class="line">        <span class="keyword">if</span> (node == node-&gt;parent-&gt;left)</span><br><span class="line">            node-&gt;parent-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            node-&gt;parent-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 无父节点，即整棵树只有一个根节点，则修改根节点为空</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_tnRoot = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------ 释放资源 ------------------</span></span><br><span class="line">    Pair&lt;K, V&gt;* pair = node-&gt;get();</span><br><span class="line">    <span class="keyword">delete</span> pair; <span class="keyword">delete</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line">BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;* BinarySearchTree&lt;K, V&gt;::max(BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;* node)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (node-&gt;right) </span><br><span class="line">        node = node-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line">BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;* BinarySearchTree&lt;K, V&gt;::min(BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;* node)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (node-&gt;left)</span><br><span class="line">        node = node-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>升序打印</p><p> 将元素按<strong>中序遍历</strong>进行打印即可</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">void</span> BinarySearchTree&lt;K, V&gt;::ascending() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;inOrder(&amp;printPairNode, <span class="keyword">this</span>-&gt;m_tnRoot);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>print</code>实现将元素按<strong>层次遍历</strong>的顺序打印</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">void</span> BinarySearchTree&lt;K, V&gt;::print()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;levelOrder(&amp;printPairNode, <span class="keyword">this</span>-&gt;m_tnRoot);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">void</span> BinarySearchTree&lt;K, V&gt;::printPairNode(BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;* node)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">    Pair&lt;K, V&gt;* p = node-&gt;get();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'['</span> &lt;&lt; p-&gt;getKey() &lt;&lt; <span class="string">']'</span> &lt;&lt; p-&gt;getVal() &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> names[<span class="number">8</span>] = &#123;</span><br><span class="line"><span class="string">"甲"</span>, <span class="string">"乙"</span>, <span class="string">"丙"</span>, <span class="string">"丁"</span>, <span class="string">"戊"</span>, <span class="string">"己"</span>, <span class="string">"庚"</span>, <span class="string">"辛"</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> numbers[<span class="number">8</span>] = &#123; <span class="number">20</span>, <span class="number">15</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">18</span>, <span class="number">30</span>, <span class="number">16</span>, <span class="number">19</span> &#125;;</span><br><span class="line"></span><br><span class="line">BinarySearchTree&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入键值对</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"插入"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"插入"</span> &lt;&lt; numbers[i] &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">tree.insert(numbers[i], names[i]);</span><br><span class="line">tree.print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"升序排列: "</span>;</span><br><span class="line">tree.ascending();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除键值对</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"删除"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">tree.erase(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"删除"</span> &lt;&lt; numbers[i] &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">tree.erase(numbers[i]);</span><br><span class="line">tree.print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">插入</span><br><span class="line">插入20: [20]甲</span><br><span class="line">插入15: [20]甲 [15]乙</span><br><span class="line">插入25: [20]甲 [15]乙 [25]丙</span><br><span class="line">插入12: [20]甲 [15]乙 [25]丙 [12]丁</span><br><span class="line">插入18: [20]甲 [15]乙 [25]丙 [12]丁 [18]戊</span><br><span class="line">插入30: [20]甲 [15]乙 [25]丙 [12]丁 [18]戊 [30]己</span><br><span class="line">插入16: [20]甲 [15]乙 [25]丙 [12]丁 [18]戊 [30]己 [16]庚</span><br><span class="line">插入19: [20]甲 [15]乙 [25]丙 [12]丁 [18]戊 [30]己 [16]庚 [19]辛</span><br><span class="line">升序排列: [12]丁 [15]乙 [16]庚 [18]戊 [19]辛 [20]甲 [25]丙 [30]己</span><br><span class="line"></span><br><span class="line">删除</span><br><span class="line">删除20: [19]辛 [15]乙 [25]丙 [12]丁 [18]戊 [30]己 [16]庚</span><br><span class="line">删除15: [19]辛 [12]丁 [25]丙 [18]戊 [30]己 [16]庚</span><br><span class="line">删除25: [19]辛 [12]丁 [30]己 [18]戊 [16]庚</span><br><span class="line">删除12: [19]辛 [16]庚 [30]己 [18]戊</span><br><span class="line">删除18: [19]辛 [16]庚 [30]己</span><br><span class="line">删除30: [19]辛 [16]庚</span><br><span class="line">删除16: [19]辛</span><br><span class="line">删除19:</span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure><p>删除时节点的重组织示意图如下</p><p><img src="/2020/03/08/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%90%9C%E7%B4%A2%E6%A0%91/【数据结构】搜索树/bst1.jpg" alt="bst1"></p><h2 id="索引二叉搜索树"><a href="#索引二叉搜索树" class="headerlink" title="索引二叉搜索树"></a>索引二叉搜索树</h2><h3 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h3><p>由<code>BinarySearchTree&lt;K, V&gt;</code>派生而来，添加操作符<code>[]</code>的重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexedBinarySearchTree</span> :</span></span><br><span class="line"><span class="keyword">public</span> BinarySearchTree&lt;K, V&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">IndexedBinarySearchTree() : BinarySearchTree&lt;K, V&gt;() &#123;&#125;</span><br><span class="line">~IndexedBinarySearchTree() &#123;&#125;</span><br><span class="line"></span><br><span class="line">BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;* <span class="keyword">operator</span>[] (<span class="keyword">int</span> index);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>初始化偏置$offset = 0$，在向右搜索时，需更新偏置$offset$使右子树中各节点的$leafSize$仍能用于索引</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line">BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;* IndexedBinarySearchTree&lt;K, V&gt;::<span class="keyword">operator</span>[] (<span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="string">"索引必须大于0！"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> leftSize = <span class="number">-1</span>; <span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line">BinaryTreeNode&lt; Pair&lt;K, V&gt;*&gt;* node = <span class="keyword">this</span>-&gt;m_tnRoot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (leftSize != index &amp;&amp; node) &#123;</span><br><span class="line">leftSize = IndexedBinarySearchTree&lt;K, V&gt;::sizeofNode(node-&gt;left);</span><br><span class="line"><span class="keyword">if</span> (offset + leftSize == index) &#123;</span><br><span class="line">IndexedBinarySearchTree&lt;K, V&gt;::printPairNode(node);</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (offset + leftSize &gt; index)</span><br><span class="line">node = node-&gt;left;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">node = node-&gt;right;</span><br><span class="line">offset += (leftSize + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> names[<span class="number">8</span>] = &#123;</span><br><span class="line"><span class="string">"甲"</span>, <span class="string">"乙"</span>, <span class="string">"丙"</span>, <span class="string">"丁"</span>, <span class="string">"戊"</span>, <span class="string">"己"</span>, <span class="string">"庚"</span>, <span class="string">"辛"</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> numbers[<span class="number">8</span>] = &#123; <span class="number">20</span>, <span class="number">15</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">18</span>, <span class="number">30</span>, <span class="number">16</span>, <span class="number">19</span> &#125;;</span><br><span class="line"></span><br><span class="line">IndexedBinarySearchTree&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入键值对</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"插入"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"插入"</span> &lt;&lt; numbers[i] &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">tree.insert(numbers[i], names[i]);</span><br><span class="line">tree.print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"升序排列: "</span>;</span><br><span class="line">tree.ascending();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"索引"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">tree[i];</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下图为例，讲解索引$index=2$的过程</p><ol><li>初始化$offset = 0$；</li><li>$index = 2$时，首先在节点$\mathcal{N}_{20}$比较$2 + offset &lt; 5$，向左搜索；</li><li>在节点$\mathcal{N}_{15}$处$2 + offset&gt; 1$，向右搜索，并更新$offset = offset + \mathcal{N}_{15}.leafSize + 1 = 2$；</li><li>节点$\mathcal{N}_{18}$处$2 &lt; 1 + offset$，向左搜索；在节点$\mathcal{N}_{16}$处$2 = 0 + offset$，返回该节点。</li></ol><p><img src="/2020/03/08/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%90%9C%E7%B4%A2%E6%A0%91/【数据结构】搜索树/index.jpg" alt="index"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">插入</span><br><span class="line">插入20: [20]甲</span><br><span class="line">插入15: [20]甲 [15]乙</span><br><span class="line">插入25: [20]甲 [15]乙 [25]丙</span><br><span class="line">插入12: [20]甲 [15]乙 [25]丙 [12]丁</span><br><span class="line">插入18: [20]甲 [15]乙 [25]丙 [12]丁 [18]戊</span><br><span class="line">插入30: [20]甲 [15]乙 [25]丙 [12]丁 [18]戊 [30]己</span><br><span class="line">插入16: [20]甲 [15]乙 [25]丙 [12]丁 [18]戊 [30]己 [16]庚</span><br><span class="line">插入19: [20]甲 [15]乙 [25]丙 [12]丁 [18]戊 [30]己 [16]庚 [19]辛</span><br><span class="line">升序排列: [12]丁 [15]乙 [16]庚 [18]戊 [19]辛 [20]甲 [25]丙 [30]己</span><br><span class="line"></span><br><span class="line">索引</span><br><span class="line">[12]丁 [15]乙 [16]庚 [18]戊 [19]辛 [20]甲 [25]丙 [30]己</span><br><span class="line"></span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】竞赛树</title>
      <link href="/2020/03/06/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E7%AB%9E%E8%B5%9B%E6%A0%91/"/>
      <url>/2020/03/06/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E7%AB%9E%E8%B5%9B%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="定义及概念"><a href="#定义及概念" class="headerlink" title="定义及概念"></a>定义及概念</h1><p><strong>定义</strong>：<strong>竞赛树</strong>(tournament tree)也是完全二叉树，它的基本操作是替换最大(或最小)元素。如果有$n$个元素，这个基本操作的用时为$\Theta(\log n)$。</p><p>竞赛树可分为<strong>赢者树</strong>(winner tree)和<strong>输者树</strong>(loser tree)，每个内部节点分别记录比赛的赢者和输者。在<strong>最小赢者树</strong>(min winner tree)中，分数小的选手获胜，分数相等则左孩子获胜，<strong>最大赢者树</strong>(max winner tree)反之。</p><p><strong>定义</strong>：有$n$个选手的<strong>赢者树</strong>是一棵完全二叉树，它有$n$个外部节点和$n-1$个内部节点，每个内部节点记录的是在该节点比赛的赢者。它的优点是，当一名选手分数改变时，修改竞赛树比较容易，由底至顶重新对该选手进行比赛即可，需要修改的比赛场次数介于$1 \sim \lceil \log_2 n \rceil$之间。</p><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>可用数组二叉树表示，存储效率最高。为了便于计算机实现，把赢者树限制为完全二叉树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxWinnerTree</span> :</span> <span class="keyword">public</span> ArrayBinaryTree&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">MaxWinnerTree() : ArrayBinaryTree&lt;T&gt;() &#123;&#125;</span><br><span class="line">MaxWinnerTree(T* <span class="built_in">set</span>, <span class="keyword">int</span> n);</span><br><span class="line">~MaxWinnerTree() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i, <span class="keyword">const</span> T&amp; value)</span> </span>&#123; <span class="keyword">this</span>-&gt;m_TElements[i + offset()] = value; &#125;  <span class="comment">// 设置选手i的值</span></span><br><span class="line"><span class="function">T&amp; <span class="title">get</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_TElements[i + offset()]; &#125;   <span class="comment">// 获取选手i的值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">index</span><span class="params">(<span class="keyword">const</span> T&amp; value)</span> <span class="keyword">const</span></span>;    <span class="comment">// 查询选手索引</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">-1</span>)</span></span>;    <span class="comment">// 在忽略选手i的情况下比赛，即始终被视作输者</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replay</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span></span>;       <span class="comment">// 在i的值修改后，对i一系列进行重赛</span></span><br><span class="line"><span class="function">T&amp; <span class="title">winner</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_TElements[<span class="number">0</span>]; &#125;  <span class="comment">// 返回胜者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">offset</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (<span class="keyword">this</span>-&gt;m_iCount - <span class="number">1</span>) / <span class="number">2</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">MaxWinnerTree&lt;T&gt;::MaxWinnerTree(T* <span class="built_in">set</span>, <span class="keyword">int</span> n) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">2</span> * n - <span class="number">1</span>;<span class="comment">// 包含n-1个内部节点与n个外部节点</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_TElements = <span class="keyword">new</span> T[size];</span><br><span class="line">    <span class="built_in">std</span>::copy(<span class="built_in">set</span>, <span class="built_in">set</span> + n, <span class="keyword">this</span>-&gt;m_TElements + n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_iCount = <span class="keyword">this</span>-&gt;m_iSize = size;</span><br><span class="line">    play();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> MaxWinnerTree&lt;T&gt;::play(<span class="keyword">const</span> <span class="keyword">int</span> i) &#123;</span><br><span class="line"><span class="comment">// 从最后一个内部节点开始竞赛</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="keyword">this</span>-&gt;parent(<span class="keyword">this</span>-&gt;m_iCount - <span class="number">1</span>); index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="keyword">this</span>-&gt;left(index); <span class="keyword">int</span> right = <span class="keyword">this</span>-&gt;right(index);</span><br><span class="line"><span class="comment">// 包含忽略的选手</span></span><br><span class="line"><span class="keyword">if</span> (left - offset() == i &amp;&amp; i &gt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">this</span>-&gt;m_TElements[index] = <span class="keyword">this</span>-&gt;m_TElements[right];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (right - offset() == i &amp;&amp; i &gt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">this</span>-&gt;m_TElements[index] = <span class="keyword">this</span>-&gt;m_TElements[left];</span><br><span class="line"><span class="comment">// 所有选手参加比赛</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_TElements[index] = <span class="keyword">this</span>-&gt;m_TElements[left] &gt; <span class="keyword">this</span>-&gt;m_TElements[right] ? \</span><br><span class="line"><span class="keyword">this</span>-&gt;m_TElements[left]: <span class="keyword">this</span>-&gt;m_TElements[right];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> MaxWinnerTree&lt;T&gt;::replay(<span class="keyword">const</span> <span class="keyword">int</span> i) &#123;</span><br><span class="line"><span class="comment">// 对选手i进行重赛</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="keyword">this</span>-&gt;parent(i + offset());<span class="comment">// 寻找父节点</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">index = <span class="keyword">this</span>-&gt;parent(index);</span><br><span class="line"><span class="keyword">int</span> left = <span class="keyword">this</span>-&gt;left(index); </span><br><span class="line"><span class="keyword">int</span> right = <span class="keyword">this</span>-&gt;right(index);</span><br><span class="line"><span class="keyword">this</span>-&gt;m_TElements[index] = <span class="keyword">this</span>-&gt;m_TElements[left] &gt;= <span class="keyword">this</span>-&gt;m_TElements[right] ? \</span><br><span class="line"><span class="keyword">this</span>-&gt;m_TElements[left]: <span class="keyword">this</span>-&gt;m_TElements[right];</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> MaxWinnerTree&lt;T&gt;::index(<span class="keyword">const</span> T&amp; value) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">T* start = <span class="keyword">this</span>-&gt;m_TElements + offset();</span><br><span class="line">T* end = <span class="keyword">this</span>-&gt;m_TElements + <span class="keyword">this</span>-&gt;m_iCount;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>)(<span class="built_in">std</span>::find(start, end, value) - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在完全二叉树的假设下，上述实现可处理奇数个或偶数个参赛选手的情况，测试如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> symbols[<span class="number">32</span>] = &#123;</span><br><span class="line"><span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">20</span>, </span><br><span class="line"><span class="number">8</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">15</span>, </span><br><span class="line"><span class="number">30</span>, <span class="number">17</span>&#125;;</span><br><span class="line">MaxWinnerTree&lt;<span class="keyword">int</span>&gt; tree(symbols, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"size: "</span> &lt;&lt; tree.size() &lt;&lt; <span class="built_in">endl</span> \</span><br><span class="line">&lt;&lt; <span class="string">"height: "</span> &lt;&lt; tree.height() &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">tree.print();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Winner: "</span> &lt;&lt; tree.winner() &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">tree.play(<span class="number">10</span>);      <span class="comment">// 忽略30重赛</span></span><br><span class="line">tree.print();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Winner: "</span> &lt;&lt; tree.winner() &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">tree.<span class="built_in">set</span>(<span class="number">10</span>, <span class="number">2</span>);    <span class="comment">// 修改 30 为 2</span></span><br><span class="line">tree.replay(<span class="number">10</span>);    <span class="comment">// 重赛</span></span><br><span class="line">tree.print();</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">size: 23</span><br><span class="line">height: 5</span><br><span class="line"></span><br><span class="line">30</span><br><span class="line">30 7</span><br><span class="line">20 30 5 7</span><br><span class="line">20 9 15 30 3 5 6 7</span><br><span class="line">20 8 2 9 12 15 30 17</span><br><span class="line">Winner: 30</span><br><span class="line"></span><br><span class="line">20</span><br><span class="line">20 7</span><br><span class="line">20 17 5 7</span><br><span class="line">20 9 15 17 3 5 6 7</span><br><span class="line">20 8 2 9 12 15 30 17</span><br><span class="line">Winner: 20</span><br><span class="line"></span><br><span class="line">20</span><br><span class="line">20 7</span><br><span class="line">20 17 5 7</span><br><span class="line">20 9 15 17 3 5 6 7</span><br><span class="line">20 8 2 9 12 15 2 17</span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure><h1 id="应用：箱子装载问题"><a href="#应用：箱子装载问题" class="headerlink" title="应用：箱子装载问题"></a>应用：箱子装载问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>箱子数量不限，每个箱子的容量为$C_i$，待装箱的物体有$n$个，物品$j$的需要占用$c_j, 0 \leq c_j \leq C_i$。<strong>可行装载</strong>(feasible packing)是指所有物品均装入箱子且不溢出，<strong>最优装载</strong>(optimal packing)是指使用箱子最少的可行装载。</p><h2 id="近似算法"><a href="#近似算法" class="headerlink" title="近似算法"></a>近似算法</h2><p>箱子装载问题是NP-hard问题，常用近似算法求解，求取次优解。有以下几种常用的算法</p><ol><li><strong>最先适配法</strong>(First Fit, FF)：物品与箱子均依次排列，第$j$个物品放入最左边的可装载箱子；</li><li><strong>最优适配法</strong>(Best Fit, BF)：第$j$个物品放入剩余可用容量$\overline{C}_i$最小但不小于$c_j$的箱子；</li><li><strong>最先适配递减法</strong>(First Fit Decreasing, FFD)：类似FF，区别是将物品按所需容量递减排列，即$c_j \geq c_{j+1}$；</li><li><strong>最优适配递减法</strong>(Best Fit Decreasing, BFD)：类似BF，区别是将物品按所需容量递减排列，即$c_j \geq c_{j+1}$。</li></ol><p><strong>定理</strong>：设$I$为箱子装载问题的任一实例，$b(I)$为最优装载所用的箱子数。那么，FF和BF所用箱子不会超过$\frac{17}{10}b(I) + 2$，FFD和BFD所用箱子不会超过$\frac{11}{9}b(I) + 4$。</p><p>用竞赛数实现FF适配法，可由根节点向叶节点搜索，减少时间复杂度。<strong>用竞赛数实现BF适配法</strong>：</p><ul><li>指定箱子数<code>n_bins</code>目与箱子容量<code>capacity</code>，初始化竞赛树所需内存空间与尺寸信息等；</li><li>结果保存为<code>result</code>，保存各个物体所选箱子的索引(0, …, <code>n_objs</code>)；</li><li>输入各物品的所需容量信息<code>objs</code>进行求解；<ol><li>优先查找当前使用容量最大的箱子，也即<strong>剩余容量最小的箱子</strong>，若该箱子能放下物品，则继续下一物品的箱子选择；否则进入2；</li><li>将不符合要求的箱子已使用容量置为<code>-1</code>，使其在竞赛数中<strong>始终无法获胜</strong>，重新比赛查找当前使用容量最大的箱子；</li><li><strong>循环2</strong>直至找到箱子，继续下一物品的箱子选择。</li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinPackingBF</span> :</span> <span class="keyword">public</span> MaxWinnerTree&lt;<span class="keyword">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">BinPackingBF(<span class="keyword">int</span> n = <span class="number">8</span>, <span class="keyword">int</span> capacity = <span class="number">10</span>);<span class="comment">// 箱子数与箱子容量</span></span><br><span class="line">~BinPackingBF() &#123; <span class="keyword">if</span> (result) <span class="keyword">delete</span> result; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>* objs, <span class="keyword">int</span> n)</span></span>;<span class="comment">// 求解</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> n_bins; <span class="keyword">int</span> capacity;</span><br><span class="line"><span class="keyword">int</span>* result; <span class="keyword">int</span> n_objs;    <span class="comment">// 保存每个箱子所在的箱子索引</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BinPackingBF::BinPackingBF(<span class="keyword">int</span> n, <span class="keyword">int</span> capacity)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">2</span> * n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_TElements = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"><span class="keyword">this</span>-&gt;m_iCount = <span class="keyword">this</span>-&gt;m_iSize = size;</span><br><span class="line"><span class="keyword">this</span>-&gt;n_bins = n; <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> BinPackingBF::solve(<span class="keyword">int</span>* objs, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">result = <span class="keyword">new</span> <span class="keyword">int</span>[n];  n_objs = n;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存每次物品放置前的箱子使用情况</span></span><br><span class="line"><span class="keyword">int</span>* bins = <span class="keyword">new</span> <span class="keyword">int</span>[n_bins];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">memset</span>(bins, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n_bins);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (objs[n] &gt; capacity)</span><br><span class="line"><span class="keyword">throw</span> <span class="string">"物体太大！"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将当前箱子使用情况赋值给外部节点</span></span><br><span class="line"><span class="built_in">memcpy</span>(<span class="keyword">this</span>-&gt;m_TElements + <span class="keyword">this</span>-&gt;offset(), bins, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n_bins);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找当前剩余容量最小的箱子</span></span><br><span class="line"><span class="keyword">this</span>-&gt;play();</span><br><span class="line"><span class="keyword">int</span> used = <span class="keyword">this</span>-&gt;winner();<span class="comment">// 当前已使用容量最大的箱子容量</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="keyword">this</span>-&gt;index(used);<span class="comment">// 当前已使用容量最大的箱子索引</span></span><br><span class="line"><span class="keyword">if</span> (capacity - used &gt;= objs[i]) &#123;<span class="comment">// 剩余容量大于物品大小</span></span><br><span class="line">result[i] = index;</span><br><span class="line">bins[index] += objs[i];</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前剩余容量最小的箱子无法装入物品i</span></span><br><span class="line"><span class="keyword">int</span> choosen = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (choosen &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_TElements[index + offset()] = <span class="number">-1</span>;<span class="comment">// 该箱子始终无法获胜</span></span><br><span class="line"><span class="keyword">this</span>-&gt;play();<span class="comment">// 重新竞赛</span></span><br><span class="line">used = <span class="keyword">this</span>-&gt;winner();<span class="comment">// 当前已使用容量最大的箱子容量</span></span><br><span class="line">index = <span class="keyword">this</span>-&gt;index(used);<span class="comment">// 当前已使用容量最大的箱子索引</span></span><br><span class="line"><span class="keyword">if</span> (capacity - used &gt;= objs[i])</span><br><span class="line">choosen = index;</span><br><span class="line">&#125;</span><br><span class="line">result[i] = choosen;</span><br><span class="line">bins[choosen] += objs[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] bins;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> BinPackingBF::print() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_objs; i++)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数测试如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">BinPackingBF <span class="title">puzzle</span><span class="params">(<span class="number">8</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> objs[<span class="number">8</span>] = &#123; <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>&#125;;</span><br><span class="line">puzzle.solve(objs, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">puzzle.print();</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 0 0 1 1 2 1 3</span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure><p>以上输出表示</p><div class="table-container"><table><thead><tr><th>箱子索引</th><th>0</th><th>1</th><th>2</th><th>3</th><th>…</th></tr></thead><tbody><tr><td>箱子物品所需容量</td><td>3, 5, 2</td><td>4, 2, 4</td><td>5</td><td>8</td><td>/</td></tr></tbody></table></div><p>将箱子排序后输入，即为<strong>BFD适配法</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iint <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">BinPackingBF <span class="title">puzzle</span><span class="params">(<span class="number">8</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> objs[<span class="number">8</span>] = &#123; <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span> &#125;;</span><br><span class="line">sort(objs, objs + <span class="number">8</span>, </span><br><span class="line">[](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123; <span class="keyword">return</span> x &gt; y; &#125;);</span><br><span class="line">puzzle.solve(objs, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">puzzle.print();</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 1 1 2 2 3 0 2</span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>箱子索引</th><th>0</th><th>1</th><th>2</th><th>3</th><th>…</th></tr></thead><tbody><tr><td>箱子物品所需容量</td><td>8, 2</td><td>5, 5</td><td>4, 4, 2</td><td>3</td><td>/</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】优先级队列</title>
      <link href="/2020/03/03/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/"/>
      <url>/2020/03/03/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="定义及抽象数据类型"><a href="#定义及抽象数据类型" class="headerlink" title="定义及抽象数据类型"></a>定义及抽象数据类型</h1><p><strong>优先级队列</strong>(priority queue)是$0$个或多个元素的集合，每个元素都有一个优先权或值，在<strong>最小优先级队列</strong>(min priority queue)中，对其进行的元素操作都是当前优先级最小的，<strong>最大优先级队列</strong>(max priority queue)则相反。优先级队列的元素可以有相同的优先级，对这些元素其顺序任意。优先级队列的操作有</p><ul><li>查找一个元素；</li><li>插入一个元素；</li><li>删除一个元素。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">抽象数据类型 PriorityQueue</span><br><span class="line">&#123;</span><br><span class="line">实例：</span><br><span class="line"></span><br><span class="line">操作：</span><br><span class="line">    empty():    队列是否为空</span><br><span class="line">    size():     队列的元素个数</span><br><span class="line">    top():      返回当前优先级最大/最小的元素</span><br><span class="line">    push(x, p): 插入元素，根据优先级调整队列顺序</span><br><span class="line">    pop():      删除并返回当前优先级最大/最小的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="大根堆-小根堆"><a href="#大根堆-小根堆" class="headerlink" title="大根堆/小根堆"></a>大根堆/小根堆</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>定义</strong>：<strong>大根树/小根树</strong>是指每个节点的值都大于其子节点的值的树，节点的子节点个数可以任意。<br><strong>定义</strong>：<strong>大根堆/小根堆</strong>即是大根树/小根数，也是<strong>完全二叉树</strong>。</p><p>利用二叉树的特性，用节点在数组描述中的位置来表示它在堆中的位置。堆作为完全二叉树，具有$n$个元素时高度为$\lceil\log_2(n+1)\rceil$。因此如果能够在$O(height)$时间内完成插入和删除操作，那么操作的复杂度为$O(\log n)$。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="数组描述"><a href="#数组描述" class="headerlink" title="数组描述"></a>数组描述</h3><p>用数组描述大根堆/小根堆更为简便，由于其为完全二叉树，可以将元素存储在连续内存中，并用数组下标作为节点索引。主要实现的有以下几个关键步骤</p><ol><li>获取某节点的<strong>父节点、子节点</strong>；<br> 对于索引为$i$的节点，其父节点为$\lfloor(i - 1) / 2\rfloor$，左右子节点分别为$2 \times i + 1, 2 \times i + 2$。注意索引数组时不能<strong>越界</strong>。</li><li>某节点<strong>“上浮”、“下沉”</strong>；<br> 上浮操作与其父节点进行比较，若满足交换条件则交换；下沉操作需先选择子节点中更大/更小的元素，若满足交换条件则交换。</li><li>堆的初始化、入堆、出堆<ul><li><strong>初始化</strong>：从最后一个<strong>非叶子节点</strong>(也即<strong>最后一个叶节点的父节点</strong>)开始，直至根节点依次进行“下沉”操作；</li><li><strong>入堆</strong>：将节点添加至数组末尾作为最后一个叶节点，进行递归的“上浮”操作直至到达合适位置；</li><li><strong>出堆</strong>：将根节点(首元素)与最后一个叶节点(末元素)交换，删除此时的末尾元素，对当前根节点进行递归的“下沉”操作直至到达合适位置。</li></ul></li></ol><p>在自底向上的建堆过程中，从$i = heapsize / 2$开始，有$1/2$的节点向下比较了$1$次，$1/4$的节点向下比较了$2$次，……，$1/2^k$的节点向下比较了$k$次，其中$1/2^k \leq 1, k \approx \log n$，那么总的比较次数如下，所以建堆的时间复杂度是$O(n)$。</p><script type="math/tex; mode=display">T = n \times \sum_{k=1}^{\log n} k /2^k \leq 2n</script><p>在一次数据插入/删除中，对树型结构进行调整，时间复杂度是$O(\log n)$。</p><p>以下为Python实现<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_Container</span>:</span></span><br><span class="line">    _data = list()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._data)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heap</span><span class="params">(_Container)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, cmp=lambda x, y: x &lt; y)</span>:</span></span><br><span class="line">        self._cmp = cmp</span><br><span class="line">    <span class="comment"># --------------------------</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_valid</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> index &lt; len(self) <span class="keyword">and</span> index &gt;= <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_parent</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (index - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_left</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * index + <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_right</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * index + <span class="number">2</span></span><br><span class="line">    <span class="comment"># --------------------------</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_toTop</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        parent = self._parent(index)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._valid(parent): </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> self._cmp(self._data[parent], self._data[index]):</span><br><span class="line">            self._data[parent], self._data[index] = \</span><br><span class="line">                self._data[index], self._data[parent]</span><br><span class="line">            <span class="keyword">return</span> parent</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_toBottom</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        left, right = self._left(index), self._right(index)</span><br><span class="line">        validL, validR = self._valid(left), self._valid(right)</span><br><span class="line">        <span class="comment"># child</span></span><br><span class="line">        child = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> validL <span class="keyword">and</span> validR:</span><br><span class="line">            child = right <span class="keyword">if</span> self._cmp(</span><br><span class="line">                self._data[left], self._data[right]) <span class="keyword">else</span> left</span><br><span class="line">        <span class="keyword">elif</span> (<span class="keyword">not</span> validL) <span class="keyword">and</span> validR:</span><br><span class="line">            child = right</span><br><span class="line">        <span class="keyword">elif</span> validL <span class="keyword">and</span> <span class="keyword">not</span> validR:</span><br><span class="line">            child = left</span><br><span class="line">        <span class="keyword">if</span> child == <span class="number">-1</span>: <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="comment"># swap</span></span><br><span class="line">        <span class="keyword">if</span> self._cmp(self._data[index], self._data[child]):</span><br><span class="line">            self._data[index], self._data[child] = \</span><br><span class="line">                self._data[child], self._data[index]</span><br><span class="line">            <span class="keyword">return</span> child</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_recursively</span><span class="params">(self, index, adjust)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            index = adjust(index)</span><br><span class="line">            <span class="keyword">if</span> index <span class="keyword">is</span> <span class="keyword">None</span>: </span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># --------------------------</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">heapify</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        self._data = nums</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self._parent(len(self) - <span class="number">1</span>), <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            self._recursively(i, self._toBottom)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        index = len(self)</span><br><span class="line">        self._data.insert(index, x)</span><br><span class="line">        self._recursively(index, self._toTop)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(self) == <span class="number">0</span>: </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self._data[<span class="number">0</span>], self._data[<span class="number">-1</span>] = \</span><br><span class="line">            self._data[<span class="number">-1</span>], self._data[<span class="number">0</span>]</span><br><span class="line">        self._data.pop(<span class="number">-1</span>)</span><br><span class="line">        self._recursively(<span class="number">0</span>, self._toBottom)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(self) == <span class="number">0</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span> self._data[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p><p>STL库中已经包含堆的实现，有以下两种方法</p><ol><li><p>用<code>vector</code>数组模拟堆，实现原理同上<br> 以建立大根堆为例，指定比较函数为<code>less&lt;int&gt;()</code>，也可自定义</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> _cmp(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxheap = &#123; <span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span> &#125;;</span><br><span class="line">make_heap(maxheap.begin(), maxheap.end(), less&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"><span class="comment">// make_heap(maxheap.begin(), maxheap.end(), _cmp);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向堆中插入数据</span></span><br><span class="line">maxheap.push_back(<span class="number">9</span>);   <span class="comment">// 添加至容器尾部</span></span><br><span class="line"><span class="comment">// 调整尾部数据的位置</span></span><br><span class="line">push_heap(maxheap.begin(), maxheap.end(), less&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从堆中获取最大元素</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; maxheap[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除最大元素</span></span><br><span class="line">     <span class="comment">// 与尾部数据交换，并维护前`n-1`个数组成的大根堆</span></span><br><span class="line">pop_heap(maxheap.begin(), maxheap.end(), less&lt;<span class="keyword">int</span>&gt;()); </span><br><span class="line">maxheap.pop_back();   <span class="comment">// 删除容器尾部元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用内置的<code>priority_queue</code>定义大根堆/小根堆</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">cmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line"><span class="comment">// 参数分别表示`_Ty, _Container, _Pr`，以下几种定义等价</span></span><br><span class="line"><span class="comment">//priority_queue&lt;int&gt; maxheap;</span></span><br><span class="line"><span class="comment">//priority_queue&lt;int, vector&lt;int&gt;, _cmp&gt; maxheap;</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; maxheap;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123; <span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="comment">// 插入元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">maxheap.push(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 是否为空</span></span><br><span class="line"><span class="keyword">bool</span> isEmpty = maxheap.empty();</span><br><span class="line"><span class="comment">// 获取元素个数</span></span><br><span class="line"><span class="keyword">int</span> n = maxheap.size();</span><br><span class="line"><span class="comment">// 获取最大元素</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; maxheap.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 删除最大元素</span></span><br><span class="line">maxheap.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】二叉树及其他树</title>
      <link href="/2020/02/29/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E4%BB%96%E6%A0%91/"/>
      <url>/2020/02/29/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E4%BB%96%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p><strong>定义</strong>：一棵树$t$是一个非空的有限元素的集合，其中一个元素为<strong>根</strong>(root)，其余元素组成$t$的子树。根据树的形态，有如下术语：<strong>孩子</strong>(child)、<strong>父母</strong>(parent)、<strong>兄弟</strong>(sibling)、<strong>孙子</strong>(grandchild)、<strong>祖父</strong>(grandparent)、<strong>祖先</strong>(ancestor)、<strong>后代</strong>(descendent)等等。树中没有孩子的元素称作<strong>叶子</strong>(leaf)。</p><p>树的另一常用术语为<strong>级</strong>(level)。树根为$1$级，其孩子为$2$级，以此类推。一棵树的<strong>高度</strong>(height)或<strong>深度</strong>(depth)是树的级个数。<strong>一个元素的度</strong>(degree of an element)是指其孩子的个数，叶节点的度为$0$。<strong>一棵树的度</strong>(degree of a tree)是其元素的度的最大值。</p><p><img src="/2020/02/29/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E4%BB%96%E6%A0%91/【数据结构】二叉树及其他树/trees.jpg" alt="trees"></p><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="定义及概念"><a href="#定义及概念" class="headerlink" title="定义及概念"></a>定义及概念</h2><p><strong>定义</strong>：二叉树(binary tree)是树的一种，其中一个元素为根，其余元素被划分为两棵二叉树，分别称<strong>左子树</strong>和<strong>右子树</strong>。二叉树和树的根本区别是：</p><ul><li>二叉树每个元素恰好有两棵子树(其中存在<strong>空树</strong>)，而树的元素孩子数目不定；</li><li>二叉树的子树是有序的；</li><li>二叉树可以为空，而树不可以。</li></ul><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p><strong>特性(1)</strong>：一棵二叉树有$n(n&gt;0)$个元素，他有$(n-1)$条边。</p><blockquote><p>除根节点外，其余元素有且仅有一个父节点，其间对应一条边。</p></blockquote><p><strong>特性(2)</strong>：一棵二叉树中，度为$2$的节点数，为度为$0$的节点(叶子节点)数目减$1$。</p><blockquote><p>例：已知二叉树中有45个叶节点，有25个度为1的节点，则二叉树的总结点数为____。<br>解析：二叉树中包含度为$0, 1, 2$的节点，叶子节点即度为$0$的节点，那么$(45 + 25 + (45 - 1) = 114)$。</p></blockquote><p><strong>特性(3)</strong>：一棵二叉树的高度为$h(h \geq 0)$，它最少有$h$个元素，最多有$2^h-1$个元素</p><blockquote><ul><li>二叉树的第$1$级包含$1$个元素；</li><li>第$i(i \geq 2)$级最少有$1$个元素，$\Sigma_{i=1}^h 1 = h$；</li><li>第$i(i \geq 2)$级最多有$2^{(i-1)}$个元素，则$\Sigma_{i=2}^h 2^{(i-1)} + 1 = 2^h - 1$；</li></ul></blockquote><p><strong>特性(4)</strong>：一棵二叉树有$n(n&gt;0)$个元素，它的最大高度为$n$，最小高度为$\log_2(n+1)$。</p><p><strong>定义(满二叉树)</strong>：高度为$h$的二叉树恰好有$2^h-1$个元素称为满二叉树(full binary tree)。</p><blockquote><ul><li>满二叉树有$2^(h-1)$个叶子节点，那么内部节点有$2^h - 1 - 2^(h-1) = 2^(h-1) - 1$。</li></ul></blockquote><p><img src="/2020/02/29/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E4%BB%96%E6%A0%91/【数据结构】二叉树及其他树/full_binary_tree.jpg" alt="full_binary_tree"></p><p><strong>定义(完全二叉树)</strong>：高度为$h$的满二叉树，其元素从第$1$级到第$h$级，<strong>每一级从左至右按顺序从$1$到$2^{h-1}$编号</strong>，并且删除$k$个编号为$(2^h-i)$的元素，其中$1 \leq i \leq k &lt; 2^h$，剩余元素组成的树称为完全二叉树(complete binary tree)。<br><img src="/2020/02/29/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E4%BB%96%E6%A0%91/【数据结构】二叉树及其他树/complete_binary_tree_1.jpg" alt="complete_binary_tree_1"><br><img src="/2020/02/29/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E4%BB%96%E6%A0%91/【数据结构】二叉树及其他树/complete_binary_tree_2.jpg" alt="complete_binary_tree_2"></p><p><strong>特性</strong>： 设完全二叉树的一元素其编号为$i$，$1 \leq i \leq n$，则<br>1) 若$i=1$，该元素为根；否则其父节点编号为$\lfloor n/2 \rfloor$；<br>2) 若$2i &gt; n$，则该元素无左孩子；否则其左孩子的编号为$2i$；<br>3) 若$2i+1 &gt; n$，则该元素无右孩子；否则其右孩子的编号为$2i+1$；</p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><h3 id="数组描述"><a href="#数组描述" class="headerlink" title="数组描述"></a>数组描述</h3><p>用数组描述二叉树时，将二叉树表示为缺少了部分元素的完全二叉树，利用完全二叉树的特性对孩子进行索引。当根节点意外的每个节点都是其父节点的右孩子时，所需存储空间最大，称为<strong>右斜二叉树</strong>(right-skewed binary tree)。</p><ol><li><p>不完全二叉树<br> <img src="/2020/02/29/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E4%BB%96%E6%A0%91/【数据结构】二叉树及其他树/array_description.jpg" alt="array_description"></p></li><li><p>右斜二叉树<br> <img src="/2020/02/29/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E4%BB%96%E6%A0%91/【数据结构】二叉树及其他树/array_description_right_skewed.jpg" alt="array_description_right_skewed"></p></li></ol><h3 id="链表描述"><a href="#链表描述" class="headerlink" title="链表描述"></a>链表描述</h3><p>用链表描述二叉树时，除元素数据存储外，每个元素描述为包含两个子节点<code>leftChild</code>与<code>rightChild</code>的节点，若某孩子节点为空则置为<code>NULL</code>。</p><ol><li><p>不完全二叉树<br> <img src="/2020/02/29/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E4%BB%96%E6%A0%91/【数据结构】二叉树及其他树/chain_description.jpg" alt="chain_description"></p></li><li><p>右斜二叉树<br> <img src="/2020/02/29/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E4%BB%96%E6%A0%91/【数据结构】二叉树及其他树/chain_description_right_skewed.jpg" alt="chain_description_right_skewed"></p></li></ol><h3 id="抽象数据描述"><a href="#抽象数据描述" class="headerlink" title="抽象数据描述"></a>抽象数据描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">抽象数据类型 binaryTree</span><br><span class="line">&#123;</span><br><span class="line">实例</span><br><span class="line">    元素集合；左子树、右子树；</span><br><span class="line">操作</span><br><span class="line">    empty() 若树为空返回true否则false</span><br><span class="line">    size()  返回二叉树的节点&#x2F;元素个数</span><br><span class="line">    preOrder(visit)     前序遍历，visit为二叉树节点操作函数</span><br><span class="line">    inOrder(visit)      中序遍历</span><br><span class="line">    postOrder(visit)    后序遍历</span><br><span class="line">    levelOrder(visit)   层次遍历</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="链表描述-1"><a href="#链表描述-1" class="headerlink" title="链表描述"></a>链表描述</h3><h4 id="子节点的声明与定义"><a href="#子节点的声明与定义" class="headerlink" title="子节点的声明与定义"></a>子节点的声明与定义</h4><p>首先，定义二叉树节点如下</p><ul><li>包含三个<code>BinaryTreeNode*</code>类型的公有成员指针变量，保存结点地址信息：父节点、左子树节点、右子树节点；</li><li>私有成员指针变量<code>T*</code>存放节点元素值；</li><li>添加成员函数<code>isRoot()</code>与<code>isLeaf()</code>，用于返回节点部分信息。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">// 左右子树的维护，放在二叉树`LinkedBinaryTree`中处理</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">BinaryTreeNode(BinaryTreeNode&lt;T&gt;* p = <span class="literal">nullptr</span>) : parent(p) &#123;</span><br><span class="line">left  = right = <span class="literal">nullptr</span>;  value = <span class="keyword">new</span> T; &#125;</span><br><span class="line">~BinaryTreeNode() &#123; <span class="keyword">delete</span> value; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isRoot</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> !parent; &#125;<span class="comment">// 是否为根节点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLeaf</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (!left) &amp;&amp; (!right); &#125;<span class="comment">// 是否为叶子节点</span></span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> *value; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">const</span> T&amp; v)</span> </span>&#123; *value = v; &#125;</span><br><span class="line"></span><br><span class="line">BinaryTreeNode* parent;<span class="comment">// 增加父母节点信息</span></span><br><span class="line">BinaryTreeNode* left, *right;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="树的声明"><a href="#树的声明" class="headerlink" title="树的声明"></a>树的声明</h4><p>以下采用链表描述实现二叉树</p><ul><li>私有指针变量<code>m_tnRoot</code>存放根节点的地址；</li><li>重载构造函数，进行根节点的初始化或树的创建；析构函数中做节点内存释放的清理工作；</li><li>共有成员函数<code>size()</code>,<code>height()</code>,<code>empty()</code>,<code>print()</code>用以获取树的信息；</li><li><code>[*]Order</code>以不同的遍历顺序访问和修改节点；</li><li>私有静态成员函数<code>[*]Node</code>为单个节点的访问和修改函数，供<code>[*]Order</code>调用；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedBinaryTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">LinkedBinaryTree();</span><br><span class="line">LinkedBinaryTree(T*, <span class="keyword">int</span>);<span class="comment">// 由给定集合生成二叉树，空叶节点用`#`表示，形如`&#123;3,9,20,#,#,15,7&#125;`</span></span><br><span class="line">LinkedBinaryTree(<span class="keyword">const</span> LinkedBinaryTree&lt;T&gt;&amp;);</span><br><span class="line">~LinkedBinaryTree();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;<span class="comment">// 二叉树结点数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">()</span></span>;<span class="comment">// 二叉树高度</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>;<span class="comment">// 二叉树是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> mode = <span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span></span>;<span class="comment">// 交换二叉树的左右子节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------ 深度优先搜索 ------------------ </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(<span class="keyword">void</span> (*visit)(BinaryTreeNode&lt;T&gt;* node), BinaryTreeNode&lt;T&gt;* node = m_tnRoot)</span></span>;<span class="comment">// 前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(<span class="keyword">void</span> (*visit)(BinaryTreeNode&lt;T&gt;* node), BinaryTreeNode&lt;T&gt;* node = m_tnRoot)</span></span>;<span class="comment">// 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(<span class="keyword">void</span> (*visit)(BinaryTreeNode&lt;T&gt;* node), BinaryTreeNode&lt;T&gt;* node = m_tnRoot)</span></span>;<span class="comment">// 后序遍历</span></span><br><span class="line"><span class="comment">// ------------------ 广度优先搜索 ------------------ </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(<span class="keyword">void</span> (*visit)(BinaryTreeNode&lt;T&gt; * node), BinaryTreeNode&lt;T&gt; * node = m_tnRoot)</span></span>;<span class="comment">// 层次遍历</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">static</span> LinkedQueue&lt;BinaryTreeNode&lt;T&gt;**&gt;* tree2flattenQueue(BinaryTreeNode&lt;T&gt;** ptr);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 节点操作，注意需要定义为static成员函数，才能取址供遍历函数调用</span></span><br><span class="line">    <span class="keyword">static</span> BinaryTreeNode&lt;T&gt;* createNode(BinaryTreeNode&lt;T&gt;* p = <span class="literal">nullptr</span>);</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(BinaryTreeNode&lt;T&gt;* node)</span></span>;</span><br><span class="line">BinaryTreeNode&lt;T&gt;* m_tnRoot;<span class="comment">// 根节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNode</span><span class="params">(BinaryTreeNode&lt;T&gt;* node)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swapNode</span><span class="params">(BinaryTreeNode&lt;T&gt;* node)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span>  <span class="title">sizeofNode</span><span class="params">(BinaryTreeNode&lt;T&gt;* node)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">heightofNode</span><span class="params">(BinaryTreeNode&lt;T&gt;* node)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="树的遍历方法"><a href="#树的遍历方法" class="headerlink" title="树的遍历方法"></a>树的遍历方法</h4><p><strong>定义</strong>：二叉树的<strong>遍历</strong>(traversal)中，每个元素仅被访问一次。有四种常用的遍历方法<br>1) 前序遍历；<br>2) 中序遍历；<br>3) 后序遍历；<br>4) 层次遍历。</p><p>其中，前三种为<strong>深度优先探索方法</strong>，最后一种为<strong>广度优先搜索方法</strong>。</p><ol><li><p>前序遍历<br> 前序遍历是指在访问某节点<code>node</code>时，<strong>先对该节点进行值的访问或修改，再依次对其左子树、右子树进行同样的嵌套操作</strong>。在<a href="#%e6%a0%91%e7%9a%84%e5%ae%9a%e4%b9%89%e4%b8%8e%e5%a3%b0%e6%98%8e">树的定义与声明</a>成员函数<code>preOrder</code>定义如下</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> LinkedBinaryTree&lt;T&gt;::preOrder(<span class="keyword">void</span> (*visit)(BinaryTreeNode&lt;T&gt;* node), BinaryTreeNode&lt;T&gt;* node)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span>; </span><br><span class="line">    visit(node); </span><br><span class="line">    preOrder(visit, node-&gt;left); </span><br><span class="line">    preOrder(visit, node-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>中序遍历<br> 中序遍历是指在访问某节点<code>node</code>时，<strong>对其元素的访问或修改放在左子树、右子树的嵌套操作之间</strong>。在<a href="#%e6%a0%91%e7%9a%84%e5%ae%9a%e4%b9%89%e4%b8%8e%e5%a3%b0%e6%98%8e">树的定义与声明</a>成员函数<code>inOrder</code>定义如下</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> LinkedBinaryTree&lt;T&gt;::inOrder(<span class="keyword">void</span> (*visit)(BinaryTreeNode&lt;T&gt;* node), BinaryTreeNode&lt;T&gt;* node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span>; </span><br><span class="line">    inOrder(visit, node-&gt;left); </span><br><span class="line">    visit(node); </span><br><span class="line">    inOrder(visit, node-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>后序遍历<br> 后序遍历是指在访问某节点<code>node</code>时，<strong>对其元素的访问或修改放在左子树、右子树的嵌套操作之后</strong>。考虑到后续遍历与前序遍历的不同，其<strong>左右子节点的访问也倒序访问</strong>，在<a href="#%e6%a0%91%e7%9a%84%e5%ae%9a%e4%b9%89%e4%b8%8e%e5%a3%b0%e6%98%8e">树的定义与声明</a>成员函数<code>postOrder</code>定义如下</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> LinkedBinaryTree&lt;T&gt;::postOrder(<span class="keyword">void</span> (*visit)(BinaryTreeNode&lt;T&gt;* node), BinaryTreeNode&lt;T&gt;* node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span>; </span><br><span class="line">    postOrder(visit, node-&gt;right);</span><br><span class="line">    postOrder(visit, node-&gt;left); </span><br><span class="line">    visit(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>层次遍历<br> 层次遍历是一种广度优先搜索方法，需要某层的节点<strong>按完全二叉树的顺序</strong>依次访问。</p><ol><li><p>将二叉树非空节点按顺序存入队列<code>LinkedQueue&lt;BinaryTreeNode&lt;T&gt;**&gt;* ordered</code>中，具体过程为</p><ol><li>初始化队列<code>queue</code>，将树/子树的根节点存入；</li><li>初始化队列<code>ordered</code>，暂时为空；</li><li>从<code>queue</code>中弹出一个节点作为父节点，将此节点存入<code>ordered</code>，并将其<strong>非空左右子节点</strong>存入<code>queue</code>作为后续的父节点，即“<strong>出一进二</strong>”，不断循环直至<code>queue</code>为空；</li><li><p>返回节点<code>ordered</code>。</p><p>值得注意的是，<code>tree2flattenQueue</code>函数需要传入父节点的地址<code>&amp;root</code>。</p></li></ol></li><li><p>由队列特性，按先入先出的顺序，依次对<code>ordered</code>的元素进行访问。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> LinkedBinaryTree&lt;T&gt;::levelOrder(<span class="keyword">void</span> (*visit)(BinaryTreeNode&lt;T&gt;* node), BinaryTreeNode&lt;T&gt;* node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">    LinkedQueue&lt;BinaryTreeNode&lt;T&gt;**&gt;* ordered = tree2flattenQueue(&amp;node);</span><br><span class="line">    <span class="keyword">while</span> (ordered-&gt;size() &gt; <span class="number">0</span>) &#123; </span><br><span class="line">        BinaryTreeNode&lt;T&gt;** n = ordered-&gt;pop();</span><br><span class="line">        visit(*n); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> ordered;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">LinkedQueue&lt;BinaryTreeNode&lt;T&gt;**&gt;* LinkedBinaryTree&lt;T&gt;::tree2flattenQueue(BinaryTreeNode&lt;T&gt;** ptr) &#123;</span><br><span class="line">    <span class="comment">// - 需要获取`m_tnRoot`的地址，不可定义形参`BinaryTreeNode&lt;T&gt;* node = m_tnRoot`再将`&amp;node`存储，因为函数返回后，形参`node`将被释放</span></span><br><span class="line">    <span class="comment">// - 注意这里要定义二级指针，否则在出队列时，会将节点破坏</span></span><br><span class="line">    LinkedQueue&lt;BinaryTreeNode&lt;T&gt;**&gt;* <span class="built_in">queue</span> = <span class="keyword">new</span> LinkedQueue&lt;BinaryTreeNode&lt;T&gt;**&gt;;<span class="comment">// 中间过程使用的队列</span></span><br><span class="line">    LinkedQueue&lt;BinaryTreeNode&lt;T&gt;**&gt;* ordered = <span class="keyword">new</span> LinkedQueue&lt;BinaryTreeNode&lt;T&gt;**&gt;;<span class="comment">// 已排序的队列</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>-&gt;push(ptr);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">queue</span>-&gt;size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        BinaryTreeNode&lt;T&gt;** p = <span class="built_in">queue</span>-&gt;pop();<span class="comment">// 弹出队首元素</span></span><br><span class="line">        ordered-&gt;push(p);<span class="comment">// 将该节点存入已排序队列</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将子节点存入队列</span></span><br><span class="line">        <span class="keyword">if</span> ((*p)-&gt;left) <span class="built_in">queue</span>-&gt;push(&amp;((*p)-&gt;left));</span><br><span class="line">        <span class="keyword">if</span> ((*p)-&gt;right) <span class="built_in">queue</span>-&gt;push(&amp;((*p)-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">queue</span>;</span><br><span class="line">    <span class="keyword">return</span> ordered;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h4 id="树的函数定义"><a href="#树的函数定义" class="headerlink" title="树的函数定义"></a>树的函数定义</h4><ol><li><p>构造函数、复制构造函数、析构函数</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">LinkedBinaryTree&lt;T&gt;::LinkedBinaryTree() </span><br><span class="line">&#123; </span><br><span class="line">    m_tnRoot = <span class="literal">nullptr</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">LinkedBinaryTree&lt;T&gt;::~LinkedBinaryTree() </span><br><span class="line">&#123; </span><br><span class="line">    postOrder(&amp;deleteNode, m_tnRoot); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 重载了构造函数，可传入数组变量进行树的构造，各元素按完全二叉树的编号顺序进行输入，若节点为空，数组中置为字符<code>&#39;#&#39;</code>。在节点的输入时，参考层级遍历的方法，借助队列实现。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">LinkedBinaryTree&lt;T&gt;::LinkedBinaryTree(T* <span class="built_in">set</span>, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化根节点</span></span><br><span class="line">    m_tnRoot = createNode(); m_tnRoot-&gt;<span class="built_in">set</span>(<span class="built_in">set</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化队列</span></span><br><span class="line">    LinkedQueue&lt;BinaryTreeNode&lt;T&gt;*&gt; queueParent;<span class="comment">// 中间过程使用的队列</span></span><br><span class="line">    queueParent.push(m_tnRoot);<span class="comment">// 放入根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (queueParent.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        BinaryTreeNode&lt;T&gt;* parent = queueParent.pop();        <span class="comment">// 弹出父节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ------------- 左子树 -------------</span></span><br><span class="line">        <span class="keyword">if</span> ((++cnt) &gt;= n) <span class="keyword">break</span>;</span><br><span class="line">        T val = <span class="built_in">set</span>[cnt];</span><br><span class="line">        <span class="keyword">if</span> (val != (T)<span class="string">'#'</span>) &#123;</span><br><span class="line">            BinaryTreeNode&lt;T&gt;* left = createNode(parent);<span class="comment">// 创建左子树</span></span><br><span class="line">            left-&gt;<span class="built_in">set</span>(val);<span class="comment">// 赋值</span></span><br><span class="line">            parent-&gt;left = left;        <span class="comment">// 子节点链接到父节点</span></span><br><span class="line">            queueParent.push(left);        <span class="comment">// 置入队列</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ------------- 右子树 -------------</span></span><br><span class="line">        <span class="keyword">if</span> ((++cnt) &gt;= n) <span class="keyword">break</span>;</span><br><span class="line">        val = <span class="built_in">set</span>[cnt];</span><br><span class="line">        <span class="keyword">if</span> (val != (T)<span class="string">'#'</span>) &#123;</span><br><span class="line">            BinaryTreeNode&lt;T&gt;* right = createNode(parent);<span class="comment">// 创建右子树</span></span><br><span class="line">            right-&gt;<span class="built_in">set</span>(val);<span class="comment">// 赋值</span></span><br><span class="line">            parent-&gt;right = right;<span class="comment">// 子节点链接到父节点</span></span><br><span class="line">            queueParent.push(right);<span class="comment">// 置入队列</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 复制构造函数主要实现树间的<strong>深拷贝</strong>，即必须保证两棵树没有内存共享的情况下值完全一致，有以下关键点</p><ul><li>节点的创建，即开辟新的内存并赋值；</li><li><p>节点间的关系，由<code>parent</code>、<code>left</code>、<code>right</code>三个指针共同维护一棵树的结构，因此只需各个节点的指针信息正确对应所指节点，将父节点为空的节点作为树的根节点，一棵树就能“<strong>立起来</strong>”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">LinkedBinaryTree&lt;T&gt;::LinkedBinaryTree(<span class="keyword">const</span> LinkedBinaryTree&lt;T&gt;&amp; tree)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化待拷贝数组</span></span><br><span class="line">    LinkedQueue&lt;BinaryTreeNode&lt;T&gt;**&gt;* queuePtrFrom = tree2flattenQueue(<span class="keyword">const_cast</span>&lt;BinaryTreeNode&lt;T&gt;**&gt;(&amp;tree.m_tnRoot));    <span class="comment">// 取消`const`特性</span></span><br><span class="line">    LinkedQueue&lt; BinaryTreeNode&lt;T&gt;*&gt;* queueFrom = <span class="keyword">new</span> LinkedQueue&lt; BinaryTreeNode&lt;T&gt;*&gt;;</span><br><span class="line">    <span class="keyword">while</span> (queuePtrFrom-&gt;size() &gt; <span class="number">0</span>) &#123; queueFrom-&gt;push(*(queuePtrFrom-&gt;pop())); &#125;</span><br><span class="line">    <span class="keyword">delete</span> queuePtrFrom;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更改类型为列表，便于查找，实际上不修改可也</span></span><br><span class="line">    ChainList&lt;BinaryTreeNode&lt;T&gt;*&gt;* listFrom = queueFrom;</span><br><span class="line">    ChainList&lt;BinaryTreeNode&lt;T&gt;*&gt;* listTo = <span class="keyword">new</span> ChainList&lt;BinaryTreeNode&lt;T&gt;*&gt;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复制数组的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; listFrom-&gt;size(); i++) &#123;</span><br><span class="line">        BinaryTreeNode&lt;T&gt;* nodeFrom = listFrom-&gt;get(i);</span><br><span class="line">        BinaryTreeNode&lt;T&gt;* nodeTo = <span class="keyword">new</span> BinaryTreeNode &lt;T&gt;;<span class="comment">// 创建节点</span></span><br><span class="line">        nodeTo-&gt;<span class="built_in">set</span>(nodeFrom-&gt;get());<span class="comment">// 复制值</span></span><br><span class="line">        listTo-&gt;insert(listTo-&gt;size(), nodeTo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链接节点间关系</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; listFrom-&gt;size(); i++) &#123;</span><br><span class="line">        BinaryTreeNode&lt;T&gt;* nodeFrom = listFrom-&gt;get(i);</span><br><span class="line">        BinaryTreeNode&lt;T&gt;* nodeTo   = listTo  -&gt;get(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 父节点</span></span><br><span class="line">        <span class="keyword">if</span> (nodeFrom-&gt;parent) &#123;</span><br><span class="line">            index = listFrom-&gt;indexOf(nodeFrom-&gt;parent);</span><br><span class="line">            nodeTo-&gt;parent = listTo-&gt;get(index);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            m_tnRoot = nodeTo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左右子树节点</span></span><br><span class="line">        <span class="keyword">if</span> (nodeFrom-&gt;left) &#123;</span><br><span class="line">            index = listFrom-&gt;indexOf(nodeFrom-&gt;left);</span><br><span class="line">            nodeTo-&gt;left = listTo-&gt;get(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nodeFrom-&gt;right) &#123;</span><br><span class="line">            index = listFrom-&gt;indexOf(nodeFrom-&gt;right);</span><br><span class="line">            nodeTo-&gt;right = listTo-&gt;get(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> listFrom; <span class="keyword">delete</span> listTo; <span class="comment">// 回收内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>树的信息</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> LinkedBinaryTree&lt;T&gt;::size() </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">return</span> sizeofNode(m_tnRoot); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span>  LinkedBinaryTree&lt;T&gt;::sizeofNode(BinaryTreeNode&lt;T&gt;* node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 采用后续遍历</span></span><br><span class="line">    <span class="keyword">int</span> sizeL = sizeofNode(node-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> sizeR = sizeofNode(node-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + sizeL + sizeR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> LinkedBinaryTree&lt;T&gt;::height() </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">return</span> heightofNode(m_tnRoot); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> LinkedBinaryTree&lt;T&gt;::heightofNode(BinaryTreeNode&lt;T&gt;* node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 采用后续遍历</span></span><br><span class="line">    <span class="keyword">int</span> heightL = heightofNode(node-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> heightR = heightofNode(node-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + (heightL &gt; heightR ? heightL : heightR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> LinkedBinaryTree&lt;T&gt;::empty() </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">return</span> size() == <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> LinkedBinaryTree&lt;T&gt;::print(<span class="keyword">int</span> mode) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (mode)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"preOrder: "</span>;</span><br><span class="line">        preOrder(&amp;printNode, m_tnRoot);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"inOrder: "</span>;</span><br><span class="line">        inOrder(&amp;printNode, m_tnRoot);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"postOrder: "</span>;</span><br><span class="line">        postOrder(&amp;printNode, m_tnRoot);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"levelOrder: "</span>;</span><br><span class="line">        levelOrder(&amp;printNode, m_tnRoot);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>树的操作<br> 交换每个节点的左右子树</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> LinkedBinaryTree&lt;T&gt;::swap()</span><br><span class="line">&#123;</span><br><span class="line">    preOrder(&amp;swapNode, m_tnRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>节点操作与访问</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BinaryTreeNode&lt;T&gt;* LinkedBinaryTree&lt;T&gt;::createNode(BinaryTreeNode&lt;T&gt;* p) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BinaryTreeNode&lt;T&gt;(p); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> LinkedBinaryTree&lt;T&gt;::deleteNode(BinaryTreeNode&lt;T&gt;* node) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span>; </span><br><span class="line">    <span class="keyword">delete</span> node; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> LinkedBinaryTree&lt;T&gt;::printNode(BinaryTreeNode&lt;T&gt;* node) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span>; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; node-&gt;get() &lt;&lt; <span class="string">" "</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> LinkedBinaryTree&lt;T&gt;::swapNode(BinaryTreeNode&lt;T&gt;* node)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">    BinaryTreeNode&lt;T&gt;* temp = node-&gt;left;</span><br><span class="line">    node-&gt;left = node-&gt;right;</span><br><span class="line">    node-&gt;right = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="数组描述-1"><a href="#数组描述-1" class="headerlink" title="数组描述"></a>数组描述</h3><p>数组描述比较简单，只需将节点按照完全二叉树进行标号，正确计算节点间的索引关系即可，访问元素更为便捷并节省空间。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayBinaryTree</span>:</span> <span class="keyword">public</span> ArrayList&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">ArrayBinaryTree() :ArrayList&lt;T&gt;() &#123;&#125;</span><br><span class="line">ArrayBinaryTree(T* <span class="built_in">set</span>, <span class="keyword">int</span> n) &#123;<span class="comment">// 由给定集合生成二叉树，空叶节点用`#`表示，形如`&#123;3,9,20,#,#,15,7&#125;`</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_TElements = <span class="keyword">new</span> T[n];</span><br><span class="line"><span class="built_in">std</span>::copy(<span class="built_in">set</span>, <span class="built_in">set</span> + n, <span class="keyword">this</span>-&gt;m_TElements);</span><br><span class="line"><span class="keyword">this</span>-&gt;m_iCount = <span class="keyword">this</span>-&gt;m_iSize = n;</span><br><span class="line">&#125;</span><br><span class="line">ArrayBinaryTree(<span class="keyword">const</span> ArrayBinaryTree&lt;T&gt;&amp; tree) &#123;</span><br><span class="line"><span class="keyword">int</span> n = tree.size();</span><br><span class="line"><span class="keyword">this</span>-&gt;m_TElements = <span class="keyword">new</span> T[n];</span><br><span class="line"><span class="built_in">std</span>::copy(tree.m_TElements, tree.m_TElements + n, <span class="keyword">this</span>-&gt;m_TElements);</span><br><span class="line"><span class="keyword">this</span>-&gt;m_iCount = <span class="keyword">this</span>-&gt;m_iSize = n;</span><br><span class="line">&#125;</span><br><span class="line">~ArrayBinaryTree() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sizeOfNode(<span class="number">0</span>); &#125;<span class="comment">// 二叉树结点数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> heightofNode(<span class="number">0</span>); &#125;<span class="comment">// 二叉树高度</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> size() == <span class="number">0</span>; &#125;<span class="comment">// 二叉树是否为空</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> H = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_iCount; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> h = <span class="built_in">std</span>::<span class="built_in">floor</span>(<span class="built_in">std</span>::log2(i + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span> (h &gt; H) &#123;</span><br><span class="line">                    H = h;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_TElements[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// ------------------ 深度优先搜索 ------------------ </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(<span class="keyword">void</span> (*visit)(<span class="keyword">int</span> node), <span class="keyword">int</span> node = <span class="number">0</span>)</span> </span>&#123;<span class="comment">// 前序遍历</span></span><br><span class="line"><span class="keyword">if</span> (!checkNode(node)) <span class="keyword">return</span>; visit(node); preOrder(visit, left(node)); preOrder(visit, right(node)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(<span class="keyword">void</span> (*visit)(<span class="keyword">int</span> node), <span class="keyword">int</span> node = <span class="number">0</span>)</span> </span>&#123;<span class="comment">// 中序遍历</span></span><br><span class="line"><span class="keyword">if</span> (!checkNode(node)) <span class="keyword">return</span>; inOrder(visit, left(node)); visit(node); inOrder(visit, right(node)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(<span class="keyword">void</span> (*visit)(<span class="keyword">int</span> node), <span class="keyword">int</span> node = <span class="number">0</span>)</span> </span>&#123;<span class="comment">// 后序遍历</span></span><br><span class="line"><span class="keyword">if</span> (!checkNode(node)) <span class="keyword">return</span>; postOrder(visit, left(node)); postOrder(visit, right(node)); visit(node); &#125;</span><br><span class="line"><span class="comment">// ------------------ 广度优先搜索 ------------------ </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(<span class="keyword">void</span> (*visit)(<span class="keyword">int</span> node), <span class="keyword">int</span> node = <span class="number">0</span>)</span> </span>&#123;<span class="comment">// 层次遍历</span></span><br><span class="line"><span class="keyword">if</span> (!checkNode(node)) <span class="keyword">return</span>; <span class="keyword">for</span> (<span class="keyword">int</span> i = node; i &lt; <span class="keyword">this</span>-&gt;m_iCount; i++) visit(i); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkNode</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123; </span><br><span class="line"><span class="keyword">if</span> (node &lt; <span class="number">0</span> || node &gt;= <span class="keyword">this</span>-&gt;m_iCount) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_TElements[node] == (T)<span class="string">'#'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123; <span class="keyword">return</span> (node - <span class="number">1</span>) / <span class="number">2</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span> * (node + <span class="number">1</span>) - <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span> * (node + <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sizeOfNode</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!checkNode(node)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sizeL = sizeOfNode(left(node));</span><br><span class="line"><span class="keyword">int</span> sizeR = sizeOfNode(right(node));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> + sizeL + sizeR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">heightofNode</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!checkNode(node)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> heightL = heightofNode(left(node));</span><br><span class="line"><span class="keyword">int</span> heightR = heightofNode(right(node));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> + (heightL &gt; heightR ? heightL : heightR);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>二叉树的一个应用是计算图的表示，单个节点的值为操作符，左右子树为操作数，例如对于运算式</p><script type="math/tex; mode=display">((a + b) > (c > e)) | a < b \& (x < y | y > z)</script><p>其运算图为<br><img src="/2020/02/29/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E4%BB%96%E6%A0%91/【数据结构】二叉树及其他树/calculate.jpg" alt="calculate"></p><p>由<code>LinkedBinaryTree&lt;T&gt;</code>派生出类<code>Expression</code>，指定其输入输入类型为字符(<code>char</code>)</p><blockquote><ol><li>子类调用父类成员时，需添加<code>this-&gt;</code>指针；</li><li>公有继承时，父类公有成员与保护成员权限不变，但子类不继承私有成员；</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Expression</span> :</span> <span class="keyword">public</span> LinkedBinaryTree&lt;<span class="keyword">char</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Expression(<span class="keyword">char</span>* symbols, <span class="keyword">int</span> n) : LinkedBinaryTree&lt;<span class="keyword">char</span>&gt;(symbols, n) &#123; translate(); &#125;</span><br><span class="line">~Expression() &#123; <span class="keyword">if</span> (expression) <span class="keyword">delete</span> expression; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> LinkedBinaryTree&lt;<span class="keyword">char</span>&gt;::size(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> LinkedBinaryTree&lt;<span class="keyword">char</span>&gt;::height(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> LinkedBinaryTree&lt;<span class="keyword">char</span>&gt;::empty(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> mode = <span class="number">3</span>)</span> </span>&#123; LinkedBinaryTree&lt;<span class="keyword">char</span>&gt;::print(mode); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">fCalculate</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">char</span>* expression;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">translate</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">translateNode</span><span class="params">(BinaryTreeNode&lt;<span class="keyword">char</span>&gt;* node, <span class="keyword">char</span>* buff, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">float</span> <span class="title">fCalculateNode</span><span class="params">(BinaryTreeNode&lt;<span class="keyword">char</span>&gt;* node)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">float</span> <span class="title">char2float</span><span class="params">(<span class="keyword">char</span>&amp; c)</span> </span>&#123; <span class="keyword">return</span> c - <span class="string">'0'</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可通过打印各节点对比查看<strong>前序遍历、中序遍历、后序遍历、层级遍历间的区别</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> symbols[<span class="number">32</span>] = &#123;</span><br><span class="line"><span class="string">'|'</span>,</span><br><span class="line"><span class="string">'&gt;'</span>, <span class="string">'&amp;'</span>,</span><br><span class="line"><span class="string">'+'</span>, <span class="string">'-'</span>, <span class="string">'&lt;'</span>, <span class="string">'|'</span>,</span><br><span class="line"><span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'&lt;'</span>, <span class="string">'&gt;'</span>,</span><br><span class="line"><span class="string">'#'</span>, <span class="string">'#'</span>, <span class="string">'#'</span>, <span class="string">'#'</span>, <span class="string">'#'</span>, <span class="string">'#'</span>, <span class="string">'#'</span>, <span class="string">'#'</span>, <span class="string">'#'</span>, <span class="string">'#'</span>, <span class="string">'#'</span>, <span class="string">'#'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'y'</span>, <span class="string">'z'</span> &#125;;</span><br><span class="line"><span class="function">Expression <span class="title">expression</span><span class="params">(symbols, <span class="number">31</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"size: "</span> &lt;&lt; expression.size() &lt;&lt; <span class="built_in">endl</span> \</span><br><span class="line">&lt;&lt; <span class="string">"height: "</span> &lt;&lt; expression.height() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) expression.print(i);</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其输出如下，得到分别为<strong>前缀</strong>(prefix)、<strong>中缀</strong>(infix)、<strong>后缀</strong>(postfix)形式的输出<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">size: 19</span><br><span class="line">height: 5</span><br><span class="line">preOrder: | &gt; + a b - c e &amp; &lt; a b | &lt; x y &gt; y z</span><br><span class="line">inOrder: a + b &gt; c - e | a &lt; b &amp; x &lt; y | y &gt; z</span><br><span class="line">postOrder: z y &gt; y x &lt; | b a &lt; &amp; e c - b a + &gt; |</span><br><span class="line">levelOrder: | &gt; &amp; + - &lt; | a b c e a b &lt; &gt; x y y z</span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure></p><p>可以看到三张顺序输出结果差异较大，如下图所示，<strong>中序遍历<code>inOrder</code>是通常的书写形式</strong>。<br><img src="/2020/02/29/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E4%BB%96%E6%A0%91/【数据结构】二叉树及其他树/calculate_pre.jpg" alt="calculate_pre"><br><img src="/2020/02/29/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E4%BB%96%E6%A0%91/【数据结构】二叉树及其他树/calculate_in.jpg" alt="calculate_in"><br><img src="/2020/02/29/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E4%BB%96%E6%A0%91/【数据结构】二叉树及其他树/calculate_post.jpg" alt="calculate_post"><br><img src="/2020/02/29/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E4%BB%96%E6%A0%91/【数据结构】二叉树及其他树/calculate_lv.jpg" alt="calculate_lv"></p><p>在实际使用该类用于计算时，应考虑<strong>运算优先级</strong>，有以下几种解决方法</p><ol><li>给不同的运算符设置不同的优先级，例如<code>×, ÷</code>比<code>+, -</code>优先级更高；</li><li><p>将操作符的每个操作数用括号括起来，如其成员函数<code>translate()</code>与<code>translateNode()</code>实现如下</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Expression::translate()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!expression) &#123;</span><br><span class="line">        expression = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">256</span>]; expression[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    translateNode(<span class="keyword">this</span>-&gt;m_tnRoot, expression, <span class="number">256</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Expression::translateNode(BinaryTreeNode&lt;<span class="keyword">char</span>&gt;* node, <span class="keyword">char</span>* buff, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 嵌套中止条件：叶节点</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;isLeaf()) &#123;</span><br><span class="line">        sprintf_s(buff, n, <span class="string">"%s%c%c%c"</span>, buff, <span class="string">'('</span>, node-&gt;get(), <span class="string">')'</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    translateNode(node-&gt;left, buff, n);<span class="comment">// 左子树</span></span><br><span class="line">    sprintf_s(buff, n, <span class="string">"%c%s%c"</span>, <span class="string">'('</span>, buff, node-&gt;get());</span><br><span class="line">    translateNode(node-&gt;right, buff, n);<span class="comment">// 右子树</span></span><br><span class="line">    sprintf_s(buff, n, <span class="string">"%s%c"</span>, buff, <span class="string">')'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 调用<code>cout &lt;&lt; expression.expression &lt;&lt; endl;</code>后，输出为$ ((((((((((a)+(b))&gt;(c)-(e)))|(a)&lt;(b))\&amp;(x)&lt;(y))|(y)&gt;(z)))))$，<strong>外层冗余括号不影响计算结果</strong>。</p></li><li><p><strong>按节点计算</strong>时，已根据输入形式自动考虑运算优先次序，实现如下</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> Expression::fCalculate() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> fCalculateNode(<span class="keyword">this</span>-&gt;m_tnRoot);<span class="comment">// 计算根节点的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> Expression::fCalculateNode(BinaryTreeNode&lt;<span class="keyword">char</span>&gt;* node)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若为叶子节点，返回操作数</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;isLeaf()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = node-&gt;get();</span><br><span class="line">        <span class="keyword">return</span> char2float(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不为叶子节点，获取左右子树的运算结果</span></span><br><span class="line">    <span class="keyword">float</span> x = fCalculateNode(node-&gt;left);</span><br><span class="line">    <span class="keyword">float</span> y = fCalculateNode(node-&gt;right);</span><br><span class="line">    <span class="comment">// 从自身读取操作符，并运算</span></span><br><span class="line">    <span class="keyword">char</span> op = node-&gt;get();</span><br><span class="line">    <span class="keyword">switch</span> (op)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">        <span class="keyword">return</span> x - y;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">        <span class="keyword">return</span> x * y;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">        <span class="keyword">return</span> x / y;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">"未定义的运算符"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 输入$(1+2)/(5\times6-7)$得到输出 <code>(((((1)+(2))/(5)*(6))-(7))) = 0.130435</code></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> symbols[<span class="number">32</span>] = &#123;</span><br><span class="line">        <span class="string">'/'</span>,</span><br><span class="line">        <span class="string">'+'</span>, <span class="string">'-'</span>, </span><br><span class="line">        <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'*'</span>, <span class="string">'7'</span>,</span><br><span class="line">        <span class="string">'#'</span>, <span class="string">'#'</span>, <span class="string">'#'</span>, <span class="string">'#'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>&#125;;</span><br><span class="line">    <span class="function">Expression <span class="title">expression</span><span class="params">(symbols, <span class="number">13</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; expression.expression &lt;&lt; <span class="string">" = "</span> &lt;&lt; expression.fCalculate() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】跳表和散列</title>
      <link href="/2020/02/24/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E8%B7%B3%E8%A1%A8%E5%92%8C%E6%95%A3%E5%88%97/"/>
      <url>/2020/02/24/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E8%B7%B3%E8%A1%A8%E5%92%8C%E6%95%A3%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><h2 id="定义及抽象数据描述"><a href="#定义及抽象数据描述" class="headerlink" title="定义及抽象数据描述"></a>定义及抽象数据描述</h2><p>定义：<strong>字典</strong>(dictionary)是由一些形如$(k, v)$的数对所组成的集合，其中$k$为<strong>关键字</strong>，$v$是与关键字$k$对应的<strong>值</strong>。</p><p>抽象数据描述：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">抽象数据类型 dictionary</span><br><span class="line">&#123;</span><br><span class="line">    实例:</span><br><span class="line">        关键字各不相同的一组数据对；</span><br><span class="line">    操作：</span><br><span class="line">        empty();        <span class="comment">// 判断是否为空</span></span><br><span class="line">        size();         <span class="comment">// 返回字典内数对个数</span></span><br><span class="line">        find(k);        <span class="comment">// 返回关键字为k的数对</span></span><br><span class="line">        insert(k, v);   <span class="comment">// 插入数据对</span></span><br><span class="line">        erase(k);       <span class="comment">// 删除关键字为k的数对</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="线性表描述"><a href="#线性表描述" class="headerlink" title="线性表描述"></a>线性表描述</h2><p>将字典保存在线性表$p_0, p_1, \dots$中，其中$p_is$是字典中<strong>按关键字递增次序排列</strong>的数对。利用二分查找进行数据对的插入、查询与删除操作。其时间复杂度为$O(\log n)$。</p><p>在插入数据对时，首先对关键字进行查询，若未找到数对则创建新的数对，插入到对应位置；否则更新已有数对。</p><p>若采用数组描述的线性表，其二分查找较容易实现(实现略)。而对于链表描述的线性表，可引入跳表(<a href="#%e8%b7%b3%e8%a1%a8%e6%8f%8f%e8%bf%b0">跳表描述</a>)减少时间复杂度，</p><h2 id="跳表描述"><a href="#跳表描述" class="headerlink" title="跳表描述"></a>跳表描述</h2><p>对于线性表描述(链表描述)的字典，对$n$个数对进行查找，至多需要$n$此关键字比较。若添加中间节点的指针信息，其比较次数可减少到$(n/2 + 1)$。由此引入<strong>跳表</strong>(skiplist)，在不同的节点位置处添加多级指针信息。</p><p>跳表可用<strong>对数形式</strong>进行<strong>级的分配</strong>。例如，对于$n$个数，$0$级链表包括所有数对，$1$级链表每$2$个数对取一个，$2$级链表每$4$个数对取一个，以此类推。那么对于一个<strong>属于$i$级链表的数对</strong>，当且仅当它属于$0~i$级链表，但不属于$i+1$级链表。如下图所示，键为$20$的数对属于$0,1$级链表，不属于$2$级链表。</p><p><img src="/2020/02/24/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E8%B7%B3%E8%A1%A8%E5%92%8C%E6%95%A3%E5%88%97/【数据结构】跳表和散列/skiplist.jpg" alt="skiplist"></p><p>但是采用对数形式描述跳表，需在插入或删除数对后更新各级链表，其<strong>指针不易维护</strong>。对于该问题，可采用<strong>概率形式</strong>解决，<strong>在查询位置处(仍需满足有序线性表)</strong>插入结点时生成随机数判定级别，使s它属于$i-1$级链表的情况下，又属于$i$级链表的概率服从<strong>均匀分布</strong>，使$n$个数对在各级中分布是均匀的，即</p><script type="math/tex; mode=display">P(属于i级链表|属于i-1级链表) = p</script><p>具体实现如下，构造键值对对象<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linkeddictionary.h</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Pair() &#123; m_key = <span class="keyword">new</span> K; m_value = <span class="keyword">new</span> V; &#125;;</span><br><span class="line">Pair(<span class="keyword">const</span> K k, <span class="keyword">const</span> V v) &#123; m_key = <span class="keyword">new</span> K; *m_key = k;  m_value = <span class="keyword">new</span> V; *m_value = v; &#125;;</span><br><span class="line">~Pair() &#123; <span class="keyword">delete</span> m_key; <span class="keyword">delete</span> m_value; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setKey</span><span class="params">(<span class="keyword">const</span> K k)</span> </span>&#123; *m_key = k; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setVal</span><span class="params">(<span class="keyword">const</span> V v)</span> </span>&#123; *m_value = v; &#125;</span><br><span class="line"><span class="function">K <span class="title">getKey</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> *m_key; &#125;</span><br><span class="line"><span class="function">V <span class="title">getVal</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> *m_value; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">K* m_key;</span><br><span class="line">V* m_value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>以下几点说明：</p><ul><li>跳表内各级链表为<code>ChainList&lt;T&gt;</code>模板类的实例，将键值对<code>Pair&lt;K, V&gt;*</code>视作各节点的值，即实例为<code>ChainList&lt;Pair&lt;K, V&gt;* &gt;</code>；</li><li>指定最大级数，各级链表地址存储在<code>ChainList&lt;Pair&lt;K, V&gt;*&gt;** m_kvp</code>中；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linkeddictionary.h</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SkipList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">SkipList(<span class="keyword">int</span> maxLevel=<span class="number">3</span>, <span class="keyword">float</span> p=<span class="number">0.5</span>);</span><br><span class="line">~SkipList();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size() == <span class="number">0</span>;  &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">size</span><span class="params">()</span>  <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_kvp[<span class="number">0</span>]-&gt;size(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> K&amp; k, <span class="keyword">const</span> V&amp; v)</span></span>;</span><br><span class="line"><span class="function">V <span class="title">get</span>  <span class="params">(<span class="keyword">const</span> K&amp; k)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">const</span> K&amp; k)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">ChainNode&lt;Pair&lt;K, V&gt;*&gt;* find(<span class="keyword">const</span> K&amp; k) <span class="keyword">const</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">level</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> lv = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">std</span>::rand() &gt; m_iCutoff; lv++);</span><br><span class="line"><span class="keyword">return</span> (lv &gt; m_iMaxLevel - <span class="number">1</span>) ? (m_iMaxLevel - <span class="number">1</span>) : lv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m_iCutoff;<span class="comment">// 条件概率，截断</span></span><br><span class="line"><span class="keyword">int</span> m_iMaxLevel;<span class="comment">// 最大链表层数</span></span><br><span class="line">ChainList&lt;Pair&lt;K, V&gt;*&gt;** m_kvp;<span class="comment">// 多层链表数组</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line">SkipList&lt;K, V&gt;::SkipList(<span class="keyword">int</span> maxLevel, <span class="keyword">float</span> p) : </span><br><span class="line">m_iMaxLevel(maxLevel), m_iCutoff(p * RAND_MAX)</span><br><span class="line">&#123;</span><br><span class="line">m_kvp = <span class="keyword">new</span> ChainList&lt;Pair&lt;K, V&gt;*&gt; * [maxLevel];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_iMaxLevel; i++)</span><br><span class="line">m_kvp[i] = <span class="keyword">new</span> ChainList&lt;Pair&lt;K, V&gt;*&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line">SkipList&lt;K, V&gt;::~SkipList()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_iMaxLevel; i++)</span><br><span class="line"><span class="keyword">delete</span> m_kvp[i];</span><br><span class="line"><span class="keyword">delete</span>[] m_kvp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">void</span> SkipList&lt;K, V&gt;::print() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_iMaxLevel; i++) &#123;</span><br><span class="line">ChainNode&lt;Pair&lt;K, V&gt;*&gt;* pn = m_kvp[i]-&gt;getNode(<span class="number">0</span>);<span class="comment">// 当前级链表的首节点</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Level ["</span> &lt;&lt; i &lt;&lt; <span class="string">"]: "</span>;</span><br><span class="line"><span class="keyword">while</span> (pn-&gt;ptr &amp;&amp; pn-&gt;next) &#123;</span><br><span class="line">Pair&lt;K, V&gt;* kvp = pn-&gt;getVal();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; kvp-&gt;getKey() &lt;&lt; <span class="string">": "</span> &lt;&lt; kvp-&gt;getVal() &lt;&lt; <span class="string">" -&gt; "</span>;</span><br><span class="line">pn = pn-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在搜索时，自最高级链表向低级搜索，因为若高级链表中存在某键值对，那么低级链表中必定存在，此时可调用<code>ChainList&lt;T&gt;::indexOf(T)</code>直接获取起始搜索位置，实现二分搜索降低时间复杂度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line">ChainNode&lt;Pair&lt;K, V&gt;*&gt;* SkipList&lt;K, V&gt;::find(<span class="keyword">const</span> K&amp; k) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 若字典内无数对，返回空</span></span><br><span class="line"><span class="keyword">if</span> (empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">ChainNode&lt;Pair&lt;K, V&gt;*&gt;* ret = m_kvp[<span class="number">0</span>]-&gt;getNode(<span class="number">0</span>);<span class="comment">// 初始化为0级链表首节点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = m_iMaxLevel - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">// 由高级向低级搜索</span></span><br><span class="line"><span class="keyword">if</span> (m_kvp[i]-&gt;empty()) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = m_kvp[i]-&gt;indexOf(ret-&gt;getVal());<span class="comment">// 查找当前节点</span></span><br><span class="line">ChainNode&lt;Pair&lt;K, V&gt;*&gt; * pn = (index == <span class="number">-1</span>)? \</span><br><span class="line">m_kvp[i]-&gt;getNode(<span class="number">0</span>): \</span><br><span class="line">            m_kvp[i]-&gt;getNode(index);                    <span class="comment">// 当前级链表开始搜索的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((pn-&gt;getVal()-&gt;getKey() &lt; k) &amp;&amp; pn-&gt;next-&gt;ptr) &#123;</span><br><span class="line">pn = pn-&gt;next; ret = pn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pn-&gt;next-&gt;ptr) <span class="keyword">continue</span>;<span class="comment">// 已为尾节点</span></span><br><span class="line"><span class="keyword">if</span> (pn-&gt;next-&gt;getVal()-&gt;getKey() == ret-&gt;getVal()-&gt;getKey()) </span><br><span class="line"><span class="keyword">return</span> pn-&gt;next;<span class="comment">// 后一节点是否符合</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line">V SkipList&lt;K, V&gt;::get(<span class="keyword">const</span> K&amp; k) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line">ChainNode&lt;Pair&lt;K, V&gt;*&gt;* found = find(k);</span><br><span class="line"><span class="keyword">if</span> (found) <span class="keyword">return</span> found-&gt;getVal()-&gt;getVal();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入时，需确定插入键值对的级数<code>level()</code>，依次插入链表即可，注意<strong>有序插入</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">void</span> SkipList&lt;K, V&gt;::insert(<span class="keyword">const</span> K&amp; k, <span class="keyword">const</span> V&amp; v)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 先进行查找，若找到节点则不添加键，仅修改值</span></span><br><span class="line">ChainNode&lt;Pair&lt;K, V&gt;*&gt; * found = find(k);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----- 若字典为空，直接插入键值对 -----</span></span><br><span class="line"><span class="keyword">if</span> (!found) &#123;</span><br><span class="line"><span class="comment">// 创建节点</span></span><br><span class="line">Pair&lt;K, V&gt;* pn = <span class="keyword">new</span> Pair&lt;K, V&gt;(k, v);</span><br><span class="line"><span class="comment">// 确定层级</span></span><br><span class="line"><span class="keyword">int</span> lv = level();</span><br><span class="line"><span class="comment">// 插入各级链表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= lv; i++) </span><br><span class="line">m_kvp[i]-&gt;insert(<span class="number">0</span>, pn);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----- 若找到节点则不添加键，仅修改值 -----</span></span><br><span class="line"><span class="keyword">if</span> (found-&gt;getVal()-&gt;getKey() == k) &#123; found-&gt;getVal()-&gt;setVal(v); <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----- 若未找到，在标志节点附近有序插入 -----</span></span><br><span class="line">Pair&lt;K, V&gt;* pn = <span class="keyword">new</span> Pair&lt;K, V&gt;(k, v);</span><br><span class="line"><span class="comment">// 确定层级</span></span><br><span class="line"><span class="keyword">int</span> lv = level();</span><br><span class="line"><span class="comment">// 插入各级链表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= lv; i++) &#123;</span><br><span class="line"><span class="comment">// 当前链表空</span></span><br><span class="line"><span class="keyword">if</span> (m_kvp[i]-&gt;empty()) &#123; m_kvp[i]-&gt;insert(<span class="number">0</span>, pn); <span class="keyword">continue</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">ChainNode&lt;Pair&lt;K, V&gt;*&gt;* lvn = m_kvp[i]-&gt;getNode(<span class="number">0</span>);<span class="comment">// 当前级链表的首节点</span></span><br><span class="line"><span class="keyword">while</span> (lvn) &#123;</span><br><span class="line"><span class="keyword">if</span> (!lvn-&gt;ptr) &#123;                <span class="comment">// 尾节点</span></span><br><span class="line">m_kvp[i]-&gt;insert(index, pn);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (lvn-&gt;ptr &amp;&amp; lvn-&gt;getVal()-&gt;getKey() &gt; k) &#123;<span class="comment">// 当前节点的键大于k</span></span><br><span class="line">m_kvp[i]-&gt;insert(index, pn);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">lvn = lvn-&gt;next; index++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>删除结点时，从高级链表至低级的顺序释放，因为若从低级链表至高级的顺序释放，某节点在调用<code>ChainList&lt;T&gt;::erase(int)</code>后，内存被释放导致高级链表中<code>ChainList&lt;T&gt;::indexOf(T)</code>难以定位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">void</span> SkipList&lt;K, V&gt;::erase(<span class="keyword">const</span> K&amp; k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 先进行查找</span></span><br><span class="line">ChainNode&lt;Pair&lt;K, V&gt;*&gt;* found = find(k);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----- 若未找到 ----</span></span><br><span class="line"><span class="keyword">if</span> (!found) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----- 若找到，删除各级链中的该数对-----</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = m_iMaxLevel - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">ChainList&lt;Pair&lt;K, V&gt;*&gt;* pc = m_kvp[i];<span class="comment">// 当前级链表</span></span><br><span class="line"><span class="keyword">int</span> index = pc-&gt;indexOf(found-&gt;getVal());</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">pc-&gt;erase(index);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数测试及输出如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SkipList&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dict(<span class="number">3</span>, <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"insert: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        dict.insert(i % <span class="number">6</span>, i);</span><br><span class="line">        dict.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"erase: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        dict.erase(i);</span><br><span class="line">        dict.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">insert:</span><br><span class="line">Level [0]: 0: 0 -&gt;</span><br><span class="line">Level [1]:</span><br><span class="line">Level [2]:</span><br><span class="line"></span><br><span class="line">Level [0]: 0: 0 -&gt; 1: 1 -&gt;</span><br><span class="line">Level [1]: 1: 1 -&gt;</span><br><span class="line">Level [2]:</span><br><span class="line"></span><br><span class="line">Level [0]: 0: 0 -&gt; 1: 1 -&gt; 2: 2 -&gt;</span><br><span class="line">Level [1]: 1: 1 -&gt; 2: 2 -&gt;</span><br><span class="line">Level [2]: 2: 2 -&gt;</span><br><span class="line"></span><br><span class="line">Level [0]: 0: 0 -&gt; 1: 1 -&gt; 2: 2 -&gt; 3: 3 -&gt;</span><br><span class="line">Level [1]: 1: 1 -&gt; 2: 2 -&gt;</span><br><span class="line">Level [2]: 2: 2 -&gt;</span><br><span class="line"></span><br><span class="line">Level [0]: 0: 0 -&gt; 1: 1 -&gt; 2: 2 -&gt; 3: 3 -&gt; 4: 4 -&gt;</span><br><span class="line">Level [1]: 1: 1 -&gt; 2: 2 -&gt; 4: 4 -&gt;</span><br><span class="line">Level [2]: 2: 2 -&gt; 4: 4 -&gt;</span><br><span class="line"></span><br><span class="line">Level [0]: 0: 0 -&gt; 1: 1 -&gt; 2: 2 -&gt; 3: 3 -&gt; 4: 4 -&gt; 5: 5 -&gt;</span><br><span class="line">Level [1]: 1: 1 -&gt; 2: 2 -&gt; 4: 4 -&gt; 5: 5 -&gt;</span><br><span class="line">Level [2]: 2: 2 -&gt; 4: 4 -&gt; 5: 5 -&gt;</span><br><span class="line"></span><br><span class="line">Level [0]: 0: 6 -&gt; 1: 1 -&gt; 2: 2 -&gt; 3: 3 -&gt; 4: 4 -&gt; 5: 5 -&gt;</span><br><span class="line">Level [1]: 1: 1 -&gt; 2: 2 -&gt; 4: 4 -&gt; 5: 5 -&gt;</span><br><span class="line">Level [2]: 2: 2 -&gt; 4: 4 -&gt; 5: 5 -&gt;</span><br><span class="line"></span><br><span class="line">Level [0]: 0: 6 -&gt; 1: 7 -&gt; 2: 2 -&gt; 3: 3 -&gt; 4: 4 -&gt; 5: 5 -&gt;</span><br><span class="line">Level [1]: 1: 7 -&gt; 2: 2 -&gt; 4: 4 -&gt; 5: 5 -&gt;</span><br><span class="line">Level [2]: 2: 2 -&gt; 4: 4 -&gt; 5: 5 -&gt;</span><br><span class="line"></span><br><span class="line">Level [0]: 0: 6 -&gt; 1: 7 -&gt; 2: 8 -&gt; 3: 3 -&gt; 4: 4 -&gt; 5: 5 -&gt;</span><br><span class="line">Level [1]: 1: 7 -&gt; 2: 8 -&gt; 4: 4 -&gt; 5: 5 -&gt;</span><br><span class="line">Level [2]: 2: 8 -&gt; 4: 4 -&gt; 5: 5 -&gt;</span><br><span class="line"></span><br><span class="line">Level [0]: 0: 6 -&gt; 1: 7 -&gt; 2: 8 -&gt; 3: 3 -&gt; 3: 9 -&gt; 4: 4 -&gt; 5: 5 -&gt;</span><br><span class="line">Level [1]: 1: 7 -&gt; 2: 8 -&gt; 4: 4 -&gt; 5: 5 -&gt;</span><br><span class="line">Level [2]: 2: 8 -&gt; 4: 4 -&gt; 5: 5 -&gt;</span><br><span class="line"></span><br><span class="line">erase:</span><br><span class="line">Level [0]: 1: 7 -&gt; 2: 8 -&gt; 3: 3 -&gt; 3: 9 -&gt; 4: 4 -&gt; 5: 5 -&gt;</span><br><span class="line">Level [1]: 1: 7 -&gt; 2: 8 -&gt; 4: 4 -&gt; 5: 5 -&gt;</span><br><span class="line">Level [2]: 2: 8 -&gt; 4: 4 -&gt; 5: 5 -&gt;</span><br><span class="line"></span><br><span class="line">Level [0]: 2: 8 -&gt; 3: 3 -&gt; 3: 9 -&gt; 4: 4 -&gt; 5: 5 -&gt;</span><br><span class="line">Level [1]: 2: 8 -&gt; 4: 4 -&gt; 5: 5 -&gt;</span><br><span class="line">Level [2]: 2: 8 -&gt; 4: 4 -&gt; 5: 5 -&gt;</span><br><span class="line"></span><br><span class="line">Level [0]: 3: 3 -&gt; 3: 9 -&gt; 4: 4 -&gt; 5: 5 -&gt;</span><br><span class="line">Level [1]: 4: 4 -&gt; 5: 5 -&gt;</span><br><span class="line">Level [2]: 4: 4 -&gt; 5: 5 -&gt;</span><br><span class="line"></span><br><span class="line">Level [0]: 3: 3 -&gt; 4: 4 -&gt; 5: 5 -&gt;</span><br><span class="line">Level [1]: 4: 4 -&gt; 5: 5 -&gt;</span><br><span class="line">Level [2]: 4: 4 -&gt; 5: 5 -&gt;</span><br></pre></td></tr></table></figure><h2 id="散列描述"><a href="#散列描述" class="headerlink" title="散列描述"></a>散列描述</h2><h3 id="散列函数和散列表"><a href="#散列函数和散列表" class="headerlink" title="散列函数和散列表"></a>散列函数和散列表</h3><p>字典的另一种表示方法是<strong>散列</strong>(hashing)。它用一个<strong>散列函数(哈希函数)</strong>把字典的数对映射到一个<strong>散列表(哈希表)</strong>的具体位置。若关键字范围过大，可将若干个不同的关键字映射到散列表的同一位置。散列表的每个位置称作<strong>桶</strong>(bucket)，桶的数目等于散列表的长度。对于关键字为$k$的数对，$f(k)$为<strong>起始桶</strong>(home bucket)。</p><p>当两个不同关键字所对应的起始桶相同，产生<strong>冲突</strong>(collision)，但一个桶内可存放多个数位，但若存储桶内没有空间存储新数对，则发生<strong>溢出</strong>(overflow)。当冲突和溢出同时发生，可采用<a href="#%e7%ba%bf%e6%80%a7%e6%8e%a2%e6%9f%a5">线性探查法</a>、平法探查法、双重散列法等解决。</p><p>可采取<strong>均匀散列函数</strong>(uniform hash function)，使映射到散列表中各个桶的关键字数量大致相同，此时冲突和溢出发生的平均数最少。在实际应用中性能表现良好的均匀散列函数被称作<strong>良好散列函数</strong>(good hash function)。</p><ol><li>均匀散列函数输入值应依赖关键字的所有位；</li><li>要使得<strong>除法散列函数</strong>成为良好散列函数，$D$应取素数，且不能被小于$20$的整数除。<script type="math/tex; mode=display">f(k) = k \% D</script></li></ol><p>为了增加哈希表的搜索效率，尽量不让哈希表插满，规定一个<strong>负载因子</strong>，控制哈希表内插入元素的个数，从而提高效率。负载因子的定义为：</p><script type="math/tex; mode=display">\alpha = 填入表中元素(关键字个数) / 可填入总元素(表长)</script><p>$alpha$越大，表明填入表内元素越多，产生哈希冲突的可能就越大。相反则越小。冲突的机会越大，则查找的成本越高；反之，查找的成本越小，查找时间就越小.</p><p>以下为STL模板类<code>hash&lt;T&gt;</code>的专业实现版本<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hash</span>&lt;string&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">size_t</span> <span class="keyword">operator</span>() (<span class="keyword">const</span> <span class="built_in">string</span> key) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> hashVal = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; key.size(); i++)</span><br><span class="line">hashVal = <span class="number">5</span> * hashVal + key.at(i);</span><br><span class="line"><span class="keyword">return</span> hashVal;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="线性探查-闭散列法，开放地址法"><a href="#线性探查-闭散列法，开放地址法" class="headerlink" title="线性探查(闭散列法，开放地址法)"></a>线性探查(闭散列法，开放地址法)</h3><p><strong>线性探查</strong>(Linear Probing)是指，在某数对插入时。键所对应的桶满时，向哈希表往后找到下一个可用的桶。对于关键字为$k$的数据对，其具体插入步骤如下</p><ol><li>搜索起始桶$f(k)$，若为空，则插入并退出，否则进入2；</li><li>将散列表当作环表继续搜索下一个可用的桶，直至以下情况发生：a)存有关键字$k$的桶已找到，修改其数值；b)到达一个空桶，插入后退出；c)回到起始桶，冲突和溢出同时发生。</li></ol><p>设散列表中有$n$条数据，桶数为$b$，散列函数的除数为$D$且$D=b$</p><ul><li>散列表初始化时间为$O(b)$；</li><li>最坏情况下(关键字都对应同一起始桶)插入和查找时间均为$\Theta(n)$；</li><li>平均性能而言，散列远优于线性表。一次成功搜索和不成功搜索平均搜索桶数分别记作$U_n$与$S_n$，则有<script type="math/tex; mode=display">U_n \approxeq \frac{1}{2} \left( 1 + \frac{1}{(1 - \alpha)^2} \right)</script><script type="math/tex; mode=display">S_n \approxeq \frac{1}{2} \left( 1 + \frac{1}{(1 - \alpha)  } \right)</script>  其中$\alpha = n / b$，称作负载因子，当负载因子比较小是，线性探查使得散列的平均性能比线性表优越许多。</li></ul><p>基于线性探查实现的字典如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTabel</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">HashTabel(<span class="keyword">int</span> length = <span class="number">50</span>, <span class="keyword">int</span> d = <span class="number">23</span>);</span><br><span class="line">~HashTabel();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size() == <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">size</span><span class="params">()</span>  <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_iLength; i++)</span><br><span class="line"><span class="keyword">if</span> (m_listIsEmpty[i]) cnt++;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> K&amp; k, <span class="keyword">const</span> V&amp; v)</span></span>;</span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">const</span> K&amp; k)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">const</span> K&amp; k)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">size_t</span> hash(<span class="keyword">const</span> K k) <span class="keyword">const</span> &#123; <span class="keyword">return</span> k % m_iD; &#125;</span><br><span class="line">Pair&lt;K, V&gt;* find(<span class="keyword">const</span> K&amp; k, <span class="keyword">bool</span> insert = <span class="literal">true</span>) <span class="keyword">const</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">const</span> Pair&lt;K, V&gt;* p)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_iLength; i++)</span><br><span class="line"><span class="keyword">if</span> (m_listTable[i] == p) <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m_iD;</span><br><span class="line">Pair&lt;K, V&gt;** m_listTable;</span><br><span class="line"><span class="keyword">bool</span>* m_listIsEmpty;</span><br><span class="line"><span class="keyword">int</span> m_iLength;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ol><li><p>关键的线性探查步骤如下</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line">Pair&lt;K, V&gt;* HashTabel&lt;K, V&gt;::find(<span class="keyword">const</span> K&amp; k, <span class="keyword">bool</span> insert) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> hv = hash(k);<span class="comment">// 求取hash值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从初始桶开始查找</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_iLength; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> index = (hv + i) % m_iLength;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回到初始位置，同时发生冲突与溢出，返回空</span></span><br><span class="line"><span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; index == hv) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在插入操作时，可返回空桶</span></span><br><span class="line"><span class="keyword">if</span> (insert &amp;&amp; m_listIsEmpty[index]) <span class="keyword">return</span> m_listTable[index];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找到相同键的桶</span></span><br><span class="line"><span class="keyword">if</span> (m_listTable[index]-&gt;getKey() == k)</span><br><span class="line"><span class="keyword">return</span> m_listTable[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造函数、析构函数、输出函数</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line">HashTabel&lt;K, V&gt;::HashTabel(<span class="keyword">int</span> length, <span class="keyword">int</span> d) :</span><br><span class="line">m_iLength(length), m_iD(d)</span><br><span class="line">&#123;</span><br><span class="line">m_listTable = <span class="keyword">new</span> Pair&lt;K, V&gt;* [m_iLength];</span><br><span class="line">m_listIsEmpty = <span class="keyword">new</span> <span class="keyword">bool</span> [m_iLength];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_iLength; i++) &#123;</span><br><span class="line">m_listTable[i] = <span class="keyword">new</span> Pair&lt;K, V&gt;;</span><br><span class="line">m_listIsEmpty[i] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line">HashTabel&lt;K, V&gt;::~HashTabel()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_iLength; i++) </span><br><span class="line"><span class="keyword">delete</span> m_listTable[i];</span><br><span class="line"><span class="keyword">delete</span>[] m_listTable;</span><br><span class="line"><span class="keyword">delete</span>[] m_listIsEmpty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">void</span> HashTabel&lt;K, V&gt;::print() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_iLength; i++) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"|["</span> &lt;&lt;  i &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line"><span class="keyword">if</span> (!m_listIsEmpty[i])</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;  m_listTable[i]-&gt;getKey() &lt;&lt; <span class="string">": "</span> &lt;&lt; \</span><br><span class="line">m_listTable[i]-&gt;getVal() &lt;&lt; <span class="string">"| -&gt;"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" -&gt; "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>插入、查询、删除</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">void</span> HashTabel&lt;K, V&gt;::insert(<span class="keyword">const</span> K&amp; k, <span class="keyword">const</span> V&amp; v)</span><br><span class="line">&#123;</span><br><span class="line">Pair&lt;K, V&gt;* found = find(k);</span><br><span class="line"><span class="keyword">if</span> (!found) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"哈希表已满"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反查位置</span></span><br><span class="line"><span class="keyword">int</span> index = indexOf(found);</span><br><span class="line"><span class="comment">// 若为空，设置键</span></span><br><span class="line"><span class="keyword">if</span> (m_listIsEmpty[index]) found-&gt;setKey(k);</span><br><span class="line"><span class="comment">// 设置值</span></span><br><span class="line">found-&gt;setVal(v); </span><br><span class="line">m_listIsEmpty[index] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line">V HashTabel&lt;K, V&gt;::get(<span class="keyword">const</span> K&amp; k) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">Pair&lt;K, V&gt;* found = find(k);</span><br><span class="line"><span class="keyword">if</span> (found) <span class="keyword">return</span> found-&gt;getVal();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">void</span> HashTabel&lt;K, V&gt;::erase(<span class="keyword">const</span> K&amp; k)</span><br><span class="line">&#123;</span><br><span class="line">Pair&lt;K, V&gt;* found = find(k, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (!found) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反查位置</span></span><br><span class="line"><span class="keyword">int</span> index = indexOf(found);</span><br><span class="line"><span class="comment">// 设置为空</span></span><br><span class="line">m_listIsEmpty[index] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>主函数测试如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HashTabel&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dict(<span class="number">10</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"insert: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        </span><br><span class="line">        dict.insert(<span class="number">2</span> * i, i);</span><br><span class="line">        dict.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"erase: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        dict.erase(<span class="number">2</span> * i);</span><br><span class="line">        dict.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>插入过程如下图所示<br><img src="/2020/02/24/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E8%B7%B3%E8%A1%A8%E5%92%8C%E6%95%A3%E5%88%97/【数据结构】跳表和散列/hashtabel_insert.jpg" alt="hashtabel_insert"></p><blockquote><p>输出格式为<code>|[index] key: value| -&gt; ...</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">insert:</span><br><span class="line">|[0]0: 0| -&gt;|[1] -&gt; |[2] -&gt; |[3] -&gt; |[4] -&gt; |[5] -&gt; |[6] -&gt; |[7] -&gt; |[8] -&gt; |[9] -&gt;</span><br><span class="line">|[0]0: 0| -&gt;|[1] -&gt; |[2]2: 1| -&gt;|[3] -&gt; |[4] -&gt; |[5] -&gt; |[6] -&gt; |[7] -&gt; |[8] -&gt; |[9] -&gt;</span><br><span class="line">|[0]0: 0| -&gt;|[1]4: 2| -&gt;|[2]2: 1| -&gt;|[3] -&gt; |[4] -&gt; |[5] -&gt; |[6] -&gt; |[7] -&gt; |[8] -&gt; |[9] -&gt;</span><br><span class="line">|[0]0: 0| -&gt;|[1]4: 2| -&gt;|[2]2: 1| -&gt;|[3]6: 3| -&gt;|[4] -&gt; |[5] -&gt; |[6] -&gt; |[7] -&gt; |[8] -&gt; |[9] -&gt;</span><br><span class="line">|[0]0: 0| -&gt;|[1]4: 2| -&gt;|[2]2: 1| -&gt;|[3]6: 3| -&gt;|[4]8: 4| -&gt;|[5] -&gt; |[6] -&gt; |[7] -&gt; |[8] -&gt; |[9] -&gt;</span><br><span class="line">|[0]0: 0| -&gt;|[1]4: 2| -&gt;|[2]2: 1| -&gt;|[3]6: 3| -&gt;|[4]8: 4| -&gt;|[5]10: 5| -&gt;|[6] -&gt; |[7] -&gt; |[8] -&gt; |[9] -&gt;</span><br><span class="line">|[0]0: 0| -&gt;|[1]4: 2| -&gt;|[2]2: 1| -&gt;|[3]6: 3| -&gt;|[4]8: 4| -&gt;|[5]10: 5| -&gt;|[6]12: 6| -&gt;|[7] -&gt; |[8] -&gt; |[9] -&gt;</span><br><span class="line">|[0]0: 0| -&gt;|[1]4: 2| -&gt;|[2]2: 1| -&gt;|[3]6: 3| -&gt;|[4]8: 4| -&gt;|[5]10: 5| -&gt;|[6]12: 6| -&gt;|[7]14: 7| -&gt;|[8] -&gt; |[9] -&gt;</span><br><span class="line">erase:</span><br><span class="line">|[0]0: 0| -&gt;|[1]4: 2| -&gt;|[2]2: 1| -&gt;|[3]6: 3| -&gt;|[4] -&gt; |[5]10: 5| -&gt;|[6]12: 6| -&gt;|[7]14: 7| -&gt;|[8] -&gt; |[9] -&gt;</span><br><span class="line">|[0]0: 0| -&gt;|[1]4: 2| -&gt;|[2]2: 1| -&gt;|[3]6: 3| -&gt;|[4] -&gt; |[5] -&gt; |[6]12: 6| -&gt;|[7]14: 7| -&gt;|[8] -&gt; |[9] -&gt;</span><br><span class="line">|[0]0: 0| -&gt;|[1]4: 2| -&gt;|[2]2: 1| -&gt;|[3]6: 3| -&gt;|[4] -&gt; |[5] -&gt; |[6] -&gt; |[7]14: 7| -&gt;|[8] -&gt; |[9] -&gt;</span><br><span class="line">|[0]0: 0| -&gt;|[1]4: 2| -&gt;|[2]2: 1| -&gt;|[3]6: 3| -&gt;|[4] -&gt; |[5] -&gt; |[6] -&gt; |[7] -&gt; |[8] -&gt; |[9] -&gt;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="链式散列-开散列法，链地址法"><a href="#链式散列-开散列法，链地址法" class="headerlink" title="链式散列(开散列法，链地址法)"></a>链式散列(开散列法，链地址法)</h3><p>链式散列是指，给散列表的每一个桶配置一个链式线性表，那么每个桶可以容纳无限多个容量，那么便不存在溢出问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashChains</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">HashChains(<span class="keyword">int</span> length = <span class="number">50</span>, <span class="keyword">int</span> d = <span class="number">23</span>);</span><br><span class="line">~HashChains();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size() == <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">size</span><span class="params">()</span>  <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_iLength; i++)</span><br><span class="line">cnt += m_listChains[i]-&gt;size();</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> K&amp; k, <span class="keyword">const</span> V&amp; v)</span></span>;</span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">const</span> K&amp; k)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">const</span> K&amp; k)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">size_t</span> hash(<span class="keyword">const</span> K k) <span class="keyword">const</span> &#123; <span class="keyword">return</span> k % m_iD; &#125;</span><br><span class="line">Pair&lt;K, V&gt;* find(<span class="keyword">const</span> K&amp; k, <span class="keyword">bool</span> insert = <span class="literal">true</span>) <span class="keyword">const</span>;</span><br><span class="line">ChainList&lt;Pair&lt;K, V&gt;*&gt;* findChain(<span class="keyword">const</span> K&amp; k) <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_listChains[hash(k)]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m_iD;</span><br><span class="line">ChainList&lt;Pair&lt;K, V&gt;*&gt;** m_listChains;<span class="comment">// 也可以换成跳表</span></span><br><span class="line"><span class="keyword">int</span> m_iLength;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><p>构造函数、析构函数、打印输出</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line">HashChains&lt;K, V&gt;::HashChains(<span class="keyword">int</span> length, <span class="keyword">int</span> d) :</span><br><span class="line">m_iLength(length), m_iD(d)</span><br><span class="line">&#123;</span><br><span class="line">m_listChains = <span class="keyword">new</span> ChainList&lt;Pair&lt;K, V&gt;*&gt;* [m_iLength];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_iLength; i++)</span><br><span class="line">m_listChains[i] = <span class="keyword">new</span> ChainList&lt;Pair&lt;K, V&gt;*&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line">HashChains&lt;K, V&gt;::~HashChains()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_iLength; i++)</span><br><span class="line"><span class="keyword">delete</span> m_listChains[i];</span><br><span class="line"><span class="keyword">delete</span>[] m_listChains;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">void</span> HashChains&lt;K, V&gt;::print() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_iLength; i++) &#123;</span><br><span class="line">ChainList&lt;Pair&lt;K, V&gt;*&gt;* chain = m_listChains[i];</span><br><span class="line">ChainNode&lt;Pair&lt;K, V&gt;*&gt;* node = chain-&gt;getNode(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; i &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line"><span class="keyword">while</span> (node &amp;&amp; node-&gt;ptr) &#123;</span><br><span class="line">Pair&lt;K, V&gt;* p = node-&gt;getVal();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p-&gt;getKey() &lt;&lt; <span class="string">":"</span> &lt;&lt; p-&gt;getVal() &lt;&lt; <span class="string">" -&gt; "</span>;</span><br><span class="line">node = node-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" | "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在各桶内查找</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line">Pair&lt;K, V&gt;* HashChains&lt;K, V&gt;::find(<span class="keyword">const</span> K&amp; k, <span class="keyword">bool</span> insert) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> hv = hash(k);<span class="comment">// 求取hash值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取哈希值对应的桶</span></span><br><span class="line">ChainList&lt;Pair&lt;K, V&gt;*&gt;* chain = m_listChains[hv];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在桶内依次查找</span></span><br><span class="line">ChainNode&lt;Pair&lt;K, V&gt;*&gt;* node = chain-&gt;getNode(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span> (node) &#123;</span><br><span class="line"><span class="comment">// 已到达链尾</span></span><br><span class="line"><span class="keyword">if</span> (!node-&gt;next) &#123;</span><br><span class="line"><span class="keyword">if</span> (!insert) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">// 插入操作时，创建节点</span></span><br><span class="line">Pair&lt;K, V&gt;* p = <span class="keyword">new</span> Pair&lt;K, V&gt;;</span><br><span class="line">chain-&gt;insert(chain-&gt;size(), p);</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找到对应键</span></span><br><span class="line"><span class="keyword">if</span> (node-&gt;getVal()-&gt;getKey() == k)</span><br><span class="line"><span class="keyword">return</span> node-&gt;getVal();</span><br><span class="line">node = node-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>插入、查询、删除操作</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">void</span> HashChains&lt;K, V&gt;::insert(<span class="keyword">const</span> K&amp; k, <span class="keyword">const</span> V&amp; v)</span><br><span class="line">&#123;</span><br><span class="line">Pair&lt;K, V&gt;* p = find(k);</span><br><span class="line"><span class="keyword">if</span> (p-&gt;getKey() != k) p-&gt;setKey(k);</span><br><span class="line">p-&gt;setVal(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line">V HashChains&lt;K, V&gt;::get(<span class="keyword">const</span> K&amp; k) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">Pair&lt;K, V&gt;* p = find(k, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (p) <span class="keyword">return</span> p-&gt;getVal();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">void</span> HashChains&lt;K, V&gt;::erase(<span class="keyword">const</span> K&amp; k)</span><br><span class="line">&#123;</span><br><span class="line">ChainList&lt;Pair&lt;K, V&gt;*&gt;* chain = findChain(k);</span><br><span class="line">Pair&lt;K, V&gt;* p = find(k, <span class="literal">false</span>);</span><br><span class="line">chain-&gt;erase(chain-&gt;indexOf(p));</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>主函数测试如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HashChains&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dict(<span class="number">10</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"insert: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        </span><br><span class="line">        dict.insert(<span class="number">2</span> * i, i);</span><br><span class="line">        dict.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"erase: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        dict.erase(<span class="number">2</span> * i);</span><br><span class="line">        dict.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>分析：插入过程如下图<br><img src="/2020/02/24/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E8%B7%B3%E8%A1%A8%E5%92%8C%E6%95%A3%E5%88%97/【数据结构】跳表和散列/hashchain_insert.jpg" alt="hashchain_insert"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">insert:</span><br><span class="line">[0]0:0 -&gt;  | [1] | [2] | [3] | [4] | [5] | [6] | [7] | [8] | [9] |</span><br><span class="line">[0]0:0 -&gt;  | [1] | [2]2:1 -&gt;  | [3] | [4] | [5] | [6] | [7] | [8] | [9] |</span><br><span class="line">[0]0:0 -&gt;  | [1]4:2 -&gt;  | [2]2:1 -&gt;  | [3] | [4] | [5] | [6] | [7] | [8] | [9] |</span><br><span class="line">[0]6:3 -&gt; 0:0 -&gt;  | [1]4:2 -&gt;  | [2]2:1 -&gt;  | [3] | [4] | [5] | [6] | [7] | [8] | [9] |</span><br><span class="line">[0]6:3 -&gt; 0:0 -&gt;  | [1]4:2 -&gt;  | [2]8:4 -&gt; 2:1 -&gt;  | [3] | [4] | [5] | [6] | [7] | [8] | [9] |</span><br><span class="line">[0]6:3 -&gt; 0:0 -&gt;  | [1]10:5 -&gt; 4:2 -&gt;  | [2]8:4 -&gt; 2:1 -&gt;  | [3] | [4] | [5] | [6] | [7] | [8] | [9] |</span><br><span class="line">[0]12:6 -&gt; 6:3 -&gt; 0:0 -&gt;  | [1]10:5 -&gt; 4:2 -&gt;  | [2]8:4 -&gt; 2:1 -&gt;  | [3] | [4] | [5] | [6] | [7] | [8] | [9] |</span><br><span class="line">[0]12:6 -&gt; 6:3 -&gt; 0:0 -&gt;  | [1]10:5 -&gt; 4:2 -&gt;  | [2]14:7 -&gt; 8:4 -&gt; 2:1 -&gt;  | [3] | [4] | [5] | [6] | [7] | [8] | [9] |</span><br><span class="line">erase:</span><br><span class="line">[0]12:6 -&gt; 6:3 -&gt; 0:0 -&gt;  | [1]10:5 -&gt; 4:2 -&gt;  | [2]14:7 -&gt; 2:1 -&gt;  | [3] | [4] | [5] | [6] | [7] | [8] | [9] |</span><br><span class="line">[0]12:6 -&gt; 6:3 -&gt; 0:0 -&gt;  | [1]4:2 -&gt;  | [2]14:7 -&gt; 2:1 -&gt;  | [3] | [4] | [5] | [6] | [7] | [8] | [9] |</span><br><span class="line">[0]6:3 -&gt; 0:0 -&gt;  | [1]4:2 -&gt;  | [2]14:7 -&gt; 2:1 -&gt;  | [3] | [4] | [5] | [6] | [7] | [8] | [9] |</span><br><span class="line">[0]6:3 -&gt; 0:0 -&gt;  | [1]4:2 -&gt;  | [2]2:1 -&gt;  | [3] | [4] | [5] | [6] | [7] | [8] | [9] |</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】栈与队列</title>
      <link href="/2020/02/21/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
      <url>/2020/02/21/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="定义及抽象数据描述"><a href="#定义及抽象数据描述" class="headerlink" title="定义及抽象数据描述"></a>定义及抽象数据描述</h2><p>定义：<strong>栈</strong>(stack)是一种特殊的线性表，其插入(aka. 入栈、压栈)和删除(aka. 出栈、弹栈)操作在表的同一端进行，即后进先出(last-in-first-out, LIFO)。两端称作栈顶(top)、栈底(bottom)。</p><p>抽象数据描述：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">抽象数据类型 <span class="built_in">stack</span></span><br><span class="line">&#123;</span><br><span class="line">    实例:</span><br><span class="line">        linearList;</span><br><span class="line">    操作：</span><br><span class="line">        empty();    <span class="comment">// 判断是否为空</span></span><br><span class="line">        size();     <span class="comment">// 返回栈内元素个数</span></span><br><span class="line">        top();      <span class="comment">// 返回栈顶元素</span></span><br><span class="line">        pop();      <span class="comment">// 出栈</span></span><br><span class="line">        push(x);    <span class="comment">// 入栈</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="链表描述"><a href="#链表描述" class="headerlink" title="链表描述"></a>链表描述</h2><p>继承自模板类<code>ChainList</code>编写模板类<code>LinkedStack</code>即可。</p><blockquote><p>注：若构造的类为模板类，那么派生类不可以直接使用继承到的基类数据和方法，需要通过<code>this</code>指针使用。子类内存释放时，将自动调用父类析构函数。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linkedstack.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"arraylist.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedStack</span>:</span> <span class="keyword">public</span> ChainList&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LinkedStack(): ChainList&lt;T&gt;() &#123;&#125;</span><br><span class="line">    ~LinkedStack()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        checkStack();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T&amp; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkStack();</span><br><span class="line">        T value = <span class="keyword">this</span>-&gt;get(<span class="number">0</span>); <span class="keyword">this</span>-&gt;erase(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;insert(<span class="number">0</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkStack</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;empty()) <span class="keyword">throw</span> <span class="string">"The stack is empty()"</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主函数测试<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkedStack&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入栈</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">stack</span>.push(<span class="number">3</span> * i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stack</span>.print();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">stack</span>.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stack</span>.print();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12 9 6 3 0</span><br><span class="line">3 0</span><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>例：一辆从前至后各车厢标号混乱的火车，从轨道入口驶入，出口驶出，与轨道垂直方向分布$k$个缓冲轨道(holding track)。要求利用缓冲轨道将车厢进行排序。</p><p><img src="/2020/02/21/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/【数据结构】栈与队列/stack.jpg" alt="stack"></p><p>实际上，此时缓冲轨道和入口轨道均可视作栈，均用<code>LinkedStack</code>表示。</p><blockquote><p>也可考虑入口至出口为双向链表，另一解决方案。</p></blockquote><p>两个功能性函数：1) 判断缓冲轨道是否为空；2) 寻找栈顶最大的缓冲轨道，返回其索引。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isHoldingTracksEmpty</span><span class="params">(<span class="keyword">const</span> LinkedStack&lt;<span class="keyword">int</span>&gt;* holdingTracks, <span class="keyword">int</span> k = <span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (holdingTracks[i].top() != <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findHoldingTracksWithMaxTop</span><span class="params">(<span class="keyword">const</span> LinkedStack&lt;<span class="keyword">int</span>&gt;* holdingTracks, <span class="keyword">int</span> k = <span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">-1</span>; <span class="keyword">int</span> max = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> top = holdingTracks[i].top();</span><br><span class="line">        <span class="keyword">if</span> (top &gt; max) &#123;</span><br><span class="line">            index = i; max = top;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>算法说明如下：<br>1) 依次将火车车厢装入缓冲轨道。注意在第$i$节标号为$s_i$的车厢选择缓冲轨道时，选择<strong>栈顶车厢标号$t_j$小于$s_i$且$|t_j - s_i|$最小</strong>的缓冲轨道$j$，这样的目的是，使缓冲轨道内数字<strong>从栈顶至栈底按从大到小</strong>的顺序排列，且尽可能连续。若找不到满足要求的轨道，进入2)；<br>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findHoldingTrack</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> num, <span class="keyword">const</span> LinkedStack&lt;<span class="keyword">int</span>&gt;* holdingTracks, <span class="keyword">int</span> k = <span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 寻找 `栈顶 &lt; 当前车厢标号num` 且 `最接近num` 的栈</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> em = INT32_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> e = holdingTracks[i].top() - num;</span><br><span class="line">        <span class="keyword">if</span> (e &lt; <span class="number">0</span> &amp;&amp; <span class="built_in">abs</span>(e) &lt; em) &#123;</span><br><span class="line">            em = <span class="built_in">abs</span>(e); index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2) 将所有缓冲轨道内的车厢按照<strong>从大到小</strong>的顺序，装回原车厢，进入3)；<br>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putBackBins</span><span class="params">(LinkedStack&lt;<span class="keyword">int</span>&gt;&amp; bins, LinkedStack&lt;<span class="keyword">int</span>&gt;* holdingTracks, <span class="keyword">int</span> k = <span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注意，此时插入车辆时，按从大到小排序</span></span><br><span class="line">    <span class="keyword">while</span> (!isHoldingTracksEmpty(holdingTracks, k)) &#123;</span><br><span class="line">        <span class="keyword">int</span> itop = findHoldingTracksWithMaxTop(holdingTracks, k);</span><br><span class="line">        bins.push(holdingTracks[itop].pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3) 重新按1)对车厢进行排序，如此循环，直至排序完成，进入4)；<br>4) 重复步骤2)一次，完成排序。</p><p>程序入口如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">LinkedStack&lt;<span class="keyword">int</span>&gt; reSortBins(<span class="keyword">const</span> LinkedStack&lt;<span class="keyword">int</span>&gt;&amp; bins, <span class="keyword">int</span> k = <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    LinkedStack&lt;<span class="keyword">int</span>&gt;* holdingTracks = <span class="keyword">new</span> LinkedStack&lt;<span class="keyword">int</span>&gt;[k];</span><br><span class="line">    LinkedStack&lt;<span class="keyword">int</span>&gt; bins_c(bins);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化各栈，栈底置`-1`</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) holdingTracks[i].push(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将链表内数据划入栈内，要求每个栈内从顶至底，标号从大到小</span></span><br><span class="line">    <span class="keyword">while</span>(!bins_c.empty()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sign = bins_c.pop(); </span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">-1</span>; </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印当前车厢编号信息</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Time["</span> &lt;&lt; cnt++ &lt;&lt; <span class="string">"]: "</span>;  bins_c.print();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 寻找 `栈顶 &lt; 当前车厢标号sign` 且 `最接近sign` 的栈</span></span><br><span class="line">            index = findHoldingTrack(sign, holdingTracks, k);</span><br><span class="line">            <span class="keyword">if</span> (index != <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若未找到，将当前已拍好序的放回车辆</span></span><br><span class="line">            putBackBins(bins_c, holdingTracks, k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 入栈</span></span><br><span class="line">        holdingTracks[index].push(sign);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看缓冲车道内排序</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"Holding tracks: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) holdingTracks[i].print();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新装回车辆</span></span><br><span class="line">    putBackBins(bins_c, holdingTracks, k);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回收工作</span></span><br><span class="line">    <span class="keyword">delete</span>[] holdingTracks;</span><br><span class="line">    <span class="keyword">return</span> bins_c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试主函数如下，输入<code>581742936</code>，排序后应输出<code>123456789</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkedStack&lt;<span class="keyword">int</span>&gt; bins;</span><br><span class="line">    <span class="keyword">int</span> origin[<span class="number">9</span>] = &#123; <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">        bins.push(origin[<span class="number">9</span> - i - <span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"origin: "</span>; bins.print(); <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    LinkedStack&lt;<span class="keyword">int</span>&gt; bins_c = reSortBins(bins, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"sorted: "</span>; bins_c.print();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">origin: 5 8 1 7 4 2 9 6 3</span><br><span class="line"></span><br><span class="line">Time[0]: 8 1 7 4 2 9 6 3</span><br><span class="line">Time[1]: 1 7 4 2 9 6 3</span><br><span class="line">Time[2]: 7 4 2 9 6 3</span><br><span class="line">Time[3]: 4 2 9 6 3</span><br><span class="line">Time[4]: 2 9 6 3</span><br><span class="line">Time[5]: 9 6 3</span><br><span class="line">Time[6]: 1 4 5 7 8 9 6 3</span><br><span class="line">Time[7]: 4 5 7 8 9 6 3</span><br><span class="line">Time[8]: 5 7 8 9 6 3</span><br><span class="line">Time[9]: 7 8 9 6 3</span><br><span class="line">Time[10]: 8 9 6 3</span><br><span class="line">Time[11]: 9 6 3</span><br><span class="line">Time[12]: 6 3</span><br><span class="line">Time[13]: 3</span><br><span class="line">Time[14]:</span><br><span class="line"></span><br><span class="line">Holding tracks:</span><br><span class="line">9 8 7 5 4 2 -1</span><br><span class="line">6 1 -1</span><br><span class="line">3 -1</span><br><span class="line"></span><br><span class="line">sorted: 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure></p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="定义及抽象数据描述-1"><a href="#定义及抽象数据描述-1" class="headerlink" title="定义及抽象数据描述"></a>定义及抽象数据描述</h2><p>定义：<strong>队列</strong>(queue)是一个线性表，其插入和删除操作分别在表的两端进行，即先进先出(first-in-first-out, FIFO)。插入的一端称队尾(back或rear)，删除元素的一端称为队首(front)。</p><p>抽象数据描述：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">抽象数据类型 <span class="built_in">queue</span></span><br><span class="line">&#123;</span><br><span class="line">    实例:</span><br><span class="line">        linearList;</span><br><span class="line">    操作：</span><br><span class="line">        empty();    <span class="comment">// 判断是否为空</span></span><br><span class="line">        size();     <span class="comment">// 返回队列内元素个数</span></span><br><span class="line">        front();    <span class="comment">// 返回队首元素</span></span><br><span class="line">        back();     <span class="comment">// 返回队尾元素</span></span><br><span class="line">        pop();      <span class="comment">// 删除队首元素</span></span><br><span class="line">        push(x);    <span class="comment">// 把元素加入队尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="链表描述-1"><a href="#链表描述-1" class="headerlink" title="链表描述"></a>链表描述</h2><p>同样的，继承自模板类<code>ChainList</code>编写模板类<code>LinkedQueue</code>即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linkedqueue.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"arraylist.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedQueue</span> :</span> <span class="keyword">public</span> ChainList&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LinkedQueue() : ChainList&lt;T&gt;() &#123;&#125;</span><br><span class="line">    ~LinkedQueue() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        checkStack();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;get(<span class="keyword">this</span>-&gt;size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        checkStack();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkStack();</span><br><span class="line">        T value = <span class="keyword">this</span>-&gt;get(<span class="keyword">this</span>-&gt;size() - <span class="number">1</span>); </span><br><span class="line">        <span class="keyword">this</span>-&gt;erase(<span class="keyword">this</span>-&gt;size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;insert(<span class="number">0</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;size(); i++)</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span>-&gt;get(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkStack</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;empty()) <span class="keyword">throw</span> <span class="string">"The queue is empty()"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主函数测试程序:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkedQueue&lt;<span class="keyword">int</span>&gt; <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入栈</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">queue</span>.push(<span class="number">3</span> * i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>.print();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"front: "</span> &lt;&lt; <span class="built_in">queue</span>.front() &lt;&lt; <span class="built_in">endl</span> &lt;&lt; </span><br><span class="line">            <span class="string">"back: "</span> &lt;&lt; <span class="built_in">queue</span>.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">queue</span>.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>.print();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">12 9 6 3 0</span><br><span class="line">front: 0</span><br><span class="line">back: 12</span><br><span class="line">12 9</span><br></pre></td></tr></table></figure><h2 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h2><p>例：一辆从前至后各车厢标号混乱的火车，从轨道入口驶入，出口驶出，与轨道水平方向分布$k$个缓冲轨道(holding track)。要求利用缓冲轨道将车厢进行排序。</p><p><img src="/2020/02/21/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/【数据结构】栈与队列/queue.jpg" alt="queue"></p><p>此时，出入轨道、缓冲轨道均视作队列。</p><p>两个功能性函数：1) 判断缓冲轨道是否为空；2) 寻找队首最小的缓冲轨道，返回其索引。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isHoldingTracksEmpty</span><span class="params">(<span class="keyword">const</span> LinkedQueue&lt;<span class="keyword">int</span>&gt;* holdingTracks, <span class="keyword">int</span> k = <span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!holdingTracks[i].empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findHoldingTracksWithMinFront</span><span class="params">(<span class="keyword">const</span> LinkedQueue&lt;<span class="keyword">int</span>&gt;* holdingTracks, <span class="keyword">int</span> k = <span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">-1</span>; <span class="keyword">int</span> min = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (holdingTracks[i].empty()) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> front = holdingTracks[i].front();</span><br><span class="line">        <span class="keyword">if</span> (front &lt; min) &#123;</span><br><span class="line">            index = i; min = front;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>算法说明如下：<br>1) 依次将火车车厢装入缓冲轨道。注意在第$i$节标号为$s_i$的车厢选择缓冲轨道时，选择<strong>队尾标号$t_j$小于$s_i$且$|t_j - s_i|$最小</strong>的缓冲轨道$j$，这样的目的是，使缓冲轨道内数字<strong>从队首至队尾按从小到大</strong>的顺序排列，且尽可能连续。<strong>注意，必须留下一条轨道用于存放1号车厢</strong>。<br>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findHoldingTrack</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> num, <span class="keyword">const</span> LinkedQueue&lt;<span class="keyword">int</span>&gt;* holdingTracks, <span class="keyword">int</span> k = <span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 寻找 `队尾 &lt; 当前车厢标号num` 且 `最接近num` 的栈</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> em = INT32_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> e = holdingTracks[i].back() - num;</span><br><span class="line">        <span class="keyword">if</span> (e &lt; <span class="number">0</span> &amp;&amp; <span class="built_in">abs</span>(e) &lt; em) &#123;</span><br><span class="line">            em = <span class="built_in">abs</span>(e); index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>2) 将车厢放入出轨道，完成排序。<br>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putIntoOutTrack</span><span class="params">(LinkedQueue&lt;<span class="keyword">int</span>&gt;&amp; outTrack, LinkedQueue&lt;<span class="keyword">int</span>&gt;* holdingTracks, <span class="keyword">int</span> k = <span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 缓冲车道的队首标记元素。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) holdingTracks[i].pop();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，此时进入出轨道时时，按从小到大排序</span></span><br><span class="line">    <span class="keyword">while</span> (!isHoldingTracksEmpty(holdingTracks, k)) &#123;</span><br><span class="line">        <span class="keyword">int</span> itop = findHoldingTracksWithMinFront(holdingTracks, k);</span><br><span class="line">        outTrack.push(holdingTracks[itop].pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">LinkedQueue&lt;<span class="keyword">int</span>&gt; reSortBins(<span class="keyword">const</span> LinkedQueue&lt;<span class="keyword">int</span>&gt;&amp; bins, <span class="keyword">int</span> k = <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    LinkedQueue&lt;<span class="keyword">int</span>&gt;* holdingTracks = <span class="keyword">new</span> LinkedQueue&lt;<span class="keyword">int</span>&gt;[k];</span><br><span class="line">    LinkedQueue&lt;<span class="keyword">int</span>&gt; bins_c(bins);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化各队列，列首置`-1`，其中一条置`11`，**用于存放`1号车`**</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            holdingTracks[i].push(<span class="number">11</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        holdingTracks[i].push(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次处理各车厢</span></span><br><span class="line">    <span class="keyword">while</span> (!bins_c.empty()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sign = bins_c.pop();</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印当前车厢编号信息</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Time["</span> &lt;&lt; cnt++ &lt;&lt; <span class="string">"]: "</span>;  bins_c.print();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 寻找 `队尾 &lt; 当前车厢标号sign` 且 `最接近sign` 的栈</span></span><br><span class="line">            index = findHoldingTrack(sign, holdingTracks, k);</span><br><span class="line">            <span class="keyword">if</span> (index != <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若未找到，存入`0`号轨道</span></span><br><span class="line">            holdingTracks[<span class="number">0</span>].push(sign);</span><br><span class="line">            sign = bins_c.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 入栈</span></span><br><span class="line">        holdingTracks[index].push(sign);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看缓冲车道内排序</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"Holding tracks: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) holdingTracks[i].print();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排列到出轨道</span></span><br><span class="line">    LinkedQueue&lt;<span class="keyword">int</span>&gt; bins_o;</span><br><span class="line">    putIntoOutTrack(bins_o, holdingTracks, k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bins_o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkedQueue&lt;<span class="keyword">int</span>&gt; bins;</span><br><span class="line">    <span class="keyword">int</span> origin[<span class="number">9</span>] = &#123; <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">        bins.push(origin[<span class="number">9</span> - i - <span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"origin: "</span>; bins.print(); <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    LinkedQueue&lt;<span class="keyword">int</span>&gt; bins_c = reSortBins(bins, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"sorted: "</span>; bins_c.print();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">origin: 5 8 1 7 4 2 9 6 3</span><br><span class="line"></span><br><span class="line">Time[0]: 5 8 1 7 4 2 9 6</span><br><span class="line">Time[1]: 5 8 1 7 4 2 9</span><br><span class="line">Time[2]: 5 8 1 7 4 2</span><br><span class="line">Time[3]: 5 8 1 7 4</span><br><span class="line">Time[4]: 5 8 1 7</span><br><span class="line">Time[5]: 5 8 1</span><br><span class="line">Time[6]: 5 8</span><br><span class="line">Time[7]: 5</span><br><span class="line">Time[8]:</span><br><span class="line"></span><br><span class="line">Holding tracks:</span><br><span class="line">5 1 11</span><br><span class="line">9 6 3 -1</span><br><span class="line">8 7 4 2 -1</span><br><span class="line"></span><br><span class="line">sorted: 9 8 7 6 5 4 3 2 1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】线性表</title>
      <link href="/2020/02/17/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/2020/02/17/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="线性表数据结构"><a href="#线性表数据结构" class="headerlink" title="线性表数据结构"></a>线性表数据结构</h1><p>定义：<strong>线性表</strong>(linear list)也称<strong>有序表</strong>(ordered list)，他的每一个实例都是元素的一个有序集合。对于形如$(e_0, e_1, \dots, e_{n-1})$的实例，$n$为有穷自然数表示线性表的长度或大小，$e_i$为线性表的元素，$i$是元素$e_i$的索引。可以认为$e_0$先于$e_1, \cdots, e_{n-1}$，<strong>除了这种先后关系外，线性表不再有其他关系</strong>。</p><p>线性表应具有以下操作：</p><ol><li>创建/删除线性表</li><li>判断是否为空</li><li>确定长度或大小</li><li>按索引查找元素</li><li>给定元素确定索引</li><li>给定索引插入/删除元素</li><li>按顺序输出线性表元素</li></ol><blockquote><p>注意，在删除某元素时，包括查找和删除两步骤。采用数组描述时间复杂度为$O(1) + O(n)$，链表描述时间复杂度为$O(n) + O(1)$，故两者删除操作的时间复杂度相同都为$O(n)$。</p></blockquote><h1 id="描述方式"><a href="#描述方式" class="headerlink" title="描述方式"></a>描述方式</h1><p>数组和链表的区别整理如下：</p><ol><li>数组静态分配内存，链表动态分配内存；</li><li>数组在内存中连续，链表不连续；</li><li>数组元素在栈区，链表元素在堆区；</li><li>数组利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度O(n)；</li><li>数组插入或删除元素的时间复杂度O(n)，链表的时间复杂度O(1)。</li></ol><h2 id="数组描述"><a href="#数组描述" class="headerlink" title="数组描述"></a>数组描述</h2><p>定义：<strong>数组描述</strong>(array representation)中，利用数组来存储线性表的元素。</p><ol><li>映射关系：用于确定一个元素在线性表中的位置，如$location(i)=i, location(i)=arrayLength-i-1$等等；</li><li>删除/插入元素：若在指定索引$i$处删除/插入元素$e_{new}$，除记录/删除元素外，需将$e_i, e_{i+1}, \cdots$前移/后移；</li><li>创建数组类：a)确定数据类型，b)确定数组长度。可使用模板类解决问题a)，使用动态数组解决问题b)。</li></ol><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><blockquote><p>注意：实现模板类时，成员函数的声明与实现需位于同一文件，即<code>.h</code>中需包含函数的实现。否则将出现连接错误<code>LINK2019</code>错误。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arraylist.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 构造、拷贝构造、析构</span></span><br><span class="line">ArrayList(<span class="keyword">int</span> initSize = <span class="number">10</span>);</span><br><span class="line">ArrayList(<span class="keyword">const</span> ArrayList&lt;T&gt;&amp;);</span><br><span class="line">~ArrayList() &#123; <span class="keyword">delete</span>[] m_TElements;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组信息</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_iCount == <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">size</span><span class="params">()</span>  <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_iCount; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素获取、查询</span></span><br><span class="line"><span class="function">T&amp;   <span class="title">get</span>    <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> index)</span>   <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">indexOf</span><span class="params">(<span class="keyword">const</span> T&amp;  element)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> index, <span class="keyword">const</span> T&amp; e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkIndex</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; m_iCount - <span class="number">1</span>) <span class="keyword">throw</span> <span class="string">"无效的索引"</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">expend</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">T*  m_TElements;</span><br><span class="line"><span class="keyword">int</span> m_iSize;</span><br><span class="line"><span class="keyword">int</span> m_iCount;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ************************************************</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ArrayList&lt;T&gt;::ArrayList(<span class="keyword">int</span> initSize) :</span><br><span class="line">m_iSize(initSize), m_iCount(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_iSize &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="string">"无效的数组长度"</span>;</span><br><span class="line">m_TElements = <span class="keyword">new</span> T[m_iSize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ArrayList&lt;T&gt;::ArrayList(<span class="keyword">const</span> ArrayList&lt;T&gt;&amp; a)</span><br><span class="line">&#123;</span><br><span class="line">m_iSize = a.m_iSize;</span><br><span class="line">m_iCount = a.m_iCount;</span><br><span class="line">m_TElements = <span class="keyword">new</span> T[m_iSize];</span><br><span class="line"><span class="built_in">std</span>::copy(a.m_TElements, a.m_TElements + m_iSize, m_TElements);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; ArrayList&lt;T&gt;::get(<span class="keyword">const</span> <span class="keyword">int</span> index) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">checkIndex(index);</span><br><span class="line"><span class="keyword">return</span> m_TElements[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> ArrayList&lt;T&gt;::indexOf(<span class="keyword">const</span> T&amp; element) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> index = (<span class="keyword">int</span>)(find(m_TElements, m_TElements + m_iSize, element) - m_TElements);</span><br><span class="line"><span class="comment">// 若未找到，返回-1</span></span><br><span class="line"><span class="keyword">return</span> index == m_iSize - <span class="number">1</span> ? <span class="number">-1</span> : index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> ArrayList&lt;T&gt;::insert(<span class="keyword">const</span> <span class="keyword">int</span> index, <span class="keyword">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">checkIndex(index);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若数组已满，则倍增</span></span><br><span class="line"><span class="keyword">if</span> (m_iCount &gt;= m_iSize - <span class="number">1</span>) </span><br><span class="line">expend();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素后移</span></span><br><span class="line"><span class="built_in">std</span>::copy(m_TElements + index, m_TElements + m_iCount, m_TElements + index + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存元素，计数自增</span></span><br><span class="line">m_TElements[index] = e; m_iCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> ArrayList&lt;T&gt;::erase(<span class="keyword">const</span> <span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">checkIndex(index);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (index &gt; m_iCount - <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前移元素</span></span><br><span class="line"><span class="built_in">std</span>::copy(m_TElements + index + <span class="number">1</span>, m_TElements + m_iCount, m_TElements + index);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数自减</span></span><br><span class="line">m_iCount--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> ArrayList&lt;T&gt;::print() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_iCount; i++)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_TElements[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> ArrayList&lt;T&gt;::expend()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">2</span> * m_iSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新辟内存空间，并复制</span></span><br><span class="line">T* elements = <span class="keyword">new</span> T[size];</span><br><span class="line"><span class="built_in">std</span>::copy(m_TElements, m_TElements + m_iSize, elements);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放原内存，重新指定</span></span><br><span class="line"><span class="keyword">delete</span> [] m_TElements;</span><br><span class="line">m_TElements = elements;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组信息</span></span><br><span class="line">m_iSize = size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数测试如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">3</span>;</span><br><span class="line">    ArrayList&lt;<span class="keyword">int</span>&gt; a1(size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        a1.insert(i, <span class="number">2</span> * i);</span><br><span class="line">        a1.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        a1.erase(<span class="number">0</span>);</span><br><span class="line">        a1.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">0 2</span><br><span class="line">0 2 4</span><br><span class="line">2 4</span><br><span class="line">4</span><br></pre></td></tr></table></figure></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><strong>优点</strong>：a)很多线性表的操作可以调用C++ 方法实现；b)时间性能良好，方法<code>indexOf</code>，<code>erase</code>，<code>insert</code>最坏时间复杂度与表达大小为线性关系。<br><strong>缺点</strong>：空间利用率低，在<code>expend</code>方法中，需开辟两倍新的内存空间并赋值后，才释放原有空间。</p><p>解决空间需求的一个方式是，把所有线性表映射到一个足够大的数组<code>array</code>中，再用数组<code>front</code>与<code>last</code>作为数组索引，构造多重表。其中<code>front[i]</code>与<code>last[i]</code>分别指定第<code>i</code>个表<code>a[i]</code>的第一个元素位置与最后一个元素位置。</p><p>需注意元素操作时，各表间元素相互干扰。</p><h2 id="链式描述"><a href="#链式描述" class="headerlink" title="链式描述"></a>链式描述</h2><p>定义：在<strong>链式描述</strong>中，对象实例的每一个元素都用一个单元或节点来描述，每个节点明确包含另一个节点的位置信息，该信息称作<strong>链(link)</strong>或<strong>指针(pointer)</strong>。</p><h3 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h3><p>链表操作即可实现，注意内存的申请与释放。</p><p>首先，构造双向链表的节点<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arraylist.h</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChainNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">ChainNode() &#123; ptr = <span class="literal">nullptr</span>; prev = <span class="literal">nullptr</span>; next = <span class="literal">nullptr</span>; &#125;</span><br><span class="line">ChainNode(<span class="keyword">const</span> T val) &#123; ptr = <span class="keyword">new</span> T; *ptr = val; prev = <span class="literal">nullptr</span>; next = <span class="literal">nullptr</span>; &#125;</span><br><span class="line">~ChainNode() &#123; <span class="keyword">if</span> (ptr) <span class="keyword">delete</span> ptr; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setVal</span><span class="params">(T val)</span>  </span>&#123; <span class="keyword">if</span> (!ptr) ptr = <span class="keyword">new</span> T;  *ptr = val;&#125;</span><br><span class="line"><span class="function">T&amp; <span class="title">getVal</span><span class="params">()</span>       </span>&#123; <span class="keyword">if</span> (!ptr) <span class="keyword">throw</span> <span class="string">"invalid node"</span>; <span class="keyword">return</span> *ptr; &#125;</span><br><span class="line"></span><br><span class="line">ChainNode* prev;</span><br><span class="line">ChainNode* next;</span><br><span class="line">T* ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arraylist.h</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChainList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 构造、析构、拷贝构造</span></span><br><span class="line">ChainList() &#123; m_cnHead = <span class="keyword">new</span> ChainNode&lt;T&gt;; m_iCount = <span class="number">0</span>; &#125;</span><br><span class="line">ChainList(<span class="keyword">const</span> ChainList&lt;T&gt;&amp;);</span><br><span class="line">~ChainList();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组信息</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> !m_cnHead-&gt;ptr; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">size</span><span class="params">()</span>  <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_iCount; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素获取、查询</span></span><br><span class="line">ChainNode&lt;T&gt;* getNode(<span class="keyword">int</span> index) <span class="keyword">const</span>;</span><br><span class="line"><span class="function">T&amp;   <span class="title">get</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> index)</span>   <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">indexOf</span><span class="params">(<span class="keyword">const</span> T&amp; value)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> index, <span class="keyword">const</span> T&amp; value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkIndex</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; m_iCount) <span class="keyword">throw</span> <span class="string">"无效的索引"</span>;&#125;</span><br><span class="line"></span><br><span class="line">ChainNode&lt;T&gt;* m_cnHead;</span><br><span class="line"><span class="keyword">int</span> m_iCount;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ChainList&lt;T&gt;::ChainList(<span class="keyword">const</span> ChainList&lt;T&gt;&amp; <span class="built_in">list</span>)</span><br><span class="line">&#123;</span><br><span class="line">m_cnHead = <span class="keyword">new</span> ChainNode&lt;T&gt;;</span><br><span class="line">m_iCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ChainNode&lt;T&gt;* node = <span class="built_in">list</span>.m_cnHead;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>.m_iCount &amp;&amp; node; i++) &#123;</span><br><span class="line">insert(i, node-&gt;getVal());</span><br><span class="line">node = node-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ChainList&lt;T&gt;::~ChainList()</span><br><span class="line">&#123;</span><br><span class="line">ChainNode&lt;T&gt;* node = m_cnHead;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!node-&gt;ptr &amp;&amp; !node) &#123;</span><br><span class="line">ChainNode&lt;T&gt;* tmp = node-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放节点空间</span></span><br><span class="line">node-&gt;~ChainNode();</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> node;</span><br><span class="line">node = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ChainNode&lt;T&gt;* ChainList&lt;T&gt;::getNode(<span class="keyword">const</span> <span class="keyword">int</span> index) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">checkIndex(index);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据索引，链式寻找节点</span></span><br><span class="line">ChainNode&lt;T&gt;* node = m_cnHead;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)node = node-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; ChainList&lt;T&gt;::get(<span class="keyword">const</span> <span class="keyword">int</span> index) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> getNode(index)-&gt;getVal();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> ChainList&lt;T&gt;::indexOf(<span class="keyword">const</span> T&amp; value) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">ChainNode&lt;T&gt;* node = m_cnHead;</span><br><span class="line"><span class="comment">// 搜索</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (node-&gt;ptr &amp;&amp; node-&gt;getVal()!=value) &#123;</span><br><span class="line">node = node-&gt;next;</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> index == m_iCount ? <span class="number">-1</span> : index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> ChainList&lt;T&gt;::insert(<span class="keyword">const</span> <span class="keyword">int</span> index, <span class="keyword">const</span> T&amp; value)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 创建节点</span></span><br><span class="line">ChainNode&lt;T&gt;* tmp = <span class="keyword">new</span> ChainNode&lt;T&gt;(value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取节点</span></span><br><span class="line">ChainNode&lt;T&gt;* node = getNode(index);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接，注意头节点的处理</span></span><br><span class="line"><span class="keyword">if</span> (node-&gt;prev) &#123;</span><br><span class="line">node-&gt;prev-&gt;next = tmp; </span><br><span class="line">tmp-&gt;prev = node-&gt;prev;</span><br><span class="line">&#125;</span><br><span class="line">tmp-&gt;next = node; </span><br><span class="line">node-&gt;prev = tmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">0</span>) m_cnHead = tmp;</span><br><span class="line"></span><br><span class="line">m_iCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> ChainList&lt;T&gt;::erase(<span class="keyword">const</span> <span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 获取节点</span></span><br><span class="line">ChainNode&lt;T&gt;* node = getNode(index);</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">m_cnHead = node-&gt;next; m_cnHead-&gt;prev = <span class="literal">nullptr</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接，释放，注意头节点的处理</span></span><br><span class="line"><span class="keyword">if</span>(node-&gt;prev) node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">node-&gt;~ChainNode();</span><br><span class="line"></span><br><span class="line">m_iCount--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> ChainList&lt;T&gt;::print() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">ChainNode&lt;T&gt;* node = m_cnHead;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (node-&gt;ptr &amp;&amp; node-&gt;next) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; node-&gt;getVal() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">node = node-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数测试如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 创建链表</span></span><br><span class="line">ChainList&lt;<span class="keyword">int</span>&gt; c1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"empty(1): "</span> &lt;&lt; c1.empty() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"size (1): "</span> &lt;&lt; c1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入0, 2, 4</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">c1.insert(i, <span class="number">2</span> * i);</span><br><span class="line">c1.print();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"empty(2): "</span> &lt;&lt; c1.empty() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"size (2): "</span> &lt;&lt; c1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"index of `2`: "</span> &lt;&lt; c1.indexOf(<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按顺序删除2, 0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">c1.erase(<span class="number">1</span> - i);</span><br><span class="line">c1.print();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"empty(3): "</span> &lt;&lt; c1.empty() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"size (3): "</span> &lt;&lt; c1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">empty(1): 1</span><br><span class="line">size (1): 0</span><br><span class="line">0</span><br><span class="line">0 2</span><br><span class="line">0 2 4</span><br><span class="line">empty(2): 0</span><br><span class="line">size (2): 3</span><br><span class="line">index of `2`: 1</span><br><span class="line">0 4</span><br><span class="line">4</span><br><span class="line">empty(3): 0</span><br><span class="line">size (3): 1</span><br></pre></td></tr></table></figure></p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><ol><li><p>内存空间</p><p> 与数组描述的线性表不同，链式描述动态分配内存空间，故可较少<code>expend</code>操作时的内存占用。<br> 由于使用指针进行内存维护，对于<code>n</code>个元素的双向线性表，该链表共申请$n(12+s)$字节内存空间(单个元素指针占用$4 \times 3$字节，数据存储占用$s$字节)。空间需求不是决定因素。</p></li><li><p>运行时间</p><p> 链式描述的线性表时间复杂度为$\Theta(n)$，数组描述的为$\Theta(1)$。链表的插入位置是随机的，也即逻辑相邻的元素在空间上不一定相邻，这样导致很多高速缓存缺失。<br> 考虑时间复杂度，可使用<strong>双向链表</strong>(doubly linked list)，用两个数据成员<code>firstNode</code>与<code>lastNode</code>分别指向链表的头部和尾部，若查询下标<code>index</code>大于size/2，则从末端进行查找。</p></li><li><p>指针的优点</p><p> 操作灵活，且动态分配内存空间。</p></li></ol><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol><li><p>箱子排序<br> 对n个存放在链表中的数据进行排序，假设每个箱子为一个链表，其节点数介于$0~n$之间，初始状态每个箱子都是空的。<br> a) 逐个删除输入链表的首元素，并将删除节点分配至相应箱子的链表首位；<br> b) 从最后一个箱子开始，逐个删除每个箱子的元素，并插入一个初始为空的链表首位。</p><p> 添加代码</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ChainList&lt;<span class="keyword">int</span>&gt; ChainList&lt;T&gt;::binsort(<span class="keyword">int</span> range, T (*pFunc)(T))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 创建箱子(存放下标，节省内存，但时间多用于查询)</span></span><br><span class="line">ChainList&lt;<span class="keyword">int</span>&gt;** bins = <span class="keyword">new</span> ChainList&lt;<span class="keyword">int</span>&gt;* [range];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; range; i++)&#123;</span><br><span class="line">bins[i] = <span class="keyword">new</span> ChainList&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数据划入箱子</span></span><br><span class="line"><span class="keyword">for</span> (ChainNode&lt;T&gt;* node = m_cnHead; node-&gt;ptr; node = node-&gt;next) &#123;</span><br><span class="line">T val = node-&gt;getVal();</span><br><span class="line"><span class="keyword">int</span> index = pFunc? (*pFunc)(val): val;</span><br><span class="line">bins[index]-&gt;insert(<span class="number">0</span>, indexOf(val));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; range; i++) &#123;</span><br><span class="line">bins[i]-&gt;print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新整合顺序，存储于链表</span></span><br><span class="line">ChainList&lt;<span class="keyword">int</span>&gt; order;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; range; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (ChainNode&lt;<span class="keyword">int</span>&gt;* node = bins[i]-&gt;m_cnHead; node-&gt;ptr; node = node-&gt;next) &#123;</span><br><span class="line">order.insert(order.size(), node-&gt;getVal());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> bins[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> bins;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ChainList&lt;T&gt; ChainList&lt;T&gt;::ordered(<span class="keyword">const</span> ChainList&lt;<span class="keyword">int</span>&gt; order)</span><br><span class="line">&#123;</span><br><span class="line">ChainList&lt;T&gt; output; <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (ChainNode&lt;<span class="keyword">int</span>&gt;* node = order.m_cnHead; node-&gt;ptr; node = node-&gt;next) &#123;</span><br><span class="line">output.insert(cnt++, get(node-&gt;getVal()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 主程序测试：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">ChainList&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">c.insert(<span class="number">0</span>, <span class="number">53</span> * i % <span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line">c.print();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>(*pf1)(<span class="keyword">int</span>) = f1;</span><br><span class="line">ChainList&lt;<span class="keyword">int</span>&gt; order = c.binsort(<span class="number">50</span>, pf1);</span><br><span class="line">ChainList&lt;<span class="keyword">int</span>&gt; ordered = c.ordered(order);</span><br><span class="line">ordered.print();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">47 44 41 38 35 32 29 26 23 20 17 14 11 8 5 2 49 46 43 40 37 34 31 28 25 22 19 16 13 10 7 4 1 48 45 42 39 36 33 30 27 24 21 18 15 12 9 6 3 0 47 44 41 38 35 32 29 26 23 20 17 14 11 8 5 2 49 46 43 40 37 34 31 28 25 22 19 16 13 10 7 4 1 48 45 42 39 36 33 30 27 24 21 18 15 12 9 6 3 0</span><br><span class="line">0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 10 11 11 12 12 13 13 14 14 15 15 16 16 17 17 18 18 19 19 20 20 21 21 22 22 23 23 24 24 25 25 26 26 27 27 28 28 29 29 30 30 31 31 32 32 33 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44 44 45 45 46 46 47 47 48 48 49 49</span><br></pre></td></tr></table></figure><p> 对于具有$m$级大小关系的$n$个数据，该排序算法需初始化$m$个空箱子。在箱子排序基础上进行改进，可得到基数排序。</p></li><li><p>基数排序<br> 基于箱子排序，基数排序可在$\Theta(n)$时间内，对$0~n^c-1$之间的$n$个整数进行排序。具体算法为：按从低到高的位数顺序，按数据当前位数字大小进行箱子排序，整数范围位于$0~9$之间，故仅需初始化$10$个箱子即可。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【算法】程序性能分析与渐近记号</title>
      <link href="/2020/02/16/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E6%B8%90%E8%BF%91%E8%AE%B0%E5%8F%B7/"/>
      <url>/2020/02/16/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E6%B8%90%E8%BF%91%E8%AE%B0%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="程序性能"><a href="#程序性能" class="headerlink" title="程序性能"></a>程序性能</h1><p><strong>程序性能</strong>(performance of a program)是指运行这个程序所需要的内存和时间的多少。</p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p><strong>定义</strong>：<strong>空间复杂度</strong>(space complexity)是该程序的运行所需内存的大小。</p><p>程序需要的空间主要以以下部分组成</p><ol><li><p>指令空间(instruction space)<br> 是指编译后的程序指令所需要的存储空间，取决于以下因素</p><ul><li>编译器；</li><li>编译选项；</li><li>目标计算机。</li></ul></li><li><p>数据空间(data space)<br>是所有常量和变量值所需要的存储空间，由</p><ul><li>常量和简单变量所需要的存储空间；</li><li>动态数组和动态类实例等动态对象所需要的空间。</li></ul></li><li><p>环境栈空间(environment stack space)<br> 保存暂停的函数和方法在恢复运行时所需要的信息：</p><ul><li>返回地址；</li><li>正在调用的函数的所有局部变量的值以及形式参数的值(仅对递归函数而言)。</li></ul></li></ol><p>程序所需要的空间可分成两部分</p><ol><li>固定部分，独立于实例特征，包括上述指令空间、简单变量空间、常量空间等；</li><li>可变部分，由动态分配空间(某种程度上依赖实力特征)和递归栈空间(依赖实力特征)构成。</li></ol><p>将空间需求的固定部分记作$c$，可变部分记作$S_p$，那么所需空间为$c + S_p(实例特征)$。</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p><strong>定义</strong>：<strong>时间复杂度</strong>(time complexity)是该程序的运行所需要的时间。</p><h3 id="操作计数"><a href="#操作计数" class="headerlink" title="操作计数"></a>操作计数</h3><p>估算程序或函数的时间复杂度，一种方法是选择一种或多种<strong>关键操作</strong>，如加、乘、比较等，确定每一种操作的<strong>执行次数</strong>，注意操作计数忽视了其他操作。以选择排序和冒泡排序为例，选择排序与冒泡排序都需要$\sum_{i=1}^{n-1} i = n(n-1)/2$次比较和$3(n-1)$次移动。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(T a[], <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;    <span class="comment">// n - 1次</span></span><br><span class="line"><span class="keyword">int</span> index = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;   <span class="comment">// i次比较</span></span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; a[index]) index = j;</span><br><span class="line">        &#125;</span><br><span class="line">T temp = a[i];                      <span class="comment">// 3次移动</span></span><br><span class="line">        a[i] = a[index]; </span><br><span class="line">        a[index] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(T a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;      <span class="comment">// n - 1次循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123; </span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123;          <span class="comment">// i次比较</span></span><br><span class="line">T temp = a[j];              <span class="comment">// 3次移动</span></span><br><span class="line">                a[j] = a[j + <span class="number">1</span>]; </span><br><span class="line">                a[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>操作计数不总是由实例特征唯一确定</strong>，如冒泡排序中，交换次数不仅依赖于实例特征$n$，还依赖于数组元素的具体值，所以就要估算最好、最坏和平均操作计数。</p><h3 id="步数"><a href="#步数" class="headerlink" title="步数"></a>步数</h3><p><strong>步数</strong>(step-count)方法中，将程序/函数的所有操作部分都进行统计。<strong>步数也是实例特征的函数</strong>，为确定程序的步数，必须<strong>先确定所采用的实例特征</strong>，如输入个数、输出个数、输入或输出的大小，不仅<strong>确定步数计算表达式中的变量</strong>，还确定了<strong>一步应该包含多少次计算</strong>。<strong>一步</strong>(a step)是独立于所选定实例特征的一个计算单位，例如$100$次乘法可视作一步，但$n$次乘法包含实例特征不能视作一步。</p><p><strong>定义</strong>：<strong>程序步</strong>(a program step)可以大概定义为<strong>一个语法或语义上的程序片段</strong>，该片段执行时间独立于实例特征，例如下面语句中变量均独立于实例特征，可视作一个程序步：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> a + b + b * c + (a + b - c) / (a + b) + <span class="number">4</span>;</span><br></pre></td></tr></table></figure></p><blockquote><ul><li>故而相同步数的程序可能差别很大；</li><li>步数与时间复杂度是同义词。</li></ul></blockquote><p>用剖析法计算程序步数时，记$s/e$为每条语句每次执行所需要的步数(steps pre execution)，$f$为语句的执行次数或频率，进行列表计算，例如对于冒泡排序</p><div class="table-container"><table><thead><tr><th>程序语句</th><th>s/e</th><th>频率</th><th>总步数</th></tr></thead><tbody><tr><td>template\<typename t\=""></typename></td><td>/</td><td>/</td><td>/</td></tr><tr><td>void bubbleSort(T a[], int n) {</td><td>/</td><td>/</td><td>/</td></tr><tr><td>for (int i = n - 1; i &gt;= 1; i—) {</td><td>$1$</td><td>$(n - 1) + 1$</td><td>$n$</td></tr><tr><td>for (int j = 0; j &lt; i; j++) {</td><td>$i+1$</td><td>$n-1$</td><td>$n(n-1)/2 + (n-1)$</td></tr><tr><td>if (a[j] &gt; a[j + 1]) { T temp = a[j]; a[j] = a[j + 1];  a[j + 1] = temp; }</td><td>$i$</td><td>$n-1$</td><td>$n(n-1)/2$</td></tr><tr><td>}}}</td><td>/</td><td>/</td><td>/</td></tr><tr><td>总计</td><td>/</td><td>/</td><td>$n^2 + n - 1$</td></tr></tbody></table></div><h1 id="渐近记号"><a href="#渐近记号" class="headerlink" title="渐近记号"></a>渐近记号</h1><p>当<strong>实例特征$n$很大($n \rightarrow \infty$)时</strong>，使用步数可以准确地预计运行时间的增长，以比较两个程序的性能。当$n \rightarrow \infty$时，最高次项在整个多项式中占主导，可省略$c_2 n + c_3$两项。<strong>渐近分析主要确定的时复杂函数中的最大项</strong>。</p><blockquote><p>例如，对于任何具有形式$c_1 n^2 + c_3 + c_2 n + c_3$,($c_1 &gt; 0$且$c_1, c_2, c_3$为常数)的步数的程序，都有</p><script type="math/tex; mode=display">\lim_{n \rightarrow \infty} \frac{c_2 n + c_3}{c_1 n^2} = 0</script></blockquote><p><strong>定义</strong>：令$p(n)$和$q(n)$是两个<strong>非负函数</strong>，那么当且仅当</p><script type="math/tex; mode=display">\lim_{n \rightarrow \infty} \frac{q(n)}{p(n)} = 0</script><p>称$p(n)$<strong>渐近地大于</strong>$q(n)$($p(n)$渐近地优于$q(n)$)，或$q(n)$<strong>渐近地小于</strong>$p(n)$；当且仅当任何一个都不是渐近大于另一个时，称$p(n)$<strong>渐近地等于</strong>$q(n)$。</p><p>步数分析中常见的项如下标，<strong>大小关系</strong>从上往下依次减小</p><div class="table-container"><table><thead><tr><th>项</th><th>名称</th></tr></thead><tbody><tr><td>$1$</td><td>常量</td></tr><tr><td>$\log n$</td><td>对数</td></tr><tr><td>$n$</td><td>线性</td></tr><tr><td>$n \log n$</td><td>$n$倍对数</td></tr><tr><td>$n^2$</td><td>平方</td></tr><tr><td>$n^3$</td><td>立方</td></tr><tr><td>$2^n$</td><td>指数</td></tr><tr><td>$n!$</td><td>阶乘</td></tr></tbody></table></div><p><strong>定义</strong>：<strong>渐近记法</strong>(asymptotic notation)描述的是大实例特征的时间或空间复杂度，用步数中<strong>渐近最大</strong>的一项的<strong>单位项</strong>来描述复杂度。<strong>几种常见的渐近记法</strong>如下</p><div class="table-container"><table><thead><tr><th>表示法</th><th>读法</th><th>含义</th><th>例</th></tr></thead><tbody><tr><td>$f(n) = O(g(n))$</td><td>$f(n)$ is big O of $g(n)$</td><td>$f(n)$渐近小于或等于$f(n)$，$g(n)$是$f(n)$的上限</td><td>$100n^2 - 20 n + 3 = O(n^2) \neq O(n)$</td></tr><tr><td>$f(n) = \Omega(g(n))$</td><td>$f(n)$ is big omega of $g(n)$</td><td>$f(n)$渐近大于或等于$f(n)$，$g(n)$是$f(n)$的下限</td><td>$100n^2 - 20 n + 3 = \Omega(n^2) = \Omega(n) \neq \Omega(n^3)$</td></tr><tr><td>$f(n) = \Theta(g(n))$</td><td>$f(n)$ is big theta of $g(n)$</td><td>$f(n)$渐近等于$f(n)$，$g(n)$是$f(n)$的上限</td><td>$100n^2 - 20 n + 3 = \Theta(n^2) \neq \Theta(n) \neq \Theta(n^3)$</td></tr></tbody></table></div><blockquote><p>注意$f(n) = O(g(n))$与$O(g(n)) = f(n)$含义不同。</p></blockquote><p>仍以冒泡排序为例，总的时间复杂度为$\Theta(n^2)$。</p><div class="table-container"><table><thead><tr><th>程序语句</th><th>s/e</th><th>频率</th><th>总步数</th></tr></thead><tbody><tr><td>template\<typename t\=""></typename></td><td>/</td><td>/</td><td>/</td></tr><tr><td>void bubbleSort(T a[], int n) {</td><td>/</td><td>/</td><td>/</td></tr><tr><td>for (int i = n - 1; i &gt;= 1; i—) {</td><td>$1$</td><td>$(n - 1) + 1$</td><td>$\Theta(n)$</td></tr><tr><td>for (int j = 0; j &lt; i; j++) {</td><td>$i+1$</td><td>$n-1$</td><td>$\Theta(n^2)$</td></tr><tr><td>if (a[j] &gt; a[j + 1]) { T temp = a[j]; a[j] = a[j + 1];  a[j + 1] = temp; }</td><td>$i$</td><td>$n-1$</td><td>$\Theta(n^2)$</td></tr><tr><td>}}}</td><td>/</td><td>/</td><td>/</td></tr><tr><td>总计</td><td>/</td><td>/</td><td>$\Theta(n^2)$</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Elastic Search</title>
      <link href="/2020/02/13/Elastic-Search/"/>
      <url>/2020/02/13/Elastic-Search/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><blockquote><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html" target="_blank" rel="noopener">Elasticsearch: 权威指南</a><br>注意ES6.x</p><ul><li><strong>移除<code>string</code>，新增<code>text</code>及<code>keyword</code>，并且<code>mappings</code>中<code>index</code>参数为布尔值</strong></li><li><strong>移除missing</strong></li></ul></blockquote><ul><li><a href="#目录">目录</a></li><li><a href="#基础入门">基础入门</a><ul><li><a href="#安装运行">安装运行</a></li><li><a href="#特性">特性</a></li><li><a href="#交互语句">交互语句</a></li><li><a href="#数据操作">数据操作</a><ul><li><a href="#元数据">元数据</a></li><li><a href="#检查文档-head">检查文档: HEAD</a></li><li><a href="#索引文档-put或post">索引文档: PUT或POST</a></li><li><a href="#新建文档-put-url_creat或post">新建文档: PUT /URL/_creat或POST</a></li><li><a href="#更新文档-put">更新文档: PUT</a></li><li><a href="#部分更新-post-url_update">部分更新: POST /URL/_update</a></li><li><a href="#取回文档-get">取回文档: GET</a></li><li><a href="#取回多个文档-get-_mget">取回多个文档: GET /_mget</a></li><li><a href="#删除文档-delete">删除文档: DELETE</a></li><li><a href="#批量操作-post-_bulk">批量操作: POST /_bulk</a></li></ul></li><li><a href="#搜索可用请求体查询替代">搜索(可用请求体查询替代)</a><ul><li><a href="#空搜索">空搜索</a></li><li><a href="#多索引和多类型">多索引和多类型</a></li><li><a href="#指定查询搜索">指定查询搜索</a></li><li><a href="#结果分页">结果分页</a></li></ul></li><li><a href="#映射与分析">映射与分析</a><ul><li><a href="#映射">映射</a><ul><li><a href="#简单域类型">简单域类型</a></li><li><a href="#查看映射-get-_index_mapping">查看映射: GET /_index/_mapping</a></li><li><a href="#自定义映射">自定义映射</a></li><li><a href="#更新映射-put-_index-mappings--">更新映射: PUT /_index {“mappings”: {…} }</a></li><li><a href="#测试映射-get-_index_analyze">测试映射: GET /_index/_analyze</a></li></ul></li><li><a href="#分析">分析</a></li></ul></li><li><a href="#请求体查询-get-url_search-query--">请求体查询: GET /URL/_search {“query”: {…} }</a><ul><li><a href="#几个重要的查询">几个重要的查询</a><ul><li><a href="#match_all">match_all</a></li><li><a href="#matchmulti_match">match/multi_match</a></li><li><a href="#termterms">term/terms</a></li><li><a href="#exists">exists</a></li><li><a href="#range">range</a></li></ul></li><li><a href="#组合多个查询">组合多个查询</a><ul><li><a href="#must">must</a></li><li><a href="#must_not">must_not</a></li><li><a href="#should">should</a></li><li><a href="#filter">filter</a></li><li><a href="#bool">bool</a></li><li><a href="#constant_score">constant_score</a></li></ul></li><li><a href="#验证查询-get-url_search_validatequeryexplain">验证查询: GET /URL/_search/_validate/query?explain</a></li></ul></li><li><a href="#排序与相关性">排序与相关性</a><ul><li><a href="#排序-get-url_search--sort----">排序: GET /URL/_search { “sort”: { … } }</a><ul><li><a href="#按字段值排序">按字段值排序</a></li><li><a href="#多级排序">多级排序</a></li><li><a href="#多值字段排序">多值字段排序</a></li></ul></li><li><a href="#相关性-_score">相关性: _score</a></li></ul></li><li><a href="#索引管理">索引管理</a><ul><li><a href="#创建-put-_index">创建: PUT /_index</a><ul><li><a href="#settings">settings</a><ul><li><a href="#number_of_shardsnumber_of_replicas">number_of_shards/number_of_replicas</a></li><li><a href="#analysis">analysis</a></li></ul></li><li><a href="#mappings">mappings</a></li></ul></li><li><a href="#删除-delete-_index">删除: DELETE /_index</a></li></ul></li></ul></li><li><a href="#深入搜索">深入搜索</a><ul><li><a href="#结构化搜索">结构化搜索</a><ul><li><a href="#精确值查找-term">精确值查找: term</a></li><li><a href="#组合过滤器-bool">组合过滤器: bool</a></li><li><a href="#精确查找多个值-terms">精确查找多个值: terms</a></li><li><a href="#范围-range">范围: range</a></li><li><a href="#处理空值-exists">处理空值: exists</a></li></ul></li><li><a href="#全文搜索">全文搜索</a><ul><li><a href="#匹配查询-match">匹配查询: match</a></li><li><a href="#多词查询-match">多词查询: match</a></li><li><a href="#组合查询-bool">组合查询: bool</a></li><li><a href="#语句权重-boost">语句权重: boost</a></li><li><a href="#控制分析-get-url_index_analyze--field--text--">控制分析: GET /URL/_index/_analyze { “field”: …, “text”: … }</a></li></ul></li><li><a href="#多字段查询">多字段查询</a><ul><li><a href="#多字段查询-multi_match">多字段查询: multi_match</a></li><li><a href="#最佳字段best_fields-dis_max">最佳字段(best_fields): dis_max</a></li><li><a href="#多数字段most_fields-fieldsubfield">多数字段(most_fields): field.subField</a></li><li><a href="#跨字段cross_fields-filed1--filedn">跨字段(cross_fields): filed1, …, filedn</a></li><li><a href="#_all字段-copy_to">_all字段: copy_to</a></li></ul></li><li><a href="#近似匹配">近似匹配</a><ul><li><a href="#短语匹配-match_phrase">短语匹配: match_phrase</a></li><li><a href="#结果集重新评分-rescore">结果集重新评分: rescore</a></li><li><a href="#相关词-shinglesngrams">相关词: shingles/Ngrams</a></li></ul></li><li><a href="#部分匹配">部分匹配</a><ul><li><a href="#前缀查询-prefix">前缀查询: prefix</a></li><li><a href="#前缀短语匹配-match_phrase_prefix">前缀短语匹配: match_phrase_prefix</a></li><li><a href="#通配符查询-wildcard">通配符查询: wildcard</a></li><li><a href="#正则表达式查询-regexp">正则表达式查询: regexp</a></li></ul></li><li><a href="#控制相关度">控制相关度</a></li></ul></li><li><a href="#聚合">聚合</a><ul><li><a href="#尝试聚合">尝试聚合</a><ul><li><a href="#命令格式-get-url_search--aggs--name--agg_type------">命令格式: GET /URL/_search { “aggs”: { “NAME”: { AGG_TYPE: { … } } } }</a></li><li><a href="#简单例子-terms-avg-max-min">简单例子: terms, avg, max, min</a></li></ul></li><li><a href="#限定聚合范围-query-global">限定聚合范围: query, global</a></li><li><a href="#直方图统计-histogram">直方图统计: histogram</a></li><li><a href="#统计量计算-extended_stats">统计量计算: extended_stats</a></li><li><a href="#按时间统计-date_histogram">按时间统计: date_histogram</a></li><li><a href="#过滤和聚合">过滤和聚合</a><ul><li><a href="#查询过滤-query---filter--">查询过滤: “query”: { …, “filter”, … }</a></li><li><a href="#聚合过滤-aggs---filter--">聚合过滤: “aggs”: { …, “filter”, … }</a></li><li><a href="#后过滤器-post_filter">后过滤器: post_filter</a></li></ul></li><li><a href="#多桶排序-order">多桶排序: order</a><ul><li><a href="#内置排序-_count-_term-_key">内置排序: _count, _term, _key</a></li><li><a href="#按度量排序自定义嵌套度量">按度量排序:自定义嵌套度量</a></li><li><a href="#深度度量排序自定义嵌套更深的度量">“深度”度量排序:自定义嵌套更深的度量</a></li></ul></li><li><a href="#近似聚合">近似聚合</a><ul><li><a href="#统计去重后的数目-cardinality">统计去重后的数目: cardinality</a><ul><li><a href="#设置精度-precision_threshold">设置精度: precision_threshold</a></li><li><a href="#优化速度-hash">优化速度: hash</a></li></ul></li><li><a href="#百分位数度量-percentiles">百分位数度量: percentiles</a></li></ul></li></ul></li><li><a href="#elasticsearch-py">elasticsearch-py</a></li></ul><h1 id="基础入门"><a href="#基础入门" class="headerlink" title="基础入门"></a><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/getting-started.html" target="_blank" rel="noopener">基础入门</a></h1><ul><li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/distributed-cluster.html" target="_blank" rel="noopener">Elasticsearch: 权威指南 » 基础入门 » 集群内的原理</a></li></ul><h2 id="安装运行"><a href="#安装运行" class="headerlink" title="安装运行"></a>安装运行</h2><blockquote><p>注意JDK8仅支持<a href="https://www.elastic.co/cn/downloads/past-releases/elasticsearch-6-6-0" target="_blank" rel="noopener">Elasticsearch 6.x</a>和<a href="https://www.elastic.co/cn/downloads/past-releases/kibana-6-6-0" target="_blank" rel="noopener">Kibana 6.x</a></p></blockquote><ul><li>下载并解压  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.6.0.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar -zxvf elasticsearch-6.6.0.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> wget https://artifacts.elastic.co/downloads/kibana/kibana-6.6.0-linux-x86_64.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar -zxvf kibana-6.6.0-linux-x86_64.tar.gz</span></span><br></pre></td></tr></table></figure></li><li><p>修改配置文件<code>elasticsearch-6.6.0/config/elasticsearch.yml</code></p><p>  主要修改的几条配置如下</p>  <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---------------------------------- Cluster -----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Use a descriptive name for your cluster:</span></span><br><span class="line"><span class="string">cluster.name:</span> <span class="string">louishsu-application</span></span><br><span class="line"><span class="comment"># ----------------------------------- Paths ------------------------------------</span></span><br><span class="line"><span class="comment"># Path to directory where to store the data (separate multiple locations by comma):</span></span><br><span class="line"><span class="string">path.data:</span> <span class="string">/home/louishsu/Downloads/elasticsearch-6.6.0/tmp/data</span></span><br><span class="line"><span class="comment"># Path to log files:</span></span><br><span class="line"><span class="string">path.logs:</span> <span class="string">/home/louishsu/Downloads/elasticsearch-6.6.0/tmp/logs</span></span><br></pre></td></tr></table></figure><p>  补齐文件夹</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir tmp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir tmp/data tmp/logs</span></span><br></pre></td></tr></table></figure></li><li><p>添加环境变量：将<code>elasticsearch-6.6.0/bin/</code>和<code>kibana-6.6.0-linux-x86_64/bin/</code>目录添加到环境变量<code>${PATH}</code>中</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> &gt;&gt;&gt; elasticsearch &gt;&gt;&gt;</span></span><br><span class="line">export ELASTICSEARCH_HOME=/home/louishsu/Downloads/elasticsearch-6.6.0</span><br><span class="line">export PATH=$PATH:$ELASTICSEARCH_HOME/bin</span><br><span class="line"><span class="meta">#</span><span class="bash"> &lt;&lt;&lt; elasticsearch &lt;&lt;&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> &gt;&gt;&gt; kibana &gt;&gt;&gt;</span></span><br><span class="line">export KIBANA_HOME=/home/louishsu/Downloads/kibana-6.6.0-linux-x86_64</span><br><span class="line">export PATH=$PATH:$KIBANA_HOME/bin</span><br><span class="line"><span class="meta">#</span><span class="bash"> &lt;&lt;&lt; kibana &lt;&lt;&lt;</span></span><br></pre></td></tr></table></figure></li><li><p>运行ElasticSearch</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> elasticsearch</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>  对<code>http://localhost:9200/?pretty</code>发送请求，可以得到如下输出</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl <span class="string">'http://localhost:9200/?pretty'</span></span></span><br><span class="line">&#123;</span><br><span class="line">    "name" : "KFnpkyD",</span><br><span class="line">    "cluster_name" : "louishsu-application",</span><br><span class="line">    "cluster_uuid" : "Jc3kJRbKSWeqUvNepFWogQ",</span><br><span class="line">    "version" : &#123;</span><br><span class="line">        "number" : "6.6.0",</span><br><span class="line">        "build_flavor" : "default",</span><br><span class="line">        "build_type" : "tar",</span><br><span class="line">        "build_hash" : "a9861f4",</span><br><span class="line">        "build_date" : "2019-01-24T11:27:09.439740Z",</span><br><span class="line">        "build_snapshot" : false,</span><br><span class="line">        "lucene_version" : "7.6.0",</span><br><span class="line">        "minimum_wire_compatibility_version" : "5.6.0",</span><br><span class="line">        "minimum_index_compatibility_version" : "5.0.0"</span><br><span class="line">    &#125;,</span><br><span class="line">    "tagline" : "You Know, for Search"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行Kibana<br>  运行kibana，并通过<code>http://localhost:5601</code>访问</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kibana</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>ES是<strong>面向文档</strong>的，存储整个对象或<strong>文档</strong>，通过<strong>索引</strong>每个文档的内容使其可以被检索。同其他NoSQL一样，使用JSON作为文档序列化格式，例如一个<code>user</code>对象可以表示为<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"email"</span>:      <span class="string">"john@smith.com"</span>,</span><br><span class="line">    <span class="attr">"first_name"</span>: <span class="string">"John"</span>,</span><br><span class="line">    <span class="attr">"last_name"</span>:  <span class="string">"Smith"</span>,</span><br><span class="line">    <span class="attr">"info"</span>: &#123;</span><br><span class="line">        <span class="attr">"bio"</span>:         <span class="string">"Eco-warrior and defender of the weak"</span>,</span><br><span class="line">        <span class="attr">"age"</span>:         <span class="number">25</span>,</span><br><span class="line">        <span class="attr">"interests"</span>: [ <span class="string">"dolphins"</span>, <span class="string">"whales"</span> ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"join_date"</span>: <span class="string">"2014/05/01"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一个 Elasticsearch 集群可以包含多个<strong>索引</strong>(指向一个或者多个物理<strong>分片</strong>的逻辑命名空间) ，相应的每个索引可以包含多个<strong>类型</strong>。 这些不同的类型存储着多个<strong>文档</strong>，每个文档又有多个<strong>属性</strong>，文档路径表示为<code>/_index/_type/_id</code>。</p><h2 id="交互语句"><a href="#交互语句" class="headerlink" title="交互语句"></a>交互语句</h2><p>Elasticsearch请求和HTTP请求类似，由以下格式组成<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X &lt;VERB&gt; '&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;' -d '&lt;BODY&gt;'</span><br></pre></td></tr></table></figure></p><blockquote><ul><li>若希望得到<code>head</code>信息，添加<code>-i</code>，即<code>curl -i -X&lt;...</code></li><li>表示为缩写格式(Kibana, Sense等控制台中使用)<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;VERB&gt; /&lt;PATH&gt;</span><br><span class="line">&lt;BODY&gt;</span><br></pre></td></tr></table></figure></li><li>在kibana的dev tool中可将缩写格式快速转换为<code>curl</code>。</li></ul></blockquote><p>例如获取集群中文档的数目<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET 'http://localhost:9200/_count?pretty' -d '</span><br><span class="line">&#123;</span><br><span class="line">    "query": &#123;</span><br><span class="line">        "match_all": &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">'</span><br></pre></td></tr></table></figure></p><p>对应缩写格式为<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /_count</span><br><span class="line">&#123;</span><br><span class="line">    "query": &#123;</span><br><span class="line">        "match_all": &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中各部件说明如下</p><div class="table-container"><table><thead><tr><th>部件</th><th>说明</th></tr></thead><tbody><tr><td><code>VERB</code></td><td>HTTP方法或谓词，<code>GET, HEAD, PUT, POST, DELETE</code></td></tr><tr><td><code>PROTOCOL</code></td><td><code>http</code>或<code>https</code>(ES前有<code>https</code>代理的情况下)</td></tr><tr><td><code>HOST</code></td><td>ES集群中节点的主机名，本地主机用<code>localhost</code>表示</td></tr><tr><td><code>PORT</code></td><td>主机运行ES服务的端口号，默认<code>9200</code></td></tr><tr><td><code>PATH</code></td><td>API的终端路径，<code>/_index/_type/_id</code>，，及<code>_count, _search</code>等</td></tr><tr><td><code>QUERY_STRING</code></td><td>查询字符串，如<code>?pretty</code></td></tr><tr><td><code>BODY</code></td><td>JSON格式的请求体(如果需要)</td></tr></tbody></table></div><h2 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h2><h3 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h3><p>文档元数据包括</p><ul><li>索引(<code>_index</code>)：因共同的特性被分组到一起的文档集合；</li><li>类别(<code>_type</code>)：共享一种相同的（或非常相似）模式的文档集合，定义“子分区”；</li><li>标识(<code>_id</code>)：文档的唯一标识，字符串。</li></ul><h3 id="检查文档-HEAD"><a href="#检查文档-HEAD" class="headerlink" title="检查文档: HEAD"></a>检查文档: HEAD</h3><p>仅获得HTTP请求报头<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HEAD /website/blog/123</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">200 OK</span><br></pre></td></tr></table></figure><h3 id="索引文档-PUT或POST"><a href="#索引文档-PUT或POST" class="headerlink" title="索引文档: PUT或POST"></a>索引文档: PUT或POST</h3><p>索引文档是指将文档<strong>存储，并可被索引</strong>，其基本命令格式为<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT /&#123;index&#125;/&#123;type&#125;/&#123;id&#125;</span><br><span class="line">&#123;</span><br><span class="line">  "field": "value",</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>新建索引<code>website</code>，类别<code>bolg</code>，文档编号<code>123</code>，用命令<code>PUT</code></p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /website/blog/123</span><br><span class="line">&#123;</span><br><span class="line">    "title": "My first blog entry",</span><br><span class="line">    "text":  "Just trying this out...",</span><br><span class="line">    "date":  "2014/01/01"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "_index":    "website",</span><br><span class="line">    "_type":     "blog",</span><br><span class="line">    "_id":       "123",</span><br><span class="line">    "_version":  1,</span><br><span class="line">    "created":   true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不指定文档编号，也可自动生成<code>_id</code>，用命令<code>POST</code></p><blockquote><p>自动生成的 ID 是 URL-safe、 基于 Base64 编码且长度为20个字符的 GUID 字符串。 这些 GUID 字符串由可修改的 FlakeID 模式生成，这种模式允许多个节点并行生成唯一 ID ，且互相之间的冲突概率几乎为零。</p></blockquote>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /website/blog/</span><br><span class="line">&#123;</span><br><span class="line">    "title": "My second blog entry",</span><br><span class="line">    "text":  "Still trying this out...",</span><br><span class="line">    "date":  "2014/01/01"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "_index":    "website",</span><br><span class="line">    "_type":     "blog",</span><br><span class="line">    "_id":       "AVFgSgVHUP18jI2wRx0w",</span><br><span class="line">    "_version":  1,</span><br><span class="line">    "created":   true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="新建文档-PUT-URL-creat或POST"><a href="#新建文档-PUT-URL-creat或POST" class="headerlink" title="新建文档: PUT /URL/_creat或POST"></a>新建文档: PUT /URL/_creat或POST</h3><p>若希望创建全新文档而不是覆盖原有文档</p><ul><li><p><code>PUT</code>命令中添加<code>_creat</code>，可指定<code>_id</code></p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT /website/blog/123/_create</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> PUT /website/blog/123?op_type=create</span></span><br><span class="line">&#123;</span><br><span class="line">    "title": "My first blog entry",</span><br><span class="line">    "text":  "Just trying this out...",</span><br><span class="line">    "date":  "2014/01/01"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  若文档<code>_index/_type/_id</code>已存在，则会返回<code>409</code>错误</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "error": &#123;</span><br><span class="line">        "root_cause": [</span><br><span class="line">        &#123;</span><br><span class="line">            "type": "version_conflict_engine_exception",</span><br><span class="line">            "reason": "[blog][123]: version conflict, document already exists (current version [1])",</span><br><span class="line">            "index_uuid": "TEPTZxdTRi6aAXE-lRvvFQ",</span><br><span class="line">            "shard": "0",</span><br><span class="line">            "index": "website"</span><br><span class="line">        &#125;</span><br><span class="line">        ],</span><br><span class="line">        "type": "version_conflict_engine_exception",</span><br><span class="line">        "reason": "[blog][123]: version conflict, document already exists (current version [1])",</span><br><span class="line">        "index_uuid": "TEPTZxdTRi6aAXE-lRvvFQ",</span><br><span class="line">        "shard": "0",</span><br><span class="line">        "index": "website"</span><br><span class="line">    &#125;,</span><br><span class="line">    "status": 409</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>POST</code>命令生成唯一<code>_id</code></p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /website/blog/</span><br><span class="line">&#123;</span><br><span class="line">    "title": "My third blog entry",</span><br><span class="line">    "text":  "Still trying this out...",</span><br><span class="line">    "date":  "2014/01/01"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "_index" : "website",</span><br><span class="line">    "_type" : "blog",</span><br><span class="line">    "_id" : "G62WC3IBb2a50-3pYPp3",</span><br><span class="line">    "_version" : 1,</span><br><span class="line">    "result" : "created",</span><br><span class="line">    "_shards" : &#123;</span><br><span class="line">        "total" : 2,</span><br><span class="line">        "successful" : 1,</span><br><span class="line">        "failed" : 0</span><br><span class="line">    &#125;,</span><br><span class="line">    "_seq_no" : 0,</span><br><span class="line">    "_primary_term" : 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="更新文档-PUT"><a href="#更新文档-PUT" class="headerlink" title="更新文档: PUT"></a>更新文档: PUT</h3><p>在ES中文档是<strong>不可变</strong>的，实际上更新现有文档是通过<strong>重建索引</strong>进行替换实现的<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /website/blog/123</span><br><span class="line">&#123;</span><br><span class="line">  "title": "My first blog entry",</span><br><span class="line">  "text":  "I am starting to get the hang of this...",</span><br><span class="line">  "date":  "2014/01/02"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "_index" : "website",</span><br><span class="line">  "_type" : "blog",</span><br><span class="line">  "_id" : "123",</span><br><span class="line">  "_version" : 2,</span><br><span class="line">  "result" : "updated",</span><br><span class="line">  "_shards" : &#123;</span><br><span class="line">    "total" : 2,</span><br><span class="line">    "successful" : 1,</span><br><span class="line">    "failed" : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  "_seq_no" : 4,</span><br><span class="line">  "_primary_term" : 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="部分更新-POST-URL-update"><a href="#部分更新-POST-URL-update" class="headerlink" title="部分更新: POST /URL/_update"></a>部分更新: POST /URL/_update</h3><p>在<code>POST</code>指令中添加<code>_update</code>选项，可接收文档的一部分内容，并进行更新<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /website/blog/3/_update</span><br><span class="line">&#123;</span><br><span class="line">   "doc" : &#123;</span><br><span class="line">    "date":  "2020/01/02"</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "_index" : "website",</span><br><span class="line">  "_type" : "blog",</span><br><span class="line">  "_id" : "3",</span><br><span class="line">  "_version" : 2,</span><br><span class="line">  "result" : "updated",</span><br><span class="line">  "_shards" : &#123;</span><br><span class="line">    "total" : 2,</span><br><span class="line">    "successful" : 1,</span><br><span class="line">    "failed" : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  "_seq_no" : 1,</span><br><span class="line">  "_primary_term" : 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="取回文档-GET"><a href="#取回文档-GET" class="headerlink" title="取回文档: GET"></a>取回文档: GET</h3><ul><li><p>用<code>GET</code>指令取回文档</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /website/blog/123?pretty</span><br></pre></td></tr></table></figure>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> HTTP/1.1 200 OK</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> content-type: application/json; charset=UTF-8</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> content-length: 264</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    "_index" :   "website",</span><br><span class="line">    "_type" :    "blog",</span><br><span class="line">    "_id" :      "123",</span><br><span class="line">    "_version" : 1,</span><br><span class="line">    "found" :    true,</span><br><span class="line">    "_source" :  &#123;</span><br><span class="line">        "title": "My first blog entry",</span><br><span class="line">        "text":  "Just trying this out...",</span><br><span class="line">        "date":  "2014/01/01"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>只返回<code>_source</code>字段</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /website/blog/123/_source</span><br></pre></td></tr></table></figure>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "title": "My first blog entry",</span><br><span class="line">    "text":  "Just trying this out...",</span><br><span class="line">    "date":  "2014/01/01"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过<code>_source</code>指定文档的部分信息，例如只返回<code>title</code>和<code>text</code>，忽略<code>date</code></p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /website/blog/123?_source=title,text</span><br></pre></td></tr></table></figure>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "_index" : "website",</span><br><span class="line">    "_type" : "blog",</span><br><span class="line">    "_id" : "123",</span><br><span class="line">    "_version" : 1,</span><br><span class="line">    "_seq_no" : 0,</span><br><span class="line">    "_primary_term" : 1,</span><br><span class="line">    "found" : true,</span><br><span class="line">    "_source" : &#123;</span><br><span class="line">        "text" : "Just trying this out...",</span><br><span class="line">        "title" : "My first blog entry"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="取回多个文档-GET-mget"><a href="#取回多个文档-GET-mget" class="headerlink" title="取回多个文档: GET /_mget"></a>取回多个文档: GET /_mget</h3><p>在<code>GET</code>命令中添加<code>_mget</code>选项，可取回多个文档，需接收<code>docs</code>参数指定文档元数据<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GET /_mget</span><br><span class="line">&#123;</span><br><span class="line">   "docs" : [</span><br><span class="line">      &#123;</span><br><span class="line">         "_index" : "website",</span><br><span class="line">         "_type" :  "blog",</span><br><span class="line">         "_id" :    3</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         "_index" : "website",</span><br><span class="line">         "_type" :  "pageviews",</span><br><span class="line">         "_id" :    1,</span><br><span class="line">         "_source": "views"</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于同一索引或同一类型中的文档，可指定<code>_index/_type/</code><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /website/blog/_mget</span><br><span class="line">&#123;</span><br><span class="line">   "docs" : [</span><br><span class="line">      &#123; "_id" : 3 &#125;,</span><br><span class="line">      &#123; "_type" : "pageviews", "_id" :   1 &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者用<code>ids</code>参数指定<code>_id</code>列表<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /website/blog/_mget</span><br><span class="line">&#123;</span><br><span class="line">   "ids" : ["3", "1"]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>响应结果相同，均为<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "docs" : [</span><br><span class="line">    &#123;</span><br><span class="line">      "_index" : "website",</span><br><span class="line">      "_type" : "blog",</span><br><span class="line">      "_id" : "3",</span><br><span class="line">      "_version" : 2,</span><br><span class="line">      "_seq_no" : 1,</span><br><span class="line">      "_primary_term" : 2,</span><br><span class="line">      "found" : true,</span><br><span class="line">      "_source" : &#123;</span><br><span class="line">        "title" : "My first blog entry",</span><br><span class="line">        "text" : "I am starting to get the hang of this...",</span><br><span class="line">        "date" : "2020/01/02"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      "_index" : "website",</span><br><span class="line">      "_type" : "pageviews",</span><br><span class="line">      "_id" : "1",</span><br><span class="line">      "found" : false</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="删除文档-DELETE"><a href="#删除文档-DELETE" class="headerlink" title="删除文档: DELETE"></a>删除文档: DELETE</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /website/blog/123</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "_index" : "website",</span><br><span class="line">  "_type" : "blog",</span><br><span class="line">  "_id" : "123",</span><br><span class="line">  "_version" : 2,</span><br><span class="line">  "result" : "deleted",</span><br><span class="line">  "_shards" : &#123;</span><br><span class="line">    "total" : 2,</span><br><span class="line">    "successful" : 1,</span><br><span class="line">    "failed" : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  "_seq_no" : 1,</span><br><span class="line">  "_primary_term" : 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若不存在，则返回如下，注意<code>_version</code>仍旧增加<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "_index" : "website",</span><br><span class="line">  "_type" : "blog",</span><br><span class="line">  "_id" : "123",</span><br><span class="line">  "_version" : 3,</span><br><span class="line">  "result" : "not_found",</span><br><span class="line">  "_shards" : &#123;</span><br><span class="line">    "total" : 2,</span><br><span class="line">    "successful" : 1,</span><br><span class="line">    "failed" : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  "_seq_no" : 2,</span><br><span class="line">  "_primary_term" : 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="批量操作-POST-bulk"><a href="#批量操作-POST-bulk" class="headerlink" title="批量操作: POST /_bulk"></a>批量操作: POST /_bulk</h3><p>在<code>POST</code>命令中添加<code>_bulk</code>选项，进行批量处理，每个子请求都是独立执行，因此某个子请求的失败不会对其他子请求的成功与否造成影响，基本格式为<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /_bulk</span><br><span class="line">&#123; action: &#123; metadata &#125;&#125;</span><br><span class="line">&#123; request body        &#125;</span><br><span class="line">&#123; action: &#123; metadata &#125;&#125;</span><br><span class="line">&#123; request body        &#125;</span><br></pre></td></tr></table></figure></p><ul><li><p><code>action</code></p><p>  | <code>action</code> | 说明 |<br>  | —- | —- |<br>  | <code>create</code> | 如果文档不存在，那么就创建它 |<br>  | <code>index</code> | 创建一个新文档或者替换一个现有的文档 |<br>  | <code>update</code> | 部分更新一个文档 |<br>  | <code>delete</code> | 删除一个文档 |</p></li><li><p><code>metadata</code>指定<code>_index, _type, _id</code></p></li><li><code>request body</code> 行由文档的 <code>_source</code> 本身组成—​文档包含的字段和值。它是 <code>index</code> 和 <code>create</code> 操作所必需的；它也是 <code>update</code> 操作所必需的，并且应该包含你传递给 <code>update</code> API 的相同请求体： <code>doc</code> 、 <code>upsert</code> 、 <code>script</code> 等等。 删除操作不需要 <code>request body</code> 行。</li></ul><p>例如<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /_bulk</span><br><span class="line">&#123; "delete": &#123; "_index": "website", "_type": "blog", "_id": "123" &#125;&#125; </span><br><span class="line">&#123; "create": &#123; "_index": "website", "_type": "blog", "_id": "123" &#125;&#125;</span><br><span class="line">&#123; "title":    "My first blog post" &#125;</span><br><span class="line">&#123; "index":  &#123; "_index": "website", "_type": "blog" &#125;&#125;</span><br><span class="line">&#123; "title":    "My second blog post" &#125;</span><br><span class="line">&#123; "update": &#123; "_index": "website", "_type": "blog", "_id": "123", "_retry_on_conflict" : 3&#125; &#125;</span><br><span class="line">&#123; "doc" : &#123;"title" : "My updated blog post"&#125; &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "took" : 203,</span><br><span class="line">  "errors" : false,</span><br><span class="line">  "items" : [</span><br><span class="line">    &#123;</span><br><span class="line">      "delete" : &#123;</span><br><span class="line">        "_index" : "website",</span><br><span class="line">        "_type" : "blog",</span><br><span class="line">        "_id" : "123",</span><br><span class="line">        "_version" : 3,</span><br><span class="line">        "result" : "deleted",</span><br><span class="line">        "_shards" : &#123;</span><br><span class="line">          "total" : 2,</span><br><span class="line">          "successful" : 1,</span><br><span class="line">          "failed" : 0</span><br><span class="line">        &#125;,</span><br><span class="line">        "_seq_no" : 5,</span><br><span class="line">        "_primary_term" : 2,</span><br><span class="line">        "status" : 200</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      "create" : &#123;</span><br><span class="line">        "_index" : "website",</span><br><span class="line">        "_type" : "blog",</span><br><span class="line">        "_id" : "123",</span><br><span class="line">        "_version" : 4,</span><br><span class="line">        "result" : "created",</span><br><span class="line">        "_shards" : &#123;</span><br><span class="line">          "total" : 2,</span><br><span class="line">          "successful" : 1,</span><br><span class="line">          "failed" : 0</span><br><span class="line">        &#125;,</span><br><span class="line">        "_seq_no" : 6,</span><br><span class="line">        "_primary_term" : 2,</span><br><span class="line">        "status" : 201</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      "index" : &#123;</span><br><span class="line">        "_index" : "website",</span><br><span class="line">        "_type" : "blog",</span><br><span class="line">        "_id" : "HK23C3IBb2a50-3pQPpQ",</span><br><span class="line">        "_version" : 1,</span><br><span class="line">        "result" : "created",</span><br><span class="line">        "_shards" : &#123;</span><br><span class="line">          "total" : 2,</span><br><span class="line">          "successful" : 1,</span><br><span class="line">          "failed" : 0</span><br><span class="line">        &#125;,</span><br><span class="line">        "_seq_no" : 2,</span><br><span class="line">        "_primary_term" : 2,</span><br><span class="line">        "status" : 201</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      "update" : &#123;</span><br><span class="line">        "_index" : "website",</span><br><span class="line">        "_type" : "blog",</span><br><span class="line">        "_id" : "123",</span><br><span class="line">        "_version" : 5,</span><br><span class="line">        "result" : "updated",</span><br><span class="line">        "_shards" : &#123;</span><br><span class="line">          "total" : 2,</span><br><span class="line">          "successful" : 1,</span><br><span class="line">          "failed" : 0</span><br><span class="line">        &#125;,</span><br><span class="line">        "_seq_no" : 7,</span><br><span class="line">        "_primary_term" : 2,</span><br><span class="line">        "status" : 200</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="搜索-可用请求体查询替代"><a href="#搜索-可用请求体查询替代" class="headerlink" title="搜索(可用请求体查询替代)"></a>搜索(可用<a href="#%e8%af%b7%e6%b1%82%e4%bd%93%e6%9f%a5%e8%af%a2">请求体查询</a>替代)</h2><h3 id="空搜索"><a href="#空搜索" class="headerlink" title="空搜索"></a>空搜索</h3><p>不指定任何查询条件的搜索<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "took" : 27,                  # 搜索还费时间(毫秒)</span><br><span class="line">  "timed_out" : false,          # 是否超时</span><br><span class="line">  "_shards" : &#123;                 # 主分片信息</span><br><span class="line">    "total" : 6,                # 参与分片总数</span><br><span class="line">    "successful" : 6,           # 成功个数</span><br><span class="line">    "skipped" : 0,              # 跳过个数</span><br><span class="line">    "failed" : 0                # 失败个数</span><br><span class="line">  &#125;,</span><br><span class="line">  "hits" : &#123;</span><br><span class="line">    "total" : 9,                # 匹配到的文档总数</span><br><span class="line">    "max_score" : 1.0,</span><br><span class="line">    "hits" : [                  # 文档列表</span><br><span class="line">      ...</span><br><span class="line">      &#123;</span><br><span class="line">        "_index" : "website",</span><br><span class="line">        "_type" : "blog",</span><br><span class="line">        "_id" : "123",</span><br><span class="line">        "_score" : 1.0,         # 文档与查询的匹配度</span><br><span class="line">        "_source" : &#123;</span><br><span class="line">          "title" : "My updated blog post"</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        "_index" : "website",</span><br><span class="line">        "_type" : "blog",</span><br><span class="line">        "_id" : "G62WC3IBb2a50-3pYPp3",</span><br><span class="line">        "_score" : 1.0,</span><br><span class="line">        "_source" : &#123;</span><br><span class="line">          "title" : "My third blog entry",</span><br><span class="line">          "text" : "Still trying this out...",</span><br><span class="line">          "date" : "2014/01/01"</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      ...</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多索引和多类型"><a href="#多索引和多类型" class="headerlink" title="多索引和多类型"></a>多索引和多类型</h3><p>假如当前存在索引<code>gb, us</code>，类型为<code>user, tweet</code>，希望查找文档，可进行多索引/多类型查询</p><ul><li>搜索所有索引和类型  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /_search                # 在所有索引中搜索所有类型</span><br></pre></td></tr></table></figure></li><li>搜索指定索引  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /gb/_search             # 在索引`gb`中搜索</span><br><span class="line">GET /gb,us/_search          # 在索引`gb, us`中搜索</span><br><span class="line">GET /g*,u*/_search          # 支持字符匹配</span><br></pre></td></tr></table></figure></li><li>搜索指定类型  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /_all/user/_search      # 在所有索引中搜索`user`类型，注意`_all`只能用于代表全部索引</span><br><span class="line">GET /gb/user/_search        # 在索引`gb`中搜索`user`类型</span><br><span class="line">GET /gb/user,tweet/_search  # 在索引`gb`中搜索`user, tweet`类型</span><br></pre></td></tr></table></figure></li></ul><h3 id="指定查询搜索"><a href="#指定查询搜索" class="headerlink" title="指定查询搜索"></a>指定查询搜索</h3><ul><li><p>在<code>tweet</code>类型中查询字段<code>&quot;tweet&quot;</code>包含<code>&quot;elasticsearhc&quot;</code>单词的所有文档</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /_all/tweet/_search?q=tweet:elasticsearch</span><br></pre></td></tr></table></figure></li><li><p>在所有结果中查询字段<code>&quot;name&quot;</code>包含<code>&quot;john&quot;</code>且<code>&quot;tweet&quot;</code>字段中包含<code>&quot;mary&quot;</code>的文档，</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+name:john +tweet:mary</span><br></pre></td></tr></table></figure><p>  其URL编码如下</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /_search?q=%2Bname%3Ajohn+%2Btweet%3Amary</span><br></pre></td></tr></table></figure><ul><li><code>%2B</code>为<code>+</code>，<code>%3A</code>为<code>:</code>，故上句中实际为</li><li><code>+</code>前缀表示必须与查询条件匹配，<code>-</code>表示不一定与查询条件匹配。</li></ul></li><li><p>在所有结果中查询<code>&quot;name&quot;</code>包含<code>&quot;john&quot;, &quot;mary&quot;</code>，<code>&quot;date&quot;</code>字段值大于<code>&quot;2014-09-10&quot;</code>，<code>&quot;all&quot;</code>字段包含<code>&quot;aggregations&quot;</code>或者<code>&quot;geo&quot;</code></p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+name:(john mary) +date:&gt;2014-09-10 +(aggregations geo)</span><br></pre></td></tr></table></figure><p>  相应编码为</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?q=%2Bname%3A(john+mary)+%2Bdate%3A%3E2014-09-10+%2B(aggregations+geo)</span><br></pre></td></tr></table></figure></li></ul><h3 id="结果分页"><a href="#结果分页" class="headerlink" title="结果分页"></a>结果分页</h3><p>用<code>size</code>和<code>from</code>参数指定分页尺寸</p><ul><li><code>size</code>: 每页显示结果条数，默认为10</li><li><code>from</code>: 跳过的初始结果数目</li></ul><p>例如<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /_search?size=2             # 每页显示2条结果</span><br><span class="line">GET /_search?size=2&amp;from=1      # 每页显示2条结果，从第2条开始显示</span><br></pre></td></tr></table></figure></p><p>相应分别为<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...,</span><br><span class="line"></span><br><span class="line">  "hits" : &#123;</span><br><span class="line">    "total" : 5,</span><br><span class="line">    "max_score" : 1.0,</span><br><span class="line">    "hits" : [</span><br><span class="line">      &#123;</span><br><span class="line">        "_index" : "website",</span><br><span class="line">        "_type" : "blog",</span><br><span class="line">        "_id" : "123",</span><br><span class="line">        "_score" : 1.0,</span><br><span class="line">        "_source" : &#123;</span><br><span class="line">          "title" : "My updated blog post"</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        "_index" : "website",</span><br><span class="line">        "_type" : "blog",</span><br><span class="line">        "_id" : "G62WC3IBb2a50-3pYPp3",</span><br><span class="line">        "_score" : 1.0,</span><br><span class="line">        "_source" : &#123;</span><br><span class="line">          "title" : "My third blog entry",</span><br><span class="line">          "text" : "Still trying this out...",</span><br><span class="line">          "date" : "2014/01/01"</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...,</span><br><span class="line"></span><br><span class="line">  "hits" : &#123;</span><br><span class="line">    "total" : 5,</span><br><span class="line">    "max_score" : 1.0,</span><br><span class="line">    "hits" : [</span><br><span class="line">      &#123;</span><br><span class="line">        "_index" : "website",</span><br><span class="line">        "_type" : "blog",</span><br><span class="line">        "_id" : "G62WC3IBb2a50-3pYPp3",</span><br><span class="line">        "_score" : 1.0,</span><br><span class="line">        "_source" : &#123;</span><br><span class="line">          "title" : "My third blog entry",</span><br><span class="line">          "text" : "Still trying this out...",</span><br><span class="line">          "date" : "2014/01/01"</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        "_index" : "website",</span><br><span class="line">        "_type" : "blog",</span><br><span class="line">        "_id" : "l5WYCHIBrXn2VHz0FgRn",</span><br><span class="line">        "_score" : 1.0,</span><br><span class="line">        "_source" : &#123;</span><br><span class="line">          "title" : "My second blog entry",</span><br><span class="line">          "text" : "Still trying this out...",</span><br><span class="line">          "date" : "2014/01/01"</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="映射与分析"><a href="#映射与分析" class="headerlink" title="映射与分析"></a>映射与分析</h2><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p><strong>映射</strong>(mapping)定义了类型中的域、每个域的数据类型和ES如何处理这些域，也用于配置与类型有关的元数据。</p><h4 id="简单域类型"><a href="#简单域类型" class="headerlink" title="简单域类型"></a>简单域类型</h4><p>ES支持如下简单域类型</p><ul><li>字符串: <code>text</code>, <code>keyword</code></li><li>整数 : <code>byte</code>, <code>short</code>, <code>integer</code>, <code>long</code></li><li>浮点数: <code>float</code>, <code>double</code></li><li>布尔型: <code>boolean</code></li><li>日期: <code>date</code></li></ul><h4 id="查看映射-GET-index-mapping"><a href="#查看映射-GET-index-mapping" class="headerlink" title="查看映射: GET /_index/_mapping"></a>查看映射: GET /_index/_mapping</h4><p>查看ES对索引<code>website</code>默认生成的<code>mapping</code>，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /website/_mapping</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "website" : &#123;                 #_index</span><br><span class="line">    "mappings" : &#123;              # 注意mapping是_index的属性</span><br><span class="line">      "blog" : &#123;                # _type</span><br><span class="line">        "properties" : &#123;        # _type的各属性定义</span><br><span class="line">          "date" : &#123;</span><br><span class="line">            "type" : "date",</span><br><span class="line">            "format" : "yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis"</span><br><span class="line">          &#125;,</span><br><span class="line">          "text" : &#123;</span><br><span class="line">            "type" : "text",</span><br><span class="line">            "fields" : &#123;</span><br><span class="line">              "keyword" : &#123;</span><br><span class="line">                "type" : "keyword",</span><br><span class="line">                "ignore_above" : 256</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          "title" : &#123;</span><br><span class="line">            "type" : "text",</span><br><span class="line">            "fields" : &#123;</span><br><span class="line">              "keyword" : &#123;</span><br><span class="line">                "type" : "keyword",</span><br><span class="line">                "ignore_above" : 256</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义映射"><a href="#自定义映射" class="headerlink" title="自定义映射"></a>自定义映射</h4><p>若需要为域自定义映射，允许执行下面操作</p><ul><li><p>全文字符串域和精确字符串域的区别: <code>index</code><br>  可选以下3种</p><ul><li>analyzed: 进行分析后，全文索引该域；</li><li>not_analyzed: 精确索引，能够被搜索但不进行分析；</li><li><code>no</code>: 不对该域进行索引，不会被搜索到。<blockquote><p>分析是指进行大小字母匹配、同义词替换等操作。</p></blockquote></li></ul></li><li><p>使用特定语言分析器: <code>analyzer</code><br>  默认使用<code>standard</code>分析器，其余可选内置分析器有<code>whitespace</code>、<code>simple</code>和<code>english</code>等</p></li><li><p>优化域以适应部分匹配</p></li><li>指定自定义数据格式</li><li>…</li></ul><h4 id="更新映射-PUT-index-“mappings”-…"><a href="#更新映射-PUT-index-“mappings”-…" class="headerlink" title="更新映射: PUT /_index {“mappings”: {…} }"></a>更新映射: PUT /_index {“mappings”: {…} }</h4><p>创建索引时，指定类型的映射；用<code>/mapping</code>为新类型增加映射，或为存在类型更新映射，但是不能修存在的类型映射，否则会破坏索引。<strong>同一索引内的所有类型(字段不冲突)共享相同的映射</strong>。</p><p>注意每个域可包含多个值，构成数组，但数组元素必须是相同类型的，如<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"tag": ["search", "nosql"]</span><br></pre></td></tr></table></figure></p><ul><li>新建索引<code>/gb</code>并添加映射  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">PUT /gb </span><br><span class="line">&#123;</span><br><span class="line">    "mappings": &#123;                               # gb索引内所有类型的映射</span><br><span class="line">        "tweet" : &#123;                             # 自定义映射名</span><br><span class="line">            "properties" : &#123;</span><br><span class="line">                "tweet" : &#123;</span><br><span class="line">                    "type" :    "text",</span><br><span class="line">                    "analyzer": "english"       # 指定分析器</span><br><span class="line">                &#125;,</span><br><span class="line">                "date" : &#123;</span><br><span class="line">                    "type" :   "date"</span><br><span class="line">                &#125;,</span><br><span class="line">                "name" : &#123;</span><br><span class="line">                    "type" :   "text",</span><br><span class="line">                &#125;,</span><br><span class="line">                "user_id" : &#123;</span><br><span class="line">                    "type" :   "long"</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>为<code>tweet</code>新增文本域<code>tag</code>，已存在的域不能修改，故不必指定  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT /gb/_mapping/tweet</span><br><span class="line">&#123;</span><br><span class="line">    "properties" : &#123;</span><br><span class="line">        "tag" : &#123;</span><br><span class="line">        "type" :    "keyword"                   # 精确搜索</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>更为复杂度，为对象添加内部域  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "gb": &#123;</span><br><span class="line">        "tweet": &#123; </span><br><span class="line">            "properties": &#123;</span><br><span class="line">                "tweet": &#123; "type": "text" &#125;,</span><br><span class="line">                "user":  &#123;                      # 域user</span><br><span class="line">                    "type": "object",</span><br><span class="line">                    "dynamic":  true,           # 动态映射，详情查看</span><br><span class="line">                                                # https://www.elastic.co/guide/cn/elasticsearch/guide/current/dynamic-mapping.html#dynamic-mapping</span><br><span class="line">                    "properties": &#123;</span><br><span class="line">                        "id":       &#123; "type": "text" &#125;,</span><br><span class="line">                        "gender":   &#123; "type": "text" &#125;,</span><br><span class="line">                        "age":      &#123; "type": "long"   &#125;,</span><br><span class="line">                        "name":     &#123;           # 子域user.name</span><br><span class="line">                            "type": "object",</span><br><span class="line">                            "properties": &#123;</span><br><span class="line">                                    "full": &#123; "type": "text" &#125;,</span><br><span class="line">                                    "first":&#123; "type": "text" &#125;,</span><br><span class="line">                                    "last": &#123; "type": "text" &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="测试映射-GET-index-analyze"><a href="#测试映射-GET-index-analyze" class="headerlink" title="测试映射: GET /_index/_analyze"></a>测试映射: GET /_index/_analyze</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /website/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  "field": "title",</span><br><span class="line">  "text": ["hello", "world"]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "tokens" : [</span><br><span class="line">    &#123;</span><br><span class="line">      "token" : "hello",</span><br><span class="line">      "start_offset" : 0,</span><br><span class="line">      "end_offset" : 5,</span><br><span class="line">      "type" : "&lt;ALPHANUM&gt;",</span><br><span class="line">      "position" : 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      "token" : "world",</span><br><span class="line">      "start_offset" : 6,</span><br><span class="line">      "end_offset" : 11,</span><br><span class="line">      "type" : "&lt;ALPHANUM&gt;",</span><br><span class="line">      "position" : 101</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/analysis-intro.html" target="_blank" rel="noopener">Elasticsearch: 权威指南 » 基础入门 » 映射和分析 » 分析与分析器</a></p></blockquote><h2 id="请求体查询-GET-URL-search-“query”-…"><a href="#请求体查询-GET-URL-search-“query”-…" class="headerlink" title="请求体查询: GET /URL/_search {“query”: {…} }"></a>请求体查询: GET /URL/_search {“query”: {…} }</h2><p>将查询语句传递给<code>query</code>参数</p><p>一个典型的结构如下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    "query": &#123;</span><br><span class="line">        QUERY_NAME: &#123;</span><br><span class="line">            ARGUMENT: VALUE, </span><br><span class="line">            ...,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>查询可分为有评分/无评分的查询，即查询/过滤</p><ul><li>查询: 是一个评分的查询，除询问“是否匹配”，还需判断匹配程度</li><li>过滤: 简单询问“是否匹配”，结果是<code>yes</code>或<code>no</code></li></ul><p>通常的规则是，使用查询<code>query</code>语句来进行<strong>全文</strong>搜索或者其它任何需要影响<strong>相关性得分</strong>的搜索。除此以外的情况都使用过滤<code>filters</code>。</p><h3 id="几个重要的查询"><a href="#几个重要的查询" class="headerlink" title="几个重要的查询"></a>几个重要的查询</h3><h4 id="match-all"><a href="#match-all" class="headerlink" title="match_all"></a>match_all</h4><p>默认的查询方式，简单匹配所有文档<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br></pre></td></tr></table></figure></p><p>等价于<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    "query": &#123;</span><br><span class="line">        "match_all": &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="match-multi-match"><a href="#match-multi-match" class="headerlink" title="match/multi_match"></a>match/multi_match</h4><p>可用的标准查询，对任何字段进行全文搜索或精确查询<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    "query": &#123;                      # 查询</span><br><span class="line">        "match": &#123;                  # 匹配</span><br><span class="line">            "tweet": "About Search" # "tweet"域出现"About Search"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在多个字段上执行相同的<code>match</code>查询，例如在<code>&quot;title&quot;, &quot;text&quot;</code>字段搜索出现<code>&quot;blog&quot;</code>的文档<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;                        # 查询</span><br><span class="line">    "multi_match": &#123;                # 多字段查询</span><br><span class="line">      "query": "blog",              # 查询内容</span><br><span class="line">      "fields": ["title", "text"]   # 字段/域</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="term-terms"><a href="#term-terms" class="headerlink" title="term/terms"></a>term/terms</h4><p>用于精确匹配，可以是数字、时间、布尔或<code>not_analyzed</code>的字符串。如查询<code>&quot;title&quot;</code>域中包含<code>&quot;third&quot;</code>的文档<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    "query": &#123;              # 查询</span><br><span class="line">        "term": &#123;           # 精确匹配</span><br><span class="line">            "title": "third"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>允许指定多值的精确匹配。例如查询<code>&quot;title&quot;</code>域中包含<code>&quot;first&quot;, &quot;third&quot;, &quot;second&quot;</code>的文档<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    "query": &#123;</span><br><span class="line">        "terms": &#123;</span><br><span class="line">            "title": [</span><br><span class="line">                "first", "second", "third"</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="exists"><a href="#exists" class="headerlink" title="exists"></a>exists</h4><p>查询指定字段中有值的文档，例如查询<code>&quot;title&quot;</code>字段不为空的文档<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "exists": &#123;</span><br><span class="line">      "field": "title"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>查询指定字段中无值的文档，例如查询<code>&quot;title&quot;</code>字段为空的文档<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GET /my_store/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "bool": &#123;</span><br><span class="line">      "must_not": [</span><br><span class="line">        &#123;</span><br><span class="line">          "exists": &#123;</span><br><span class="line">            "field": "title"</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="range"><a href="#range" class="headerlink" title="range"></a>range</h4><p>查询落在指定区间内的数字或时间，允许的操作符有</p><ul><li><code>gt</code>: 大于</li><li><code>gte</code>: 大于等于</li><li><code>lt</code>: 小于</li><li><code>lte</code>: 小于等于</li></ul><p>如年龄域<code>&quot;age&quot;</code>不小于20且小于30的文档<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    "query": &#123;              # 查询</span><br><span class="line">        "range": &#123;          # 范围查询</span><br><span class="line">            "age": &#123;        # 年龄域</span><br><span class="line">                "gte": 20,  # 不小于20</span><br><span class="line">                "lt" : 30,  # 大于30</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="组合多个查询"><a href="#组合多个查询" class="headerlink" title="组合多个查询"></a>组合多个查询</h3><p>例如要求查询满足下列条件的文档</p><ul><li><code>&quot;title&quot;</code>域包含<code>&quot;how to make millions&quot;</code></li><li>不能匹配<code>&quot;tag&quot;</code>值为<code>&quot;spam&quot;</code>的文档</li><li><code>&quot;tag&quot;</code>值是<code>&quot;starred&quot;</code>的文档最佳</li><li>日期<code>&quot;date&quot;</code>在<code>&quot;2014-01-01&quot;</code>之后的文档最佳</li></ul><blockquote><p><strong>注意</strong>：</p><ul><li>以下查询内需嵌套<a href="#%e5%87%a0%e4%b8%aa%e9%87%8d%e8%a6%81%e7%9a%84%e6%9f%a5%e8%af%a2">几个重要的查询</a></li><li>若一个查询内包含多个语句，用<code>[]</code>表示数组，且每个完整的查询包含<code>{}</code>，注意括号使用</li></ul></blockquote><h4 id="must"><a href="#must" class="headerlink" title="must"></a>must</h4><p>文档必须匹配给定条件，才能被匹配成功。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"must": &#123;</span><br><span class="line">    "match": &#123;</span><br><span class="line">        "title": "how to make millions"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="must-not"><a href="#must-not" class="headerlink" title="must_not"></a>must_not</h4><p>文档必须不匹配给定条件，才能被匹配成功。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"must_not": &#123;</span><br><span class="line">    "match": &#123;</span><br><span class="line">        "tag": "spam"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="should"><a href="#should" class="headerlink" title="should"></a>should</h4><p>用于修正每个文档的相关性得分，如果满足任意语句将增加<code>_score</code>，否则无影响。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">"should": [</span><br><span class="line">    &#123;</span><br><span class="line">        "match": &#123;</span><br><span class="line">            "tag": "starred"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        "range": &#123;</span><br><span class="line">            "date": &#123;</span><br><span class="line">                "gte": "2014-01-01"</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>必须匹配，以过滤模式进行，<strong>满足条件的文档被包含</strong>。考虑日期条件写入<code>should</code>会影响文档评分，将其更改为<code>filter</code>匹配<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">"filter": &#123;</span><br><span class="line">    "range": &#123;</span><br><span class="line">        "date": &#123;</span><br><span class="line">            "gte": "2014-01-01"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h4 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h4><p>通过<code>bool</code>查询将多查询组合在一起<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    "bool": &#123;</span><br><span class="line">        "must": &#123;           # "title"域包含"how to make millions"</span><br><span class="line">            "match": &#123;</span><br><span class="line">                "title": "how to make millions"</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        "must_not": &#123;       # 不能匹配"tag"值为"spam"的文档</span><br><span class="line">            "match": &#123;</span><br><span class="line">                "tag": "spam"</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        "should": &#123;         # "tag"值是"starred"或日期"date"在"2014-01-01"之后的文档最佳</span><br><span class="line">            "match": &#123;</span><br><span class="line">                "tag": "starred"</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        "filter": &#123;         # 不想让日期影响文档评分，将日期条件写入`filter`</span><br><span class="line">            "range": &#123;</span><br><span class="line">                "date": &#123;</span><br><span class="line">                    "gte": "2014-01-01"</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="constant-score"><a href="#constant-score" class="headerlink" title="constant_score"></a>constant_score</h4><p>将一个不变的常量评分应用于所有匹配的文档，经常用于只需执行只包含<code>filter</code>查询而没有其他查询(评分查询)的情况<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    "query": &#123;</span><br><span class="line">        "constant_score": &#123;</span><br><span class="line">            "filter": &#123;</span><br><span class="line">                "term": &#123;</span><br><span class="line">                    "category": "ebooks"</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="验证查询-GET-URL-search-validate-query-explain"><a href="#验证查询-GET-URL-search-validate-query-explain" class="headerlink" title="验证查询: GET /URL/_search/_validate/query?explain"></a>验证查询: GET /URL/_search/_validate/query?explain</h3><p>例如一个错误的查询语句如下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    # 正确查询语句如下</span><br><span class="line">    # "match": &#123;</span><br><span class="line">    #   "title": "third"</span><br><span class="line">    # &#125;</span><br><span class="line">    "title": &#123;</span><br><span class="line">      "match": "third"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "error": &#123;</span><br><span class="line">    "root_cause": [</span><br><span class="line">      &#123;</span><br><span class="line">        "type": "parsing_exception",</span><br><span class="line">        "reason": "Unknown key for a VALUE_STRING in [query].",</span><br><span class="line">        "line": 3,</span><br><span class="line">        "col": 5</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    "type": "parsing_exception",</span><br><span class="line">    "reason": "Unknown key for a VALUE_STRING in [query].",</span><br><span class="line">    "line": 3,</span><br><span class="line">    "col": 5</span><br><span class="line">  &#125;,</span><br><span class="line">  "status": 400</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>通过<code>_validate/query</code>验证语句是否合法</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /_search/_validate/query</span><br><span class="line">&#123;</span><br><span class="line">    "query":</span><br><span class="line">        "title": &#123;</span><br><span class="line">        "match": "third"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "valid" : false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加参数<code>explain</code>输出错误原因</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /_search/_validate/query?explain</span><br><span class="line">&#123;</span><br><span class="line">    "query":</span><br><span class="line">        "title": &#123;</span><br><span class="line">        "match": "third"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "valid" : false,</span><br><span class="line">    "error" : "org.elasticsearch.common.ParsingException: [_na] query malformed, must start with start_object"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="排序与相关性"><a href="#排序与相关性" class="headerlink" title="排序与相关性"></a>排序与相关性</h2><h3 id="排序-GET-URL-search-“sort”-…"><a href="#排序-GET-URL-search-“sort”-…" class="headerlink" title="排序: GET /URL/_search { “sort”: { … } }"></a>排序: GET /URL/_search { “sort”: { … } }</h3><p>可以将排序语句与搜索语句放入一个<code>GET</code>请求中，即对搜索结果进行排序，例如<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /URL/_search</span><br><span class="line">&#123;</span><br><span class="line">    "query": &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    "sort": &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="按字段值排序"><a href="#按字段值排序" class="headerlink" title="按字段值排序"></a>按字段值排序</h4><p>如根据<code>&quot;date&quot;</code>域排序，将最新的文档放在最前<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /website/_search</span><br><span class="line">&#123;</span><br><span class="line">  "sort": &#123;</span><br><span class="line">      "date": &#123;</span><br><span class="line">        "order": "desc"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>若不指定顺序，默认升序排序<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /website/_search</span><br><span class="line">&#123;</span><br><span class="line">  "sort": "date"</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 同</span></span><br><span class="line">GET /website/_search</span><br><span class="line">&#123;</span><br><span class="line">  "sort": &#123;</span><br><span class="line">      "date": &#123;</span><br><span class="line">        "order": "asc"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "took" : 2,</span><br><span class="line">  "timed_out" : false,</span><br><span class="line">  "_shards" : &#123;</span><br><span class="line">    "total" : 5,</span><br><span class="line">    "successful" : 5,</span><br><span class="line">    "skipped" : 0,</span><br><span class="line">    "failed" : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  "hits" : &#123;</span><br><span class="line">    "total" : 5,</span><br><span class="line">    "max_score" : null,     # 在排序中，`_score`无意义，故未计算；将track_scores参数设置为true也可计算</span><br><span class="line">    "hits" : [</span><br><span class="line">      &#123;</span><br><span class="line">        "_index" : "website",</span><br><span class="line">        "_type" : "blog",</span><br><span class="line">        "_id" : "3",</span><br><span class="line">        "_score" : null,    # 在排序中，`_score`无意义，故未计算；将track_scores参数设置为true也可计算</span><br><span class="line">        "_source" : &#123;</span><br><span class="line">          "title" : "My first blog entry",</span><br><span class="line">          "text" : "I am starting to get the hang of this...",</span><br><span class="line">          "date" : "2020/01/02",</span><br><span class="line">          "index" : 1</span><br><span class="line">        &#125;,</span><br><span class="line">        "sort" : [</span><br><span class="line">          1577923200000     # 时间戳，自epoch(January 1, 1970 00:00:00 UTC)以来的毫秒数</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      ...,</span><br><span class="line">      &#123;</span><br><span class="line">        "_index" : "website",</span><br><span class="line">        "_type" : "blog",</span><br><span class="line">        "_id" : "123",</span><br><span class="line">        "_score" : null,</span><br><span class="line">        "_source" : &#123;</span><br><span class="line">          "title" : "My updated blog post"</span><br><span class="line">        &#125;,</span><br><span class="line">        "sort" : [</span><br><span class="line">          -9223372036854775808</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      ...,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多级排序"><a href="#多级排序" class="headerlink" title="多级排序"></a>多级排序</h4><p>结合<code>&quot;date&quot;</code>和<code>&quot;_source&quot;</code>进行排序，匹配结果先以日期降序排序，再按索引升序排序<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /website/_search</span><br><span class="line">&#123;</span><br><span class="line">  "sort": [</span><br><span class="line">    &#123;</span><br><span class="line">      "date": "desc"</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      "index": "asc"</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="多值字段排序"><a href="#多值字段排序" class="headerlink" title="多值字段排序"></a>多值字段排序</h4><p>若指定排序字段包含多个值，这些值没有顺序关系，仅仅是被包装，那么可以通过参数<code>mode</code>将多值处理后进行排序，支持<code>min, max, avg, sum</code>。例如统计各班平均分并按降序排序<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    "sort": &#123;</span><br><span class="line">        "score": &#123;</span><br><span class="line">            "order": "desc",</span><br><span class="line">            "mode": "avg"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="相关性-score"><a href="#相关性-score" class="headerlink" title="相关性: _score"></a>相关性: _score</h3><p>ES的文档相似度用TF/IDF定义，包括</p><ul><li>词频：检索词在字段中出现的频率，出现频率越高相关性越高；</li><li>反文档频率：检索词在索引中出现的频率，出现频率越高相关性越低；</li><li>字段长度准则：字段长度越长，相关性越低。</li></ul><h2 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h2><h3 id="创建-PUT-index"><a href="#创建-PUT-index" class="headerlink" title="创建: PUT /_index"></a>创建: PUT /_index</h3><p>希望在索引数据前，分析器和映射已经被建立，那么可以手动创建索引，在请求体中传入设置或类型映射</p><blockquote><p>在<code>config/elasticsearch.yml</code>中指定<code>action.auto_create_index: false</code>可以禁止自动创建索引</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PUT /index</span><br><span class="line">&#123;</span><br><span class="line">    "settings": &#123; ... any settings ... &#125;,</span><br><span class="line">    "mappings": &#123;</span><br><span class="line">        "type_one": &#123; ... any mappings ... &#125;,</span><br><span class="line">        "type_two": &#123; ... any mappings ... &#125;,</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="settings"><a href="#settings" class="headerlink" title="settings"></a>settings</h4><h5 id="number-of-shards-number-of-replicas"><a href="#number-of-shards-number-of-replicas" class="headerlink" title="number_of_shards/number_of_replicas"></a>number_of_shards/number_of_replicas</h5><p>有连个重要的设置参数</p><ul><li><code>number_of_shards</code>: 每个索引的主分片数目，默认为5；</li><li><code>number_of_replicas</code>: 每个主分片的副本数，默认为1。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT /index</span><br><span class="line">&#123;</span><br><span class="line">    "settings": &#123;</span><br><span class="line">        "number_of_shards": 1</span><br><span class="line">        "number_of_replicas": 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以动态修改副本数<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT /index/_settings</span><br><span class="line">&#123;</span><br><span class="line">    "number_of_replicas": 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="analysis"><a href="#analysis" class="headerlink" title="analysis"></a>analysis</h5><p>设置本索引内的分析器，可以配置为已存在的分析器或自定义，默认情况下为<code>standard</code>分析器，包含以下部分</p><ul><li><code>standard</code>分词器，通过单词边界分割输入的文本；</li><li><code>standard</code>词汇单元过滤器，整理分词器触发的词汇单元；</li><li><code>lowercase</code>词汇单元过滤器，转换所有词汇单元为小写；</li><li><code>stop</code>词汇单元过滤器，删除停用词(默认禁用)。</li></ul><p>自定义西语分析器方式如下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT /spanish_docs</span><br><span class="line">&#123;</span><br><span class="line">    "settings": &#123;                           # 设置</span><br><span class="line">        "analysis": &#123;                       # 分析器设置</span><br><span class="line">            "analyzer": &#123;                   # 分析器</span><br><span class="line">                "es_std": &#123;                 # 分析器名</span><br><span class="line">                    "type":      "standard",# 使用standard分析器</span><br><span class="line">                    "stopwords": "_spanish_"# 设置西语停用词过滤器</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/custom-analyzers.html" target="_blank" rel="noopener">创建一个自定义分析器</a>见详细文档说明。</p><h4 id="mappings"><a href="#mappings" class="headerlink" title="mappings"></a>mappings</h4><p>详情查看<a href="#%e6%9b%b4%e6%96%b0%e6%98%a0%e5%b0%84-put-index-%22mappings%22">更新映射: PUT /_index {“mappings”: {…} }</a></p><h3 id="删除-DELETE-index"><a href="#删除-DELETE-index" class="headerlink" title="删除: DELETE /_index"></a>删除: DELETE /_index</h3><ul><li>删除指定索引  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /index</span><br></pre></td></tr></table></figure></li><li>删除多个索引  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE /index_1,index_2</span><br><span class="line">DELETE /index_*</span><br></pre></td></tr></table></figure></li><li>删除全部索引  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE /_all</span><br><span class="line">DELETE /*</span><br></pre></td></tr></table></figure></li></ul><h1 id="深入搜索"><a href="#深入搜索" class="headerlink" title="深入搜索"></a><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/search-in-depth.html" target="_blank" rel="noopener">深入搜索</a></h1><h2 id="结构化搜索"><a href="#结构化搜索" class="headerlink" title="结构化搜索"></a>结构化搜索</h2><p>存储以下数据<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST /my_store/products/_bulk</span><br><span class="line">&#123; "index": &#123; "_id": 1 &#125;&#125;</span><br><span class="line">&#123; "price" : 10, "productID" : "XHDK-A-1293-#fJ3", "from": null, "count": 10 &#125;</span><br><span class="line">&#123; "index": &#123; "_id": 2 &#125;&#125;</span><br><span class="line">&#123; "price" : 20, "productID" : "KDKE-B-9947-#kL5" &#125;</span><br><span class="line">&#123; "index": &#123; "_id": 3 &#125;&#125;</span><br><span class="line">&#123; "price" : 30, "productID" : "JODL-X-1937-#pV7" &#125;</span><br><span class="line">&#123; "index": &#123; "_id": 4 &#125;&#125;</span><br><span class="line">&#123; "price" : 30, "productID" : "QQPX-R-3956-#aD8" &#125;</span><br></pre></td></tr></table></figure></p><h3 id="精确值查找-term"><a href="#精确值查找-term" class="headerlink" title="精确值查找: term"></a>精确值查找: term</h3><ul><li>精确查找时，会使用过滤器<code>filter</code>；</li><li>不希望对查询进行评分计算，使用<code>constant_score</code>查询；</li><li>精确查询文本时，该域<code>mappings</code>需设置为<code>not_analyzed</code>；</li><li>理论上非评分查询<strong>先于</strong>评分查询执行，减少评分计算降低计算成本。</li></ul><p>删除原有索引，并新建<code>mapping</code>，重新导入数据<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_store</span><br><span class="line">&#123;</span><br><span class="line">  "mappings": &#123;</span><br><span class="line">    "products": &#123;</span><br><span class="line">      "properties": &#123;</span><br><span class="line">        "productID": &#123;</span><br><span class="line">          "type": "keyword"   # 注意ES6.x移除`string`</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>精确搜索<code>&quot;productID&quot;</code>为<code>&quot;XHDK-A-1293-#fJ3&quot;</code>的文档<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /my_store/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "constant_score": &#123;</span><br><span class="line">      "filter": &#123;</span><br><span class="line">        "term": &#123;</span><br><span class="line">          "productID": "XHDK-A-1293-#fJ3"</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      "boost": 1.2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="组合过滤器-bool"><a href="#组合过滤器-bool" class="headerlink" title="组合过滤器: bool"></a>组合过滤器: bool</h3><ul><li><p>查找<strong>价格为20或<code>&quot;productID&quot;</code>为<code>&quot;XHDK-A-1293-#fJ3&quot;</code>，但价格必定不为30</strong>的文档</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">GET /my_store/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "constant_score": &#123;</span><br><span class="line">      "filter": &#123;</span><br><span class="line">        "bool": &#123;       # 组合`should`x2 + `must_not`</span><br><span class="line">          "should": [ </span><br><span class="line">            &#123;</span><br><span class="line">              "term": &#123;</span><br><span class="line">                "price": 30</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              "term": &#123;</span><br><span class="line">                "productID": "XHDK-A-1293-#fJ3"</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ],</span><br><span class="line">          "must_not": &#123;</span><br><span class="line">            "term": &#123;</span><br><span class="line">              "price": 30</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查找<strong>满足<code>&quot;productID&quot;</code>为<code>&quot;KDKE-B-9947-#kL5&quot;</code>，或<code>&quot;productID&quot;</code>为<code>&quot;JODL-X-1937-#pV7&quot;</code>且价格为30</strong>的文档</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">GET /my_store/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "constant_score": &#123;</span><br><span class="line">      "filter": &#123;</span><br><span class="line">        "bool": &#123;                   # 组合`should`x2</span><br><span class="line">          "should": [</span><br><span class="line">            &#123;</span><br><span class="line">              "term": &#123;</span><br><span class="line">                "productID": "KDKE-B-9947-#kL5"</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">              "bool": &#123;             # `must`中为列表，将被展开，对每个元素求取布尔值，因此用`bool`将其包裹，即`must`x2</span><br><span class="line">                "must": [</span><br><span class="line">                  &#123;</span><br><span class="line">                    "term": &#123;</span><br><span class="line">                      "productID": "JODL-X-1937-#pV7"</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;, &#123;</span><br><span class="line">                    "term": &#123;</span><br><span class="line">                      "price": 30</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;  </span><br><span class="line">                ]</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      "boost": 1.2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="精确查找多个值-terms"><a href="#精确查找多个值-terms" class="headerlink" title="精确查找多个值: terms"></a>精确查找多个值: terms</h3><p>注意：</p><ul><li>文档<strong>包含</strong><code>terms</code>给出列表中的词就会被匹配，而不是<strong>等值</strong>；</li><li>若需精确相等，最好的方式是<strong>增加并索引另一个字段</strong>。</li></ul><ul><li>查找价格字段为20或30的文档  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET /my_store/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "constant_score": &#123;</span><br><span class="line">      "filter": &#123;</span><br><span class="line">        "terms": &#123;</span><br><span class="line">          "price": [</span><br><span class="line">            20, 30</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      "boost": 1.2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="范围-range"><a href="#范围-range" class="headerlink" title="范围: range"></a>范围: range</h3><p>可用于限定<strong>数值、日期、字符串(字典序)</strong>范围进行查询</p><ul><li>查找价格大于20小于40的文档  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GET /my_store/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "constant_score": &#123;</span><br><span class="line">      "filter": &#123;</span><br><span class="line">        "range": &#123;</span><br><span class="line">          "price": &#123;</span><br><span class="line">            "gt": 20,</span><br><span class="line">            "lt": 40</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      "boost": 1.2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="处理空值-exists"><a href="#处理空值-exists" class="headerlink" title="处理空值: exists"></a>处理空值: exists</h3><p><code>null, [], [null]</code>是等价的，无法存于倒排索引中</p><ul><li>查询<code>&quot;count&quot;</code>域不为空的文档  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /my_store/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "constant_score": &#123;</span><br><span class="line">      "filter": &#123;</span><br><span class="line">        "exists": &#123;</span><br><span class="line">          "field": "count"</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      "boost": 1.2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>查询<code>&quot;count&quot;</code>域为空的文档  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GET /my_store/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "constant_score": &#123;</span><br><span class="line">      "filter": &#123;</span><br><span class="line">        "bool": &#123;             # ES6.x移除missing</span><br><span class="line">          "must_not": &#123;</span><br><span class="line">            "exists": &#123;</span><br><span class="line">              "field": "count"</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      "boost": 1.2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="全文搜索"><a href="#全文搜索" class="headerlink" title="全文搜索"></a>全文搜索</h2><p>在全文字段中搜索到最相关的文档，两个最重要的方面是</p><ul><li>相关性：评价查询与结果间的相关程度，可以是TF/IDF、地理位置邻近、模糊相似，或其他算法；</li><li>分析：将文本转换为有区别的、规范化的token，为了1)创建倒排索引；2)查询倒排索引。</li></ul><p>索引一些数据<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DELETE /my_index </span><br><span class="line"></span><br><span class="line">PUT /my_index</span><br><span class="line">&#123; "settings": &#123; "number_of_shards": 1 &#125;&#125; </span><br><span class="line"></span><br><span class="line">POST /my_index/my_type/_bulk</span><br><span class="line">&#123; "index": &#123; "_id": 1 &#125;&#125;</span><br><span class="line">&#123; "title": "The quick brown fox" &#125;</span><br><span class="line">&#123; "index": &#123; "_id": 2 &#125;&#125;</span><br><span class="line">&#123; "title": "The quick brown fox jumps over the lazy dog" &#125;</span><br><span class="line">&#123; "index": &#123; "_id": 3 &#125;&#125;</span><br><span class="line">&#123; "title": "The quick brown fox jumps over the quick dog" &#125;</span><br><span class="line">&#123; "index": &#123; "_id": 4 &#125;&#125;</span><br><span class="line">&#123; "title": "Brown fox brown dog" &#125;</span><br></pre></td></tr></table></figure></p><h3 id="匹配查询-match"><a href="#匹配查询-match" class="headerlink" title="匹配查询: match"></a>匹配查询: match</h3><ul><li><p>查询<code>&quot;title&quot;</code>中包含<code>&quot;quick&quot;</code>的文档，<code>&quot;title&quot;</code>为<code>&quot;text&quot;</code>类型可被分析(<code>&quot;quick&quot;</code>同<code>&quot;QUICK&quot;</code>等)</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "match": &#123;</span><br><span class="line">      "title": "quick"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多词查询-match"><a href="#多词查询-match" class="headerlink" title="多词查询: match"></a>多词查询: match</h3></li><li><p>查询<code>&quot;title&quot;</code>中包含<code>&quot;BROWN DOG!&quot;</code>的文档</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "match": &#123;</span><br><span class="line">      "title": "BROWN DOG!"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>查询匹配<strong>所有词项</strong>的文档  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "match": &#123;</span><br><span class="line">      "title": &#123;                # 域的参数设置</span><br><span class="line">        "query": "BROWN DOG!",</span><br><span class="line">        "operator": "and"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>指定必须匹配的词项数  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "match": &#123;</span><br><span class="line">      "title": &#123;                # 域的参数设置</span><br><span class="line">        "query": "BROWN DOG!",</span><br><span class="line">        "minimum_should_match": "75%"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="组合查询-bool"><a href="#组合查询-bool" class="headerlink" title="组合查询: bool"></a>组合查询: bool</h3><ul><li><p>匹配<strong>出现<code>&quot;quick&quot;</code>，但不出现<code>&quot;lazy&quot;</code>，最佳匹配<code>&quot;brown&quot;, &quot;dog&quot;</code></strong>的文档</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "bool": &#123;</span><br><span class="line">      "must": [</span><br><span class="line">        &#123;</span><br><span class="line">          "match": &#123;</span><br><span class="line">            "title": "quick"</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      "must_not": [</span><br><span class="line">        &#123;</span><br><span class="line">          "match": &#123;</span><br><span class="line">            "title": "lazy"</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ], </span><br><span class="line">      "should": [</span><br><span class="line">        &#123;</span><br><span class="line">          "match": &#123;</span><br><span class="line">            "title": "brown dog"</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>匹配精度控制</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "bool": &#123;</span><br><span class="line">      "should": [</span><br><span class="line">        &#123;</span><br><span class="line">          "match": &#123;</span><br><span class="line">            "title": "brown fox dog"</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ], </span><br><span class="line">      "minimum_should_match": 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="语句权重-boost"><a href="#语句权重-boost" class="headerlink" title="语句权重: boost"></a>语句权重: boost</h3><p>希望为<code>&quot;brown&quot;, &quot;quick&quot;</code>提升更高的权重，即出现这些词的文档比未出现这些词的文档更匹配，可以用<code>should</code>语句如下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "bool": &#123;</span><br><span class="line">      "should": [</span><br><span class="line">        &#123;</span><br><span class="line">          "match": &#123;</span><br><span class="line">            "title": "brown quick"</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...,</span><br><span class="line">  "hits" : &#123;</span><br><span class="line">    "total" : 4,</span><br><span class="line">    "max_score" : 0.7564473,</span><br><span class="line">    "hits" : [</span><br><span class="line">      &#123;</span><br><span class="line">        "_index" : "my_index",</span><br><span class="line">        "_type" : "my_type",</span><br><span class="line">        "_id" : "2",</span><br><span class="line">        "_score" : 0.7564473,</span><br><span class="line">        "_source" : &#123;</span><br><span class="line">          "title" : "The quick brown fox jumps over the lazy dog"</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        "_index" : "my_index",</span><br><span class="line">        "_type" : "my_type",</span><br><span class="line">        "_id" : "3",</span><br><span class="line">        "_score" : 0.68324494,</span><br><span class="line">        "_source" : &#123;</span><br><span class="line">          "title" : "The quick brown fox jumps over the quick dog"</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        "_index" : "my_index",</span><br><span class="line">        "_type" : "my_type",</span><br><span class="line">        "_id" : "1",</span><br><span class="line">        "_score" : 0.5753642,</span><br><span class="line">        "_source" : &#123;</span><br><span class="line">          "title" : "The quick brown fox"</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        "_index" : "my_index",</span><br><span class="line">        "_type" : "my_type",</span><br><span class="line">        "_id" : "4",</span><br><span class="line">        "_score" : 0.2810996,</span><br><span class="line">        "_source" : &#123;</span><br><span class="line">          "title" : "Brown fox brown dog"</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>希望提升<code>&quot;quick&quot;</code>的权重多于<code>&quot;brown&quot;</code></strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "bool": &#123;</span><br><span class="line">      "should": [</span><br><span class="line">        &#123;</span><br><span class="line">          "match": &#123;</span><br><span class="line">            "title": &#123;            # 修改域的参数</span><br><span class="line">              "query": "quick",</span><br><span class="line">              "boost": 3 </span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          "match": &#123; </span><br><span class="line">            "title": &#123;</span><br><span class="line">              "query": "brown",</span><br><span class="line">              "boost": 2</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...,</span><br><span class="line">  "hits" : &#123;</span><br><span class="line">    "total" : 4,</span><br><span class="line">    "max_score" : 2.111807,</span><br><span class="line">    "hits" : [</span><br><span class="line">      &#123;</span><br><span class="line">        "_index" : "my_index",</span><br><span class="line">        "_type" : "my_type",</span><br><span class="line">        "_id" : "2",</span><br><span class="line">        "_score" : 2.111807,</span><br><span class="line">        "_source" : &#123;</span><br><span class="line">          "title" : "The quick brown fox jumps over the lazy dog"</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        "_index" : "my_index",</span><br><span class="line">        "_type" : "my_type",</span><br><span class="line">        "_id" : "3",</span><br><span class="line">        "_score" : 1.7620528,</span><br><span class="line">        "_source" : &#123;</span><br><span class="line">          "title" : "The quick brown fox jumps over the quick dog"</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        "_index" : "my_index",</span><br><span class="line">        "_type" : "my_type",</span><br><span class="line">        "_id" : "1",</span><br><span class="line">        "_score" : 1.4384105,</span><br><span class="line">        "_source" : &#123;</span><br><span class="line">          "title" : "The quick brown fox"</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        "_index" : "my_index",</span><br><span class="line">        "_type" : "my_type",</span><br><span class="line">        "_id" : "4",</span><br><span class="line">        "_score" : 0.5621992,</span><br><span class="line">        "_source" : &#123;</span><br><span class="line">          "title" : "Brown fox brown dog"</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="控制分析-GET-URL-index-analyze-“field”-…-“text”-…"><a href="#控制分析-GET-URL-index-analyze-“field”-…-“text”-…" class="headerlink" title="控制分析: GET /URL/_index/_analyze { “field”: …, “text”: … }"></a>控制分析: GET /URL/_index/_analyze { “field”: …, “text”: … }</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  "field": "title",</span><br><span class="line">  "text": [</span><br><span class="line">    "The quick brown fox jumps over the lazy dog",</span><br><span class="line">    "The quick brown fox jumps over the quick dog"</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多字段查询"><a href="#多字段查询" class="headerlink" title="多字段查询"></a><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/multi-field-search.html" target="_blank" rel="noopener">多字段查询</a></h2><h3 id="多字段查询-multi-match"><a href="#多字段查询-multi-match" class="headerlink" title="多字段查询: multi_match"></a>多字段查询: multi_match</h3><p>注意：将<code>not_analyzed</code>字段与<code>multi_match</code>中<code>analyzed</code>字段混在一起没有多大用处。在<code>multi_match</code>查询中避免使用<code>not_analyzed</code>字段。</p><p>在<code>&quot;title&quot;</code>和<code>&quot;body&quot;</code>字段搜索<code>&quot;Quick brown fox&quot;</code>，最低<code>should</code>匹配30%，可写作<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "bool": &#123;         # `should`x2</span><br><span class="line">      "should": [</span><br><span class="line">        &#123;</span><br><span class="line">          "match": &#123;</span><br><span class="line">            "body": &#123;</span><br><span class="line">              "query": "Quick brown fox",</span><br><span class="line">              "minimum_should_match": "30%"</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">          "match": &#123;</span><br><span class="line">            "title": &#123;</span><br><span class="line">              "query": "Quick brown fox",</span><br><span class="line">              "minimum_should_match": "30%"</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>可简写为  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "multi_match": &#123;</span><br><span class="line">      "query": "Quick brown fox",</span><br><span class="line">      "fields": ["title", "body"],</span><br><span class="line">      "minimum_should_match": "30%"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用<code>^boost</code>为<code>&quot;body&quot;</code>字段提升权重</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "multi_match": &#123;</span><br><span class="line">      "query": "Quick brown fox",</span><br><span class="line">      "fields": ["title", "body^2"],</span><br><span class="line">      "minimum_should_match": "30%"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>若在<code>&quot;book_title&quot;, &quot;chapter_title&quot;</code>等字段中搜索，可将<code>fields</code>参数指定为</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "multi_match": &#123;</span><br><span class="line">      "query": "Quick brown fox",</span><br><span class="line">      "fields": "*_title"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="最佳字段-best-fields-dis-max"><a href="#最佳字段-best-fields-dis-max" class="headerlink" title="最佳字段(best_fields): dis_max"></a>最佳字段(best_fields): dis_max</h3><p>考虑以下两个文档<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">    "title": "Quick brown rabbits",</span><br><span class="line">    "body":  "Brown rabbits are commonly seen."</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /my_index/my_type/2</span><br><span class="line">&#123;</span><br><span class="line">    "title": "Keeping pets healthy",</span><br><span class="line">    "body":  "My quick brown fox eats rabbits on a regular basis."</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这两个文档简单判断有如下特点</p><ul><li>文档1两个字段中都包含<code>&quot;brown&quot;</code>，但不包含<code>&quot;fox&quot;</code>；</li><li>文档2的<code>&quot;body&quot;</code>字段包含<code>&quot;brown&quot;, &quot;fox&quot;</code>两个词</li></ul><p>那么文档2匹配度可能会更高，当用<code>match</code>进行匹配<code>&quot;Brown fox&quot;</code>时，产生如下结果<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "multi_match": &#123;          # 多字段匹配</span><br><span class="line">      "query": "Brown fox",</span><br><span class="line">      "fields": ["title", "body"]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">...,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line">        "_index" : "my_index",</span><br><span class="line">        "_type" : "my_type",</span><br><span class="line">        "_id" : "2",</span><br><span class="line">        "_score" : 0.5753642,</span><br><span class="line">        "_source" : &#123;</span><br><span class="line">          "title" : "Keeping pets healthy",</span><br><span class="line">          "body" : "My quick brown fox eats rabbits on a regular basis."</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        "_index" : "my_index",</span><br><span class="line">        "_type" : "my_type",</span><br><span class="line">        "_id" : "1",</span><br><span class="line">        "_score" : 0.5753642,</span><br><span class="line">        "_source" : &#123;</span><br><span class="line">          "title" : "Quick brown rabbits",</span><br><span class="line">          "body" : "Brown rabbits are commonly seen."</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>产生的结果是两者匹配度是一致的，这是因为<code>bool</code>计算评分方式如下</p><ol><li>执行<code>should</code>语句中多个查询，得到各个查询的评分；</li><li>求取各个评分的均值作为文档查询评分。</li></ol><p>可以采用<strong>分离最大化查询语句</strong><code>dis_max</code>进行查询，将任何与任一查询匹配的文档作为结果返回，但只将<strong>最佳匹配的评分</strong>作为查询的评分结果返回<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "dis_max": &#123;              # 分离最大化查询</span><br><span class="line">      "queries": [            # 查询列表</span><br><span class="line">        &#123;</span><br><span class="line">          "multi_match": &#123;</span><br><span class="line">            "query": "Brown fox",</span><br><span class="line">            "fields": ["title", "body"]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">..., </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line">        "_index" : "my_index",</span><br><span class="line">        "_type" : "my_type",</span><br><span class="line">        "_id" : "2",</span><br><span class="line">        "_score" : 0.5753642,</span><br><span class="line">        "_source" : &#123;</span><br><span class="line">          "title" : "Keeping pets healthy",</span><br><span class="line">          "body" : "My quick brown fox eats rabbits on a regular basis."</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        "_index" : "my_index",</span><br><span class="line">        "_type" : "my_type",</span><br><span class="line">        "_id" : "1",</span><br><span class="line">        "_score" : 0.2876821,</span><br><span class="line">        "_source" : &#123;</span><br><span class="line">          "title" : "Quick brown rabbits",</span><br><span class="line">          "body" : "Brown rabbits are commonly seen."</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><hr><p>指定<code>tie_breaker</code>参数将其他匹配语句评分也考虑其中</p><ol><li>获得最佳匹配语句的评分<code>_score</code>;</li><li>将其他匹配语句的评分结果与<code>tie_breaker</code>相乘;</li><li>对以上评分求和并规范化。</li></ol><p><code>tie_breaker</code> 可以是 0 到 1 之间的浮点数，其中 0 代表使用 dis_max 最佳匹配语句的普通逻辑， 1 表示所有匹配语句同等重要。最佳的精确值需要根据数据与查询调试得出，但是合理值应该与零接近（处于 0.1 - 0.4 之间），这样就不会颠覆 <code>dis_max</code> 最佳匹配性质的根本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "dis_max": &#123;  </span><br><span class="line">      "queries": [      </span><br><span class="line">        &#123;</span><br><span class="line">          "multi_match": &#123;</span><br><span class="line">            "query": "Brown fox",</span><br><span class="line">            "fields": ["title", "body"]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      "tie_breaker": 0.3</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多数字段-most-fields-field-subField"><a href="#多数字段-most-fields-field-subField" class="headerlink" title="多数字段(most_fields): field.subField"></a><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/most-fields.html" target="_blank" rel="noopener">多数字段(most_fields)</a>: field.subField</h3><p>可以在某字段(域)添加子字段，如希望在查找时，<strong>用不同的分析器对某字段进行分析</strong>，定义<code>_mappings</code><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    "settings": &#123; "number_of_shards": 1 &#125;, </span><br><span class="line">    "mappings": &#123;</span><br><span class="line">        "my_type": &#123;</span><br><span class="line">            "properties": &#123;</span><br><span class="line">                "title": &#123; </span><br><span class="line">                    "type":     "string",</span><br><span class="line">                    "analyzer": "english",</span><br><span class="line">                    "fields": &#123;</span><br><span class="line">                        "std":   &#123;                # 字段`title.std`</span><br><span class="line">                            "type":     "string",</span><br><span class="line">                            "analyzer": "standard"</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>查询时可以对字段及其子字段进行查询，将<code>type</code>设置为<code>most_fields</code>，希望将所有匹配字段的<strong>评分合并</strong>起来，所以使用<code>most_fields</code>类型。这让<code>multi_match</code>查询用<code>bool</code>查询将两个字段语句包在里面，而不是使用<code>dis_max</code>查询。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">   "query": &#123;</span><br><span class="line">        "multi_match": &#123;</span><br><span class="line">            "query":  "jumping rabbits",</span><br><span class="line">            "type":   "most_fields", </span><br><span class="line">            "fields": [ "title", "title.std" ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="跨字段-cross-fields-filed1-…-filedn"><a href="#跨字段-cross-fields-filed1-…-filedn" class="headerlink" title="跨字段(cross_fields): filed1, …, filedn"></a>跨字段(cross_fields): filed1, …, filedn</h3><p>某些实体需要多个字段唯一标识信息，如地址<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "street":   "5 Poland Street",</span><br><span class="line">    "city":     "London",</span><br><span class="line">    "country":  "United Kingdom",</span><br><span class="line">    "postcode": "W1V 3DG"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用<code>multi_match</code>进行查询，并将<code>type</code>设置为<code>most_fields</code><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "multi_match": &#123;</span><br><span class="line">      "query":       "Poland Street W1V",</span><br><span class="line">      "type":        "most_fields",</span><br><span class="line">      "fields":      [ "street", "city", "country", "postcode" ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="all字段-copy-to"><a href="#all字段-copy-to" class="headerlink" title="_all字段: copy_to"></a>_all字段: copy_to</h3><p>在创建索引<code>mappings</code>时，可将部分字段的值“复制”，如下，<code>first_name</code>和<code>last_name</code>的映射并不影响<code>full_name</code>如何被索引，<code>full_name</code>将两个字段的内容复制到本地，然后根据<code>full_name</code>的映射自行索引。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    "mappings": &#123;</span><br><span class="line">        "person": &#123;</span><br><span class="line">            "properties": &#123;</span><br><span class="line">                "first_name": &#123;</span><br><span class="line">                    "type":     "string",</span><br><span class="line">                    "copy_to":  "full_name" </span><br><span class="line">                &#125;,</span><br><span class="line">                "last_name": &#123;</span><br><span class="line">                    "type":     "string",</span><br><span class="line">                    "copy_to":  "full_name" </span><br><span class="line">                &#125;,</span><br><span class="line">                "full_name": &#123;</span><br><span class="line">                    "type":     "string"</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="近似匹配"><a href="#近似匹配" class="headerlink" title="近似匹配"></a>近似匹配</h2><h3 id="短语匹配-match-phrase"><a href="#短语匹配-match-phrase" class="headerlink" title="短语匹配: match_phrase"></a>短语匹配: match_phrase</h3><ul><li>找到彼此邻近搜索词的查询，例如匹配短语<code>&quot;quick brown fox&quot;</code>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "match_phrase": &#123;</span><br><span class="line">      "title": "quick brown fox"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加<code>slop</code>参数近似短语匹配</p><p>  词条相隔多远时仍然能将文档视为匹配,相隔多远的意思是<strong>为了让查询和文档匹配你需要移动词条多少次</strong>，通过设置一个像50或者100这样的高<code>slop</code>值能够排除单词距离太远的文档，但是也给予了那些单词临近的的文档更高的分数</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "match_phrase": &#123;</span><br><span class="line">      "title": &#123;</span><br><span class="line">        "query": "quick brown fox",</span><br><span class="line">        "slop": 3</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用邻近度提高相关度</p><p>  考虑到短语匹配需要全部词条出现在文中中，这要求显然过高，因为在7个词条中若6条匹配，那么相似度就很高了，所以可以将<code>match_phrase</code>放入<code>should</code>语句，以邻近度提升文档的相关度</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "bool": &#123;</span><br><span class="line">      "must": [</span><br><span class="line">        &#123;</span><br><span class="line">          "match": &#123;</span><br><span class="line">            "title": "dog"</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      "should": [</span><br><span class="line">        &#123;</span><br><span class="line">          "match_phrase": &#123;</span><br><span class="line">            "title": &#123;</span><br><span class="line">              "query": "quick brown fox",</span><br><span class="line">              "slop": 3</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="结果集重新评分-rescore"><a href="#结果集重新评分-rescore" class="headerlink" title="结果集重新评分: rescore"></a>结果集重新评分: rescore</h3><p>用<code>rescore</code>API对一次简单的<code>match</code>匹配结果顶部文档重新评分并排序，以给同时匹配短语查询的文档一个额外的相关度升级，例如<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">    "query": &#123;               # match简单查询</span><br><span class="line">        "match": &#123;  </span><br><span class="line">            "title": &#123;</span><br><span class="line">                "query":                "quick brown fox",</span><br><span class="line">                "minimum_should_match": "30%"</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    "rescore": &#123;            # 重新评分</span><br><span class="line">        "window_size": 50,  # 每一分片进行重新评分的顶部文档数量</span><br><span class="line">        "query": &#123;          # 定制另一个查询进行重新评分</span><br><span class="line">            "rescore_query": &#123;</span><br><span class="line">                "match_phrase": &#123;</span><br><span class="line">                    "title": &#123;</span><br><span class="line">                        "query": "quick brown fox",</span><br><span class="line">                        "slop":  50</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="相关词-shingles-Ngrams"><a href="#相关词-shingles-Ngrams" class="headerlink" title="相关词: shingles/Ngrams"></a><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/shingles.html" target="_blank" rel="noopener">相关词: shingles/Ngrams</a></h3><p>用<code>Ngrams</code>进行匹配以提高相关性。</p><h2 id="部分匹配"><a href="#部分匹配" class="headerlink" title="部分匹配"></a>部分匹配</h2><p>创建索引如下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    "mappings": &#123;</span><br><span class="line">        "address": &#123;</span><br><span class="line">            "properties": &#123;</span><br><span class="line">                "postcode": &#123;</span><br><span class="line">                    "type":  "keyword"</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>索引一些数据<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index/address/_bulk</span><br><span class="line">&#123;"index": &#123;"_id": 1&#125;&#125;</span><br><span class="line">&#123; "postcode": "W1V 3DG" &#125;</span><br><span class="line">&#123;"index": &#123;"_id": 2&#125;&#125;</span><br><span class="line">&#123; "postcode": "W2F 8HW" &#125;</span><br><span class="line">&#123;"index": &#123;"_id": 3&#125;&#125;</span><br><span class="line">&#123; "postcode": "W1F 7HW" &#125;</span><br><span class="line">&#123;"index": &#123;"_id": 4&#125;&#125;</span><br><span class="line">&#123; "postcode": "WC1N 1LZ" &#125;</span><br><span class="line">&#123;"index": &#123;"_id": 5&#125;&#125;</span><br><span class="line">&#123; "postcode": "SW5 0BE" &#125;</span><br></pre></td></tr></table></figure></p><h3 id="前缀查询-prefix"><a href="#前缀查询-prefix" class="headerlink" title="前缀查询: prefix"></a>前缀查询: prefix</h3><p>查找所有以<code>W1</code>开始的邮编<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "prefix": &#123;</span><br><span class="line">      "postcode": &#123;</span><br><span class="line">        "value": "W1"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="前缀短语匹配-match-phrase-prefix"><a href="#前缀短语匹配-match-phrase-prefix" class="headerlink" title="前缀短语匹配: match_phrase_prefix"></a>前缀短语匹配: match_phrase_prefix</h3><p>可通过前缀短语匹配查询，<strong>注意<code>not_analyzed</code>的字段不能被匹配成功</strong>。<br>例如某文档存在字段<code>&quot;info&quot;: &quot;somebody&#39;s home&quot;</code>，可以通过如下查找<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;my_index&#x2F;address&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_phrase_prefix&quot;: &#123;</span><br><span class="line">      &quot;info&quot;: &quot;somebody&#39;s h&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="通配符查询-wildcard"><a href="#通配符查询-wildcard" class="headerlink" title="通配符查询: wildcard"></a>通配符查询: wildcard</h3><p>允许指定匹配的正则式。它使用标准的shell通配符查询： </p><ul><li><code>?</code>匹配任意字符；</li><li><code>*</code>匹配0或多个字符。</li></ul><p>匹配包含<code>W1F 7HW</code>和<code>W2F 8HW</code>的文档<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/address/_search</span><br><span class="line">&#123;</span><br><span class="line">    "query": &#123;</span><br><span class="line">        "wildcard": &#123;</span><br><span class="line">            "postcode": "W?F*HW" </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="正则表达式查询-regexp"><a href="#正则表达式查询-regexp" class="headerlink" title="正则表达式查询: regexp"></a>正则表达式查询: regexp</h3><p>只匹配<code>W</code>区域所有邮编，但是<a href="#%e9%80%9a%e9%85%8d%e7%ac%a6%e6%9f%a5%e8%af%a2-wildcard">通配符查询: wildcard</a>中查询语句也会匹配<code>WC</code>开头得邮编，那么用正则表达式匹配可以处理这种复杂的情况<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/address/_search</span><br><span class="line">&#123;</span><br><span class="line">    "query": &#123;</span><br><span class="line">        "regexp": &#123;</span><br><span class="line">            "postcode": "W[0-9].+" </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="控制相关度"><a href="#控制相关度" class="headerlink" title="控制相关度"></a><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/controlling-relevance.html" target="_blank" rel="noopener">控制相关度</a></h2><h1 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/aggregations.html" target="_blank" rel="noopener">聚合</a></h1><p>索引一些数据<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">POST /cars/transactions/_bulk</span><br><span class="line">&#123; "index": &#123;&#125;&#125;</span><br><span class="line">&#123; "price" : 10000, "color" : "red", "make" : "honda", "sold" : "2014-10-28" &#125;</span><br><span class="line">&#123; "index": &#123;&#125;&#125;</span><br><span class="line">&#123; "price" : 20000, "color" : "red", "make" : "honda", "sold" : "2014-11-05" &#125;</span><br><span class="line">&#123; "index": &#123;&#125;&#125;</span><br><span class="line">&#123; "price" : 30000, "color" : "green", "make" : "ford", "sold" : "2014-05-18" &#125;</span><br><span class="line">&#123; "index": &#123;&#125;&#125;</span><br><span class="line">&#123; "price" : 15000, "color" : "blue", "make" : "toyota", "sold" : "2014-07-02" &#125;</span><br><span class="line">&#123; "index": &#123;&#125;&#125;</span><br><span class="line">&#123; "price" : 12000, "color" : "green", "make" : "toyota", "sold" : "2014-08-19" &#125;</span><br><span class="line">&#123; "index": &#123;&#125;&#125;</span><br><span class="line">&#123; "price" : 20000, "color" : "red", "make" : "honda", "sold" : "2014-11-05" &#125;</span><br><span class="line">&#123; "index": &#123;&#125;&#125;</span><br><span class="line">&#123; "price" : 80000, "color" : "red", "make" : "bmw", "sold" : "2014-01-01" &#125;</span><br><span class="line">&#123; "index": &#123;&#125;&#125;</span><br><span class="line">&#123; "price" : 25000, "color" : "blue", "make" : "ford", "sold" : "2014-02-12" &#125;</span><br></pre></td></tr></table></figure></p><h2 id="尝试聚合"><a href="#尝试聚合" class="headerlink" title="尝试聚合"></a>尝试聚合</h2><h3 id="命令格式-GET-URL-search-“aggs”-“NAME”-AGG-TYPE-…"><a href="#命令格式-GET-URL-search-“aggs”-“NAME”-AGG-TYPE-…" class="headerlink" title="命令格式: GET /URL/_search { “aggs”: { “NAME”: { AGG_TYPE: { … } } } }"></a>命令格式: GET /URL/_search { “aggs”: { “NAME”: { AGG_TYPE: { … } } } }</h3><p>聚合语句的典型命令格式如下，一个聚合语句内只包含一个<code>AGG_TYPE</code>，包含其余聚合语句时嵌套<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GET /URL/_search</span><br><span class="line">&#123;</span><br><span class="line">  "aggs": &#123;</span><br><span class="line">    "NAME": &#123;</span><br><span class="line">      "AGG_TYPE": &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;,</span><br><span class="line">      "aggs": &#123;</span><br><span class="line">        "NAME": &#123;</span><br><span class="line">          "AGG_TYPE": &#123;</span><br><span class="line">            ...</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="简单例子-terms-avg-max-min"><a href="#简单例子-terms-avg-max-min" class="headerlink" title="简单例子: terms, avg, max, min"></a>简单例子: terms, avg, max, min</h3><ul><li><p>根据颜色分桶<strong>计数</strong></p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">  "size": 0,</span><br><span class="line"><span class="meta">  #</span><span class="bash"> ------------ 新增 ------------</span></span><br><span class="line">  "aggs": &#123;</span><br><span class="line">    # 聚合语句，根据颜色进行分桶计数</span><br><span class="line">    "popular_colors": &#123;</span><br><span class="line">      "terms": &#123;</span><br><span class="line">        "field": "color"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">  #</span><span class="bash"> ------------ 新增 ------------</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  得到错误</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "error": &#123;</span><br><span class="line">    "root_cause": [</span><br><span class="line">      &#123;</span><br><span class="line">        "type": "illegal_argument_exception",</span><br><span class="line">        "reason": "Fielddata is disabled on text fields by default. Set fielddata=true on [color] in order to load fielddata in memory by uninverting the inverted index. Note that this can however use significant memory. Alternatively use a keyword field instead."</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    ...,</span><br><span class="line">  &#125;,</span><br><span class="line">  "status": 400</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  原因见<a href="https://www.cnblogs.com/shsgshn/p/11535849.html" target="_blank" rel="noopener">ES报错：”illegal_argument_exception” - cnblogs</a>，应修改为</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">  "size": 0,</span><br><span class="line">  "aggs": &#123;</span><br><span class="line">    "popular_colors": &#123;</span><br><span class="line">      "terms": &#123;</span><br><span class="line">        "field": "color.keyword"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...,</span><br><span class="line">  </span><br><span class="line">  "aggregations" : &#123;</span><br><span class="line">    "popular_colors" : &#123;</span><br><span class="line">      "doc_count_error_upper_bound" : 0,</span><br><span class="line">      "sum_other_doc_count" : 0,</span><br><span class="line">      "buckets" : [         # 分桶信息</span><br><span class="line">        &#123;</span><br><span class="line">          "key" : "red",</span><br><span class="line">          "doc_count" : 4   # 红色总计4辆</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          "key" : "blue",</span><br><span class="line">          "doc_count" : 2</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          "key" : "green",</span><br><span class="line">          "doc_count" : 2</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>计算<strong>每种颜色车的价格均值</strong></p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">  "size": 0,</span><br><span class="line">  "aggs": &#123;</span><br><span class="line">    # 聚合语句，根据颜色进行分桶计数</span><br><span class="line">    "popular_colors": &#123;</span><br><span class="line">      "terms": &#123;</span><br><span class="line">        "field": "color.keyword"</span><br><span class="line">      &#125;,</span><br><span class="line">      # ------------ 新增 ------------</span><br><span class="line">      # 嵌套聚合语句，在颜色分桶内计算均值</span><br><span class="line">      "aggs": &#123;</span><br><span class="line">        "average_price_of_color": &#123;</span><br><span class="line">          "avg": &#123;</span><br><span class="line">            "field": "price"</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      # ------------ 新增 ------------</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...,</span><br><span class="line">  </span><br><span class="line">  "aggregations" : &#123;</span><br><span class="line">    "popular_colors" : &#123;</span><br><span class="line">      "doc_count_error_upper_bound" : 0,</span><br><span class="line">      "sum_other_doc_count" : 0,</span><br><span class="line">      "buckets" : [</span><br><span class="line">        &#123;</span><br><span class="line">          "key" : "red",</span><br><span class="line">          "doc_count" : 4,        # 红色总计4辆</span><br><span class="line">          "average_price_of_color" : &#123;</span><br><span class="line">            "value" : 32500.0     # 红色分桶内价格均值</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加<strong>每种颜色车制造厂商</strong>信息</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">  "size": 0,</span><br><span class="line">  "aggs": &#123;</span><br><span class="line">    # 聚合语句，根据颜色进行分桶计数</span><br><span class="line">    "popular_colors": &#123;</span><br><span class="line">      "terms": &#123;</span><br><span class="line">        "field": "color.keyword"</span><br><span class="line">      &#125;,</span><br><span class="line">      "aggs": &#123;</span><br><span class="line">        # 嵌套聚合语句，在颜色分桶内计算均值</span><br><span class="line">        "average_price_of_color": &#123;</span><br><span class="line">          "avg": &#123;</span><br><span class="line">            "field": "price"</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        # ------------ 新增 ------------</span><br><span class="line">        # 嵌套聚合语句，在颜色分桶内统计制造厂商</span><br><span class="line">        "the_maker_of_the_car_of_this_color": &#123;</span><br><span class="line">          "terms": &#123;</span><br><span class="line">            "field": "make.keyword"</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        # ------------ 新增 ------------</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...,</span><br><span class="line"></span><br><span class="line">  "aggregations" : &#123;</span><br><span class="line">    "popular_colors" : &#123;</span><br><span class="line">      "doc_count_error_upper_bound" : 0,</span><br><span class="line">      "sum_other_doc_count" : 0,</span><br><span class="line">      "buckets" : [</span><br><span class="line">        &#123;</span><br><span class="line">          "key" : "red",</span><br><span class="line">          "doc_count" : 4,        # 红色总计4辆</span><br><span class="line">          "the_maker_of_the_car_of_this_color" : &#123;</span><br><span class="line">            "doc_count_error_upper_bound" : 0,</span><br><span class="line">            "sum_other_doc_count" : 0,</span><br><span class="line">            "buckets" : [         # 红色分桶内，按制造厂商分桶</span><br><span class="line">              &#123;</span><br><span class="line">                "key" : "honda",</span><br><span class="line">                "doc_count" : 3   # honda制造3辆</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                "key" : "bmw",</span><br><span class="line">                "doc_count" : 1   # bwm制造3辆</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;,</span><br><span class="line">          "average_price_of_color" : &#123;</span><br><span class="line">            "value" : 32500.0     # 红色分桶内价格均值</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加<strong>每种颜色、每种厂商制造的车的价格最高、最低价格</strong>信息</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">  "size": 0,</span><br><span class="line">  "aggs": &#123;</span><br><span class="line">    # 聚合语句，根据颜色进行分桶计数</span><br><span class="line">    "popular_colors": &#123;</span><br><span class="line">      "terms": &#123;</span><br><span class="line">        "field": "color.keyword"</span><br><span class="line">      &#125;,</span><br><span class="line">      "aggs": &#123;</span><br><span class="line">        # 嵌套聚合语句，在颜色分桶内计算均值</span><br><span class="line">        "average_price_of_color": &#123;</span><br><span class="line">          "avg": &#123;</span><br><span class="line">            "field": "price"</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        # 嵌套聚合语句，在颜色分桶内统计制造厂商</span><br><span class="line">        "the_maker_of_the_car_of_this_color": &#123;</span><br><span class="line">          "terms": &#123;</span><br><span class="line">            "field": "make.keyword"</span><br><span class="line">          &#125;,</span><br><span class="line">          # ------------ 新增 ------------</span><br><span class="line">          "aggs": &#123;</span><br><span class="line">            # 嵌套聚合语句的嵌套聚合语句，在颜色分桶、制造厂商子分桶内计算价格最小值</span><br><span class="line">            "minimal_price_of_this_color_of_this_maker": &#123;</span><br><span class="line">              "min": &#123;</span><br><span class="line">                "field": "price"</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            # 嵌套聚合语句的嵌套聚合语句，在颜色分桶、制造厂商子分桶内计算价格最大值</span><br><span class="line">            "maximal_price_of_this_color_of_this_maker": &#123;</span><br><span class="line">              "max": &#123;</span><br><span class="line">                "field": "price"</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          # ------------ 新增 ------------</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...,</span><br><span class="line"></span><br><span class="line">  "aggregations" : &#123;</span><br><span class="line">    "popular_colors" : &#123;</span><br><span class="line">      "doc_count_error_upper_bound" : 0,</span><br><span class="line">      "sum_other_doc_count" : 0,</span><br><span class="line">      "buckets" : [</span><br><span class="line">        &#123;</span><br><span class="line">          "key" : "red",</span><br><span class="line">          "doc_count" : 4,              # 红色总计4辆</span><br><span class="line">          "the_maker_of_the_car_of_this_color" : &#123;       </span><br><span class="line">            "doc_count_error_upper_bound" : 0,</span><br><span class="line">            "sum_other_doc_count" : 0,</span><br><span class="line">            "buckets" : [               # 红色分桶内，按制造厂商分桶</span><br><span class="line">              &#123;</span><br><span class="line">                "key" : "honda",</span><br><span class="line">                "doc_count" : 3,        # honda制造3辆</span><br><span class="line">                "maximal_price_of_this_color_of_this_maker" : &#123;</span><br><span class="line">                  "value" : 20000.0     # 红色车、honda制造，价格最大值</span><br><span class="line">                &#125;,</span><br><span class="line">                "minimal_price_of_this_color_of_this_maker" : &#123;</span><br><span class="line">                  "value" : 10000.0     # 红色车、honda制造，价格最小值</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;,</span><br><span class="line">              </span><br><span class="line">              ...</span><br><span class="line">            ]</span><br><span class="line">          &#125;,</span><br><span class="line">          "average_price_of_color" : &#123;</span><br><span class="line">            "value" : 32500.0           # 红色分桶内价格均值</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="限定聚合范围-query-global"><a href="#限定聚合范围-query-global" class="headerlink" title="限定聚合范围: query, global"></a>限定聚合范围: query, global</h2><p>在上面例子中，未进行<code>query</code>请求，所以默认是对所有文档进行聚合的。<code>aggs</code>可以和<code>query</code>同时使用，也就是说，聚合是基于我们查询匹配的文档集合进行计算的。</p><ul><li>计算<code>honda</code>生产的汽车各颜色的价格的所有统计量  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">  "size": 0,</span><br><span class="line"><span class="meta">  #</span><span class="bash"> ----- 查询honda汽车 ----- </span></span><br><span class="line">  "query": &#123;</span><br><span class="line">    "term": &#123;</span><br><span class="line">      "make": &#123;</span><br><span class="line">        "value": "honda"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="meta">  #</span><span class="bash"> ----- 查询honda汽车 ----- </span></span><br><span class="line">  "aggs": &#123;</span><br><span class="line">    # ----- 以颜色分桶 ------</span><br><span class="line">    "color_of_cars": &#123;</span><br><span class="line">      "terms": &#123;</span><br><span class="line">        "field": "color.keyword"</span><br><span class="line">      &#125;,</span><br><span class="line">      "aggs": &#123;</span><br><span class="line">        # -- 该颜色价格统计量 --</span><br><span class="line">        "all_stats_of_cars_with_this_color": &#123;</span><br><span class="line">          "extended_stats": &#123;</span><br><span class="line">            "field": "price"</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        # -- 该颜色价格统计量 --</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    # ----- 以颜色分桶 ------</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>但有时也想在获得子集的同时，得到所有对象的聚合结果，如下</p><ul><li><p>统计<code>honda</code>汽车均值与所有汽车售价均值的对比，可以用查询获得子集计算普通聚合，再用<strong>全局桶</strong>获取全部汽车售价均值</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">  "size": 0, </span><br><span class="line"><span class="meta">  #</span><span class="bash"> ----- 查询honda汽车 ----- </span></span><br><span class="line">  "query": &#123;</span><br><span class="line">    "term": &#123;</span><br><span class="line">      "make": &#123;</span><br><span class="line">        "value": "honda"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="meta">  #</span><span class="bash"> ----- 查询honda汽车 ----- </span></span><br><span class="line">  "aggs": &#123;</span><br><span class="line">    # ---- honda汽车均值 ----</span><br><span class="line">    "average_price_of_honda": &#123;</span><br><span class="line">      "avg": &#123;</span><br><span class="line">        "field": "price"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    # ---- honda汽车均值 ----</span><br><span class="line">    # ----- 全部汽车统计 ----</span><br><span class="line">    "all_maker": &#123;</span><br><span class="line">      "global": &#123;&#125;,   # 全局桶，无参数</span><br><span class="line">      "aggs": &#123;</span><br><span class="line">        # -- 全部汽车均值 ---</span><br><span class="line">        "average_price_of_all_maker": &#123;</span><br><span class="line">          "avg": &#123;</span><br><span class="line">            "field": "price"</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        # -- 全部汽车均值 ---</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    # ----- 全部汽车统计 ----</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="直方图统计-histogram"><a href="#直方图统计-histogram" class="headerlink" title="直方图统计: histogram"></a>直方图统计: histogram</h2><ul><li><p>对价格进行直方图统计</p><p>  以间隔20000对车价格进行直方图统计</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">  "size": 0,</span><br><span class="line">  "aggs": &#123;</span><br><span class="line">    "histogram_of_price": &#123;</span><br><span class="line">      "histogram": &#123;        # 直方图统计</span><br><span class="line">        "field": "price",</span><br><span class="line">        "interval": 20000   # 间隔20000</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...,</span><br><span class="line"></span><br><span class="line">  "aggregations" : &#123;</span><br><span class="line">    "histogram_of_price" : &#123;</span><br><span class="line">      "buckets" : [</span><br><span class="line">        &#123;</span><br><span class="line">          "key" : 0.0,        # 区间下界，代表0 ~ 19,999</span><br><span class="line">          "doc_count" : 3</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          "key" : 20000.0,</span><br><span class="line">          "doc_count" : 4</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          "key" : 40000.0,</span><br><span class="line">          "doc_count" : 0</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          "key" : 60000.0,</span><br><span class="line">          "doc_count" : 0</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          "key" : 80000.0,</span><br><span class="line">          "doc_count" : 1</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>求取每个价格区间车辆总价</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">  "size": 0,</span><br><span class="line">  "aggs": &#123;</span><br><span class="line">    "histogram_of_price": &#123;</span><br><span class="line">      "histogram": &#123;        # 直方图统计</span><br><span class="line">        "field": "price",</span><br><span class="line">        "interval": 20000   # 间隔20000</span><br><span class="line">      &#125;,</span><br><span class="line">      # ------------ 新增 ------------</span><br><span class="line">      "aggs": &#123;</span><br><span class="line">        "sum_of_price_in_this_bin": &#123;</span><br><span class="line">          "sum": &#123;          # 求和</span><br><span class="line">            "field": "price"</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      # ------------ 新增 ------------</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...,</span><br><span class="line"></span><br><span class="line">  "aggregations" : &#123;</span><br><span class="line">    "histogram_of_price" : &#123;</span><br><span class="line">      "buckets" : [</span><br><span class="line">        &#123;</span><br><span class="line">          "key" : 0.0,</span><br><span class="line">          "doc_count" : 3,</span><br><span class="line">          "sum_of_price_in_this_bin" : &#123;</span><br><span class="line">            "value" : 37000.0</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="统计量计算-extended-stats"><a href="#统计量计算-extended-stats" class="headerlink" title="统计量计算: extended_stats"></a>统计量计算: extended_stats</h2><p>关于每个厂商车的价格所有统计量<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">  "size": 0,</span><br><span class="line">  "aggs": &#123;</span><br><span class="line">    "the_maker_of_cars": &#123;</span><br><span class="line">      "terms": &#123;</span><br><span class="line">        "field": "make.keyword"</span><br><span class="line">      &#125;,</span><br><span class="line">      # ----------- 新增 -----------</span><br><span class="line">      "aggs": &#123;</span><br><span class="line">        "stats_of_price_of_this_maker": &#123;</span><br><span class="line">          "extended_stats": &#123;</span><br><span class="line">            "field": "price"</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      # ----------- 新增 -----------</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...,</span><br><span class="line">  </span><br><span class="line">  "aggregations" : &#123;</span><br><span class="line">    "the_maker_of_cars" : &#123;</span><br><span class="line">      "doc_count_error_upper_bound" : 0,</span><br><span class="line">      "sum_other_doc_count" : 0,</span><br><span class="line">      "buckets" : [</span><br><span class="line">        &#123;</span><br><span class="line">          "key" : "honda",</span><br><span class="line">          "doc_count" : 3,</span><br><span class="line">          "stats_of_price_of_this_maker" : &#123;</span><br><span class="line">            "count" : 3,</span><br><span class="line">            "min" : 10000.0,</span><br><span class="line">            "max" : 20000.0,</span><br><span class="line">            "avg" : 16666.666666666668,</span><br><span class="line">            "sum" : 50000.0,</span><br><span class="line">            "sum_of_squares" : 9.0E8,</span><br><span class="line">            "variance" : 2.222222222222221E7,</span><br><span class="line">            "std_deviation" : 4714.045207910315,</span><br><span class="line">            "std_deviation_bounds" : &#123;</span><br><span class="line">              "upper" : 26094.757082487296,</span><br><span class="line">              "lower" : 7238.5762508460375</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="按时间统计-date-histogram"><a href="#按时间统计-date-histogram" class="headerlink" title="按时间统计: date_histogram"></a>按时间统计: date_histogram</h2><ul><li><p>根据销售时间，统计每月售出数目和总价</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">  "size": 0,</span><br><span class="line">  "aggs": &#123;</span><br><span class="line">    "sold_every_month": &#123;</span><br><span class="line">      "date_histogram": &#123;       # 按时间求直方图</span><br><span class="line">        "field": "sold",        </span><br><span class="line">        "interval": "month",    # 按月</span><br><span class="line">        "format": "yyyy-MM-dd"  # 指定时间格式(可选)</span><br><span class="line">      &#125;,</span><br><span class="line">      "aggs": &#123;</span><br><span class="line">        "totally_sold_price_in_this_month": &#123;</span><br><span class="line">          "sum": &#123;              # 计算每个月售出总价</span><br><span class="line">            "field": "price"</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...,</span><br><span class="line"></span><br><span class="line">  "aggregations" : &#123;</span><br><span class="line">    "sold_every_month" : &#123;</span><br><span class="line">      "buckets" : [</span><br><span class="line">        &#123;</span><br><span class="line">          "key_as_string" : "2014-01-01",</span><br><span class="line">          "key" : 1388534400000,</span><br><span class="line">          "doc_count" : 1,</span><br><span class="line">          "totally_sold_price_in_this_month" : &#123;</span><br><span class="line">            "value" : 80000.0</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        ...,</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">          "key_as_string" : "2014-11-01",</span><br><span class="line">          "key" : 1414800000000,</span><br><span class="line">          "doc_count" : 2,</span><br><span class="line">          "total_sold_price" : &#123;</span><br><span class="line">            "value" : 40000.0</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不忽略空桶</p><p>  可以看到上面输出中并不包含<code>2014-01-01 ~ 2014-12-31</code>全年，因为统计为空的桶被忽略了，可指定如下两个参数强制返回空桶，并返回全年信息</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">  "size": 0,</span><br><span class="line">  "aggs": &#123;</span><br><span class="line">    "sold_every_month": &#123;</span><br><span class="line">      "date_histogram": &#123;</span><br><span class="line">        "field": "sold",</span><br><span class="line">        "interval": "month", </span><br><span class="line">        "format": "yyyy-MM-dd",</span><br><span class="line">        # ------- 新增 -------</span><br><span class="line">        "min_doc_count": 0,     # 强制返回空桶</span><br><span class="line">        "extended_bounds": &#123;    # 强制返回该日期范围内的桶</span><br><span class="line">          "min": "2014-01-01",</span><br><span class="line">          "max": "2014-12-31"</span><br><span class="line">        &#125;</span><br><span class="line">        # ------- 新增 -------</span><br><span class="line">      &#125;,</span><br><span class="line">      "aggs": &#123;</span><br><span class="line">        "total_sold_price": &#123;</span><br><span class="line">          "sum": &#123;</span><br><span class="line">            "field": "price"</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>按季度展示所有汽车品牌总销售额</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">  "size": 0,</span><br><span class="line">  "aggs": &#123;</span><br><span class="line">    "sold_per_quarter": &#123;</span><br><span class="line">      # --- 按季度统计直方图 ---</span><br><span class="line">      "date_histogram": &#123;</span><br><span class="line">        "field": "sold",</span><br><span class="line">        "interval": "quarter",</span><br><span class="line">        "format": "yyyy-MM-dd",</span><br><span class="line">        "min_doc_count": 0,</span><br><span class="line">        "extended_bounds": &#123;</span><br><span class="line">          "min": "2014-01-01",</span><br><span class="line">          "max": "2014-12-31"</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      "aggs": &#123;</span><br><span class="line">        # --- 统计每个季度总销售额 ---</span><br><span class="line">        "total_sold_in_this_quarter": &#123;</span><br><span class="line">          "sum": &#123;</span><br><span class="line">            "field": "price"</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        # --- 统计每个季度总销售额 ---</span><br><span class="line">        # -------- 按品牌分箱 -------</span><br><span class="line">        "sold_of_maker": &#123;</span><br><span class="line">          "terms": &#123;</span><br><span class="line">            "field": "make.keyword"</span><br><span class="line">          &#125;,</span><br><span class="line">          # ---- 求该品牌总销售额 ----</span><br><span class="line">          "aggs": &#123;</span><br><span class="line">            "sum_of_sold_price_of_this_maker": &#123;</span><br><span class="line">              "sum": &#123;</span><br><span class="line">                "field": "price"</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          # ---- 求该品牌总销售额 ----</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        # -------- 按品牌分箱 -------</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      # --- 按季度统计直方图 ---</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="过滤和聚合"><a href="#过滤和聚合" class="headerlink" title="过滤和聚合"></a>过滤和聚合</h2><h3 id="查询过滤-“query”-…-“filter”-…"><a href="#查询过滤-“query”-…-“filter”-…" class="headerlink" title="查询过滤: “query”: { …, “filter”, … }"></a>查询过滤: “query”: { …, “filter”, … }</h3><p>在查询过程中设置过滤条件，同时影响搜索和聚合结果</p><ul><li><p>售价在10000美元之上的汽车计算其均值</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">  "size": 0, </span><br><span class="line">  "query": &#123;            # 过滤查询</span><br><span class="line">    "constant_score": &#123;</span><br><span class="line">      "filter": &#123;</span><br><span class="line">        "range": &#123;</span><br><span class="line">          "price": &#123;</span><br><span class="line">            "gt": 10000</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="meta">  #</span><span class="bash"> ------------------------</span></span><br><span class="line">  "aggs": &#123;</span><br><span class="line">    "average_price_of_cars": &#123;</span><br><span class="line">      "avg": &#123;</span><br><span class="line">        "field": "price"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="聚合过滤-“aggs”-…-“filter”-…"><a href="#聚合过滤-“aggs”-…-“filter”-…" class="headerlink" title="聚合过滤: “aggs”: { …, “filter”, … }"></a>聚合过滤: “aggs”: { …, “filter”, … }</h3><p>只想<strong>对聚合结果进行过滤</strong>时，在聚合语句<code>aggs</code>中设置过滤条件，影响聚合</p><ul><li>统计<code>honda</code>汽车2014年下半年售出的车的均值，但是<strong>要求查询结果返回全部honda的文档</strong>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "term": &#123;</span><br><span class="line">      "make": &#123;</span><br><span class="line">        "value": "honda"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="meta">  #</span><span class="bash"> ---------------------------------------</span></span><br><span class="line">  "aggs": &#123;</span><br><span class="line">    "cars_sold_in_2014_M6_to_M12": &#123;</span><br><span class="line">      "filter": &#123;</span><br><span class="line">        "range": &#123;</span><br><span class="line">          "sold": &#123;</span><br><span class="line">            "from": "2014-07-01",</span><br><span class="line">            "to": "2014-12-31"</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      # -----------------------------------</span><br><span class="line">      "aggs": &#123;</span><br><span class="line">        "average_price_of_cars_sold_in_2014_M6_to_M12": &#123;</span><br><span class="line">          "avg": &#123;</span><br><span class="line">            "field": "price"</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="后过滤器-post-filter"><a href="#后过滤器-post-filter" class="headerlink" title="后过滤器: post_filter"></a>后过滤器: post_filter</h3><p>用后过滤器(<code>post_filter</code>)<strong>只过滤搜索结果而不过滤聚合结果</strong>，只影响搜索结果</p><ul><li><p>统计<code>honda</code>汽车2014年下半年售出的车均值，但是<strong>要求查询结果返回全部车信息</strong></p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">  "size": 0, </span><br><span class="line">  "query": &#123;</span><br><span class="line">    "term": &#123;</span><br><span class="line">      "make": &#123;</span><br><span class="line">        "value": "honda"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="meta">  #</span><span class="bash"> ---------------------------------------</span></span><br><span class="line">  "post_filter": &#123;</span><br><span class="line">    "range": &#123;</span><br><span class="line">      "sold": &#123;</span><br><span class="line">        "from": "2014-07-01",</span><br><span class="line">        "to": "2014-12-31"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, </span><br><span class="line"><span class="meta">  #</span><span class="bash"> ---------------------------------------</span></span><br><span class="line">  "aggs": &#123;</span><br><span class="line">    "average_price_of_cars_sold_in_2014_M6_to_M12": &#123;</span><br><span class="line">      "avg": &#123;</span><br><span class="line">        "field": "price"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="多桶排序-order"><a href="#多桶排序-order" class="headerlink" title="多桶排序: order"></a>多桶排序: order</h2><p>默认情况下，桶会根据<code>doc_count</code>降序排序，可以通过不同的处理方式修改桶的排序方式</p><h3 id="内置排序-count-term-key"><a href="#内置排序-count-term-key" class="headerlink" title="内置排序: _count, _term, _key"></a>内置排序: _count, _term, _key</h3><p>在聚合对象中引入<code>order</code>对象，可根据以下几个值进行排序</p><ul><li><code>_count</code>: 按文档排序，对<code>terms</code>, <code>histogram</code>, <code>date_histogram</code>有效；</li><li><code>_term</code>: 按词项的字符串值的字母排序，只对<code>terms</code>有效；</li><li><code>_key</code>: 按桶的键值数值排序，理论上与<code>_term</code>类似，只对<code>histogram</code>, <code>date_histogram</code>有效</li></ul><p>例如，按车的颜色进行分桶，各桶按文档数升序排序<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">  "size": 0,</span><br><span class="line">  "aggs": &#123;</span><br><span class="line">    "colors_of_cars": &#123;</span><br><span class="line">      "terms": &#123;</span><br><span class="line">        "field": "color.keyword",</span><br><span class="line">        # ------------------</span><br><span class="line">        "order": &#123;</span><br><span class="line">          "_term": "asc"</span><br><span class="line">        &#125;</span><br><span class="line">        # ------------------</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="按度量排序-自定义嵌套度量"><a href="#按度量排序-自定义嵌套度量" class="headerlink" title="按度量排序:自定义嵌套度量"></a>按度量排序:自定义嵌套度量</h3><p>可在<code>order</code>中传入自定义度量，该度量在聚合内定义，用<code>aggs.metric</code>进行访问</p><p>例如，<strong>按车的颜色进行分桶</strong>，各桶按价格的均值升序排序<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">  "size": 0,</span><br><span class="line">  "aggs": &#123;</span><br><span class="line">    "colors_of_cars": &#123;</span><br><span class="line">      "terms": &#123;</span><br><span class="line">        "field": "color.keyword",</span><br><span class="line">        # -----------------------------</span><br><span class="line">        "order": &#123;</span><br><span class="line">          "stats_of_cars_in_this_color.variance": "asc"</span><br><span class="line">        &#125;</span><br><span class="line">        # -----------------------------</span><br><span class="line">      &#125;,</span><br><span class="line">      # -------------------------------</span><br><span class="line">      "aggs": &#123;</span><br><span class="line">        "stats_of_cars_in_this_color": &#123;</span><br><span class="line">          "extended_stats": &#123;</span><br><span class="line">            "field": "price"</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      # -------------------------------</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="“深度”度量排序-自定义嵌套更深的度量"><a href="#“深度”度量排序-自定义嵌套更深的度量" class="headerlink" title="“深度”度量排序:自定义嵌套更深的度量"></a>“深度”度量排序:自定义嵌套更深的度量</h3><p>在子聚合中定义孙聚合，用孙聚合的指标作为排序度量，用<code>aggs&gt;aggs.metric</code>访问，可定义更深的路径</p><p>例如，<strong>按价格分桶</strong>后，以各价格区间内<strong>红色、绿色车</strong>的<strong>价格方差降序</strong>排序<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">  "size": 0,</span><br><span class="line">  "aggs": &#123;</span><br><span class="line">    "histogram_of_price": &#123;</span><br><span class="line">      "histogram": &#123;</span><br><span class="line">        "field": "price",</span><br><span class="line">        "interval": 5000,</span><br><span class="line">        # -----------------------------------</span><br><span class="line">        "order": &#123;</span><br><span class="line">          "red_green_cars&gt;price_stats.variance": "desc"</span><br><span class="line">        &#125;</span><br><span class="line">        # -----------------------------------</span><br><span class="line">      &#125;,</span><br><span class="line">      # -------------------------------------</span><br><span class="line">      "aggs": &#123;</span><br><span class="line">        "red_green_cars": &#123;</span><br><span class="line">          "filter": &#123;</span><br><span class="line">            "terms": &#123;</span><br><span class="line">              "color": [</span><br><span class="line">                "red","green"</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          # ---------------------------------</span><br><span class="line">          "aggs": &#123;</span><br><span class="line">            "price_stats": &#123;</span><br><span class="line">              "extended_stats": &#123;</span><br><span class="line">                "field": "price"</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="近似聚合"><a href="#近似聚合" class="headerlink" title="近似聚合"></a>近似聚合</h2><h3 id="统计去重后的数目-cardinality"><a href="#统计去重后的数目-cardinality" class="headerlink" title="统计去重后的数目: cardinality"></a>统计去重后的数目: cardinality</h3><p><code>cardinality</code>聚合可以确定某字段的值去重后的个数，例如：统计所有车颜色的种类个数<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">  "size": 0,</span><br><span class="line">  "aggs": &#123;</span><br><span class="line">    # ---------------------------</span><br><span class="line">    "distinct_colors": &#123;</span><br><span class="line">      "cardinality": &#123;</span><br><span class="line">        "field": "color.keyword"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    # ---------------------------</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...,</span><br><span class="line"></span><br><span class="line">  "aggregations" : &#123;</span><br><span class="line">    "distinct_colors" : &#123;</span><br><span class="line">      "value" : 3</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="设置精度-precision-threshold"><a href="#设置精度-precision-threshold" class="headerlink" title="设置精度: precision_threshold"></a>设置精度: precision_threshold</h4><p>指定参数<code>precision_threshold</code>，定义在何种基数水平下我们希望得到一个近乎精确的结果，例如<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">  "size": 0,</span><br><span class="line">  "aggs": &#123;</span><br><span class="line">    "distinct_colors": &#123;</span><br><span class="line">      "cardinality": &#123;</span><br><span class="line">        "field": "color.keyword",</span><br><span class="line">        # ---------------------------</span><br><span class="line">        "precision_threshold": 100</span><br><span class="line">        # ---------------------------</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="优化速度-hash"><a href="#优化速度-hash" class="headerlink" title="优化速度: hash"></a>优化速度: hash</h4><p>在<code>mappings</code>中将<code>property.fields.hash</code>设置为<code>murmur3</code>类型，预先计算而不是在统计时计算哈希值<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">DELETE /cars/</span><br><span class="line"></span><br><span class="line">PUT /cars/</span><br><span class="line">&#123;</span><br><span class="line">  "mappings": &#123;</span><br><span class="line">    "transactions": &#123;</span><br><span class="line">      "properties": &#123;</span><br><span class="line">        "color": &#123;</span><br><span class="line">          "type": "string",</span><br><span class="line">          "fields": &#123;</span><br><span class="line">            "hash": &#123;</span><br><span class="line">              "type": "murmur3" </span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST /cars/transactions/_bulk</span><br><span class="line">&#123; "index": &#123;&#125;&#125;</span><br><span class="line">&#123; "price" : 10000, "color" : "red", "make" : "honda", "sold" : "2014-10-28" &#125;</span><br><span class="line">&#123; "index": &#123;&#125;&#125;</span><br><span class="line">&#123; "price" : 20000, "color" : "red", "make" : "honda", "sold" : "2014-11-05" &#125;</span><br><span class="line">&#123; "index": &#123;&#125;&#125;</span><br><span class="line">&#123; "price" : 30000, "color" : "green", "make" : "ford", "sold" : "2014-05-18" &#125;</span><br><span class="line">&#123; "index": &#123;&#125;&#125;</span><br><span class="line">&#123; "price" : 15000, "color" : "blue", "make" : "toyota", "sold" : "2014-07-02" &#125;</span><br><span class="line">&#123; "index": &#123;&#125;&#125;</span><br><span class="line">&#123; "price" : 12000, "color" : "green", "make" : "toyota", "sold" : "2014-08-19" &#125;</span><br><span class="line">&#123; "index": &#123;&#125;&#125;</span><br><span class="line">&#123; "price" : 20000, "color" : "red", "make" : "honda", "sold" : "2014-11-05" &#125;</span><br><span class="line">&#123; "index": &#123;&#125;&#125;</span><br><span class="line">&#123; "price" : 80000, "color" : "red", "make" : "bmw", "sold" : "2014-01-01" &#125;</span><br><span class="line">&#123; "index": &#123;&#125;&#125;</span><br><span class="line">&#123; "price" : 25000, "color" : "blue", "make" : "ford", "sold" : "2014-02-12" &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">    "size" : 0,</span><br><span class="line">    "aggs" : &#123;</span><br><span class="line">        "distinct_colors" : &#123;</span><br><span class="line">            "cardinality" : &#123;</span><br><span class="line">              "field" : "color.hash" </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="百分位数度量-percentiles"><a href="#百分位数度量-percentiles" class="headerlink" title="百分位数度量: percentiles"></a><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/percentiles.html" target="_blank" rel="noopener">百分位数度量: percentiles</a></h3><p>展现以具体百分比下观察到的数值，如第95各百分位上的数值，是高于95%的数据总和。常用于寻找异常数据，如应用于$3\sigma$准则</p><p>例如求各车价格的百分位数<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">  "size": 0,</span><br><span class="line">  "aggs": &#123;</span><br><span class="line">    "percentile": &#123;</span><br><span class="line">      "percentiles": &#123;</span><br><span class="line">        "field": "price",</span><br><span class="line">        "percents": [</span><br><span class="line">          1, 5, 25, 50, 75, 95, 99</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="elasticsearch-py"><a href="#elasticsearch-py" class="headerlink" title="elasticsearch-py"></a>elasticsearch-py</h1><blockquote><p><a href="https://elasticsearch-py.readthedocs.io/en/master/#" target="_blank" rel="noopener">Docs » Python Elasticsearch Client - Elasticsearch</a></p></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># See more at https://elasticsearch-py.readthedocs.io/en/master/api.html#elasticsearch</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一些数据</span></span><br><span class="line">INDEX, TYPE = <span class="string">"cars"</span>, <span class="string">"transactions"</span></span><br><span class="line">TABLE = [</span><br><span class="line">    &#123; <span class="string">"price"</span> : <span class="number">10000</span>, <span class="string">"color"</span> : <span class="string">"red"</span>, <span class="string">"make"</span> : <span class="string">"honda"</span>, <span class="string">"sold"</span> : <span class="string">"2014-10-28"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"price"</span> : <span class="number">20000</span>, <span class="string">"color"</span> : <span class="string">"red"</span>, <span class="string">"make"</span> : <span class="string">"honda"</span>, <span class="string">"sold"</span> : <span class="string">"2014-11-05"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"price"</span> : <span class="number">30000</span>, <span class="string">"color"</span> : <span class="string">"green"</span>, <span class="string">"make"</span> : <span class="string">"ford"</span>, <span class="string">"sold"</span> : <span class="string">"2014-05-18"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"price"</span> : <span class="number">15000</span>, <span class="string">"color"</span> : <span class="string">"blue"</span>, <span class="string">"make"</span> : <span class="string">"toyota"</span>, <span class="string">"sold"</span> : <span class="string">"2014-07-02"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"price"</span> : <span class="number">12000</span>, <span class="string">"color"</span> : <span class="string">"green"</span>, <span class="string">"make"</span> : <span class="string">"toyota"</span>, <span class="string">"sold"</span> : <span class="string">"2014-08-19"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"price"</span> : <span class="number">20000</span>, <span class="string">"color"</span> : <span class="string">"red"</span>, <span class="string">"make"</span> : <span class="string">"honda"</span>, <span class="string">"sold"</span> : <span class="string">"2014-11-05"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"price"</span> : <span class="number">80000</span>, <span class="string">"color"</span> : <span class="string">"red"</span>, <span class="string">"make"</span> : <span class="string">"bmw"</span>, <span class="string">"sold"</span> : <span class="string">"2014-01-01"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"price"</span> : <span class="number">25000</span>, <span class="string">"color"</span> : <span class="string">"blue"</span>, <span class="string">"make"</span> : <span class="string">"ford"</span>, <span class="string">"sold"</span> : <span class="string">"2014-02-12"</span> &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建ES对象</span></span><br><span class="line"><span class="keyword">from</span> elasticsearch6 <span class="keyword">import</span> Elasticsearch</span><br><span class="line">es = Elasticsearch([<span class="string">"localhost:9200"</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单条记录插入</span></span><br><span class="line">es.index(index=INDEX, doc_type=TYPE, id=<span class="string">"0"</span>, body=TABLE[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定文档查找</span></span><br><span class="line">es.get(index=INDEX, doc_type=TYPE, id=<span class="string">"0"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定文档更新</span></span><br><span class="line">body = &#123;</span><br><span class="line">    <span class="string">"doc"</span>:&#123;</span><br><span class="line">        <span class="string">"price"</span>: <span class="number">15000</span>,</span><br><span class="line">        <span class="string">"color"</span>: <span class="string">"green"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">es.update(index=INDEX, doc_type=TYPE, id=<span class="string">"0"</span>, body=body)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单条记录删除</span></span><br><span class="line">es.delete(index=INDEX, doc_type=TYPE, id=<span class="string">"0"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 索引批量数据，注意bulk输入格式</span></span><br><span class="line">body = []</span><br><span class="line"><span class="keyword">for</span> i, doc <span class="keyword">in</span> enumerate(TABLE):</span><br><span class="line">    option = &#123;</span><br><span class="line">        <span class="string">"index"</span>: &#123;</span><br><span class="line">            <span class="string">"_index"</span>: INDEX, <span class="string">"_type"</span>: TYPE, <span class="string">"_id"</span>: str(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    body += [option, doc]</span><br><span class="line">print(body)</span><br><span class="line">es.bulk(index=INDEX, doc_type=TYPE, body=body)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询，例如：</span></span><br><span class="line"><span class="comment"># 查找所有红色车中，车辆价格在15000以上，下半年售出的车最佳</span></span><br><span class="line">body = &#123;</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"bool"</span>: &#123;</span><br><span class="line">      <span class="string">"must"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"term"</span>: &#123;</span><br><span class="line">            <span class="string">"color"</span>: &#123;</span><br><span class="line">              <span class="string">"value"</span>: <span class="string">"red"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"range"</span>: &#123;</span><br><span class="line">            <span class="string">"price"</span>: &#123;</span><br><span class="line">              <span class="string">"gte"</span>: <span class="number">15000</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="string">"should"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"range"</span>: &#123;</span><br><span class="line">            <span class="string">"sold"</span>: &#123;</span><br><span class="line">              <span class="string">"from"</span>: <span class="string">"2014-07-01"</span>,</span><br><span class="line">              <span class="string">"to"</span>: <span class="string">"2014-12-31"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">es.search(index=INDEX, doc_type=TYPE, body=body)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 聚合，例如：</span></span><br><span class="line"><span class="comment"># 按颜色分桶，计算每种颜色平均价格，统计每种颜色的制造厂商及其各颜色售价的最大、最小值</span></span><br><span class="line">body = &#123;</span><br><span class="line">  <span class="string">"size"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">"aggs"</span>: &#123;</span><br><span class="line">    <span class="string">"popular_colors"</span>: &#123;</span><br><span class="line">      <span class="string">"terms"</span>: &#123;</span><br><span class="line">        <span class="string">"field"</span>: <span class="string">"color.keyword"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">"aggs"</span>: &#123;</span><br><span class="line">        <span class="string">"average_price_of_color"</span>: &#123;</span><br><span class="line">          <span class="string">"avg"</span>: &#123;</span><br><span class="line">            <span class="string">"field"</span>: <span class="string">"price"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"the_maker_of_the_car_of_this_color"</span>: &#123;</span><br><span class="line">          <span class="string">"terms"</span>: &#123;</span><br><span class="line">            <span class="string">"field"</span>: <span class="string">"make.keyword"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">"aggs"</span>: &#123;</span><br><span class="line">            <span class="string">"minimal_price_of_this_color_of_this_maker"</span>: &#123;</span><br><span class="line">              <span class="string">"min"</span>: &#123;</span><br><span class="line">                <span class="string">"field"</span>: <span class="string">"price"</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"maximal_price_of_this_color_of_this_maker"</span>: &#123;</span><br><span class="line">              <span class="string">"max"</span>: &#123;</span><br><span class="line">                <span class="string">"field"</span>: <span class="string">"price"</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">es.search(index=INDEX, doc_type=TYPE, body=body)</span><br></pre></td></tr></table></figure><!-- # 使用案例> [Kibana 用户手册 » 基础入门 » 加载示例数据](https://www.elastic.co/guide/cn/kibana/current/tutorial-load-dataset.html)以[shakespeare.json](https://download.elastic.co/demos/kibana/gettingstarted/shakespeare_6.0.json)为数据，对其进行索引、查询等操作，各文档数据组织方式为``` json{    "line_id": INT,    "play_name": "String",    "speech_number": INT,    "line_number": "String",    "speaker": "String",    "text_entry": "String",}``` -->]]></content>
      
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】排序</title>
      <link href="/2020/02/13/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/02/13/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#%e7%9b%ae%e5%bd%95">目录</a></li><li><a href="#%e5%89%8d%e8%a8%80">前言</a></li><li><a href="#%e5%9f%ba%e4%ba%8e%e5%88%86%e9%85%8d%e7%9a%84%e6%8e%92%e5%ba%8f">基于分配的排序</a><ul><li><a href="#%e8%ae%a1%e6%95%b0%e7%ae%b1%e5%ad%90%e6%8e%92%e5%ba%8f">计数/箱子排序</a></li><li><a href="#%e6%a1%b6%e6%8e%92%e5%ba%8f">桶排序</a></li><li><a href="#%e5%9f%ba%e6%95%b0%e6%8e%92%e5%ba%8f">基数排序</a></li></ul></li><li><a href="#%e5%9f%ba%e4%ba%8e%e4%ba%a4%e6%8d%a2%e7%9a%84%e6%8e%92%e5%ba%8f">基于交换的排序</a><ul><li><a href="#%e5%86%92%e6%b3%a1%e6%8e%92%e5%ba%8f">冒泡排序</a></li><li><a href="#%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f">快速排序</a><ul><li><a href="#%e6%95%b0%e7%bb%84%e5%ae%9e%e7%8e%b0">数组实现</a></li><li><a href="#%e9%93%be%e8%a1%a8%e5%ae%9e%e7%8e%b0">链表实现</a></li></ul></li></ul></li><li><a href="#%e5%9f%ba%e4%ba%8e%e9%80%89%e6%8b%a9%e7%9a%84%e6%8e%92%e5%ba%8f">基于选择的排序</a><ul><li><a href="#%e7%ae%80%e5%8d%95%e9%80%89%e6%8b%a9%e6%8e%92%e5%ba%8f">简单选择排序</a></li><li><a href="#%e5%a0%86%e6%8e%92%e5%ba%8f">堆排序</a></li></ul></li><li><a href="#%e5%9f%ba%e4%ba%8e%e6%8f%92%e5%85%a5%e7%9a%84%e6%8e%92%e5%ba%8f">基于插入的排序</a><ul><li><a href="#%e7%9b%b4%e6%8e%a5%e6%8f%92%e5%85%a5%e6%8e%92%e5%ba%8f">直接插入排序</a></li><li><a href="#%e5%b8%8c%e5%b0%94%e6%8e%92%e5%ba%8f">希尔排序</a></li></ul></li><li><a href="#%e5%9f%ba%e4%ba%8e%e5%bd%92%e5%b9%b6%e7%9a%84%e6%8e%92%e5%ba%8f">基于归并的排序</a><ul><li><a href="#%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f">归并排序</a><ul><li><a href="#%e6%95%b0%e7%bb%84%e5%ae%9e%e7%8e%b0-1">数组实现</a></li><li><a href="#%e9%93%be%e8%a1%a8%e5%ae%9e%e7%8e%b0-1">链表实现</a></li></ul></li></ul></li><li><a href="#%e6%80%a7%e8%83%bd%e5%af%b9%e6%af%94">性能对比</a></li><li><a href="#reference">Reference</a></li></ul><p>注：基于交换、选择、插入、归并的排序都是基于交换的排序。</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>排序算法的实际意义，除排序外，还可以拓展应用到<a href="https://www.lintcode.com/problem/?tag=sort" target="_blank" rel="noopener">其他问题</a>的解决中，如：</p><ol><li>利用<a href="#%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f">快速排序</a>对数组进行分区，使数组前半与后半元素满足不同性质(如奇偶性)；</li><li>利用<a href="#%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f">快速排序</a>查找<a href="https://www.lintcode.com/problem/kth-largest-element" target="_blank" rel="noopener">第$k$大元素</a>、<a href="https://www.lintcode.com/problem/median/" target="_blank" rel="noopener">中位数</a>；</li><li>利用<a href="#%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f">归并排序</a>寻找数组中的<a href="https://www.lintcode.com/problem/reverse-pairs" target="_blank" rel="noopener">逆序对</a>；</li><li>利用<a href="#%e6%a1%b6%e6%8e%92%e5%ba%8f">桶排序</a>求取数组中<a href="https://www.lintcode.com/problem/maximum-gap/description" target="_blank" rel="noopener">最大间距</a>；</li><li>……</li></ol><h1 id="基于分配的排序"><a href="#基于分配的排序" class="headerlink" title="基于分配的排序"></a>基于分配的排序</h1><h2 id="计数-箱子排序"><a href="#计数-箱子排序" class="headerlink" title="计数/箱子排序"></a>计数/箱子排序</h2><p>箱子排序类似<strong>借助哈希表计数</strong>的方法，对数组内<strong>各元素</strong>进行计数存放在“箱子”中，然后从“箱子”收集元素形成有序数组。当待排序数组中数据范围较小时可考虑使用该方法</p><blockquote><p>数据范围较大时，空间复杂度高且利用率可能较低，可借助哈希表。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binSort</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums.size() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 寻找最小最大元素</span></span><br><span class="line">T minVal = *<span class="built_in">std</span>::min_element(nums.begin(), nums.end());</span><br><span class="line">T maxVal = *<span class="built_in">std</span>::max_element(nums.begin(), nums.end());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构筑“箱子”，时间O(n)，空间O(k)</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; bins(maxVal - minVal + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">bins[nums[i] - minVal]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收集元素，时间O(k)</span></span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bins.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (bins[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bins[i]; j++) &#123;</span><br><span class="line">nums[k++] = i + minVal;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>类似计数/箱子排序，不同之处是，每个桶(“箱子”)内<strong>存放一定范围的数</strong>，每个桶对应一个数字区间(桶间区间无重复且连续)以降低时间复杂度，并保证桶内数组有序，那么就有两个关键点：</p><ol><li>元素值域的划分，即元素到桶的映射规则；</li><li>桶内元素的排序，使用其他排序。</li></ol><p>桶排序作为排序算法不是特别实用，更为突出的是一种<strong>算法设计方法</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.size() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 寻找最小最大元素</span></span><br><span class="line">    T minVal = *<span class="built_in">std</span>::min_element(nums.begin(), nums.end());</span><br><span class="line">    T maxVal = *<span class="built_in">std</span>::max_element(nums.begin(), nums.end());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构筑“桶”，间隔为`10`</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; &gt; bins((maxVal - minVal) / <span class="number">10</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="comment">// 映射</span></span><br><span class="line">        <span class="keyword">int</span> index = (nums[i] - minVal) / <span class="number">10</span>;</span><br><span class="line">        bins[index].push_back(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 桶内排序，并取出</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bins.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">std</span>::sort(bins[i].begin(), bins[i].end());</span><br><span class="line">        <span class="keyword">while</span> (!bins[i].empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = bins[i].begin();</span><br><span class="line">            nums[k++] = *it;</span><br><span class="line">            bins[i].erase(it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序也借助桶进行排序，只保留$10$个桶，存放$0 \sim 9$内的数字。对数组进行排序时，<strong>自个位开始向高位</strong>每位进行排序。注意基数排序为<strong>稳定排序</strong>，因此高位进行排序时，可以保证之前低位排序的数字顺序不改变。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">digit</span><span class="params">(T num, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> base = (<span class="keyword">int</span>)<span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="number">10</span>, d);</span><br><span class="line">    <span class="keyword">return</span> num / base % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.size() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 构筑“桶”</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; &gt; bins(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">0</span>;<span class="comment">// 位标</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据第`d`位，将数字放入桶</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = digit(nums[i], d);</span><br><span class="line">            bins[index].push_back(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数字排序完毕</span></span><br><span class="line">        <span class="keyword">if</span> (bins[<span class="number">0</span>].size() == nums.size()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从桶中收集数字</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bins.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 每个桶有序取出</span></span><br><span class="line">            <span class="keyword">while</span> (!bins[i].empty()) &#123;</span><br><span class="line">                <span class="keyword">auto</span> it = bins[i].begin();  <span class="comment">// 首元素</span></span><br><span class="line">                nums[k++] = *it;            <span class="comment">// 存放到数组</span></span><br><span class="line">                bins[i].erase(it);          <span class="comment">// 删除</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        d++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="基于交换的排序"><a href="#基于交换的排序" class="headerlink" title="基于交换的排序"></a>基于交换的排序</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序是由一系列<strong>冒泡操作</strong>组成的，元素比较和移动发生在<strong>相邻元素</strong>间。一次冒泡结束后，未排序部分中的<strong>最大元素被移动到数组最右端</strong>，然后对小于该元素的部分，<strong>重复冒泡操作</strong>直至排序完成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(T a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">nullptr</span> || n &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当n-1个数排序后，最后一个数也排序完毕，故进行n-1次循环即可</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 一次冒泡操作，将最大数存储至索引为`i`处</span></span><br><span class="line">        <span class="keyword">bool</span> moved = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                T temp = a[j]; </span><br><span class="line">                a[j] = a[j + <span class="number">1</span>]; </span><br><span class="line">                a[j + <span class="number">1</span>] = temp;</span><br><span class="line"></span><br><span class="line">                moved = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!moved) <span class="keyword">break</span>;<span class="comment">// 本次冒泡中无元素移动，提前结束</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是一种<strong>分治策略</strong>的排序算法。对$n$个数进行排序时</p><ol><li>选择某个数(如最左端的数)为<strong>支点</strong>(pivot)；</li><li>从左至右搜索大于支点的元素，再从右至左搜索小于支点的元素，将上述两个元素交换；</li><li>重复2直至两端元素满足<strong>一端全部小于支点，一端全部大于支点</strong>；</li><li>将支点移动到两端元素中间，并分别对左右两端<strong>递归排序</strong>。</li></ol><p>在最坏情况下，<code>left</code>总是等于<code>begin</code>，此时快速排序用时$\Theta(n^2)$；而最好情况下，<code>left</code>在<code>(begin + end) / 2</code>处，这时复杂度为$\Theta (n \log n)$；平均性能下，时间复杂度也为$\Theta(n \log n)$。</p><p>在某次partition完成后，优先处理较短序列可以减少程序的<strong>递归深度</strong>(系统栈保存的深度)，如果按长的递归优先的话，那么短的递归会一直保存在栈中，直到长的处理完。短的优先的话，长的递归调用没有进行，他是作为一个整体保存在栈中的，所以递归栈中的保留的递归数据少一些。但是<strong>栈深度</strong>(函数调用深度)与是否先处理短序列无关。</p><p>partition有三种实现方式：</p><ol><li><p>利用左右双指针，左指针从pivot之后第1个元素开始，从左至右查找比pivot大的元素，右指针从最后一个元素开始从右至左查找比pivot小的元素，两者进行交换，循环直至指针相遇，然后将pivot放置到合适位置(左指针附近)；</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">47 31 83 91 57 18 96 16</span><br><span class="line"> p  i                 j     初始化</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">47 31 83 91 57 18 96 16</span><br><span class="line"> p  i                 j     i &lt; j 交换元素</span><br><span class="line">-----------------------</span><br><span class="line">47 16 83 91 57 18 96 31</span><br><span class="line"> p     i        j           i &lt; j 交换元素</span><br><span class="line">-----------------------</span><br><span class="line">47 16 18 91 57 83 96 31</span><br><span class="line"> p     j  i                 i &gt; j 终止循环</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">18 16 47 91 57 83 96 31</span><br><span class="line">       p                    移动pivot到i-1</span><br><span class="line">-----------------------</span><br></pre></td></tr></table></figure> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(T a[], <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">nullptr</span> || begin &gt;= end) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前子数组的头元素视作支点</span></span><br><span class="line">    T pivot = a[begin];</span><br><span class="line">    <span class="comment">// 左右索引</span></span><br><span class="line">    <span class="keyword">int</span> left = begin, right = end - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 搜索从左至右大于支点的元素a[left]</span></span><br><span class="line">        <span class="keyword">while</span> (a[left] &lt;= pivot &amp;&amp; left &lt; end) left++;</span><br><span class="line">        <span class="comment">// 搜索从右至左小于支点的元素a[right]</span></span><br><span class="line">        <span class="keyword">while</span> (a[right] &gt;= pivot &amp;&amp; right &gt; begin) right--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换a[left]与a[right]</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            T temp = a[left];</span><br><span class="line">            a[left] = a[right];</span><br><span class="line">            a[right] = temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时索引为`begin + 1 ~ left - 1`的数都小于支点，索引为`left ~ end - 1`的数都大于支点；</span></span><br><span class="line">    <span class="comment">// 将支点调整至left - 1处，使支点左侧元素都小于支点，右侧都大于支点</span></span><br><span class="line">    a[begin] = a[left - <span class="number">1</span>];</span><br><span class="line">    a[left - <span class="number">1</span>] = pivot;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>利用快慢指针，快指针从左到右查找不大于pivot的元素，将慢指针向前移动一步后交换两个元素，循环直至快指针遍历整个数组，再将pivot移动至合适位置(慢指针附近)；</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">47 31 83 91 57 18 96 16</span><br><span class="line">p&#x2F;i,j                       </span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">47 31 83 91 57 18 96 16</span><br><span class="line">p&#x2F;i             j           快指针查找找不大于pivot的元素                       </span><br><span class="line">47 18 83 91 57 31 96 16</span><br><span class="line"> p  i           j           慢指针向前一步，交换</span><br><span class="line">-----------------------</span><br><span class="line">47 18 83 91 57 31 96 16</span><br><span class="line"> p  i           j           快指针查找找不大于pivot的元</span><br><span class="line">47 18 31 91 57 83 96 16</span><br><span class="line"> p     i        j           慢指针向前一步，交换</span><br><span class="line">-----------------------</span><br><span class="line">47 18 31 91 57 83 96 16</span><br><span class="line"> p     i              j     快指针查找找不大于pivot的元</span><br><span class="line">47 18 31 16 57 83 96 91</span><br><span class="line"> p        i           j     慢指针向前一步，交换</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">16 18 31 47 57 83 96 91</span><br><span class="line">          p                 移动pivot到i</span><br></pre></td></tr></table></figure> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition2</span><span class="params">(T a[], <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">nullptr</span> || begin &gt;= end) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前子数组的头元素视作支点</span></span><br><span class="line">    T pivot = a[begin];</span><br><span class="line">    <span class="comment">// 快慢指针</span></span><br><span class="line">    <span class="keyword">int</span> slow = begin, fast = begin;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 先走一步</span></span><br><span class="line">        fast++;</span><br><span class="line">        <span class="keyword">if</span> (fast == end) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快指针不停的走，直到值遇到不大于支点的节点</span></span><br><span class="line">        <span class="keyword">if</span> (a[fast] &lt;= pivot) &#123;</span><br><span class="line">            <span class="comment">// 慢指针跟上一步</span></span><br><span class="line">            slow++;</span><br><span class="line">            <span class="comment">// 交换</span></span><br><span class="line">            T temp = a[slow];</span><br><span class="line">            a[slow] = a[fast];</span><br><span class="line">            a[fast] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 支点放置到合适位置</span></span><br><span class="line">    a[begin] = a[slow];</span><br><span class="line">    a[slow] = pivot;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>也利用左右双指针，首先初始化左指针、右指针为数组头尾，注意此时左指针元素即pivot。首先右指针从右至左查找找大于pivot的元素，将其与左指针元素交换，那么此时右指针元素即pivot，然后左指针从pivot开始，从左至右查找小于pivot的元素(包括pivot)，循环直至两指针相遇，判断是左指针超限或右指针超限以确定pivot当前位置索引。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">47 31 83 91 57 18 96 16</span><br><span class="line">p&#x2F;i                   j     初始化</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">47 31 83 91 57 18 96 16</span><br><span class="line">p&#x2F;i                   j     右指针从右至左查找找大于pivot的元素</span><br><span class="line">16 31 83 91 57 18 96 47</span><br><span class="line"> i                   p&#x2F;j    与左指针元素交换</span><br><span class="line">-----------------------</span><br><span class="line">16 31 83 91 57 18 96 47</span><br><span class="line">       i             p&#x2F;j    左指针从左至右查找小于pivot的元素</span><br><span class="line">16 31 47 91 57 18 96 83</span><br><span class="line">      p&#x2F;i             j     与右指针元素交换</span><br><span class="line">-----------------------</span><br><span class="line">16 31 47 91 57 18 96 83</span><br><span class="line">      p&#x2F;i       j           右指针从右至左查找找大于pivot的元素</span><br><span class="line">16 31 18 91 57 47 96 83</span><br><span class="line">       i       p&#x2F;j          与左指针元素交换</span><br><span class="line">-----------------------</span><br><span class="line">16 31 18 91 57 47 96 83</span><br><span class="line">          i    p&#x2F;j          左指针从左至右查找小于pivot的元素</span><br><span class="line">16 31 18 47 57 91 96 83</span><br><span class="line">         p&#x2F;i    j           与右指针元素交换</span><br><span class="line">-----------------------</span><br><span class="line">16 31 18 47 57 91 96 83</span><br><span class="line">       j p&#x2F;i                右指针从右至左查找比pivot小的元素，结束循环</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">16 31 18 47 57 91 96 83</span><br><span class="line">          p                 移动pivot已在合适位置处</span><br></pre></td></tr></table></figure> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition3</span><span class="params">(T a[], <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">nullptr</span> || begin &gt;= end) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前子数组的头元素视作支点</span></span><br><span class="line">    T pivot = a[begin];</span><br><span class="line">    <span class="comment">// 左右指针</span></span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;<span class="comment">// 指针移动标志</span></span><br><span class="line">    <span class="keyword">int</span> left = begin, right = end - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 指针顺序查找</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="comment">// 从右到左查找小于pivot的元素</span></span><br><span class="line">            <span class="keyword">while</span> (right &gt;= <span class="number">0</span> &amp;&amp; a[right] &gt;= pivot) right--;</span><br><span class="line">            <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span> left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 从左到右查找大于pivot的元素</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; end &amp;&amp; a[left] &lt;= pivot) left++;</span><br><span class="line">            <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换元素</span></span><br><span class="line">        T temp = a[left];</span><br><span class="line">        a[left] = a[right];</span><br><span class="line">        a[right] = temp;</span><br><span class="line">        <span class="comment">// 交换方向</span></span><br><span class="line">        flag = !flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(T a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">nullptr</span> || n &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    quickSort(a, <span class="number">0</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(T a[], <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span><span class="comment">// a[begin] ~ a[end - 1]</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">nullptr</span> || begin &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (end - begin &lt; <span class="number">2</span>) <span class="keyword">return</span>;    <span class="comment">// 终止条件：仅包含1个数，无需排序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pivot = partition(a, begin, end);   <span class="comment">// 任意一种均可</span></span><br><span class="line">    <span class="keyword">if</span> (pivot == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 划分子数组，递归</span></span><br><span class="line">    quickSort(a, begin, pivot);</span><br><span class="line">    quickSort(a, pivot + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/13/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F/【算法】排序/quicksort.jpg" alt="quicksort"></p><h3 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h3><p>链表的快排算法如下，大部分同数组快排无异，主要是分区函数。这里用节点地址判断是否到达子链表终点<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    quicksortList(head, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksortList</span><span class="params">(ListNode* start, ListNode* end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start == end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 分区</span></span><br><span class="line">    ListNode* pivot = partition(start, end);</span><br><span class="line">    <span class="comment">// 左右两侧递归</span></span><br><span class="line">    quicksortList(start, pivot);</span><br><span class="line">    quicksortList(pivot-&gt;next, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于<strong>单向链表无法获取父节点信息，故借助快慢指针</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* start, ListNode* end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 支点</span></span><br><span class="line">    <span class="keyword">int</span> pivot = start-&gt;val;</span><br><span class="line">    <span class="comment">// 借助快慢指针，将数据分区</span></span><br><span class="line">    ListNode* slow = start; <span class="comment">// `slow`左侧(包含slow)的数据均小于等于`pivot`</span></span><br><span class="line">    ListNode* fast = start; <span class="comment">// `fast`的数据待判断</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整数据位置</span></span><br><span class="line">    <span class="keyword">while</span> (fast != end) &#123;</span><br><span class="line">        <span class="comment">// 先走一步</span></span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">nullptr</span>) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 快指针不停的走，直到值遇到不大于支点的节点</span></span><br><span class="line">        <span class="keyword">if</span> (fast-&gt;val &lt;= pivot) &#123;</span><br><span class="line">            <span class="comment">// 赶紧跟上</span></span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 交换</span></span><br><span class="line">            <span class="keyword">int</span> temp = slow-&gt;val;</span><br><span class="line">            slow-&gt;val = fast-&gt;val;</span><br><span class="line">            fast-&gt;val = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 支点放置到合适位置</span></span><br><span class="line">    start-&gt;val = slow-&gt;val;</span><br><span class="line">    slow-&gt;val = pivot;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 慢指针即支点位置</span></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="基于选择的排序"><a href="#基于选择的排序" class="headerlink" title="基于选择的排序"></a>基于选择的排序</h1><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><p>选择排序是一种简单直观的排序算法。它的基本算法描述是：</p><ol><li>从待排序的数据元素中选出最大的元素，存放在<strong>数组的末尾</strong>；</li><li>再从剩余的未排序元素中寻找到最大元素，然后放到<strong>已排序的序列的前端</strong>；</li><li>重复2直至排序完成。</li></ol><p>交换次数比冒泡排序少，由于交换所需CPU时间比比较所需的CPU时间多，$n$较小时，选择排序比冒泡排序快。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(T a[], <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">nullptr</span> || n &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当n-1个数排序后，最后一个数也排序完毕，故进行n-1次循环即可</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将索引为i的数与索引为0 ~ i-1的数进行比较，找到最大</span></span><br><span class="line">        <span class="keyword">int</span> index = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[index]) index = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换</span></span><br><span class="line">        T temp = a[i]; a[i] = a[index]; a[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序是利用<strong>堆</strong>设计的排序算法，是一种选择排序，不稳定，最坏，最好，平均时间复杂度均为$O(n\log n)$，堆排序的基本算法描述是：</p><ol><li>将输入数组初始化为大根堆(<strong>完全二叉树的数组描述</strong>)：从最后一个非叶子节点开始调整，若该节点元素小于孩子节点元素，则交换位置并对该孩子节点<strong>递归调整</strong>；</li><li>将大根堆堆顶元素与数组的末尾元素交换，末尾元素加入堆顶<strong>递归调整</strong>，维护<strong>剩余元素组成的堆</strong>结构；</li><li>重复2直至排序完成。</li></ol><p>建堆时间复杂度是$O(n)$，插入/删除一个元素的时间复杂度是$O(\log n)$，所以堆排序时间复杂度是$O(n \log n)$。</p><blockquote><p>关于优先级队列的时间复杂度，可查看<a href="https://louishsu.xyz/2020/03/03/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/" target="_blank" rel="noopener">【数据结构】优先级队列</a>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(T a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">nullptr</span> || n &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化最大堆(需从最后一个节点开始)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; adjust(a, n, i--));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当n-1个数排序后，最后一个数也排序完毕，故进行n-1次循环即可</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 堆顶元素依次出堆，与末尾元素交换</span></span><br><span class="line">        T temp = a[i]; a[i] = a[<span class="number">0</span>]; a[<span class="number">0</span>] = temp;</span><br><span class="line">        <span class="comment">// 调整堆顶元素位置</span></span><br><span class="line">        adjust(a, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">(T a[], <span class="keyword">int</span> n, <span class="keyword">int</span> index)</span><span class="comment">// 调整元素a[index]在最大堆中的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">nullptr</span> || n &lt;= <span class="number">0</span> || index &lt; <span class="number">0</span> || index &gt;= n) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断元素与左右子节点元素的值大小关系，若不满足最大堆则递归调整位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt;= <span class="number">2</span>; c++) &#123;</span><br><span class="line">        <span class="keyword">int</span> child = <span class="number">2</span> * index + c;<span class="comment">// 左、右子节点的索引</span></span><br><span class="line">        <span class="keyword">if</span> (child &gt;= n) <span class="keyword">return</span>;<span class="comment">// 无子节点，无需调整</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a[index] &lt; a[child]) &#123;<span class="comment">// 该节点不满足最大堆，进行“上浮”调整</span></span><br><span class="line">            T temp = a[index]; a[index] = a[child]; a[child] = temp;</span><br><span class="line">            adjust(a, n, child);<span class="comment">// 继续调整直至叶子节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借助STL标准库，上述代码可进行简化<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums.size() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="comment">// 剩余元素构筑最大堆</span></span><br><span class="line"><span class="built_in">std</span>::make_heap(nums.begin(), nums.begin() + i + <span class="number">1</span>, <span class="built_in">std</span>::less&lt;T&gt;());</span><br><span class="line"><span class="comment">// 将堆顶元素放置到末尾</span></span><br><span class="line"><span class="built_in">std</span>::pop_heap(nums.begin(), nums.begin() + i + <span class="number">1</span>, <span class="built_in">std</span>::less&lt;T&gt;());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="基于插入的排序"><a href="#基于插入的排序" class="headerlink" title="基于插入的排序"></a>基于插入的排序</h1><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>直接插入排序的算法描述如下</p><ol><li>对第$i(i &gt; 0)$个数进行排序时，前$0, \cdots, i - 1$的数字已排序；</li><li>在已排序数组中顺序查找(也可改进为二分折半查找)合适的插入位置，将该数字放入，并将该位置后的数字向后挪动；</li><li>重复上述操作直至所有数字排序完成。</li></ol><p>直接插入排序在<strong>小规模数据</strong>时效率较高，且<strong>对越有序的数组，排序效率越高</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.size() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = nums[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在`0, ..., i - 1`中寻找合适的插入位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="comment">// `j`处大于`num`，为插入位置</span></span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; num) &#123;</span><br><span class="line">                <span class="comment">// 从后向前挪动</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &gt; j; k--) &#123;</span><br><span class="line">                    nums[k] = nums[k - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 存放`num`在`j`处</span></span><br><span class="line">                nums[j] = num;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序又称<strong>递减增量排序</strong>，是对直接选择排序的改进，使其对大规模数据或无序数组排序也高效。</p><p>注意到直接插入排序在<strong>几乎有序的数组</strong>中排序效率较高，希尔排序通过<strong>分组</strong>的策略，先从<strong>数据规模较小</strong>的分组开始排序，并且保证在某次分组选择排序时，数组经过前几次的分组选择排序<strong>已部分有序</strong>。</p><p>算法描述如下</p><ol><li>定义<strong>递减</strong>的<strong>增量排序序列</strong>${g_1, g_2, \cdots, g_K}$，其中$g_K = 1$；</li><li>在第$k$次排序中，以$g_k$位<strong>间隔</strong>取出待排序数组中的数，进行<strong>分组</strong>(共$g_k$组)以减少数据规模，对每个组进行<strong>选择排序</strong>；</li><li>在第$k + 1$次排序时，数组部分有序，减少数据复制次数，提升选择排序的效率；</li><li>不断循环直至排序完成。</li></ol><p>希尔排序的时间复杂度分析困难，与<strong>增量排序序列</strong>定义有关，下界是$O(nlogn)$，可以定义为：</p><ul><li>希尔增量：${n / 2, n / 4, \cdots, 4, 2, 1}$，时间复杂度最坏为$O(n^2)$；</li><li>Hibbard增量：${2^k - 1, \cdots, 7, 3, 1}$，时间复杂度(最坏情形)为$O(n^{1.5})$；</li><li>Sedgewick增量：${9 \times 4^k - 9 \times 2^i + 1或4^i - 3 \times 2^i + 1, \cdots, 41, 19, 5, 1}$，时间复杂度(最坏情形)为$O(n^{1.3})$；</li><li>…</li></ul><p><img src="/2020/02/13/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F/【算法】排序/shellSort.gif" alt="shellSort"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.size() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 希尔增量：`&#123;n/2, n/4, ..., 4, 2, 1&#125;`</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gk = nums.size() / <span class="number">2</span>; gk &gt; <span class="number">0</span>; gk /= <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 划分为`gk`个组，每组`n/2-1 ~ n/2`个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; gk; k++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对分组数据`nums[k], nums[k + gk], nums[k + 2 * gk]... `进行选择排序</span></span><br><span class="line">            shellInsertSort(nums, k, gk);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellInsertSort</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&amp; nums, <span class="keyword">int</span> group, <span class="keyword">int</span> gk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = group; i &lt; nums.size(); i += gk) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = nums[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在`group, group + gk, group + 2 * gk, ...`中寻找合适的插入位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = group; j &lt; i; j += gk) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// `j`处大于`num`，为插入位置</span></span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; num) &#123;</span><br><span class="line">                <span class="comment">// 从后向前挪动</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &gt; j; k -= gk) &#123;</span><br><span class="line">                    nums[k] = nums[k - gk];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 存放`num`在`j`处</span></span><br><span class="line">                nums[j] = num;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="基于归并的排序"><a href="#基于归并的排序" class="headerlink" title="基于归并的排序"></a>基于归并的排序</h1><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序是一种分治策略的排序算法，将$n$个数进行<strong>二路划分</strong>，对每个子集合进行排(如插入、冒泡等)，再依次组合归并有序集合得到整个有序集合，可以看作是别的排序算法的递归实现。注意到将两个子集合归并时，两子集和已有序，故实际上无需采用其余排序算法。</p><h3 id="数组实现-1"><a href="#数组实现-1" class="headerlink" title="数组实现"></a>数组实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(T a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">nullptr</span> || n &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    mergeSort(a, <span class="number">0</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对`a[begin: end]`进行排序</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(T a[], <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">nullptr</span> || begin &lt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (end - begin &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分治</span></span><br><span class="line">    <span class="keyword">int</span> middle = (begin + end) / <span class="number">2</span>;</span><br><span class="line">    mergeSort(a, begin, middle);</span><br><span class="line">    mergeSort(a, middle, end);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并</span></span><br><span class="line">    merge(a, begin, middle, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并`a[begin: middle]`与`a[middle: end]`</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(T a[], <span class="keyword">int</span> begin, <span class="keyword">int</span> middle, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">nullptr</span> || begin &gt; middle || middle &gt; end) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空间复杂度O(n)、时间复杂度O(n)</span></span><br><span class="line">    <span class="keyword">int</span> n = end - middle;</span><br><span class="line">    T* b = <span class="keyword">new</span> T[n];</span><br><span class="line">    <span class="built_in">memcpy</span>(b, a + middle, n * <span class="keyword">sizeof</span>(T));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 三个指针</span></span><br><span class="line">    T* ptr = a + end - <span class="number">1</span>;       <span class="comment">// 目标存放区域的末尾</span></span><br><span class="line">    T* ptr1 = a + middle - <span class="number">1</span>;   <span class="comment">// 数组1的末尾</span></span><br><span class="line">    T* ptr2 = b + n - <span class="number">1</span>;        <span class="comment">// 数组2的末尾</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从后往前覆盖a的值</span></span><br><span class="line">    <span class="keyword">while</span> (ptr &gt;= a + begin) &#123;</span><br><span class="line"></span><br><span class="line">        T* p = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 有一个数组已经到达末尾</span></span><br><span class="line">        <span class="keyword">if</span> (ptr1 &lt; a + begin) &#123;</span><br><span class="line">            p = ptr2; ptr2--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ptr2 &lt; b) &#123;</span><br><span class="line">            p = ptr1; ptr1--;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 从两个有序数组中选择较大的数</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (*ptr1 &gt; * ptr2) &#123;</span><br><span class="line">                p = ptr1; ptr1--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p = ptr2; ptr2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存放数据</span></span><br><span class="line">        *ptr = *p;</span><br><span class="line">        ptr--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> [] b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表实现-1"><a href="#链表实现-1" class="headerlink" title="链表实现"></a>链表实现</h3><p>链表的归并排序如下，比较关键的是将链表划分与合并，总体框架如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergesortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 划分链表</span></span><br><span class="line">    ListNode* mid = binarySplitList(head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归终止：只有一个或两个节点</span></span><br><span class="line">    <span class="keyword">if</span> (head == mid) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;next &amp;&amp; head-&gt;val &gt; head-&gt;next-&gt;val) &#123;</span><br><span class="line">            <span class="comment">// 交换</span></span><br><span class="line">            head-&gt;val ^= head-&gt;next-&gt;val;</span><br><span class="line">            head-&gt;next-&gt;val ^= head-&gt;val;</span><br><span class="line">            head-&gt;val ^= head-&gt;next-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分治</span></span><br><span class="line">    head = mergesortList(head);</span><br><span class="line">    mid  = mergesortList(mid );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并</span></span><br><span class="line">    head = binaryMergeList(head, mid);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>链表的划分，可以采用<strong>快慢指针</strong>的方式将链表对半划分，注意这种方式<strong>不能正确处理节点数目不大于$2$的链表</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">binarySplitList</span><span class="params">(ListNode* head)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注意只有一个或两个节点时，`slow == false`</span></span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    ListNode* slow = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 慢指针即中间指针</span></span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找前半链表的尾节点</span></span><br><span class="line">    <span class="keyword">while</span> (head-&gt;next &amp;&amp; head-&gt;next != slow) &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前半链表末尾置空指针</span></span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是两个链表合并的过程，时间复杂度$O(m+n)$，空间复杂度$O(1)$<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">binaryMergeList</span><span class="params">(ListNode* head1, ListNode* head2)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* sorted = <span class="literal">nullptr</span>; <span class="comment">// 记录头节点</span></span><br><span class="line">    ListNode* node = <span class="literal">nullptr</span>;   <span class="comment">// 游走节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 选择合适的节点</span></span><br><span class="line">        ListNode* choosen = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (head1 == <span class="literal">nullptr</span> &amp;&amp; head2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// 两连边均空，排序完成</span></span><br><span class="line">            <span class="keyword">return</span> sorted;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一边链表已到末尾</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (head1 != <span class="literal">nullptr</span> &amp;&amp; head2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            choosen = head1; head1 = head1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head1 == <span class="literal">nullptr</span> &amp;&amp; head2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            choosen = head2; head2 = head2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 选择较小的节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (head1-&gt;val &lt; head2-&gt;val) &#123;</span><br><span class="line">                choosen = head1; head1 = head1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                choosen = head2; head2 = head2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加至链表</span></span><br><span class="line">        choosen-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (sorted == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            sorted = node = choosen;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node-&gt;next = choosen; </span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h1><div class="table-container"><table><thead><tr><th>排序算法</th><th>平均时间</th><th>最好情况</th><th>最坏情况</th><th>额外空间</th><th>稳定度</th></tr></thead><tbody><tr><td>计数/箱子</td><td>$Ο(n+k)$</td><td>$Ο(n+k)$</td><td>$Ο(n+k)$</td><td>$O(k)$</td><td>稳定</td></tr><tr><td>桶</td><td>$Ο(n+k)$</td><td>$Ο(n+k)$</td><td>$Ο(n^2)$</td><td>$Ο(n+k)$</td><td>稳定</td></tr><tr><td>基数</td><td>$O(n \times k)$</td><td>$O(n \times k)$</td><td>$O(n \times k)$</td><td>$O(n + k)$</td><td>稳定</td></tr><tr><td>冒泡</td><td>$O(n^2)$</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>稳定</td></tr><tr><td><strong>快速</strong></td><td>$O(n \log n)$</td><td>$O(n \log n)$</td><td>$O(n^2)$</td><td>$O(n \log n)$</td><td><strong>不稳定</strong></td></tr><tr><td>选择</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td><strong>不稳定</strong></td></tr><tr><td><strong>堆排序</strong></td><td>$O(n \log n)$</td><td>$O(n \log n)$</td><td>$O(n \log n)$</td><td>$O(1)$</td><td><strong>不稳定</strong></td></tr><tr><td>插入</td><td>$O(n^2)$</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>稳定</td></tr><tr><td><strong>希尔</strong></td><td>$O(n \log n)$</td><td>$O(n \log^2 n)$</td><td>$O(n \log^2 n)$</td><td>$O(1)$</td><td><strong>不稳定</strong></td></tr><tr><td><strong>归并</strong></td><td>$O(n \log n)$</td><td>$O(n \log n)$</td><td>$O(n \log n)$</td><td><strong>$O(n)$</strong></td><td>稳定</td></tr></tbody></table></div><ul><li>上表中$k$表示整数范围内的数;</li><li>以上冒泡是指改进之后的算法，可将最好时间复杂度从$O(n^2)$降低至$O(n)$，比较$n-1$次</li><li>三种“基础”排序算法冒泡、选择、插入中，直插法在原数组有序时也只比较$n$次，只有选择排序最好情况下也是$O(n^2)$；基于选择的排序、两个优化的排序(快排、希尔)都是<strong>不稳定排序</strong>；</li><li>从$n$个数中选取最$k$个最小的数，最快的是<strong>堆排序</strong>($O(n \log k)$)；若不要求$k$个数有序，可采用快排partition($O(n)$)；</li><li><strong>归并排序</strong>可用于外部排序(如用100MB空间对1GB数进行排序)；</li><li>就平均性能而言,目前最好的内排序方法是<strong>快速排序</strong>；</li><li>输入若已经是排好序的，<strong>插入排序</strong>算法最快；</li></ul><blockquote><p><strong>稳定排序</strong>，是指在排序算法中，相同值的两个元素，在输入数组中先出现的数在输出数组中也先出现。像冒泡排序，插入排序，基数排序，归并排序等都是稳定排序。<br><strong>原地(原址、就地)排序</strong>是指：基本上不需要额外辅助的的空间，允许少量额外的辅助变量进行的排序。就是在原来的排序数组中比较和交换的排序。像选择排序，插入排序，希尔排序，快速排序，堆排序等都会有一项比较且交换操作(swap(i,j))的逻辑在其中，因此他们都是属于原地(原址、就地)排序，而合并排序，计数排序，基数排序等不是原地排序。<br>出于俩概念混乱的目的，在此书之，以免忘记。<br>————————————————<br>版权声明：本文为CSDN博主「liao_hb」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/liao_hb/java/article/details/81335121" target="_blank" rel="noopener">https://blog.csdn.net/liao_hb/java/article/details/81335121</a></p></blockquote><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html" target="_blank" rel="noopener">十大经典排序算法 - 菜鸟教程</a>；</li><li><a href="https://www.cnblogs.com/codingmylife/archive/2012/10/21/2732980.html" target="_blank" rel="noopener">稳定排序和不稳定排序 - 龙渊阁</a>；</li></ol>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>经典机器学习算法推导汇总</title>
      <link href="/2020/02/10/%E7%BB%8F%E5%85%B8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E6%8E%A8%E5%AF%BC%E6%B1%87%E6%80%BB/"/>
      <url>/2020/02/10/%E7%BB%8F%E5%85%B8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E6%8E%A8%E5%AF%BC%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#%e7%9b%ae%e5%bd%95">目录</a></li><li><a href="#%e5%89%8d%e8%a8%80">前言</a></li><li><a href="#mlemap">MLE/MAP</a><ul><li><a href="#%e6%9c%80%e5%a4%a7%e4%bc%bc%e7%84%b6%e4%bc%b0%e8%ae%a1mle">最大似然估计(MLE)</a></li><li><a href="#%e6%9c%80%e5%a4%a7%e5%90%8e%e9%aa%8c%e6%a6%82%e7%8e%87%e4%bc%b0%e8%ae%a1map">最大后验概率估计(MAP)</a></li></ul></li><li><a href="#%e7%ba%bf%e6%80%a7%e5%9b%9e%e5%bd%92%e9%80%bb%e8%be%91%e6%96%af%e8%92%82%e5%9b%9e%e5%bd%92">线性回归/逻辑斯蒂回归</a><ul><li><a href="#%e7%ba%bf%e6%80%a7%e5%9b%9e%e5%bd%92">线性回归</a></li><li><a href="#%e9%80%bb%e8%be%91%e6%96%af%e8%92%82%e5%9b%9e%e5%bd%92lr">逻辑斯蒂回归(LR)</a></li></ul></li><li><a href="#%e6%9c%b4%e7%b4%a0%e8%b4%9d%e5%8f%b6%e6%96%af">朴素贝叶斯</a></li><li><a href="#pcalda">PCA/LDA</a><ul><li><a href="#pca">PCA</a><ul><li><a href="#%e8%ae%a1%e7%ae%97%e6%ad%a5%e9%aa%a4">计算步骤</a></li><li><a href="#%e8%af%81%e6%98%8e">证明</a></li></ul></li><li><a href="#lda">LDA</a><ul><li><a href="#%e8%ae%a1%e7%ae%97%e6%ad%a5%e9%aa%a4-1">计算步骤</a></li><li><a href="#%e8%af%81%e6%98%8e-1">证明</a></li></ul></li></ul></li><li><a href="#emgmm">EM/GMM</a><ul><li><a href="#em%e7%ae%97%e6%b3%95">EM算法</a></li><li><a href="#gmm%e6%a8%a1%e5%9e%8b">GMM模型</a></li></ul></li><li><a href="#svm">SVM</a><ul><li><a href="#kkt%e6%9d%a1%e4%bb%b6">KKT条件</a></li><li><a href="#%e6%a0%b8%e6%8a%80%e5%b7%a7">核技巧</a></li><li><a href="#%e5%88%86%e7%b1%bb%e9%97%ae%e9%a2%98">分类问题</a><ul><li><a href="#%e7%ba%bf%e6%80%a7%e5%8f%af%e5%88%86">线性可分</a></li><li><a href="#%e7%ba%bf%e6%80%a7%e4%b8%8d%e5%8f%af%e5%88%86">线性不可分</a></li></ul></li><li><a href="#%e5%9b%9e%e5%bd%92%e9%97%ae%e9%a2%98">回归问题</a></li><li><a href="#%e6%b1%82%e8%a7%a3%e4%bc%98%e5%8c%96%e9%97%ae%e9%a2%98">求解优化问题</a></li></ul></li><li><a href="#%e8%81%9a%e7%b1%bb">聚类</a><ul><li><a href="#%e8%b7%9d%e7%a6%bb%e5%ba%a6%e9%87%8f">距离度量</a></li><li><a href="#kmeans">KMeans</a></li><li><a href="#spectral">Spectral</a></li></ul></li><li><a href="#%e5%86%b3%e7%ad%96%e6%a0%91">决策树</a><ul><li><a href="#id3">ID3</a></li><li><a href="#c45">C4.5</a></li><li><a href="#cart">CART</a></li><li><a href="#rf">RF</a></li></ul></li></ul><div style="page-break-after: always;"></div><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文只做复习使用，只给出关键算法描述和证明。</p><h1 id="MLE-MAP"><a href="#MLE-MAP" class="headerlink" title="MLE/MAP"></a>MLE/MAP</h1><p>给定$N$个样本对${(X^{(i)}, y^{(i)}), i = 1, \cdots, N}$，其中$y \in {C_k, k = 1, \cdots, K}$，要求估计参数模型$P(X | \theta)$的参数$\theta$，使之最能描述给定数据分布。</p><h2 id="最大似然估计-MLE"><a href="#最大似然估计-MLE" class="headerlink" title="最大似然估计(MLE)"></a>最大似然估计(MLE)</h2><script type="math/tex; mode=display">\begin{aligned}    优化目标：& \hat{\theta} = \arg \max P(D | \theta) \\    定义：& L(D | \theta) = P(D | \theta) = \prod_i P(X^{(i)} | \theta) \\    取对数：& \log L(D | \theta) = \sum_i \log P(X^{(i)} | \theta) \\    求取极值：& \frac{\partial}{\partial \theta} \log L(D | \theta) = 0 \Rightarrow \hat{\theta}\end{aligned}</script><h2 id="最大后验概率估计-MAP"><a href="#最大后验概率估计-MAP" class="headerlink" title="最大后验概率估计(MAP)"></a>最大后验概率估计(MAP)</h2><script type="math/tex; mode=display">\begin{aligned}    优化目标：& \hat{\theta} = \arg \max P(\theta | D) \\    其中：& P(\theta | D) = \frac{P(D | \theta) P(\theta)}{P(D)} \\    & P(\theta)为给定的参数先验概率分布 \\    定义：& L(\theta | D) = P(D | \theta) P(\theta) = \prod_i P(X^{(i)} | \theta) \cdot P(\theta) \\    取对数：&  \log L(\theta | D) = \sum_i \log P(X^{(i)} | \theta) + \log P(\theta) \\    求取极值：& \frac{\partial}{\partial \theta} \log L(\theta | D) = 0 \Rightarrow \hat{\theta}\end{aligned}</script><div style="page-break-after: always;"></div><h1 id="线性回归-逻辑斯蒂回归"><a href="#线性回归-逻辑斯蒂回归" class="headerlink" title="线性回归/逻辑斯蒂回归"></a>线性回归/逻辑斯蒂回归</h1><p>给定$N$个样本对${(X^{(i)}, y^{(i)}), i = 1, \cdots, N}$，记样本矩阵$X_{N \times n}$。</p><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><script type="math/tex; mode=display">\begin{aligned}    标签信息：& y \in \mathcal{R}^1，    定义模型：\hat{y}_{1\times 1} = w_{n \times 1}^T x_{n \times 1} + b \\     增广后：& \hat{y}_{1\times 1} = w_{n \times 1}^T x_{n \times 1} \begin{cases} w_1 = b \\ x_1 = 1 \end{cases} \\    MSE作为损失，则总体损失：& L(\hat{y}, y) = \frac{1}{N} \sum_{i=1}^N \frac{1}{2} (\hat{y}^{(i)} - y^{(i)})^2 \\    求取梯度：& \frac{\partial L}{\partial w_j} =         \frac{1}{N} \sum_{i=1}^N (\hat{y}^{(i)} - y^{(i)}) \frac{\partial \hat{y}^{(i)}}{\partial w_j} =         \frac{1}{N} \sum_{i=1}^N (\hat{y}^{(i)} - y^{(i)}) x^{(i)}_j \Rightarrow \\    梯度下降：& w_j := w_j - \alpha \frac{\partial L}{\partial w_j}\end{aligned}</script><p>若描述为矩阵</p><script type="math/tex; mode=display">\begin{aligned}    \left.\begin{aligned}        & 标签信息 Y \in R^{N} \\        定义模型：& \hat{Y}_{N \times 1} = X_{N \times (n + 1)} w_{(n + 1) \times 1} \\        总体损失：& L(\hat{Y}, Y) = \frac{1}{N} \cdot \frac{1}{2} || \hat{Y} - Y ||_2^2 =        \frac{1}{N} \cdot \frac{1}{2} (\hat{Y} - Y)^T(\hat{Y} - Y)    \end{aligned}\right\} \Rightarrow \\    L(\hat{Y}, Y) = \frac{1}{2 N} (w^T X^T X w - 2 Y^T X w + Y^T Y) \\    求取梯度： \frac{\partial L}{\partial w} = \frac{1}{\cancel{2} N} (\cancel{2} X^T X w - \cancel{2} X^T Y) = 0 \Rightarrow \\    \begin{cases}        梯度下降：& w := w - \alpha \frac{\partial L}{\partial w} \\        解析解：& \hat{w}^* = \underbrace{(X^T X + \lambda I)^{-1} X^T}_{X^+} Y     \end{cases}\end{aligned}</script><div style="page-break-after: always;"></div><h2 id="逻辑斯蒂回归-LR"><a href="#逻辑斯蒂回归-LR" class="headerlink" title="逻辑斯蒂回归(LR)"></a>逻辑斯蒂回归(LR)</h2><script type="math/tex; mode=display">\begin{aligned}    标签信息： y \in \{0, 1\} \\    定义模型：& \begin{cases} \hat{y} = \sigma(z) \\ z = w^T X + b \end{cases} \\    & 其中 \sigma(z) = \frac{1}{1 + \exp(-z)} \\    样本X服从0-1分布：& P(X) = (1 - \hat{y})^{1 - y} (\hat{y})^{y} (\hat{y}^{(i)}为直接待估参数) \\    MLE：& L(D | w) = \prod_i P(X^{(i)}) \Rightarrow         \log L(D | w) = \sum_i \log P(X^{(i)}) \\    优化目标：& \hat{w} = \arg \max L(D | w) = \arg \max \log L(D | w) \\    求取极值：& \begin{aligned}        \frac{\partial L}{\partial w_j} & =        \frac{\partial}{\partial w_j} \sum_i \log P(X^{(i)}) \\         & = \frac{\partial}{\partial w_j} \sum_i \log (1 - \hat{y}^{(i)})^{1 - y^{(i)}} (\hat{y}^{(i)})^{y^{(i)}} \\        & = \frac{\partial}{\partial w_j} \sum_i (1 - y^{(i)}) \log (1 - \hat{y}^{(i)}) + \frac{\partial}{\partial w_j} \sum_i y^{(i)} \log \hat{y}^{(i)} \\        & = \sum_i (1 - y^{(i)}) \frac{1}{1 - \hat{y}^{(i)}} (- \frac{\partial y^{(i)}}{\partial w_j}) +             \sum_i y^{(i)} \frac{1}{\hat{y}^{(i)}} (\frac{\partial y^{(i)}}{\partial w_j})    \end{aligned} \\    其中：& \frac{\partial y^{(i)}}{\partial w_j} = \sigma'(z^{(i)}) \frac{\partial z^{(i)}}{\partial w_j} = \sigma(z^{(i)}) (1 - \sigma(z^{(i)})) x^{(i)}_j \Rightarrow \\    & \frac{\partial L}{\partial w_j} = \sum_i - (1 - \bcancel{y^{(i)}}) \frac{1}{\cancel{1 - \hat{y}^{(i)}}} \sigma(z^{(i)}) \cancel{(1 - \sigma(z^{(i)}))} x^{(i)}_j + \\        & \sum_i y^{(i)} \frac{1}{\cancel{\hat{y}^{(i)}}} \cancel{\sigma(z^{(i)})} (1 - \bcancel{\sigma(z^{(i)})}) x^{(i)}_j         = \sum_i (y^{(i)} - \hat{y}^{(i)}) x^{(i)}_j \Rightarrow \\         梯度下降：& w_j := w_j - \alpha \frac{\partial L}{\partial w_j}\end{aligned}</script><div style="page-break-after: always;"></div><h1 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h1><p>给定$N$个样本对${(X^{(i)}, y^{(i)}), i = 1, \cdots, N}$，其中$y \in {C_k, k = 1, \cdots, K}$。</p><script type="math/tex; mode=display">\begin{aligned}    定义模型为条件概率分布：& P(Y | X) \\    由贝叶斯公式：& P(Y | X) = \frac{P(X | Y) P(Y)}{P(X)} \\    称：& \begin{cases}        后验概率：& P(Y | X) \\         似然函数：& P(X | Y) = \prod_{j=1}^n P(X_j | Y) (朴素贝叶斯)\\         先验概率：& P(Y) \\         证据因子：& P(X) = \sum_k P(X | Y = C_k) P(Y = C_k)    \end{cases} \\    \hat{y} & = \max_k P(X | Y = C_k) P(Y = C_k) \\     & = \max_k \prod_{j=1}^n P(X_j | Y = C_k) P(Y = C_k)\end{aligned}</script><h1 id="PCA-LDA"><a href="#PCA-LDA" class="headerlink" title="PCA/LDA"></a>PCA/LDA</h1><h2 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h2><p>给定<strong>包含$M$个样本的$N$维数据集</strong>${X_{N \times 1}^{(i)}, i = 1, \cdots, M}$构成样本矩阵$X_{N \times M} = \begin{bmatrix}X^{(1)} &amp; X^{(2)} &amp; \cdots X^{(M)}\end{bmatrix}$，现希望求取主分量$\beta_k, k = 1, \cdots, K$使得数据投影<strong>在各主分量上的散布最大/方差最大</strong>。</p><h3 id="计算步骤"><a href="#计算步骤" class="headerlink" title="计算步骤"></a>计算步骤</h3><ol><li>计算维度间的<strong>协方差矩阵</strong>$\Sigma_{N \times N} = \frac{1}{M} \tilde{X} \tilde{X}^T$，其中$\tilde{X}^{(i)} = X^{(i)} - \overline{X}, \overline{X} = \frac{1}{M} \sum_{i=1}^{M} X^{(i)}$；</li><li>求矩阵$\Sigma$的<strong>特征值分解</strong>，即$\Sigma \beta_k = \lambda_k \beta_k$；</li><li>将特征对$(\lambda_k, \beta_k)$按特征值$\lambda_k$降序排序后，选取前$K$个<strong>主分量</strong>作为投影轴构成投影矩阵$B_{N \times K}$；</li><li><strong>投影</strong>：$S_{K \times M} = B_{N \times K}^T X_{N \times M}$；<strong>重建</strong>；$\hat{X} = B_{N \times K} S_{K \times M}$。</li></ol><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><ol><li><p>第$1$主成分<br> 优化目标为</p><script type="math/tex; mode=display"> \begin{aligned}     \beta_1 & = \arg \max ||S_1||_2^2 \\ s.t. & \quad ||\beta_1||_2^2 = 1 \end{aligned}</script><p> 那么</p><script type="math/tex; mode=display"> \begin{aligned}     \left. \begin{aligned}         \left. \begin{aligned}             ||S_1||_2^2 & = S_1^T S_1 \\             S_1 & = X^T \beta_1         \end{aligned} \right\} \Rightarrow         ||S_1||_2^2 = \beta_1^T \underbrace{X X^T}_C \beta_1 \\         C = X X^T = W \Lambda W^T     \end{aligned} \right\} \Rightarrow \\     \left. \begin{aligned}         ||S_1||_2^2 = \beta_1^T W \Lambda \underbrace{W^T \beta_1}_{\alpha_1} = \sum_{i=1}^N \lambda_i \alpha_{1i} \leq \lambda_1 \sum_{i=1}^N \alpha_{1i} \\         \beta_1^T \beta_1 = \alpha_1^T W^T W \alpha = \alpha_1^T \alpha = \sum_{i=1}^N \alpha_{1i} = 1(单位约束)     \end{aligned} \right\} \Rightarrow \\     ||S_1||_2^2 \leq \lambda_1 \quad 为使||S_1||_2^2极大化，取 \\     \begin{cases}         \alpha_{11} = 1\\         \alpha_{1i} = 0, i = 2, 3, \cdots, N     \end{cases} \Rightarrow      \beta_1 = W \alpha_1 = w_1 \end{aligned}</script></li><li><p>第$r(r&gt;1)$主成分<br> 优化目标为</p><script type="math/tex; mode=display"> \begin{aligned}     \beta_r & = \arg \max ||S_r||_2^2 \\     s.t. & \quad \beta_r^T \beta_i = 0, i = 1, \cdots, r - 1 \\     & ||\beta_r||_2^2 = 1 \end{aligned}</script><p> 那么</p><script type="math/tex; mode=display"> \begin{aligned}     \left. \begin{aligned}         \left. \begin{aligned}             ||S_r||_2^2 = S_r^T S_r \\             S_r = X^T \beta_r         \end{aligned} \right\} \Rightarrow         ||S_r||_2^2 = \beta_r^T \underbrace{X X^T}_C \beta_r \\         C = X X^T = W \Lambda W^T     \end{aligned} \right\} \Rightarrow \\     \left. \begin{aligned}         ||S_r||_2^2 = \beta_r^T W \Lambda \underbrace{W^T \beta_r}_{\alpha_r} = \sum_{i=1}^N \lambda_i \alpha_{ri} \\         \beta_r^T \beta_i =(W \alpha_r)^T (w_i) = \alpha_{ri} = 0, i \neq r (正交约束) \\         \beta_r^T \beta_r = \alpha_r^T W^T W \alpha = \alpha_r^T \alpha = \sum_{i=1}^N \alpha_{1i} = 1(单位约束)     \end{aligned} \right\} \Rightarrow \\     ||S_r||_2^2 = \lambda_r \alpha_{rr} \quad 为使||S_r||_2^2极大化，取 \\     \begin{cases}         \alpha_{rr} = 1 \\         \alpha_{ri} = 0, i = \neq r     \end{cases} \Rightarrow      \beta_r = W \alpha_r = w_r \end{aligned}</script></li></ol><div style="page-break-after: always;"></div><h2 id="LDA"><a href="#LDA" class="headerlink" title="LDA"></a>LDA</h2><p>给定$N$个样本对${(X^{(i)}, y^{(i)}), i = 1, \cdots, N}$，其中$y \in {C_k, k = 1, \cdots, K}$，记样本矩阵$X_{N \times n}$。现利用类别信息求取投影主轴$u$，<strong>使得投影后类内散步小，类间散步大</strong>。</p><p>定义：</p><script type="math/tex; mode=display">\begin{cases}    总样本均值： & \mu = \frac{1}{N} \sum_{i=1}^N X^{(i)} \\    类别样本均值： & \mu_k = \frac{1}{N_k} \sum_{i=1}^{N_k} X^{(i)}, y^{(i)} = C_k \\    类内离差阵： & S_{W, n \times n} = \sum_k \frac{N_k}{N} \left[         \frac{1}{N_k} \sum_i (X^{(i)} - \mu_k) (X^{(i)} - \mu_k)^T    \right] \\    类内离差阵： & S_{B, n \times n} = \sum_k \frac{N_k}{N} \left[         (\mu_k - \mu) (\mu_k - \mu)^T     \right] \\\end{cases}</script><h3 id="计算步骤-1"><a href="#计算步骤-1" class="headerlink" title="计算步骤"></a>计算步骤</h3><ol><li>计算类内/类间离差阵$S_W/S_B$；</li><li>计算矩阵$S_W^{-1}S_B$的特征对$(\lambda_i, u_i)$；</li><li>将特征对按特征值降序排序，选取最大的特征值对应特征向量作为投影主轴，构成投影矩阵$U_{n \times m}$；</li><li>投影到主轴上，$\hat{X}_{N \times m} = X_{N \times n} U_{n \times m}$。</li></ol><h3 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h3><script type="math/tex; mode=display">\begin{aligned}    将样本点X^{(i)}投影到第一主轴u_1上有 \quad \tilde{X}^{(i)} = u_1^T X^{(i)} \quad 在投影空间有 \\    \left.\begin{aligned}        \tilde{X}^{(i)} & = u_1^T X^{(i)}, \tilde{\mu} = u_1^T \mu, \tilde{\mu}_k = u_1^T \mu_k \\        \tilde{S_W}_{1 \times 1} & = \sum_k \frac{N_k}{N} \left[             \frac{1}{N_k} \sum_i (\tilde{X}^{(i)} - \tilde{\mu}_k) (\tilde{X}^{(i)} - \tilde{\mu}_k)^T         \right] \\        \tilde{S_B}_{1 \times 1} & = \sum_k \frac{N_k}{N} \left[             (\tilde{\mu}_k - \tilde{\mu}) (\tilde{\mu}_k - \tilde{\mu})^T        \right]    \end{aligned}\right\} \Rightarrow    \begin{cases}        \tilde{S_W} = u_1^T S_W u_1 \\         \tilde{S_B} = u_1^T S_B u_1    \end{cases} \\    定义优化目标为：u_1 = \arg \max \frac{\tilde{S_W}}{\tilde{S_B}} = \arg \max \frac{u_1^T S_W u_1}{u_1^T S_B u_1} \\    求取极值：\frac{\partial}{\partial u_1} \frac{u_1^T S_W u_1}{u_1^T S_B u_1} = \frac{(u_1^T S_B u_1)(2 S_w u_1) - (u_1^T S_w u_1)(2 S_B u_1)}{(u_1^T S_B u_1)^2} = 0 \Rightarrow \\    S_w u_1 = \underbrace{\frac{u_1^T S_W u_1}{u_1^T S_B u_1}}_{\lambda_1} S_B u_1，记\lambda_1 = \frac{u_1^T S_W u_1}{u_1^T S_B u_1}\end{aligned}</script><div style="page-break-after: always;"></div><h1 id="EM-GMM"><a href="#EM-GMM" class="headerlink" title="EM/GMM"></a>EM/GMM</h1><h2 id="EM算法"><a href="#EM算法" class="headerlink" title="EM算法"></a>EM算法</h2><p>给定包含$N$对样本数据${(X^{(i)}, y^{(i)}), i = 1, \cdots, N}$。设分类模型为概率模型$P(X | \theta)$，其中$\theta$待估。该模型包含$K$种<strong>隐藏变量</strong>状态${w_k, k = 1, \cdots, K}$。那么证明过程总结如下</p><script type="math/tex; mode=display">\begin{aligned}    MLE \Rightarrow L(D | \theta) = \prod_i P(X^{(i)} | \theta)     \Rightarrow \log L(D | \theta) = \sum_i \log P(X^{(i)} | \theta) \\     \Rightarrow 优化目标：\theta^{(t + 1)} = \arg \max \log L(D | \theta) \\ \\    \left. \begin{aligned}        P(X^{(i)} | \theta) = \sum_k P(X^{(i)}, w^{(i)}_k | \theta) (引入隐变量w_k) \\        \frac{P(w^{(i)}_k | \theta^{(t)})}{P(w^{(i)}_k | \theta^{(t)})} = 1 (引入迭代变量\theta^{(t)})    \end{aligned} \right\} \Rightarrow \\    \left. \begin{aligned}        \log L(D | \theta) = \sum_i             \log \sum_k                 P(X^{(i)}, w^{(i)}_k | \theta) \frac{P(w^{(i)}_k | \theta^{(t)})}{P(w^{(i)}_k | \theta^{(t)})} \\        \begin{cases}            \varphi(\cdot)下凸 \\ \sum_i w_i = 1        \end{cases} \Rightarrow \varphi(\sum_i w_i x_i) \leq \sum_i w_i \varphi(x_i) (Jensen不等式)    \end{aligned} \right\} \Rightarrow \\    \log L(D | \theta) = \sum_i \sum_k P(w^{(i)}_k | \theta^{(t)})         \log \frac{P(X^{(i)}, w^{(i)}_k | \theta)}{P(w^{(i)}_k | \theta^{(t)})} \\        = \underbrace{ \sum_i \sum_k P(w^{(i)}_k | \theta^{(t)})             \log P(X^{(i)}, w^{(i)}_k | \theta)}_{E_w\left[ \log P(X^{(i)}, w^{(i)}_k | \theta) \right]} \\        \underbrace{- \sum_i \sum_k P(w^{(i)}_k | \theta^{(t)})         \log P(w^{(i)}_k | \theta^{(t)})}_{H\left[ P(w^{(i)}_k | \theta^{(t)}) \right]} \\    记 \quad Q(\theta | \theta^{(t)}) = E_w\left[ \log P(X^{(i)}, w^{(i)}_k | \theta) \right] \\     \Rightarrow 优化目标：\theta^{(t + 1)} = \arg \max Q(\theta | \theta^{(t)}) \\    对Q(\theta | \theta^{(t)})求极值求解\theta^{(t + 1)}。\end{aligned}</script><div style="page-break-after: always;"></div><h2 id="GMM模型"><a href="#GMM模型" class="headerlink" title="GMM模型"></a>GMM模型</h2><p>高斯混合模型，具有如下概率形式</p><script type="math/tex; mode=display">P(X | \mu, \Sigma) = \sum_{k=1}^K \pi_k N(X | \mu_k, \Sigma_k)</script><p>其中</p><script type="math/tex; mode=display">\begin{cases}    \sum_k \pi_k = 1 \\    N(X | \mu_k, \Sigma_k) = \frac{1}{(2\pi)^{d/2}|\Sigma|^{1/2}}     \exp \left[        - \frac{1}{2} (X - \mu_k)^T \Sigma_k^{-1} (X - \mu_k)    \right]\end{cases}</script><p>用<strong>EM算法</strong>对参数进行估计</p><script type="math/tex; mode=display">\begin{aligned}    \left. \begin{aligned}        Q(\theta|\theta^{(t)}) = \sum_i \sum_k P(w_k^{(i)}|\theta^{(t)}) \log \underbrace{P(x^{(i)} | w_k^{(i)}, \theta) P(w_k^{(i)} | \theta)}_{P(x^{(i)}, w_k^{(i)} | \theta)} \\        \begin{cases}            P(w_k^{(i)}|\theta^{(t)}) =             \frac{\pi_k^{(t)} N(x^{(i)}|\mu_k^{(t)}, \Sigma_k^{(t)})}            {\sum_j \pi_j^{(t)} N(x^{(i)}|\mu_j^{(t)}, \Sigma_j^{(t)})}            = \gamma^{(i)(t)}_k \\            P(x^{(i)} | w_k^{(i)}, \theta) = N(x^{(i)}|\mu_k, \Sigma_k) \\            P(w_k^{(i)} | \theta) = \pi_k        \end{cases}    \end{aligned} \right\} \Rightarrow \\    Q(\theta|\theta^{(t)}) = \sum_i \sum_k \gamma^{(i)(t)}_k \log \pi_k N(x^{(i)}|\mu_k, \Sigma_k) \\    求解Q函数极值 \Rightarrow    \begin{cases}        \mu_k^{(t+1)} = \frac{\sum_i \gamma^{(i)(t)}_k x^{(i)}}{\sum_i \gamma^{(i)(t)}_k} \\        \Sigma_k^{(t+1)} = \frac{\sum_i \gamma^{(i)(t)}_k (x^{(i)} - \mu_k) (x^{(i)} - \mu_k)^T}{\sum_i \gamma^{(i)(t)}_k} \\        \pi_k^{(t+1)} = \frac{\sum_i \gamma^{(i)(t)}_k}{N}    \end{cases}\end{aligned}</script><div style="page-break-after: always;"></div><h1 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h1><h2 id="KKT条件"><a href="#KKT条件" class="headerlink" title="KKT条件"></a>KKT条件</h2><script type="math/tex; mode=display">\begin{aligned}    \left.\begin{aligned}        w = \arg \min f(w) \\        s.t. \quad h_j(w) = 0, j = 1, \cdots, m \\        g_j(w) \leq 0, j = 1, \cdots, p    \end{aligned}\right\} \Rightarrow \\    L(w, \lambda, \mu) = f(w) + \sum_j \lambda_j h_j(w) + \sum_j \mu_j \left(g_j(w) + \epsilon^2 \right) \\    \Rightarrow \begin{cases}        \frac{\partial}{\partial w} f(w) +             \sum_j \lambda_j \frac{\partial}{\partial w} h_j(w) +             \sum_j \mu_j \frac{\partial}{\partial w} g_j(w) = 0 \\        h_j(w) = 0, j = 1, \cdots, m \\        \left.\begin{aligned}            \mu_j g_j(w) = 0 \\             \mu_j \geq 0        \end{aligned} \right\}  j = 1, \cdots, p    \end{cases}\end{aligned}</script><h2 id="核技巧"><a href="#核技巧" class="headerlink" title="核技巧"></a>核技巧</h2><p>设某函数$\Phi(x)$，可将$x$从$n$维空间映射到$n’$维空间，定义两个向量的核函数为$\kappa(x_i, x_j) = \Phi(x_i)^T \Phi(x_j)$，常用和函数有</p><script type="math/tex; mode=display">\begin{cases}    线性核：& \kappa(x_i, x_j) = x_i^T x_j \\    多项式核：& \kappa(x_i, x_j) = (\gamma x_i^T x_j + c)^n \\    sigmoid核：& \kappa(x_i, x_j) = \tanh (\gamma x_i^T x_j + c) \\    拉普拉斯核：& \kappa(x_i, x_j) = \exp (- \gamma \frac{||x_i - x_j||}{\sigma}) \\    高斯核：& \kappa(x_i, x_j) = \exp (- \gamma \frac{||x_i - x_j||^2}{2 \sigma^2}) \end{cases}</script><div style="page-break-after: always;"></div><h2 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h2><p>给定$N$对样本${(X^{(i)}, y^{(i)}), i = 1, \cdots, N}, y \in {-1, 1}$，求取超平面$w^T \Phi(x) + b = 0$使样本点落在该超平面两侧。</p><h3 id="线性可分"><a href="#线性可分" class="headerlink" title="线性可分"></a>线性可分</h3><script type="math/tex; mode=display">\begin{aligned}    \left.\begin{aligned}        记r_{+/-}为分类平面到支持向量x_{+/-}的距离，则r = r_+ + r_-，且r_{+/-} = \frac{|w^T \Phi(x_{+/-}) + b|}{||w||} = \frac{1}{||w||} \\        正/负样本分别满足\begin{cases}            w^T \Phi(x^{(i)}) + b > 1 & y^{(i)} > 0 \\            w^T \Phi(x^{(i)}) + b < -1 & y^{(i)} < 0         \end{cases} \Rightarrow y^{(i)} [w^T \Phi(x^{(i)}) + b] \geq 1(包括支持向量)    \end{aligned}\right\} \Rightarrow \\\end{aligned}</script><script type="math/tex; mode=display">\begin{aligned}    优化目标：& \begin{aligned}            w, b & = \arg \max r \\             s.t. & \quad y^{(i)} [w^T \Phi(x^{(i)}) + b] \geq 1        \end{aligned} \\    即： & \begin{aligned}            w, b & = \arg \min \frac{1}{2} ||w||^2 \\ s.t. & \quad y^{(i)} [w^T \Phi(x^{(i)}) + b] \geq 1        \end{aligned}\end{aligned}</script><h3 id="线性不可分"><a href="#线性不可分" class="headerlink" title="线性不可分"></a>线性不可分</h3><p>在线性可分支持向量机基础上，对每个样本添加松弛变量$\epsilon^{(i)}$</p><script type="math/tex; mode=display">\begin{aligned}    优化目标：\begin{aligned}            w, b & = \arg \min \left[ \frac{1}{2} ||w||^2 + C \sum_i \epsilon^{(i)} \right] \\             s.t. & \quad y^{(i)} [w^T \Phi(x^{(i)}) + b] \geq 1 - \epsilon^{(i)}            \\ & \epsilon^{(i)} \geq 0        \end{aligned}\end{aligned}</script><h2 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a>回归问题</h2><p>给定$N$对样本${(X^{(i)}, y^{(i)}), i = 1, \cdots, N}, y \in R$，求回归模型$\hat{y} = w^T \Phi(x) + b$，使得每个样本尽量拟合到该模型上，定义损失为</p><script type="math/tex; mode=display">L^{(i)} = \begin{cases}    |y^{(i)} - w^T \Phi(x^{(i)}) - b| - \epsilon & |y^{(i)} - w^T \Phi(x^{(i)}) - b| > \epsilon \\     0 & otherwise\end{cases}</script><div style="page-break-after: always;"></div><h2 id="求解优化问题"><a href="#求解优化问题" class="headerlink" title="求解优化问题"></a>求解优化问题</h2><p>以线性可分支持向量机为例，讲解参数$w， b$的优化方法</p><script type="math/tex; mode=display">优化目标：\begin{aligned}    w, b & = \arg \min \frac{1}{2} ||w||^2 \\     s.t. & \quad y^{(i)} [w^T \Phi(x^{(i)}) + b] \geq 1\end{aligned}</script><script type="math/tex; mode=display">\begin{aligned}    拉格朗日函数：L(w, b, \mu) = \frac{1}{2} ||w||^2 + \sum_i \mu^{(i)} \left\{ 1 - y^{(i)} [w^T \Phi(x^{(i)}) + b] \right\} \\    w, b, \mu = \arg \min_{w, b} \max_{\mu} L(w, b, \mu) \Rightarrow     w, b, \mu = \arg \max_{\mu} \min_{w, b} L(w, b, \mu)(对偶问题) \\    求解极值：\begin{cases}        \begin{aligned}            \frac{\partial}{\partial w_j} L(w, b, \mu) = \frac{1}{2} \frac{\partial}{\partial w_j} ||w||^2 +                 \sum_i \mu^{(i)} \left\{ - y^{(i)} \frac{\partial}{\partial w_j} w^T \Phi(x^{(i)}) \right\} = \\            w_j - \sum_i \mu^{(i)} y^{(i)} \Phi(x^{(i)})_j        \end{aligned} \\        \begin{aligned}            \frac{\partial}{\partial b} L(w, b, \mu) = \sum_i \mu^{(i)} \left\{ -y^{(i)} \frac{\partial}{\partial b} b \right\} = \\            - \sum_i \mu^{(i)} y^{(i)}        \end{aligned}    \end{cases} \\    由K.K.T条件：\begin{cases}        \left.\begin{aligned}            \sum_i \mu^{(i)} y^{(i)} \Phi(x^{(i)})_j & = w_j \\            \sum_i \mu^{(i)} y^{(i)} & = 0        \end{aligned}\right\} (极值条件) \\        1 - y^{(i)} [w^T \Phi(x^{(i)}) + b] \leq 0 (不等式约束) \\        \left.\begin{aligned}            \mu^{(i)} \left\{ 1 - y^{(i)} [w^T \Phi(x^{(i)}) + b] \right\} = 0 \\             \mu^{(i)} > 0        \end{aligned} \right\} (优化目标取'='的必要条件)    \end{cases}\end{aligned}</script><div style="page-break-after: always;"></div><p>$拉格朗日函数展开后，将极值条件代入，有$</p><script type="math/tex; mode=display">\begin{aligned}    L(w, b, \mu) & = \frac{1}{2} ||w||^2 + \sum_i \mu^{(i)} \left\{ 1 - y^{(i)} [w^T \Phi(x^{(i)}) + b] \right\} \\    & = \frac{1}{2} w^T w + \sum_i \mu^{(i)} - \sum_i \mu^{(i)} y^{(i)} w^T \Phi(x^{(i)}) - \sum_i \mu^{(i)} y^{(i)} b \\    & = \frac{1}{2} w^T w + \sum_i \mu^{(i)} - \sum_i \mu^{(i)} y^{(i)} \underbrace{\left( \sum_j w_j \Phi(x^{(i)})_j \right)}_{w^T \Phi(x^{(i)})} - \cancel{\sum_i \mu^{(i)} y^{(i)} b} \\    & \left.\begin{aligned}        = \frac{1}{2} w^T w + \sum_i \mu^{(i)} - \sum_j w_j \cdot \underbrace{\sum_i \mu^{(i)} y^{(i)} \Phi(x^{(i)})_j}_{w_i}         = - \frac{1}{2} w^T w + \sum_i \mu^{(i)} \\        w^T w = \left( \sum_i \mu^{(i)} y^{(i)} \Phi(x^{(i)}) \right)^T             \left( \sum_i \mu^{(i)} y^{(i)} \Phi(x^{(i)}) \right) = \\            \sum_i \sum_j \mu^{(i)} \mu^{(j)} y^{(i)} y^{(j)} \Phi(x^{(i)})^T \Phi(x^{(j)})    \end{aligned}\right\} \Rightarrow \\    L(\mu) & = - \frac{1}{2} \underbrace{\sum_i \sum_j \mu^{(i)} \mu^{(j)} y^{(i)} y^{(j)} \Phi(x^{(i)})^T \Phi(x^{(j)})}_{w^T w} + \sum_i \mu^{(i)}\end{aligned}</script><p>$那么现在的优化问题如下，用SMO进行求解$</p><script type="math/tex; mode=display">\begin{aligned}    \mu & = \arg \max_{\mu} L(\mu) \\    s.t. & \quad \mu^{(i)} \geq 0, \quad \sum_i \mu^{(i)} y^{(i)} = 0 \\    \Rightarrow & \mu^* \Rightarrow w^*, b^*\end{aligned}</script><div style="page-break-after: always;"></div><h1 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h1><p>仅介绍部分概念和算法步骤。给定样本集合${X^{(i)}, i = 1, \cdots, N}$，指定划分类别$K$，要求利用样本分布，将样本划分为$K$个类别。</p><h2 id="距离度量"><a href="#距离度量" class="headerlink" title="距离度量"></a>距离度量</h2><p>定义两个$n$维向量$x, y$，有如下常用距离定义</p><script type="math/tex; mode=display">\begin{aligned}    曼哈顿距离 & d = || x - y ||_1 = \sum_j |x_j - y_j| \\    欧氏距离 & d = || x - y ||_2 = (\sum_j (x_j - y_j)^2)^{1 / 2} \\    闵可夫斯基距离 & d = || x - y ||_p = (\sum_j |x_j - y_j|^p)^{1 / p} \\    余弦距离 & d = || x - y ||_1 = \cos <x, y> = \frac{x^T y}{||x||\cdot||y||} \\\end{aligned}</script><h2 id="KMeans"><a href="#KMeans" class="headerlink" title="KMeans"></a>KMeans</h2><ol><li>随机选取$K$个样本点作为初始中心点(初值敏感)；</li><li>计算每个样本点到各中心点的距离($N \times K$)；</li><li>将每个样本划分到距离最近的中心点指代的类别中；</li><li>每个类别重新计算中心点，更新参数；</li><li>重复2~4直至收敛。</li></ol><h2 id="Spectral"><a href="#Spectral" class="headerlink" title="Spectral"></a>Spectral</h2><ol><li>构建相似矩阵$\begin{cases} S_{N \times N} = \begin{bmatrix} d_{ij} \end{bmatrix} \ d_{ij} = ||x^{(i)} - x^{(j)}||_2^2 \end{cases}$；</li><li>计算邻接矩阵<script type="math/tex; mode=display"> \begin{cases}     \epsilon近邻法：& w_{ij} = \begin{cases}             \epsilon & d_{ij} \leq \epsilon \\             0 & otherwise         \end{cases} \\     K近邻法：& w_{ij} = \begin{cases}             \exp(-\frac{d_{ij}}{2 \sigma^2}) & x^{(i)} \in \delta_K(x^{(j)}) \quad AND/OR \quad x^{(j)} \in \delta_K(x^{(i)}) \\             0 & otherwise         \end{cases} \\ & \delta_K(x)表示x的K邻域 \\     全连接法：& w_{ij} =  \exp(-\frac{d_{ij}}{2 \sigma^2}) \end{cases}</script></li><li>求度矩阵$D_{N \times N} = \text{diag}{\sum_j w_{ij}, i = 1, \cdots, N}$，即$W$行和作为对角元素；</li><li>求(正则)拉普拉斯矩阵$L = D - W$或$L = D^{-1}(D - W)$或$L = D^{-1/2}(D - W)D^{-1/2}$；</li><li>求$L$的特征分解，选取$N’(N’ \leq N)$个<strong>最小</strong>特征值对应的特征向量组成矩阵$F_{N \times N’}$；</li><li>将矩阵$F$每行视作样本$f^{(i)}$，标准化后执行其他简单的聚类如KMeans，得到聚类结果。</li></ol><div style="page-break-after: always;"></div><h1 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h1><p>给定包含$|D|$个样本的样本集$D = {(X^{(i)}, y^{(i)}), i = 1, \cdots, |D|}$，属于$K$个类别$y \in {C_k, k = 1, \cdots, K}$，设类别$C_k$的样本数目为$|D_{k}|$，设特征$A$有$|A|$个特征${A_a, a = 1, \cdots, |A|}$，每个特征包含样本数目$|D_{a}|$，记特征为$A_a$的样本中属于类别$C_k$的样本数目为$|D_{ak}|$。</p><h2 id="ID3"><a href="#ID3" class="headerlink" title="ID3"></a>ID3</h2><p>用<strong>信息增益</strong>作为准则选择当前最优划分属性：信息增益越大表示属性越优</p><script type="math/tex; mode=display">\begin{aligned}    g(D, A) = H(D) - H(D | A) \\    \left.\begin{aligned}        H(D) & = - \sum_k \frac{|D_k|}{|D|} \log \frac{|D_k|}{|D|}(总样本的类别熵) \\        H(D | A) & = \sum_a \frac{|D_a|}{|D|}         \underbrace{\left( - \sum_k \frac{|D_{ak}|}{|D_a|} \log \frac{|D_{ak}|}{|D_a|} \right)}_{H(D_a)} (特征A_a的类别熵的加权和)    \end{aligned} \right\}\end{aligned}</script><h2 id="C4-5"><a href="#C4-5" class="headerlink" title="C4.5"></a>C4.5</h2><p>用<strong>信息增益比</strong>作为准则选择当前最优划分属性：信息增益比越大表示属性越优</p><ul><li>以信息增益比(information gain ratio)作为特征选择的准则，克服ID3会优先选择有较多属性值的特征的缺点；</li><li>弥补不能处理特征属性值连续的问题。</li></ul><script type="math/tex; mode=display">\begin{aligned}    g_R(D, A) & = \frac{g(D, A)}{H_A(D)} \\    H_A(D) & = - \sum_a \frac{|D_a|}{|D|} \log \frac{|D_a|}{|D|} (特征A的属性熵)\end{aligned}</script><h2 id="CART"><a href="#CART" class="headerlink" title="CART"></a>CART</h2><p>用<strong>信息增益比</strong>作为准则选择当前最优划分属性：信息增益比越大表示属性越优</p><script type="math/tex; mode=display">\begin{aligned}    g_G(D, A) = \text{Gini}(D) - \text{Gini}(D|A) \\    \left.\begin{aligned}        \text{Gini}(D) & = 1 - \sum_k (\frac{|D_k|}{|D|})^2 (总样本的类别基尼系数) \\        \text{Gini}(D|A) & = \sum_a \frac{|D_a|}{|D|}             \underbrace{\left( 1 - \sum_k (\frac{|D_{ak}|}{|D_a|})^2 \right)}_{\text{Gini}(D_a)} (特征A_a的类别基尼系数的加权和)    \end{aligned}\right\}\end{aligned}</script><h2 id="RF"><a href="#RF" class="headerlink" title="RF"></a>RF</h2><p>随机森林是用Bagging策略，对包含$N$个样本的数据集<strong>进行$M$次的有放回的采样，每次随机取$N_m$个样本</strong>，得到$M$个样本数目为$N_m$的样本子集，对每个子集建立分类器。</p><blockquote><p><strong>Bootstrap采样</strong>：对于一个样本，它在某一次含$m$个样本的训练集的随机采样中，每次被采集到的概率是$1/m$。不被采集到的概率为$1−1/m$。如果$m$次采样都没有被采集中的概率是$(1−1/m)^m$。当$m→\infty$时，$\lim_{m \rightarrow \infty} (1−1/m)^m \approx 0.368$。也就是说，在bagging的每轮随机采样中，训练集中大约有36.8%的数据没有被采样集采集中。对于这部分大约$36.8\%$的没有被采样到的数据，我们常常称之为袋外数据(Out Of Bag, 简称OOB)。这些数据没有参与训练集模型的拟合，因此可以用来检测模型的泛化能力。</p></blockquote><p>随机森林在Bagging策略上进行训练：</p><ol><li>用Bootstrap策略随机采样$M$次；</li><li>一棵树的生成时，<strong>仅从所有特征($K$个)中选取$k$个特征</strong>；</li><li>生成$M$棵树进行投票表决，确定预测结果(分类可取众数、回归可取均值)。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Matchine Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2020/02/08/MySQL/"/>
      <url>/2020/02/08/MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#目录">目录</a></li><li><a href="#关系型数据库管理系统-rdbms">关系型数据库管理系统: RDBMS</a><ul><li><a href="#特点">特点</a></li><li><a href="#术语">术语</a></li></ul></li><li><a href="#安装">安装</a></li><li><a href="#测试数据">测试数据</a></li><li><a href="#数据类型">数据类型</a><ul><li><a href="#text类型">Text类型</a></li><li><a href="#number类型">Number类型</a></li><li><a href="#datetime类型">Date/Time类型</a></li></ul></li><li><a href="#运算符">运算符</a><ul><li><a href="#算术运算符------div-mod">算术运算符: +, -, *, /, DIV, MOD</a></li><li><a href="#比较运算符-------between-in--like-regexp-is-null">比较运算符: =, &lt;&gt;/!=, &lt;, &lt;=, &gt;, &gt;=, BETWEEN, IN, &lt;=&gt;, LIKE, REGEXP, IS NULL</a></li><li><a href="#逻辑运算符-not-and-or-xor">逻辑运算符: NOT, AND, OR, XOR</a></li><li><a href="#位运算符------">位运算符: &amp;, |, ^, !, &lt;&lt;, &gt;&gt;</a></li></ul></li><li><a href="#管理">管理</a><ul><li><a href="#数据库操作">数据库操作</a><ul><li><a href="#显示-show-databases">显示: SHOW DATABASES;</a></li><li><a href="#创建-create-database-database">创建: CREATE DATABASE database;</a></li><li><a href="#删除-drop-database-database">删除: DROP DATABASE database;</a></li><li><a href="#选择-use-database">选择: USE database;</a></li></ul></li><li><a href="#数据表操作">数据表操作</a><ul><li><a href="#显示-show-tables">显示: SHOW TABLES;</a></li><li><a href="#创建-create-table-table_name-column_name-column_type">创建: CREATE TABLE table_name (column_name column_type);</a><ul><li><a href="#缺失值限定-not-null">缺失值限定: NOT NULL</a></li><li><a href="#编号自增-auto_increment">编号自增: AUTO_INCREMENT</a></li><li><a href="#默认值-default">默认值: DEFAULT</a></li><li><a href="#主键-primary-key">主键: PRIMARY KEY</a></li><li><a href="#引擎-engine">引擎: ENGINE</a></li><li><a href="#临时表-create-temporary-table-table_name-column_name-column_type">临时表: CREATE TEMPORARY TABLE table_name (column_name column_type);</a></li></ul></li><li><a href="#更新-alter-table-table_name">更新: ALTER TABLE table_name;</a><ul><li><a href="#表">表</a><ul><li><a href="#修改表名-rename">修改表名: RENAME</a></li></ul></li><li><a href="#字段">字段</a><ul><li><a href="#添加-add">添加: ADD</a></li><li><a href="#删除-drop">删除: DROP</a></li><li><a href="#修改名称-change">修改名称: CHANGE</a></li><li><a href="#修改类型-modify">修改类型: MODIFY</a></li></ul></li><li><a href="#修改默认值-set">修改默认值: SET</a></li></ul></li><li><a href="#删除-drop-table-table_name">删除: DROP TABLE table_name;</a></li></ul></li><li><a href="#用户账号">用户账号</a><ul><li><a href="#查看-use-mysql">查看: USE mysql;</a></li><li><a href="#创建-create-user-user_name-identified-by-passwod">创建: CREATE USER user_name IDENTIFIED BY ‘passwod’;</a></li><li><a href="#删除-drop-user-user_name">删除: DROP USER user_name;</a></li><li><a href="#访问权限">访问权限</a><ul><li><a href="#查看-show-grants-for-user_name">查看: SHOW GRANTS FOR user_name;</a></li><li><a href="#修改-grant-revoke">修改: GRANT, REVOKE</a></li></ul></li><li><a href="#更改密码-set-password-for-user_name--passwordnew-password">更改密码: SET PASSWORD FOR user_name = PASSWORD(‘new password’);</a></li></ul></li></ul></li><li><a href="#过滤-where">过滤: WHERE</a><ul><li><a href="#范围查询--------between-and">范围查询: =, &lt;&gt;, !=, &lt;, &lt;=, &gt;, &gt;=, BETWEEN-AND</a></li><li><a href="#条件范围-in">条件范围: IN</a></li><li><a href="#否定关键字-not">否定关键字: NOT</a></li><li><a href="#组合子句-and-or">组合子句: AND, OR</a></li><li><a href="#空值检查-is-null">空值检查: IS NULL</a></li><li><a href="#通配符过滤-like">通配符过滤: LIKE</a><ul><li><a href="#匹配0个1个或多个字符-">匹配0个、1个或多个字符: %</a></li><li><a href="#只且必须匹配1个字符-_">只且必须匹配1个字符: _</a></li></ul></li><li><a href="#正则表达式">正则表达式</a></li></ul></li><li><a href="#查询-select">查询: SELECT</a><ul><li><a href="#排序-order-by">排序: ORDER BY</a></li><li><a href="#分组-group-by">分组: GROUP BY</a></li><li><a href="#分组过滤-having">分组过滤: HAVING</a></li><li><a href="#子查询-select">子查询: SELECT</a></li><li><a href="#组合查询-union">组合查询: UNION</a></li></ul></li><li><a href="#插入-insert-into">插入: INSERT INTO</a></li><li><a href="#更新-update-set">更新: UPDATE-SET</a></li><li><a href="#删除-delete-from">删除: DELETE FROM</a></li><li><a href="#连接-join-on">连接: JOIN-ON</a><ul><li><a href="#创建连接-where">创建连接: WHERE</a></li><li><a href="#内连接等值连接join-或-inner-join">内连接(等值连接)：JOIN 或 INNER JOIN</a></li><li><a href="#左连接left-join">左连接：LEFT JOIN</a></li><li><a href="#右连接right-join">右连接：RIGHT JOIN</a></li></ul></li><li><a href="#函数-function">函数: FUNCTION</a><ul><li><a href="#字符串函数">字符串函数</a></li><li><a href="#数字函数">数字函数</a></li><li><a href="#日期函数">日期函数</a></li><li><a href="#其他函数">其他函数</a></li><li><a href="#自定义函数">自定义函数</a><ul><li><a href="#创建-create-function---returns">创建: CREATE FUNCTION - RETURNS</a></li><li><a href="#查看-show-create-function">查看: SHOW CREATE FUNCTION</a></li><li><a href="#删除-drop-function-function_name">删除: DROP FUNCTION function_name;</a></li><li><a href="#变量">变量</a><ul><li><a href="#全局变量-set-variable_name--variable_value">全局变量: SET @variable_name = variable_value;</a></li><li><a href="#局部变量-declare-variable_name-variable_type-default-variable_value">局部变量: DECLARE variable_name variable_type DEFAULT variable_value,</a></li></ul></li><li><a href="#调用-select-function_nameparams_list">调用: SELECT function_name(params_list);</a></li></ul></li></ul></li><li><a href="#事务">事务</a><ul><li><a href="#特点-1">特点</a></li><li><a href="#控制语句-begin-end-commit-rollback-savepoint">控制语句: BEGIN, END, COMMIT, ROLLBACK, SAVEPOINT</a></li></ul></li><li><a href="#全文搜索">全文搜索</a><ul><li><a href="#启用-fulltext">启用: FULLTEXT</a></li><li><a href="#搜索-match-against">搜索: MATCH, AGAINST</a></li><li><a href="#查询扩展-with-query-expansion">查询扩展: WITH QUERY EXPANSION</a></li><li><a href="#布尔文本搜索-in-boolean-mode">布尔文本搜索: IN BOOLEAN MODE</a></li></ul></li><li><a href="#存储过程-procedure">存储过程: PROCEDURE</a><ul><li><a href="#创建-create-procedure-procedure_name-">创建: CREATE PROCEDURE procedure_name(…) …;</a></li><li><a href="#删除-drop-procedure-procedure_name">删除: DROP PROCEDURE procedure_name;</a></li><li><a href="#调用-call-procedure_name">调用: CALL procedure_name(…);</a></li></ul></li><li><a href="#视图-view">视图: VIEW</a><ul><li><a href="#创建-create-view-view_name-as-">创建: CREATE VIEW view_name AS …;</a></li><li><a href="#查看-show-create-view-view_name">查看: SHOW CREATE VIEW view_name;</a></li><li><a href="#删除-drop-view-view_name">删除: DROP VIEW view_name;</a></li></ul></li><li><a href="#游标-cursor">游标: CURSOR</a><ul><li><a href="#创建-declare-cursor_name-cursor-for-">创建: DECLARE cursor_name CURSOR FOR …;</a></li><li><a href="#打开-open-cursor_name">打开: OPEN cursor_name;</a></li><li><a href="#关闭-close-cursor_name">关闭: CLOSE cursor_name;</a></li></ul></li><li><a href="#触发器-trigger">触发器: TRIGGER</a></li><li><a href="#reference">Reference</a></li></ul><p><img src="/2020/02/08/MySQL/数据定义.jpg" alt="数据定义"></p><h1 id="关系型数据库管理系统-RDBMS"><a href="#关系型数据库管理系统-RDBMS" class="headerlink" title="关系型数据库管理系统: RDBMS"></a>关系型数据库管理系统: RDBMS</h1><p>关系型数据库是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>数据以表格的形式出现；</li><li>每行为各种记录名称；</li><li>每列为记录名称所对应的数据域；</li><li>许多的行和列组成一张表单</li><li>若干的表单组成database。</li></ul><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul><li><strong>数据库</strong>: 数据库是一些关联表的集合。</li><li><strong>表</strong>: 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。</li><li><strong>列</strong>: 一列(数据元素) 包含了相同类型的数据, 例如邮政编码的数据。</li><li><strong>行</strong>：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。</li><li><strong>主键</strong>：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。<ul><li>用于唯一标识一条记录的一列(或一组列)；</li><li>在使用多列时，必须保证所有列值的组合时唯一的(此时单列可以不唯一)；</li><li>每行都必须有主键值(不允许NULL)；</li><li>任意两条记录不具有相同的主键值。</li></ul></li><li><strong>外键</strong>：外键用于关联两个表。</li><li><strong>复合键</strong>：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。</li><li><strong>索引</strong>：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。</li><li><strong>冗余</strong>：存储两倍数据，冗余降低了性能，但提高了数据的安全性。</li><li><strong>参照完整性</strong>: 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>在Ubuntu下安装MySQL命令如下<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install mysql-server             <span class="comment"># 安装</span></span><br><span class="line">$ sudo apt-get install libmysqlclient-dev</span><br><span class="line">$ sudo service mysql start                  <span class="comment"># 启动</span></span><br><span class="line">$ sudo mysql_secure_installation            <span class="comment"># 配置密码等</span></span><br><span class="line">$ sudo mysql -u root -p                     <span class="comment"># 登录</span></span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 4</span><br><span class="line">Server version: 5.7.30-0ubuntu0.18.04.1 (Ubuntu)</span><br><span class="line">Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective  owners.</span><br><span class="line">Type <span class="string">'help;'</span> or <span class="string">'\h'</span> <span class="keyword">for</span> <span class="built_in">help</span>. Type <span class="string">'\c'</span> to clear the current input statement.</span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure></p><h1 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h1><p>为结合实际讲解说明，生成一些测试数据如下<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一个临时内存表</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_bin_trust_function_creators=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`vote_recordss_memory`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`vote_recordss_memory`</span> (</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="string">`user_id`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">    <span class="string">`vote_num`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">    <span class="string">`group_id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">    <span class="string">`status`</span> tinyint(<span class="number">2</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'1'</span>,</span><br><span class="line">    <span class="string">`create_time`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'1971-01-01 01:01:01'</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">    <span class="keyword">KEY</span> <span class="string">`index_user_id`</span> (<span class="string">`user_id`</span>) <span class="keyword">USING</span> <span class="keyword">HASH</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">1</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建一个普通表，用作模拟大数据的测试用例</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`vote_records`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`vote_records`</span> (</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="string">`user_id`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'用户Id'</span>,</span><br><span class="line">    <span class="string">`vote_num`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'投票数'</span>,</span><br><span class="line">    <span class="string">`group_id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'用户组id 0-未激活用户 1-普通用户 2-vip用户 3-管理员用户'</span>,</span><br><span class="line">    <span class="string">`status`</span> tinyint(<span class="number">2</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'1'</span> <span class="keyword">COMMENT</span> <span class="string">'状态 1-正常 2-已删除'</span>,</span><br><span class="line">    <span class="string">`create_time`</span> datetime  <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'1971-01-01 01:01:01'</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">    <span class="keyword">KEY</span> <span class="string">`index_user_id`</span> (<span class="string">`user_id`</span>) <span class="keyword">USING</span> <span class="keyword">HASH</span> <span class="keyword">COMMENT</span> <span class="string">'用户ID哈希索引'</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'投票记录表'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为了数据的随机性和真实性，我们需要创建一个可生成长度为n的随机字符串的函数。</span></span><br><span class="line"><span class="comment">-- 创建生成长度为n的随机字符串的函数</span></span><br><span class="line">DELIMITER // <span class="comment">-- 修改MySQL delimiter：'//'</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`rand_strings`</span> //</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">NAMES</span> utf8 //</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> <span class="string">`rand_strings`</span> (n <span class="built_in">INT</span>) <span class="keyword">RETURNS</span> <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">CHARSET</span> <span class="string">'utf8'</span></span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line">    <span class="keyword">DECLARE</span> char_str <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="string">'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> return_str <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    WHILE i &lt; n DO</span><br><span class="line">        <span class="keyword">SET</span> return_str = <span class="keyword">concat</span>(return_str, <span class="keyword">substring</span>(char_str, <span class="keyword">FLOOR</span>(<span class="number">1</span> + <span class="keyword">RAND</span>()*<span class="number">62</span>), <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">SET</span> i = i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">WHILE</span>;</span><br><span class="line">    RETURN return_str;</span><br><span class="line"><span class="keyword">END</span> //</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为了操作方便，我们再创建一个插入数据的存储过程</span></span><br><span class="line"><span class="comment">-- 创建插入数据的存储过程</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`insert_vote_recordss_memory`</span> //</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> <span class="string">`insert_vote_recordss_memory`</span>(<span class="keyword">IN</span> n <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> vote_num <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> <span class="keyword">group_id</span> <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> <span class="keyword">status</span> TINYINT <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line">    WHILE i &lt; n DO</span><br><span class="line">        <span class="keyword">SET</span> vote_num = <span class="keyword">FLOOR</span>(<span class="number">1</span> + <span class="keyword">RAND</span>() * <span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">SET</span> <span class="keyword">group_id</span> = <span class="keyword">FLOOR</span>(<span class="number">0</span> + <span class="keyword">RAND</span>()*<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">SET</span> <span class="keyword">status</span> = <span class="keyword">FLOOR</span>(<span class="number">1</span> + <span class="keyword">RAND</span>()*<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`vote_recordss_memory`</span> <span class="keyword">VALUES</span> (<span class="literal">NULL</span>, rand_strings(<span class="number">20</span>), vote_num, <span class="keyword">group_id</span>, <span class="keyword">status</span>, <span class="keyword">NOW</span>());</span><br><span class="line">        <span class="keyword">SET</span> i = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">WHILE</span>;</span><br><span class="line"><span class="keyword">END</span> //</span><br><span class="line">DELIMITER ;  <span class="comment">-- 改回默认的 MySQL delimiter：';'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 开始执行存储过程，等待生成数据</span></span><br><span class="line"><span class="keyword">CALL</span> insert_vote_recordss_memory(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 把数据从内存表插入到普通表中</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> vote_records <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`vote_recordss_memory`</span>;</span><br></pre></td></tr></table></figure></p><p>可以看到表格创建成功<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW COLUMNS FROM vote_records;</span><br><span class="line">+<span class="comment">-------------+---------------------+------+-----+---------------------+----------------+</span></span><br><span class="line">| Field       | Type                | Null | Key | Default             | Extra          |</span><br><span class="line">+<span class="comment">-------------+---------------------+------+-----+---------------------+----------------+</span></span><br><span class="line">| id          | int(10) unsigned    | NO   | PRI | NULL                | auto_increment |</span><br><span class="line">| user_id     | varchar(20)         | NO   | MUL |                     |                |</span><br><span class="line">| vote_num    | int(10) unsigned    | NO   |     | 0                   |                |</span><br><span class="line">| group_id    | int(10) unsigned    | NO   |     | 0                   |                |</span><br><span class="line">| status      | tinyint(2) unsigned | NO   |     | 1                   |                |</span><br><span class="line">| create_time | datetime            | NO   |     | 1971-01-01 01:01:01 |                |</span><br><span class="line">+<span class="comment">-------------+---------------------+------+-----+---------------------+----------------+</span></span><br><span class="line">6 rows in <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure></p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="Text类型"><a href="#Text类型" class="headerlink" title="Text类型"></a>Text类型</h2><div class="table-container"><table><thead><tr><th>类型</th><th>大小(bytes)</th><th>用途</th></tr></thead><tbody><tr><td>CHAR</td><td>0-255</td><td>定长字符串</td></tr><tr><td>VARCHAR</td><td>0-65535</td><td>变长字符串</td></tr><tr><td>TINYBLOB</td><td>0-255</td><td>不超过 255 个字符的二进制字符串</td></tr><tr><td>BLOB</td><td>0-65 535</td><td>二进制形式的长文本数据</td></tr><tr><td>MEDIUMBLOB</td><td>0-16 777 215</td><td>二进制形式的中等长度文本数据</td></tr><tr><td>LONGBLOB</td><td>0-4 294 967 295</td><td>二进制形式的极大文本数据</td></tr><tr><td>TINYTEXT</td><td>0-255</td><td>短文本字符串</td></tr><tr><td>TEXT</td><td>0-65 535</td><td>长文本数据</td></tr><tr><td>MEDIUMTEXT</td><td>0-16 777 215</td><td>中等长度文本数据</td></tr><tr><td>LONGTEXT</td><td>0-4 294 967 295</td><td>极大文本数据</td></tr></tbody></table></div><h2 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h2><div class="table-container"><table><thead><tr><th>类型</th><th>大小(bytes)</th><th>范围（有符号）</th><th>范围（无符号）</th><th>用途</th></tr></thead><tbody><tr><td>TINYINT</td><td>1</td><td>(-128，127)</td><td>(0，255)</td><td>小整数值</td></tr><tr><td>SMALLINT</td><td>2</td><td>(-32 768，32 767)</td><td>(0，65 535)</td><td>大整数值</td></tr><tr><td>MEDIUMINT</td><td>3</td><td>(-8 388 608，8 388 607)</td><td>(0，16 777 215)</td><td>大整数值</td></tr><tr><td>INT或INTEGER</td><td>4</td><td>(-2 147 483 648，2 147 483 647)</td><td>(0，4 294 967 295)</td><td>大整数值</td></tr><tr><td>BIGINT</td><td>8</td><td>(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td><td>(0，18 446 744 073 709 551 615)</td><td>极大整数值</td></tr><tr><td>FLOAT</td><td>4</td><td>(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td><td>0，(1.175 494 351 E-38，3.402 823 466 E+38)</td><td>单精度浮点数值</td></tr><tr><td>DOUBLE</td><td>8</td><td>(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td>0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td>双精度浮点数值</td></tr><tr><td>DECIMAL</td><td>对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td>依赖于M和D的值</td><td>依赖于M和D的值</td><td>定点小数值</td></tr></tbody></table></div><h2 id="Date-Time类型"><a href="#Date-Time类型" class="headerlink" title="Date/Time类型"></a>Date/Time类型</h2><div class="table-container"><table><thead><tr><th>类型</th><th>大小(bytes)</th><th>范围</th><th>格式</th><th>用途</th></tr></thead><tbody><tr><td>YEAR</td><td>1</td><td>1901/2155</td><td>YYYY</td><td>年份值</td></tr><tr><td>DATE</td><td>3</td><td>1000-01-01/9999-12-31</td><td>YYYY-MM-DD</td><td>日期值</td></tr><tr><td>TIME</td><td>3</td><td>‘-838:59:59’/‘838:59:59’</td><td>HH:MM:SS</td><td>时间值或持续时间</td></tr><tr><td>DATETIME</td><td>8</td><td>1000-01-01 00:00:00/9999-12-31 23:59:59</td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值</td></tr><tr><td>TIMESTAMP</td><td>4</td><td>1970-01-01 00:00:00/2038，结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07</td><td>YYYYMMDD HHMMSS</td><td>混合日期和时间值，时间戳</td></tr></tbody></table></div><blockquote><p>注：在 INSERT 或 UPDATE 查询中，TIMESTAMP 自动把自身设置为当前的日期和时间。TIMESTAMP 也接受不同的格式，比如 YYYYMMDDHHMMSS、YYMMDDHHMMSS、YYYYMMDD 或 YYMMDD。</p></blockquote><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算术运算符-DIV-MOD"><a href="#算术运算符-DIV-MOD" class="headerlink" title="算术运算符: +, -, *, /, DIV, MOD"></a>算术运算符: +, -, *, /, DIV, MOD</h2><div class="table-container"><table><thead><tr><th>运算符</th><th>作用</th></tr></thead><tbody><tr><td>+</td><td>加法</td></tr><tr><td>-</td><td>减法</td></tr><tr><td>*</td><td>乘法</td></tr><tr><td>/</td><td>除法</td></tr><tr><td>DIV</td><td>取整</td></tr><tr><td>% 或 MOD</td><td>取余</td></tr></tbody></table></div><h2 id="比较运算符-lt-gt-lt-lt-gt-gt-BETWEEN-IN-lt-gt-LIKE-REGEXP-IS-NULL"><a href="#比较运算符-lt-gt-lt-lt-gt-gt-BETWEEN-IN-lt-gt-LIKE-REGEXP-IS-NULL" class="headerlink" title="比较运算符: =, &lt;&gt;/!=, &lt;, &lt;=, &gt;, &gt;=, BETWEEN, IN, &lt;=&gt;, LIKE, REGEXP, IS NULL"></a>比较运算符: =, &lt;&gt;/!=, &lt;, &lt;=, &gt;, &gt;=, BETWEEN, IN, &lt;=&gt;, LIKE, REGEXP, IS NULL</h2><div class="table-container"><table><thead><tr><th>符号</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>=</td><td>等于</td><td></td></tr><tr><td>&lt;&gt;, !=</td><td>不等于</td><td></td></tr><tr><td>&gt;</td><td>大于</td><td></td></tr><tr><td>&lt;</td><td>小于</td><td></td></tr><tr><td>&lt;=</td><td>小于等于</td><td></td></tr><tr><td>&gt;=</td><td>大于等于</td><td></td></tr><tr><td>BETWEEN</td><td>在两值之间</td><td>&gt;=min&amp;&amp;&lt;=max</td></tr><tr><td>NOT BETWEEN</td><td>不在两值之间</td><td></td></tr><tr><td>IN</td><td>在集合中</td><td></td></tr><tr><td>NOT IN</td><td>不在集合中</td><td></td></tr><tr><td>&lt;=&gt;</td><td>严格比较两个NULL值是否相等</td><td>两个操作码均为NULL时，其所得值为1；而当一个操作码为NULL时，其所得值为0</td></tr><tr><td>LIKE</td><td>模糊匹配</td><td></td></tr><tr><td>REGEXP 或 RLIKE</td><td>正则式匹配</td><td></td></tr><tr><td>IS NULL</td><td>为空</td><td></td></tr><tr><td>IS NOT NULL</td><td>不为空</td></tr></tbody></table></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select 'beijing' REGEXP 'jing';</span><br><span class="line">+<span class="comment">-------------------------+</span></span><br><span class="line">| 'beijing' REGEXP 'jing' |</span><br><span class="line">+<span class="comment">-------------------------+</span></span><br><span class="line">|                       1 |</span><br><span class="line">+<span class="comment">-------------------------+</span></span><br><span class="line"></span><br><span class="line">mysql&gt; select 'beijing' REGEXP 'xi';</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">| 'beijing' REGEXP 'xi' |</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">|                     0 |</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br></pre></td></tr></table></figure><h2 id="逻辑运算符-NOT-AND-OR-XOR"><a href="#逻辑运算符-NOT-AND-OR-XOR" class="headerlink" title="逻辑运算符: NOT, AND, OR, XOR"></a>逻辑运算符: NOT, AND, OR, XOR</h2><div class="table-container"><table><thead><tr><th>运算符号</th><th>作用</th></tr></thead><tbody><tr><td>NOT 或 !</td><td>逻辑非</td></tr><tr><td>AND</td><td>逻辑与</td></tr><tr><td>OR</td><td>逻辑或</td></tr><tr><td>XOR</td><td>逻辑异或</td></tr></tbody></table></div><h2 id="位运算符-amp-lt-lt-gt-gt"><a href="#位运算符-amp-lt-lt-gt-gt" class="headerlink" title="位运算符: &amp;, |, ^, !, &lt;&lt;, &gt;&gt;"></a>位运算符: &amp;, |, ^, !, &lt;&lt;, &gt;&gt;</h2><div class="table-container"><table><thead><tr><th>运算符号</th><th>作用</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与</td></tr><tr><td></td><td></td><td>按位或</td></tr><tr><td>^</td><td>按位异或</td></tr><tr><td>!</td><td>取反</td></tr><tr><td>&lt;&lt;</td><td>左移</td></tr><tr><td>&gt;&gt;</td><td>右移</td></tr></tbody></table></div><h1 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h1><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><h3 id="显示-SHOW-DATABASES"><a href="#显示-SHOW-DATABASES" class="headerlink" title="显示: SHOW DATABASES;"></a>显示: SHOW DATABASES;</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW DATABASES;</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">| Database           |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">| test               |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><h3 id="创建-CREATE-DATABASE-database"><a href="#创建-CREATE-DATABASE-database" class="headerlink" title="创建: CREATE DATABASE database;"></a>创建: CREATE DATABASE database;</h3><h3 id="删除-DROP-DATABASE-database"><a href="#删除-DROP-DATABASE-database" class="headerlink" title="删除: DROP DATABASE database;"></a>删除: DROP DATABASE database;</h3><h3 id="选择-USE-database"><a href="#选择-USE-database" class="headerlink" title="选择: USE database;"></a>选择: USE database;</h3><h2 id="数据表操作"><a href="#数据表操作" class="headerlink" title="数据表操作"></a>数据表操作</h2><h3 id="显示-SHOW-TABLES"><a href="#显示-SHOW-TABLES" class="headerlink" title="显示: SHOW TABLES;"></a>显示: SHOW TABLES;</h3><h3 id="创建-CREATE-TABLE-table-name-column-name-column-type"><a href="#创建-CREATE-TABLE-table-name-column-name-column-type" class="headerlink" title="创建: CREATE TABLE table_name (column_name column_type);"></a>创建: CREATE TABLE table_name (column_name column_type);</h3><p>在创建新表时，<strong>指定的表名必须不存在</strong>，否则将出错。为防止意外覆盖已有的表，SQL要求首先手工删除该表，然后再重建它，而不是简单地用创建表语句覆盖它。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> table_name;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line">(</span><br><span class="line">    field_name1 field_type1 [<span class="keyword">NOT</span> <span class="literal">NULL</span> [AUTO_INCREMENT [<span class="keyword">DEFAULT</span> <span class="keyword">default</span>]]],</span><br><span class="line">    field_name2 field_type2 [<span class="keyword">NOT</span> <span class="literal">NULL</span> [AUTO_INCREMENT [<span class="keyword">DEFAULT</span> <span class="keyword">default</span>]]],</span><br><span class="line">    ...,</span><br><span class="line">    field_nameN field_typeN [<span class="keyword">NOT</span> <span class="literal">NULL</span> [AUTO_INCREMENT [<span class="keyword">DEFAULT</span> <span class="keyword">default</span>]]],</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (key1, ..., keyM)</span><br><span class="line">) <span class="keyword">ENGINE</span> = engine_name ...;</span><br></pre></td></tr></table></figure></p><h4 id="缺失值限定-NOT-NULL"><a href="#缺失值限定-NOT-NULL" class="headerlink" title="缺失值限定: NOT NULL"></a>缺失值限定: NOT NULL</h4><p>可以通过<code>NOT NULL</code>关键字指定不接受空值的列，即在插入或更新行时，该列必须有值，否则返回错误。</p><h4 id="编号自增-AUTO-INCREMENT"><a href="#编号自增-AUTO-INCREMENT" class="headerlink" title="编号自增: AUTO_INCREMENT"></a>编号自增: AUTO_INCREMENT</h4><p>每次执行一个INSERT操作时，<strong>MySQL自动对该列增量，给该列赋予下一个可用的值</strong>。这样给每个行分配一个唯一的数值，从而可以用作主键值。<strong>每个表只允许一个AUTO_INCREMENT列，而且它必须被索引</strong>(如通过使他成为主键)。</p><p>可以在<code>INSERT</code>语句中对<code>AUTO_INCREMENT</code>的属性指定一个至今未使用过的值以<strong>覆盖当前值</strong>，后续的将以该值进行增加；可以通过<code>last_insert_id()</code>获取上一个自动增量值<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">last_insert_id</span>();</span><br></pre></td></tr></table></figure></p><h4 id="默认值-DEFAULT"><a href="#默认值-DEFAULT" class="headerlink" title="默认值: DEFAULT"></a>默认值: DEFAULT</h4><ul><li>与大多数DBMS不一样，MySQL不允许使用函数作为默认值，它只支持常量；</li><li>用于计算或数据分组的列最好设置默认值。</li></ul><h4 id="主键-PRIMARY-KEY"><a href="#主键-PRIMARY-KEY" class="headerlink" title="主键: PRIMARY KEY"></a>主键: PRIMARY KEY</h4><p>可以在<code>PRIMARY KEY()</code>中定义主键(一个或多个)，主键可以在创建表时定义，或者在创建表之后定义。</p><h4 id="引擎-ENGINE"><a href="#引擎-ENGINE" class="headerlink" title="引擎: ENGINE"></a>引擎: ENGINE</h4><p>MySQL具有多种引擎，具有不同的功能和特性，为不同的任务选择合适的引擎可以获得良好的功能和灵活性，以下为几个重要的引擎</p><ul><li><code>InnoDB</code>是一个可靠的事务处理引擎，<strong>不支持全文本搜索</strong>；</li><li><code>MyISAM</code>是一个性能极高的引擎，<strong>它支持全文本搜索，但不支持事务处理</strong>；</li><li><code>MEMORY</code>功能等同于<code>MyISAM</code>，<strong>数据存储在内存中</strong>，速度很快，特别适合于临时表。</li></ul><h4 id="临时表-CREATE-TEMPORARY-TABLE-table-name-column-name-column-type"><a href="#临时表-CREATE-TEMPORARY-TABLE-table-name-column-name-column-type" class="headerlink" title="临时表: CREATE TEMPORARY TABLE table_name (column_name column_type);"></a>临时表: CREATE TEMPORARY TABLE table_name (column_name column_type);</h4><p>在创建时用关键字<code>TEMPORARY</code>临时表，只在当前连接可见，当关闭连接时，Mysql会自动删除表并释放所有空间。</p><h3 id="更新-ALTER-TABLE-table-name"><a href="#更新-ALTER-TABLE-table-name" class="headerlink" title="更新: ALTER TABLE table_name;"></a>更新: ALTER TABLE table_name;</h3><p>理想状态下，表中存储数据后，该表就不应该被更新，在设计时应花大量时间考虑，以便后期不进行大的改动。</p><h4 id="表"><a href="#表" class="headerlink" title="表"></a>表</h4><h5 id="修改表名-RENAME"><a href="#修改表名-RENAME" class="headerlink" title="修改表名: RENAME"></a>修改表名: RENAME</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_old_name <span class="keyword">RENAME</span> <span class="keyword">TO</span> table_new_name</span><br></pre></td></tr></table></figure><h4 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h4><h5 id="添加-ADD"><a href="#添加-ADD" class="headerlink" title="添加: ADD"></a>添加: ADD</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> field_name field_type;</span><br></pre></td></tr></table></figure><h5 id="删除-DROP"><a href="#删除-DROP" class="headerlink" title="删除: DROP"></a>删除: DROP</h5><p>如果数据表中只剩余一个字段则无法使用<code>DROP</code>来删除字段。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> field_name;</span><br></pre></td></tr></table></figure></p><h5 id="修改名称-CHANGE"><a href="#修改名称-CHANGE" class="headerlink" title="修改名称: CHANGE"></a>修改名称: CHANGE</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">CHANGE</span> old_name new_name field_new_type;</span><br></pre></td></tr></table></figure><h5 id="修改类型-MODIFY"><a href="#修改类型-MODIFY" class="headerlink" title="修改类型: MODIFY"></a>修改类型: MODIFY</h5><p>可以指定是否包含值或者是否设置默认值<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">MODIFY</span> field_name field_new_type [<span class="keyword">NOT</span> <span class="literal">NULL</span> [<span class="keyword">DEFAULT</span> <span class="keyword">default</span>]];</span><br></pre></td></tr></table></figure></p><h4 id="修改默认值-SET"><a href="#修改默认值-SET" class="headerlink" title="修改默认值: SET"></a>修改默认值: SET</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ALTER</span> field_name <span class="keyword">SET</span> <span class="keyword">DEFAULT</span> <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure><h3 id="删除-DROP-TABLE-table-name"><a href="#删除-DROP-TABLE-table-name" class="headerlink" title="删除: DROP TABLE table_name;"></a>删除: DROP TABLE table_name;</h3><h2 id="用户账号"><a href="#用户账号" class="headerlink" title="用户账号"></a>用户账号</h2><h3 id="查看-USE-mysql"><a href="#查看-USE-mysql" class="headerlink" title="查看: USE mysql;"></a>查看: USE mysql;</h3><p>MYSQL用户账号的信息存储在名为<code>mysql</code>的数据库中<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use mysql;</span><br><span class="line">Reading table information for completion of table and column names</span><br><span class="line">You can turn off this feature to get a quicker startup <span class="keyword">with</span> -A</span><br><span class="line"><span class="keyword">Database</span> <span class="keyword">changed</span></span><br><span class="line">mysql&gt; <span class="keyword">show</span> <span class="keyword">tables</span>;</span><br><span class="line">+<span class="comment">---------------------------+</span></span><br><span class="line">| Tables_in_mysql           |</span><br><span class="line">+<span class="comment">---------------------------+</span></span><br><span class="line">| columns_priv              |</span><br><span class="line">| db                        |</span><br><span class="line">| engine_cost               |</span><br><span class="line">| event                     |</span><br><span class="line">| func                      |</span><br><span class="line">| general_log               |</span><br><span class="line">| gtid_executed             |</span><br><span class="line">| help_category             |</span><br><span class="line">| help_keyword              |</span><br><span class="line">| help_relation             |</span><br><span class="line">| help_topic                |</span><br><span class="line">| innodb_index_stats        |</span><br><span class="line">| innodb_table_stats        |</span><br><span class="line">| ndb_binlog_index          |</span><br><span class="line">| plugin                    |</span><br><span class="line">| proc                      |</span><br><span class="line">| procs_priv                |</span><br><span class="line">| proxies_priv              |</span><br><span class="line">| server_cost               |</span><br><span class="line">| servers                   |</span><br><span class="line">| slave_master_info         |</span><br><span class="line">| slave_relay_log_info      |</span><br><span class="line">| slave_worker_info         |</span><br><span class="line">| slow_log                  |</span><br><span class="line">| tables_priv               |</span><br><span class="line">| time_zone                 |</span><br><span class="line">| time_zone_leap_second     |</span><br><span class="line">| time_zone_name            |</span><br><span class="line">| time_zone_transition      |</span><br><span class="line">| time_zone_transition_type |</span><br><span class="line">| user                      |</span><br><span class="line">+<span class="comment">---------------------------+</span></span><br><span class="line">31 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> <span class="keyword">user</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">limit</span> <span class="number">5</span>;</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| user             |</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| debian-sys-maint |</span><br><span class="line">| mysql.session    |</span><br><span class="line">| mysql.sys        |</span><br><span class="line">| root             |</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">4 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure></p><h3 id="创建-CREATE-USER-user-name-IDENTIFIED-BY-‘passwod’"><a href="#创建-CREATE-USER-user-name-IDENTIFIED-BY-‘passwod’" class="headerlink" title="创建: CREATE USER user_name IDENTIFIED BY ‘passwod’;"></a>创建: CREATE USER user_name IDENTIFIED BY ‘passwod’;</h3><p>注意默认的密码要求<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE 'validate_password%';</span><br><span class="line">+<span class="comment">--------------------------------------+--------+</span></span><br><span class="line">| Variable_name                        | Value  |</span><br><span class="line">+<span class="comment">--------------------------------------+--------+</span></span><br><span class="line">| validate_password_check_user_name    | OFF    |</span><br><span class="line">| validate_password_dictionary_file    |        |</span><br><span class="line">| validate_password_length             | 8      |</span><br><span class="line">| validate_password_mixed_case_count   | 1      |</span><br><span class="line">| validate_password_number_count       | 1      |</span><br><span class="line">| validate_password_policy             | MEDIUM |</span><br><span class="line">| validate_password_special_char_count | 1      |</span><br><span class="line">+<span class="comment">--------------------------------------+--------+</span></span><br><span class="line">7 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p><h3 id="删除-DROP-USER-user-name"><a href="#删除-DROP-USER-user-name" class="headerlink" title="删除: DROP USER user_name;"></a>删除: DROP USER user_name;</h3><h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><h4 id="查看-SHOW-GRANTS-FOR-user-name"><a href="#查看-SHOW-GRANTS-FOR-user-name" class="headerlink" title="查看: SHOW GRANTS FOR user_name;"></a>查看: SHOW GRANTS FOR user_name;</h4><h4 id="修改-GRANT-REVOKE"><a href="#修改-GRANT-REVOKE" class="headerlink" title="修改: GRANT, REVOKE"></a>修改: GRANT, REVOKE</h4><h3 id="更改密码-SET-PASSWORD-FOR-user-name-PASSWORD-‘new-password’"><a href="#更改密码-SET-PASSWORD-FOR-user-name-PASSWORD-‘new-password’" class="headerlink" title="更改密码: SET PASSWORD FOR user_name = PASSWORD(‘new password’);"></a>更改密码: SET PASSWORD FOR user_name = PASSWORD(‘new password’);</h3><h1 id="过滤-WHERE"><a href="#过滤-WHERE" class="headerlink" title="过滤: WHERE"></a>过滤: WHERE</h1><ul><li>类似于程序语言中的 if 条件，根据 MySQL 表中的字段值来读取指定的数据；</li><li>可以运用于 SQL 的 <code>SELECT</code>、<code>DELETE</code> 或者 <code>UPDATE</code> 命令；</li><li>在同时使用<code>ORDER BY</code>和<code>WHERE</code>子句时，<strong>应该让<code>ORDER BY</code>位于<code>WHERE</code>之后</strong>，否则将会产生错误；</li></ul><h2 id="范围查询-lt-gt-lt-lt-gt-gt-BETWEEN-AND"><a href="#范围查询-lt-gt-lt-lt-gt-gt-BETWEEN-AND" class="headerlink" title="范围查询: =, &lt;&gt;, !=, &lt;, &lt;=, &gt;, &gt;=, BETWEEN-AND"></a>范围查询: =, &lt;&gt;, !=, &lt;, &lt;=, &gt;, &gt;=, BETWEEN-AND</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">field</span> <span class="keyword">BETWEEN</span> <span class="keyword">low</span> <span class="keyword">AND</span> <span class="keyword">high</span></span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td>=</td><td>等于</td></tr><tr><td>&lt;&gt;, !=</td><td>不等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>BETWEEN low AND high</td><td>在指定的两个值范围(包含这两个值)内</td></tr></tbody></table></div><h2 id="条件范围-IN"><a href="#条件范围-IN" class="headerlink" title="条件范围: IN"></a>条件范围: IN</h2><p>指定条件范围，由圆括号和逗号分隔的清单给出<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">field</span> <span class="keyword">IN</span> (value1, value2, ...)</span><br></pre></td></tr></table></figure></p><h2 id="否定关键字-NOT"><a href="#否定关键字-NOT" class="headerlink" title="否定关键字: NOT"></a>否定关键字: NOT</h2><p>即非运算符，否定之后所有的任何条件<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">field</span> <span class="keyword">NOT</span> <span class="keyword">IN</span> (value1, value2, ...)</span><br></pre></td></tr></table></figure></p><h2 id="组合子句-AND-OR"><a href="#组合子句-AND-OR" class="headerlink" title="组合子句: AND, OR"></a>组合子句: AND, OR</h2><p>可以通过<strong>逻辑操作符</strong>连接或改变<code>WHERE</code>子句中的子句关键字，可以通过<code>AND</code>和<code>OR</code>子句的方式使用。SQL在处理<code>OR</code>操作符前，优先处理<code>AND</code>操作符，使用<strong>圆括号</strong>明确地分组相应的操作符解决运算符优先级问题。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> condition1 <span class="keyword">AND</span> (condition2 <span class="keyword">OR</span> condition3) ...</span><br></pre></td></tr></table></figure></p><h2 id="空值检查-IS-NULL"><a href="#空值检查-IS-NULL" class="headerlink" title="空值检查: IS NULL"></a>空值检查: IS NULL</h2><p>在创建表时，表设计人员可以指定其中的列是否可以不包含值。在一个列不包含值时，称其为包含空值NULL。<strong>NULL无值(no value)</strong>，它与字段包含0、空字符串或仅仅包含空格不同。用<code>IS NULL</code>子句检查具有<code>NULL</code>值的列<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">field</span> <span class="keyword">IS</span> <span class="literal">NULL</span></span><br></pre></td></tr></table></figure><br>在通过过滤选择出不具有特定值的行时，你可能希望返回具有NULL值的行。但是，不行。因为未知具有特殊的含义，数据库不知道它们是否匹配，所以在匹配过滤或不匹配过滤时不返回它们。因此，在过滤数据时，一定要验证返回数据中确实给出了被过滤列具有NULL的行。</p><h2 id="通配符过滤-LIKE"><a href="#通配符过滤-LIKE" class="headerlink" title="通配符过滤: LIKE"></a>通配符过滤: LIKE</h2><p>在搜索子句中使用通配符，必须使用<code>LIKE</code>操作符，用于<strong>指示后跟的搜索模式利用通配符匹配而不是直接相等匹配进行比较</strong>，可以用<code>LIKE</code>子句代替等号。</p><p><strong>通配符搜索处理花费时间比其他搜索都要长</strong>，有以下技巧</p><ul><li>不要过度使用通配符，能用其他语句解决尽量用其他语句；</li><li><strong>尽量不要把通配符放在搜索模式的开头</strong>，这是最慢的；</li><li>注意通配符的位置，防止匹配错误。</li></ul><h3 id="匹配0个、1个或多个字符"><a href="#匹配0个、1个或多个字符" class="headerlink" title="匹配0个、1个或多个字符: %"></a>匹配0个、1个或多个字符: %</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">field</span> <span class="keyword">LIKE</span> pattern     <span class="comment">-- 如`&lt;head&gt;%`, `%&lt;tail&gt;`, `%&lt;body&gt;%`, `&lt;head&gt;%&lt;tail&gt;`等</span></span><br></pre></td></tr></table></figure><ul><li><code>NULL</code>无法被<code>%</code>匹配；</li><li>记录属性值的<strong>首尾空格被视作字符</strong>，不会被省略；</li><li>根据MySQL的配置方式，可以指定是否<strong>区分大小写</strong>。</li></ul><h3 id="只且必须匹配1个字符"><a href="#只且必须匹配1个字符" class="headerlink" title="只且必须匹配1个字符: _"></a>只且必须匹配1个字符: _</h3><p>功能与<code>%</code>类似，但是与<code>%</code>能匹配0个字符不一样，<code>_</code>总是匹配一个字符，不能多也不能少。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">field</span> <span class="keyword">LIKE</span> pattern     <span class="comment">-- 如`T_m`匹配`Tim, Tom, ...`</span></span><br></pre></td></tr></table></figure><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>TODO:</p><h1 id="查询-SELECT"><a href="#查询-SELECT" class="headerlink" title="查询: SELECT"></a>查询: SELECT</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">DISTINCT</span>] field1, field1, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name1, table_name2, ...</span><br><span class="line">[<span class="keyword">WHERE</span> condition]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> field1 [<span class="keyword">ASC</span>(<span class="keyword">default</span>)/<span class="keyword">DESC</span>, [field2 [<span class="keyword">ASC</span>(<span class="keyword">default</span>)/<span class="keyword">DESC</span>], ...]]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">field</span>]</span><br><span class="line">[<span class="keyword">LIMIT</span> N][ <span class="keyword">OFFSET</span> M];</span><br></pre></td></tr></table></figure><ul><li>指定<code>SELECT *</code>可返回所有列查询结果；</li><li><code>DISTINCT</code>关键字用于去重，应用于所有列而不仅是前置它的列；</li><li><code>LIMIT N</code>子句指示返回最多行数；</li><li><code>OFFSET M</code>指定<code>SELECT</code>语`句开始查询的数据偏移量。默认情况下偏移量为0。</li></ul><p>注意<code>SELECT</code>子句的<strong>执行顺序</strong></p><div class="table-container"><table><thead><tr><th>子句</th><th>说明</th><th>是否必须使用</th></tr></thead><tbody><tr><td>SELECT</td><td>要返回的列或者表达式</td><td>是</td></tr><tr><td>FROM</td><td>从中检索数据的表</td><td>仅在从表里选择数据时使用</td></tr><tr><td>WHERE</td><td>行级查询</td><td>否</td></tr><tr><td>GROUP BY</td><td>分组说明</td><td>仅在按组计算聚集时使用</td></tr><tr><td>HAVING</td><td>组间过滤（用在GROPUP BY之后）</td><td>否</td></tr><tr><td>ORDER BY</td><td>设置输出排序顺序</td><td>否</td></tr><tr><td>LIMIT</td><td>要检索的函数</td><td>否</td></tr></tbody></table></div><h2 id="排序-ORDER-BY"><a href="#排序-ORDER-BY" class="headerlink" title="排序: ORDER BY"></a>排序: ORDER BY</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">field</span> <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><p>若不指定排序，则返回记录的顺序无实际意义。关系数据库设计理论认为，<strong>如果不明确规定排序顺序，则不应该假定检索出的数据的顺序有意义</strong>。</p><ul><li>可以用非检索的列对记录进行排序，即<code>field</code>无需出现在<code>SELECT</code>中；</li><li>按多个列排序时，排序完全按所规定的顺序进行，即先比较<code>field1</code>，在<code>field1</code>值相同的记录中，比较<code>field2</code>继续排序；</li><li>默认按升序排序<code>ASC</code>，可指定为降序<code>DESC</code>，该关键字只应用到直接位于其前面的列名。</li></ul><p><strong>例</strong>：从表中查询所有vip的id，并按创建时间排序<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT user_id </span><br><span class="line">    -&gt; FROM vote_records </span><br><span class="line">    -&gt; WHERE group_id = 2 </span><br><span class="line">    -&gt; ORDER BY create_time;</span><br><span class="line">    -&gt; LIMIT 5</span><br><span class="line">+<span class="comment">----------------------+</span></span><br><span class="line">| user_id              |</span><br><span class="line">+<span class="comment">----------------------+</span></span><br><span class="line">| GYEaLaoh2cIRY6tUXVzX |</span><br><span class="line">| 2dNctAlNOx3xkSgvCnTc |</span><br><span class="line">| fObjP4F1UkKCHt6VaUTy |</span><br><span class="line">| Nw5I8pqMrJcBfhusGS90 |</span><br><span class="line">| Zf8LfLXkD12WrgO7YmHg |</span><br><span class="line">+<span class="comment">----------------------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure></p><h2 id="分组-GROUP-BY"><a href="#分组-GROUP-BY" class="headerlink" title="分组: GROUP BY"></a>分组: GROUP BY</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">field</span></span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">field</span></span><br></pre></td></tr></table></figure><p><strong>例</strong>：从表中查询所有vip的id，并按用户状态分组<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT user_id, COUNT(*) AS count_id </span><br><span class="line">    -&gt; FROM vote_records </span><br><span class="line">    -&gt; WHERE group_id = 2 </span><br><span class="line">    -&gt; GROUP BY status;</span><br><span class="line">+<span class="comment">----------------------+----------+</span></span><br><span class="line">| user_id              | count_id |</span><br><span class="line">+<span class="comment">----------------------+----------+</span></span><br><span class="line">| 2dNctAlNOx3xkSgvCnTc |     1655 |</span><br><span class="line">| GYEaLaoh2cIRY6tUXVzX |     1667 |</span><br><span class="line">+<span class="comment">----------------------+----------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure></p><h2 id="分组过滤-HAVING"><a href="#分组过滤-HAVING" class="headerlink" title="分组过滤: HAVING"></a>分组过滤: HAVING</h2><p>可以设定条件过滤分组，支持所有的<code>WHERE</code>操作符。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">field</span></span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">field</span></span><br><span class="line"><span class="keyword">HAVING</span> condition</span><br></pre></td></tr></table></figure></p><p><strong>例</strong>：从表中查询所有vip的id，并按用户状态分组，筛选出投票数大于2000的用户<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT user_id, vote_num, COUNT(*) AS count_id </span><br><span class="line">    -&gt; FROM vote_records </span><br><span class="line">    -&gt; WHERE group_id = 2 </span><br><span class="line">    -&gt; GROUP BY status</span><br><span class="line">    -&gt; HAVING vote_num &gt; 2000;</span><br><span class="line">+<span class="comment">----------------------+----------+----------+</span></span><br><span class="line">| user_id              | COUNT(*) | vote_num |</span><br><span class="line">+<span class="comment">----------------------+----------+----------+</span></span><br><span class="line">| GYEaLaoh2cIRY6tUXVzX |     1667 |     5341 |</span><br><span class="line">+<span class="comment">----------------------+----------+----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p><h2 id="子查询-SELECT"><a href="#子查询-SELECT" class="headerlink" title="子查询: SELECT"></a>子查询: SELECT</h2><p>将查询嵌套在其他查询中，例如<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select cust_id</span><br><span class="line">    -&gt; from orders</span><br><span class="line">    -&gt; where order_num in (</span><br><span class="line">    -&gt;    select order_num</span><br><span class="line">    -&gt;    from orderitems</span><br><span class="line">    -&gt;    where prod_id = 'TNT2');</span><br></pre></td></tr></table></figure></p><h2 id="组合查询-UNION"><a href="#组合查询-UNION" class="headerlink" title="组合查询: UNION"></a>组合查询: UNION</h2><p>用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中</p><ul><li>必须由两条或两条以上的<code>SELECT</code>语句组成，语句间用<code>UNION</code>关键字分割；</li><li>每个<code>SELECT</code>语句必须包含相同的列、表达式或聚集函数，但列的次序不需要一致；</li><li>列数据类型必须兼容，能隐式转换类型也可以。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> field1, field2, ... field_n</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">tables</span></span><br><span class="line">[<span class="keyword">WHERE</span> conditions]</span><br><span class="line"><span class="keyword">UNION</span> [ALL | <span class="keyword">DISTINCT</span>]      <span class="comment">-- 默认`DISTINCT`，即去重；`ALL`表示返回所有结果，不进行去重</span></span><br><span class="line"><span class="keyword">SELECT</span> field1, field2, ... field_n</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">tables</span></span><br><span class="line">[<span class="keyword">WHERE</span> conditions];</span><br></pre></td></tr></table></figure><h1 id="插入-INSERT-INTO"><a href="#插入-INSERT-INTO" class="headerlink" title="插入: INSERT INTO"></a>插入: INSERT INTO</h1><p>对于不指定列名的插入语句，需要对每个列依次提供一个值，虽然这种语法很简单，但并不安全，应该尽量避免使用。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name</span><br><span class="line"><span class="keyword">VALUES</span> (</span><br><span class="line">    value1, </span><br><span class="line">    value2, </span><br><span class="line">    ..., </span><br><span class="line">    valueN);</span><br></pre></td></tr></table></figure></p><p>在表名后明确指定部分或全部列名，各个值将被插入到对应的列中，次序不影响结果<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (</span><br><span class="line">    field1, </span><br><span class="line">    field2,</span><br><span class="line">    ...,</span><br><span class="line">    fieldN)</span><br><span class="line"><span class="keyword">VALUES</span> (</span><br><span class="line">    value1, </span><br><span class="line">    value2, </span><br><span class="line">    ..., </span><br><span class="line">    valueN);</span><br></pre></td></tr></table></figure></p><p>还可同时插入多行数据<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (</span><br><span class="line">    field1, </span><br><span class="line">    field2,</span><br><span class="line">    ...,</span><br><span class="line">    fieldN)</span><br><span class="line"><span class="keyword">VALUES</span> (</span><br><span class="line">    value1, </span><br><span class="line">    value2, </span><br><span class="line">    ..., </span><br><span class="line">    valueN),</span><br><span class="line">    (</span><br><span class="line">    value1, </span><br><span class="line">    value2, </span><br><span class="line">    ..., </span><br><span class="line">    valueN);</span><br></pre></td></tr></table></figure></p><p>插入从其他表中检索得到的数据(复制表)<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (</span><br><span class="line">    field1, </span><br><span class="line">    field2,</span><br><span class="line">    ...,</span><br><span class="line">    fieldN)</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    field1, </span><br><span class="line">    field2,</span><br><span class="line">    ...,</span><br><span class="line">    fieldN</span><br><span class="line"><span class="keyword">FROM</span> another_table_name;</span><br></pre></td></tr></table></figure></p><h1 id="更新-UPDATE-SET"><a href="#更新-UPDATE-SET" class="headerlink" title="更新: UPDATE-SET"></a>更新: UPDATE-SET</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name </span><br><span class="line"><span class="keyword">SET</span> field1 = new_value1, field2 = new_value2</span><br><span class="line">[<span class="keyword">WHERE</span> condition]</span><br></pre></td></tr></table></figure><ul><li>可以将值设置为<code>NULL</code>以删除它，例如用于将整列数据删除；</li><li>若用<code>UPDATE</code>更新多行时，其中一行或多行出现一个错误，那么整个操作被取消，可以使用<code>IGNORE</code>关键忽略错误行继续更新。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">IGNORE</span> table_name </span><br><span class="line"><span class="keyword">SET</span> field1 = new_value1, field2 = new_value2</span><br><span class="line">[<span class="keyword">WHERE</span> condition]</span><br></pre></td></tr></table></figure></li></ul><h1 id="删除-DELETE-FROM"><a href="#删除-DELETE-FROM" class="headerlink" title="删除: DELETE FROM"></a>删除: DELETE FROM</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> </span><br><span class="line"><span class="keyword">FROM</span> table_name </span><br><span class="line">[<span class="keyword">WHERE</span> condition]</span><br></pre></td></tr></table></figure><blockquote><p>在使用<code>UPDATE</code>和<code>DELETE</code>时应遵循如下习惯</p><ul><li>必须非常注意<code>WHERE</code>子句，防止数据丢失；</li><li>先用<code>SELECT</code>查询需删除的记录，确保没有问题；</li><li>保证每个表都有主键，尽可能像<code>WHERE</code>子句那样使用(可以指定各主键、多个值或值得范围)；</li><li>使用强制实施引用完整性的数据库，这样MySQL将不允许删除具有与其他表相关联的数据的行。</li></ul></blockquote><h1 id="连接-JOIN-ON"><a href="#连接-JOIN-ON" class="headerlink" title="连接: JOIN-ON"></a>连接: JOIN-ON</h1><p>创建两个表如下<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database RUNOOB;</span><br><span class="line">mysql&gt; use RUNOOB;</span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line">mysql&gt; create table tcount_tbl(</span><br><span class="line">    -&gt; runoob_author varchar(20),</span><br><span class="line">    -&gt; runoob_count int(2)</span><br><span class="line">    -&gt; );</span><br><span class="line">    Query OK, 0 rows affected (0.06 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into tcount_tbl</span><br><span class="line">    -&gt; (runoob_author, runoob_count)</span><br><span class="line">    -&gt; values</span><br><span class="line">    -&gt; ("runoob", 10),</span><br><span class="line">    -&gt; ("RUNOOB.COM", 20),</span><br><span class="line">    -&gt; ("Google", 22);</span><br><span class="line">    Query OK, 3 rows affected (0.01 sec)</span><br><span class="line">    Records: 3  Duplicates: 0  Warnings: 0 </span><br><span class="line"></span><br><span class="line">mysql&gt; create table runoob_tbl(</span><br><span class="line">    -&gt; runoob_id int(4),</span><br><span class="line">    -&gt; runoob_title varchar(20),</span><br><span class="line">    -&gt; runoob_author varchar(20),</span><br><span class="line">    -&gt; submission_date date);</span><br><span class="line">    Query OK, 0 rows affected (0.03 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into runoob_tbl</span><br><span class="line">    -&gt; (runoob_id, runoob_title, runoob_author, submission_date)</span><br><span class="line">    -&gt; values</span><br><span class="line">    -&gt; (1, "PHP", "runoob", "2017-04-12"),</span><br><span class="line">    -&gt; (2, "MySQL", "runoob", "2017-04-12"),</span><br><span class="line">    -&gt; (3, "Java", "RUNOOB.COM", "2015-05-01"),</span><br><span class="line">    -&gt; (4, "Python", "RUNOOB.COM", "2016-03-06"),</span><br><span class="line">    -&gt; (5, "C", "FK", "2017-04-05");</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM tcount_tbl;</span><br><span class="line">+<span class="comment">---------------+--------------+</span></span><br><span class="line">| runoob_author | runoob_count |</span><br><span class="line">+<span class="comment">---------------+--------------+</span></span><br><span class="line">| runoob        | 10           |</span><br><span class="line">| RUNOOB.COM    | 20           |</span><br><span class="line">| Google        | 22           |</span><br><span class="line">+<span class="comment">---------------+--------------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; <span class="keyword">SELECT</span> * <span class="keyword">from</span> runoob_tbl;</span><br><span class="line">+<span class="comment">-----------+---------------+---------------+-----------------+</span></span><br><span class="line">| runoob_id | runoob_title  | runoob_author | submission_date |</span><br><span class="line">+<span class="comment">-----------+---------------+---------------+-----------------+</span></span><br><span class="line">| 1         | PHP           | runoob        | 2017-04-12      |</span><br><span class="line">| 2         | MySQL         | runoob        | 2017-04-12      |</span><br><span class="line">| 3         | Java          | RUNOOB.COM    | 2015-05-01      |</span><br><span class="line">| 4         | Python        | RUNOOB.COM    | 2016-03-06      |</span><br><span class="line">| 5         | C             | FK            | 2017-04-05      |</span><br><span class="line">+<span class="comment">-----------+---------------+---------------+-----------------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure></p><h2 id="创建连接-WHERE"><a href="#创建连接-WHERE" class="headerlink" title="创建连接: WHERE"></a>创建连接: WHERE</h2><p>读取<code>runoob_tbl</code>表中所有<code>runoob_author</code>字段在<code>tcount_tbl</code>表对应的<code>runoob_count</code>字段值<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT a.runoob_id, a.runoob_author, b.runoob_count  -- 完全限定列名</span><br><span class="line">    -&gt; FROM runoob_tbl AS a, tcount_tbl AS b </span><br><span class="line">    -&gt; WHERE a.runoob_author = b.runoob_author;</span><br><span class="line">+<span class="comment">-------------+-----------------+----------------+</span></span><br><span class="line">| a.runoob_id | a.runoob_author | b.runoob_count |</span><br><span class="line">+<span class="comment">-------------+-----------------+----------------+</span></span><br><span class="line">| 1           | runoob          | 10             |</span><br><span class="line">| 2           | runoob          | 10             |</span><br><span class="line">| 3           | RUNOOB.COM      | 20             |</span><br><span class="line">| 4           | RUNOOB.COM      | 20             |</span><br><span class="line">+<span class="comment">-------------+-----------------+----------------+</span></span><br><span class="line">4 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure></p><h2 id="内连接-等值连接-：JOIN-或-INNER-JOIN"><a href="#内连接-等值连接-：JOIN-或-INNER-JOIN" class="headerlink" title="内连接(等值连接)：JOIN 或 INNER JOIN"></a>内连接(等值连接)：JOIN 或 INNER JOIN</h2><p>读取<code>runoob_tbl</code>表中所有<code>runoob_author</code>字段在<code>tcount_tbl</code>表对应的<code>runoob_count</code>字段值<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT a.runoob_id, a.runoob_author, b.runoob_count  -- 完全限定列名</span><br><span class="line">    -&gt; FROM runoob_tbl AS a INNER JOIN tcount_tbl AS b </span><br><span class="line">    -&gt; ON a.runoob_author = b.runoob_author;</span><br><span class="line">+<span class="comment">-------------+-----------------+----------------+</span></span><br><span class="line">| a.runoob_id | a.runoob_author | b.runoob_count |</span><br><span class="line">+<span class="comment">-------------+-----------------+----------------+</span></span><br><span class="line">| 1           | runoob          | 10             |</span><br><span class="line">| 2           | runoob          | 10             |</span><br><span class="line">| 3           | RUNOOB.COM      | 20             |</span><br><span class="line">| 4           | RUNOOB.COM      | 20             |</span><br><span class="line">+<span class="comment">-------------+-----------------+----------------+</span></span><br><span class="line">4 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p><h2 id="左连接：LEFT-JOIN"><a href="#左连接：LEFT-JOIN" class="headerlink" title="左连接：LEFT JOIN"></a>左连接：LEFT JOIN</h2><p>会读取左边数据表的全部数据，即便右边表无对应数据。注意<code>tcount_tbl</code>的<code>runoob_author</code>字段中存在值<code>&quot;FK&quot;</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT a.runoob_id, a.runoob_author, b.runoob_count </span><br><span class="line">    -&gt; FROM runoob_tbl AS a LEFT JOIN tcount_tbl AS b </span><br><span class="line">    -&gt; ON a.runoob_author = b.runoob_author;</span><br><span class="line">+<span class="comment">-------------+-----------------+----------------+</span></span><br><span class="line">| a.runoob_id | a.runoob_author | b.runoob_count |</span><br><span class="line">+<span class="comment">-------------+-----------------+----------------+</span></span><br><span class="line">| 1           | runoob          | 10             |</span><br><span class="line">| 2           | runoob          | 10             |</span><br><span class="line">| 3           | RUNOOB.COM      | 20             |</span><br><span class="line">| 4           | RUNOOB.COM      | 20             |</span><br><span class="line">| 5           | FK              | NULL           |</span><br><span class="line">+<span class="comment">-------------+-----------------+----------------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><h2 id="右连接：RIGHT-JOIN"><a href="#右连接：RIGHT-JOIN" class="headerlink" title="右连接：RIGHT JOIN"></a>右连接：RIGHT JOIN</h2><p>读取右边数据表的全部数据，即便左边边表无对应数据。注意<code>tcount_tbl</code>的<code>runoob_count</code>字段中存在值<code>&quot;22&quot;</code>。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT a.runoob_id, a.runoob_author, b.runoob_count </span><br><span class="line">    -&gt; FROM runoob_tbl AS a RIGHT JOIN tcount_tbl AS b </span><br><span class="line">    -&gt; ON a.runoob_author = b.runoob_author;</span><br><span class="line">+<span class="comment">-------------+-----------------+----------------+</span></span><br><span class="line">| a.runoob_id | a.runoob_author | b.runoob_count |</span><br><span class="line">+<span class="comment">-------------+-----------------+----------------+</span></span><br><span class="line">| 1           | runoob          | 10             |</span><br><span class="line">| 2           | runoob          | 10             |</span><br><span class="line">| 3           | RUNOOB.COM      | 20             |</span><br><span class="line">| 4           | RUNOOB.COM      | 20             |</span><br><span class="line">| NULL        | NULL            | 22             |</span><br><span class="line">+<span class="comment">-------------+-----------------+----------------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure></p><h1 id="函数-FUNCTION"><a href="#函数-FUNCTION" class="headerlink" title="函数: FUNCTION"></a>函数: FUNCTION</h1><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><div class="table-container"><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>ASCII(s)</td><td>返回字符串 s 的第一个字符的 ASCII 码。</td></tr><tr><td>CHAR_LENGTH(s)</td><td>返回字符串 s 的字符数</td></tr><tr><td>CHARACTER_LENGTH(s)</td><td>返回字符串 s 的字符数</td></tr><tr><td>CONCAT(s1,s2…sn)</td><td>字符串 s1,s2 等多个字符串合并为一个字符串</td></tr><tr><td>CONCAT_WS(x, s1,s2…sn)</td><td>同 CONCAT(s1,s2,…) 函数，但是每个字符串之间要加上 x，x 可以是分隔符</td></tr><tr><td>FIELD(s,s1,s2…)</td><td>返回第一个字符串 s 在字符串列表(s1,s2…)中的位置</td></tr><tr><td>FIND_IN_SET(s1,s2)</td><td>返回在字符串s2中与s1匹配的字符串的位置</td></tr><tr><td>FORMAT(x,n)</td><td>函数可以将数字 x 进行格式化 “#,###.##”, 将 x 保留到小数点后 n 位，最后一位四舍五入。</td></tr><tr><td>INSERT(s1,x,len,s2)</td><td>字符串 s2 替换 s1 的 x 位置开始长度为 len 的字符串</td></tr><tr><td>LOCATE(s1,s)</td><td>从字符串 s 中获取 s1 的开始位置</td></tr><tr><td>LCASE(s)</td><td>将字符串 s 的所有字母变成小写字母</td></tr><tr><td>LOWER(s)</td><td>将字符串 s 的所有字母变成小写字母</td></tr><tr><td>UCASE(s)</td><td>将字符串转换为大写</td></tr><tr><td>UPPER(s)</td><td>将字符串转换为大写</td></tr><tr><td>LEFT(s,n)</td><td>返回字符串 s 的前 n 个字符</td></tr><tr><td>RIGHT(s,n)</td><td>返回字符串 s 的后 n 个字符</td></tr><tr><td>LPAD(s1,len,s2)</td><td>在字符串 s1 的开始处填充字符串 s2，使字符串长度达到 len</td></tr><tr><td>RPAD(s1,len,s2)</td><td>在字符串 s1 的结尾处添加字符串 s2，使字符串的长度达到 len</td></tr><tr><td>TRIM(s)</td><td>去掉字符串 s 开始和结尾处的空格</td></tr><tr><td>LTRIM(s)</td><td>去掉字符串 s 开始处的空格</td></tr><tr><td>RTRIM(s)</td><td>去掉字符串 s 结尾处的空格</td></tr><tr><td>MID(s,n,len)</td><td>从字符串 s 的 n 位置截取长度为 len 的子字符串，同 SUBSTRING(s,n,len)</td></tr><tr><td>REPEAT(s,n)</td><td>将字符串 s 重复 n 次</td></tr><tr><td>REPLACE(s,s1,s2)</td><td>将字符串 s2 替代字符串 s 中的字符串 s1</td></tr><tr><td>REVERSE(s)</td><td>将字符串s的顺序反过来</td></tr><tr><td>SPACE(n)</td><td>返回 n 个空格</td></tr><tr><td>POSITION(s1 IN s)</td><td>从字符串 s 中获取 s1 的开始位置</td></tr><tr><td>STRCMP(s1,s2)</td><td>比较字符串 s1 和 s2，如果 s1 与 s2 相等返回 0 ，如果 s1&gt;s2 返回 1，如果 s1 &lt; s2 返回 -1</td></tr><tr><td>SUBSTR(s, start, length)</td><td>从字符串 s 的 start 位置截取长度为 length 的子字符串</td></tr><tr><td>SUBSTRING(s, start, length)</td><td>从字符串 s 的 start 位置截取长度为 length 的子字符串</td></tr><tr><td>SUBSTRING_INDEX(s, delimiter, number)</td><td>返回从字符串 s 的第 number 个出现的分隔符 delimiter 之后的子串。如果 number 是正数，返回第 number 个字符左边的字符串；如果 number 是负数，返回第(number 的绝对值(从右边数))个字符右边的字符串。</td></tr></tbody></table></div><h2 id="数字函数"><a href="#数字函数" class="headerlink" title="数字函数"></a>数字函数</h2><div class="table-container"><table><thead><tr><th>函数名</th><th>描述</th></tr></thead><tbody><tr><td>COUNT(expression)</td><td>返回查询的记录总数，expression 参数是一个字段或者 * 号</td></tr><tr><td>AVG(expression)</td><td>返回一个表达式的平均值，expression 是一个字段</td></tr><tr><td>SUM(expression)</td><td>返回指定字段的总和</td></tr><tr><td>MAX(expression)</td><td>返回字段 expression 中的最大值</td></tr><tr><td>MIN(expression)</td><td>返回字段 expression 中的最小值</td></tr><tr><td>GREATEST(expr1, expr2, expr3, …)</td><td>返回列表中的最大值</td></tr><tr><td>LEAST(expr1, expr2, expr3, …)</td><td>返回列表中的最小值</td></tr><tr><td>ABS(x)</td><td>返回 x 的绝对值　　</td></tr><tr><td>SIGN(x)</td><td>返回 x 的符号，x 是负数、0、正数分别返回 -1、0 和 1　</td></tr><tr><td>ROUND(x)</td><td>返回离 x 最近的整数</td></tr><tr><td>FLOOR(x)</td><td>返回小于或等于 x 的最大整数　　</td></tr><tr><td>CEIL(x)</td><td>返回大于或等于 x 的最小整数　</td></tr><tr><td>CEILING(x)</td><td>返回大于或等于 x 的最小整数　</td></tr><tr><td>TRUNCATE(x,y)</td><td>返回数值 x 保留到小数点后 y 位的值（与 ROUND 最大的区别是不会进行四舍五入）</td></tr><tr><td>n DIV m</td><td>整除，n 为被除数，m 为除数</td></tr><tr><td>MOD(x,y)</td><td>返回 x 除以 y 以后的余数　</td></tr><tr><td>SQRT(x)</td><td>返回x的平方根　　</td></tr><tr><td>EXP(x)</td><td>返回 e 的 x 次方　　</td></tr><tr><td>POW(x,y)</td><td>返回 x 的 y 次方　</td></tr><tr><td>POWER(x,y)</td><td>返回 x 的 y 次方　</td></tr><tr><td>LN(x)</td><td>返回数字的自然对数，以 e 为底。</td></tr><tr><td>LOG(x) 或 LOG(base, x)</td><td>返回自然对数(以 e 为底的对数)，如果带有 base 参数，则 base 为指定带底数。　　</td></tr><tr><td>LOG2(x)</td><td>返回以 2 为底的对数</td></tr><tr><td>LOG10(x)</td><td>返回以 10 为底的对数　　</td></tr><tr><td>PI()</td><td>返回圆周率(3.141593）　　</td></tr><tr><td>DEGREES(x)</td><td>将弧度转换为角度　　</td></tr><tr><td>RADIANS(x)</td><td>将角度转换为弧度　　</td></tr><tr><td>SIN(x)</td><td>求正弦值(参数是弧度)　　</td></tr><tr><td>COS(x)</td><td>求余弦值(参数是弧度)</td></tr><tr><td>TAN(x)</td><td>求正切值(参数是弧度)</td></tr><tr><td>COT(x)</td><td>求余切值(参数是弧度)</td></tr><tr><td>ACOS(x)</td><td>求 x 的反余弦值(参数是弧度)</td></tr><tr><td>ASIN(x)</td><td>求反正弦值(参数是弧度)</td></tr><tr><td>ATAN(x)</td><td>求反正切值(参数是弧度)</td></tr><tr><td>ATAN2(n, m)</td><td>求反正切值(参数是弧度)</td></tr><tr><td>RAND()</td><td>返回 0 到 1 的随机数　　</td></tr></tbody></table></div><h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h2><div class="table-container"><table><thead><tr><th>函数名</th><th>描述</th></tr></thead><tbody><tr><td>ADDDATE(d,n)</td><td>计算起始日期 d 加上 n 天的日期</td></tr><tr><td>ADDTIME(t,n)</td><td>时间 t 加上 n 秒的时间</td></tr><tr><td>CURDATE()</td><td>返回当前日期</td></tr><tr><td>CURRENT_DATE()</td><td>返回当前日期</td></tr><tr><td>CURRENT_TIME</td><td>返回当前时间</td></tr><tr><td>CURRENT_TIMESTAMP()</td><td>返回当前日期和时间</td></tr><tr><td>CURTIME()</td><td>返回当前时间</td></tr><tr><td>DATE()</td><td>从日期或日期时间表达式中提取日期值</td></tr><tr><td>DATEDIFF(d1,d2)</td><td>计算日期 d1-&gt;d2 之间相隔的天数</td></tr><tr><td>ADDDATE(d，INTERVAL expr type)</td><td>计算起始日期 d 加上一个时间段后的日期</td></tr><tr><td>DATE_FORMAT(d,f)</td><td>按表达式 f的要求显示日期 d</td></tr><tr><td>DATE_SUB(date,INTERVAL expr type)</td><td>函数从日期减去指定的时间间隔。</td></tr><tr><td>DAY(d)</td><td>返回日期值 d 的日期部分</td></tr><tr><td>DAYNAME(d)</td><td>返回日期 d 是星期几，如 Monday,Tuesday</td></tr><tr><td>DAYOFMONTH(d)</td><td>计算日期 d 是本月的第几天</td></tr><tr><td>DAYOFWEEK(d)</td><td>日期 d 今天是星期几，1 星期日，2 星期一，以此类推</td></tr><tr><td>DAYOFYEAR(d)</td><td>计算日期 d 是本年的第几天</td></tr><tr><td>EXTRACT(type FROM d)</td><td>从日期 d 中获取指定的值，type 指定返回的值。type可取值为：MICROSECOND, SECOND, MINUTE, HOUR, DAY, WEEK, MONTH, QUARTER, YEAR, SECOND_MICROSECOND, MINUTE_MICROSECOND, MINUTE_SECOND, HOUR_MICROSECOND, HOUR_SECOND, HOUR_MINUTE, DAY_MICROSECOND, DAY_SECOND, DAY_MINUTE, DAY_HOUR, YEAR_MONTH</td></tr><tr><td>FROM_DAYS(n)</td><td>计算从 0000 年 1 月 1 日开始 n 天后的日期</td></tr><tr><td>HOUR(t)</td><td>返回 t 中的小时值</td></tr><tr><td>LAST_DAY(d)</td><td>返回给给定日期的那一月份的最后一天</td></tr><tr><td>LOCALTIME()</td><td>返回当前日期和时间</td></tr><tr><td>LOCALTIMESTAMP()</td><td>返回当前日期和时间</td></tr><tr><td>MAKEDATE(year, day-of-year)</td><td>基于给定参数年份 year 和所在年中的天数序号 day-of-year 返回一个日期</td></tr><tr><td>MAKETIME(hour, minute, second)</td><td>组合时间，参数分别为小时、分钟、秒</td></tr><tr><td>MICROSECOND(date)</td><td>返回日期参数所对应的微秒数</td></tr><tr><td>MINUTE(t)</td><td>返回 t 中的分钟值</td></tr><tr><td>MONTHNAME(d)</td><td>返回日期当中的月份名称，如 November</td></tr><tr><td>MONTH(d)</td><td>返回日期d中的月份值，1 到 12</td></tr><tr><td>NOW()</td><td>返回当前日期和时间</td></tr><tr><td>PERIOD_ADD(period, number)</td><td>为 年-月 组合日期添加一个时段</td></tr><tr><td>PERIOD_DIFF(period1, period2)</td><td>返回两个时段之间的月份差值</td></tr><tr><td>QUARTER(d)</td><td>返回日期d是第几季节，返回 1 到 4</td></tr><tr><td>SECOND(t)</td><td>返回 t 中的秒钟值</td></tr><tr><td>SEC_TO_TIME(s)</td><td>将以秒为单位的时间 s 转换为时分秒的格式</td></tr><tr><td>STR_TO_DATE(string, format_mask)</td><td>将字符串转变为日期</td></tr><tr><td>SUBDATE(d,n)</td><td>日期 d 减去 n 天后的日期</td></tr><tr><td>SUBTIME(t,n)</td><td>时间 t 减去 n 秒的时间</td></tr><tr><td>SYSDATE()</td><td>返回当前日期和时间</td></tr><tr><td>TIME(expression)</td><td>提取传入表达式的时间部分</td></tr><tr><td>TIME_FORMAT(t,f)</td><td>按表达式 f 的要求显示时间 t</td></tr><tr><td>TIME_TO_SEC(t)</td><td>将时间 t 转换为秒</td></tr><tr><td>TIMEDIFF(time1, time2)</td><td>计算时间差值</td></tr><tr><td>TIMESTAMP(expression, interval)</td><td>单个参数时，函数返回日期或日期时间表达式；有2个参数时，将参数加和</td></tr><tr><td>TO_DAYS(d)</td><td>计算日期 d 距离 0000 年 1 月 1 日的天数</td></tr><tr><td>WEEK(d)</td><td>计算日期 d 是本年的第几个星期，范围是 0 到 53</td></tr><tr><td>WEEKDAY(d)</td><td>日期 d 是星期几，0 表示星期一，1 表示星期二</td></tr><tr><td>WEEKOFYEAR(d)</td><td>计算日期 d 是本年的第几个星期，范围是 0 到 53</td></tr><tr><td>YEAR(d)</td><td>返回年份</td></tr><tr><td>YEARWEEK(date, mode)</td><td>返回年份及第几周（0到53），mode 中 0 表示周天，1表示周一，以此类推</td></tr></tbody></table></div><h2 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h2><div class="table-container"><table><thead><tr><th>函数名</th><th>描述</th></tr></thead><tbody><tr><td>CAST(x AS type)</td><td>转换数据类型</td></tr><tr><td>BIN(x)</td><td>返回 x 的二进制编码</td></tr><tr><td>BINARY(s)</td><td>将字符串 s 转换为二进制字符串</td></tr><tr><td>CONV(x,f1,f2)</td><td>返回 f1 进制数变成 f2 进制数</td></tr><tr><td>CONVERT(s USING cs)</td><td>函数将字符串 s 的字符集变成 cs</td></tr><tr><td>LAST_INSERT_ID()</td><td>返回最近生成的 AUTO_INCREMENT 值</td></tr><tr><td>COALESCE(expr1, expr2, …., expr_n)</td><td>返回参数中的第一个非空表达式（从左向右）</td></tr><tr><td>CASE expression <br> WHEN condition1 THEN result1 <br> WHEN condition2 THEN result2 … <br> WHEN conditionN THEN resultN <br> ELSE result <br> END</td><td>CASE 表示函数开始，END 表示函数结束。如果 condition1 成立，则返回 result1, 如果 condition2 成立，则返回 result2，当全部不成立则返回 result，而当有一个成立之后，后面的就不执行了。</td></tr><tr><td>IF(expr,v1,v2)</td><td>如果表达式 expr 成立，返回结果 v1；否则，返回结果 v2。</td></tr><tr><td>IFNULL(v1,v2)</td><td>如果 v1 的值不为 NULL，则返回 v1，否则返回 v2。</td></tr><tr><td>ISNULL(expression)</td><td>判断表达式是否为 NULL</td></tr><tr><td>CONNECTION_ID()</td><td>返回服务器的连接数</td></tr><tr><td>DATABASE()</td><td>返回当前数据库名</td></tr><tr><td>NULLIF(expr1, expr2)</td><td>比较两个字符串，如果字符串 expr1 与 expr2 相等 返回 NULL，否则返回 expr1</td></tr><tr><td>CURRENT_USER()</td><td>返回当前用户</td></tr><tr><td>SESSION_USER()</td><td>返回当前用户</td></tr><tr><td>SYSTEM_USER()</td><td>返回当前用户</td></tr><tr><td>USER()</td><td>返回当前用户</td></tr><tr><td>VERSION()</td><td>返回数据库的版本号</td></tr></tbody></table></div><h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><h3 id="创建-CREATE-FUNCTION-RETURNS"><a href="#创建-CREATE-FUNCTION-RETURNS" class="headerlink" title="创建: CREATE FUNCTION - RETURNS"></a>创建: CREATE FUNCTION - RETURNS</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$        <span class="comment">-- sql在遇到指定的`delimiter`时，将执行前面的语句，默认为`;`</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> function_name(param_name1 param_type1, ...) </span><br><span class="line"><span class="keyword">RETURNS</span> return_type</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">body</span>;</span><br><span class="line">    RETURN return_value;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">$$                  <span class="comment">-- 执行语句</span></span><br><span class="line">DELIMITER ;         <span class="comment">-- 重置`delimiter`</span></span><br></pre></td></tr></table></figure><h3 id="查看-SHOW-CREATE-FUNCTION"><a href="#查看-SHOW-CREATE-FUNCTION" class="headerlink" title="查看: SHOW CREATE FUNCTION"></a>查看: SHOW CREATE FUNCTION</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> function_name;</span><br></pre></td></tr></table></figure><h3 id="删除-DROP-FUNCTION-function-name"><a href="#删除-DROP-FUNCTION-function-name" class="headerlink" title="删除: DROP FUNCTION function_name;"></a>删除: DROP FUNCTION function_name;</h3><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="全局变量-SET-variable-name-variable-value"><a href="#全局变量-SET-variable-name-variable-value" class="headerlink" title="全局变量: SET @variable_name = variable_value;"></a>全局变量: SET @variable_name = variable_value;</h4><p>例如<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 计算1 ~ 指定数据之间的和</span></span><br><span class="line">delimiter $$</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> my_sum(x <span class="built_in">int</span>) <span class="keyword">returns</span> <span class="built_in">int</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">set</span> @i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">set</span> @<span class="keyword">sum</span> = <span class="number">0</span>;</span><br><span class="line">    while @i &lt;= x do</span><br><span class="line">        <span class="keyword">set</span> @<span class="keyword">sum</span> = @<span class="keyword">sum</span> + @i;</span><br><span class="line">        <span class="keyword">set</span> @i = @i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line">    return @sum;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">$$</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure></p><h4 id="局部变量-DECLARE-variable-name-variable-type-DEFAULT-variable-value"><a href="#局部变量-DECLARE-variable-name-variable-type-DEFAULT-variable-value" class="headerlink" title="局部变量: DECLARE variable_name variable_type DEFAULT variable_value,"></a>局部变量: DECLARE variable_name variable_type DEFAULT variable_value,</h4><p>例如<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 求1 ~ 指定数之前的和，但5的倍数不加</span></span><br><span class="line">delimiter $$</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> my_sum2(x <span class="built_in">int</span>) <span class="keyword">returns</span> <span class="built_in">int</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> i <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">declare</span> <span class="keyword">sum</span> <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    sumwhile:while i &lt;= x do</span><br><span class="line">        if i % 5 = 0 then</span><br><span class="line">            <span class="keyword">set</span> i = i + <span class="number">1</span>;</span><br><span class="line">            iterate sumwhile;</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">        <span class="keyword">set</span> <span class="keyword">sum</span> = <span class="keyword">sum</span> + i;</span><br><span class="line">        <span class="keyword">set</span> i = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line">    return sum;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">$$</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure></p><h3 id="调用-SELECT-function-name-params-list"><a href="#调用-SELECT-function-name-params-list" class="headerlink" title="调用: SELECT function_name(params_list);"></a>调用: SELECT function_name(params_list);</h3><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><p><strong>只有使用了 Innodb 数据库引擎的数据库或表才支持事务。</strong></p><p><strong>事务</strong>(transaction)用于处理操作两大、复杂度高的数据，必须满足以下4个条件</p><ul><li><strong>原子性</strong>：一个事务中的所有操作，要么全部完成，要么全部不完成。若执行过程中发生错误，会被回滚至事务开始的状态；</li><li><strong>一致性</strong>：事务开始前后数据库的完整性没有被破坏，写入的资料必须完全符合所有的预设规则；</li><li><strong>隔离性</strong>：允许多个并发事务同时对数据进行读写和修改，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。分为不同级别，包括<ul><li>未提交(Read uncommitted)</li><li>读提交(read committed)</li><li>可重复读(repeatable read)</li><li>串行化(Serializable)</li></ul></li><li><strong>持久性</strong>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><h2 id="控制语句-BEGIN-END-COMMIT-ROLLBACK-SAVEPOINT"><a href="#控制语句-BEGIN-END-COMMIT-ROLLBACK-SAVEPOINT" class="headerlink" title="控制语句: BEGIN, END, COMMIT, ROLLBACK, SAVEPOINT"></a>控制语句: BEGIN, END, COMMIT, ROLLBACK, SAVEPOINT</h2><ul><li><strong>开启事务</strong>：<code>BEGIN</code>或<code>START TRANSACTION</code>；</li><li><strong>提交事务</strong>：<code>COMMIT</code>或<code>COMMIT WORK</code>，使已经对数据库进行的所有修改永久化；</li><li><strong>回滚事务</strong>：<code>ROLLBACK</code>或<code>ROLLBACK WORK</code>，回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；</li><li><strong>保存点</strong>：一个事务可以有多个保存点<ul><li><code>SAVEPOINT identifier</code>在事务中创建一个保存点；</li><li><code>RELEASE SAVEPOINT identifier</code>删除一个保存点，当没有指定的保存点时，执行该语句会抛出一个异常；</li><li><code>ROLLBACK TO identifier</code>把事务回滚到标记点。</li></ul></li><li><code>SET TRANSACTION</code>用来设置事务的隔离级别，InnoDB 存储引擎提供事务的隔离级别有<ul><li><code>READ UNCOMMITTED</code></li><li><code>READ COMMITTED</code></li><li><code>REPEATABLE READ</code></li><li><code>SERIALIZABLE</code></li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use RUNOOB;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; CREATE TABLE runoob_transaction_test( id int(5)) engine=innodb;  -- 创建数据表</span><br><span class="line">Query OK, 0 rows affected (0.04 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; select * from runoob_transaction_test;</span><br><span class="line">Empty <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; <span class="keyword">begin</span>;  <span class="comment">-- 开始事务</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; insert into runoob_transaction_test value(5);</span><br><span class="line">Query OK, 1 rows affected (0.01 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; insert into runoob_transaction_test value(6);</span><br><span class="line">Query OK, 1 rows affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; commit; -- 提交事务</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt;  select * from runoob_transaction_test;</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| id   |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| 5    |</span><br><span class="line">| 6    |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; <span class="keyword">begin</span>;    <span class="comment">-- 开始事务</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt;  insert into runoob_transaction_test values(7);</span><br><span class="line">Query OK, 1 rows affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; rollback;   -- 回滚</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt;   select * from runoob_transaction_test;   -- 因为回滚所以数据没有插入</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| id   |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| 5    |</span><br><span class="line">| 6    |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><h1 id="全文搜索"><a href="#全文搜索" class="headerlink" title="全文搜索"></a>全文搜索</h1><p><code>LIKE</code>关键字能用通配操作符匹配文本，但是该机制存在以下<strong>限制</strong></p><ul><li><strong>性能</strong>：通配符和正则表达式匹配尝试匹配表中所有行，这非常耗时；</li><li><strong>明确控制</strong>：很难用通配符和正则表达式明确空值匹配说明和不匹配说明；</li><li><strong>智能化控制</strong>：不能提供一种智能化的选择结果的方法。</li></ul><p>全本搜索必须索引被搜索的列，且随着数据的改变不断地重新索引，<strong>有以下几点说明</strong></p><ul><li>在索引全文本匹配时，<strong>短词</strong>被忽略且从索引中排除(短词即具有指定个字符的词，可更改)；</li><li>MySQL带有<strong>内建停用词</strong>，在索引时总是被忽略(可覆盖停用词列表)；</li><li>MySQL将<strong>出现在50%行以上的词作为非用词忽略</strong>，该规则不用于布尔匹配模式；因此若表中行数少于3行，则全文搜索不返回结果(因为每个词或者不出现，或者至少出现在50%行中)；</li><li>忽略词中的<strong>单引号</strong>，如<code>don&#39;t</code>被视作<code>dont</code>；</li><li>不具有<strong>词分隔符</strong>的语言(如汉语、日语)不能恰当地返回全文本搜索结果；</li><li>只有使用了 <strong>MyISAM</strong> 数据库引擎的数据库或表才支持全文搜索。</li></ul><h2 id="启用-FULLTEXT"><a href="#启用-FULLTEXT" class="headerlink" title="启用: FULLTEXT"></a>启用: FULLTEXT</h2><p>在创建表时，用关键字指定需要进行全文搜索的字段(一个或多个)。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line">(</span><br><span class="line">    field_name1 field_type1 [<span class="keyword">NOT</span> <span class="literal">NULL</span> [AUTO_INCREMENT [<span class="keyword">DEFAULT</span> <span class="keyword">default</span>]]],</span><br><span class="line">    field_name2 field_type2 [<span class="keyword">NOT</span> <span class="literal">NULL</span> [AUTO_INCREMENT [<span class="keyword">DEFAULT</span> <span class="keyword">default</span>]]],</span><br><span class="line">    ...,</span><br><span class="line">    field_nameN field_typeN [<span class="keyword">NOT</span> <span class="literal">NULL</span> [AUTO_INCREMENT [<span class="keyword">DEFAULT</span> <span class="keyword">default</span>]]],</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (key1, ..., keyM),</span><br><span class="line">    FULLTEXT (field_name1, ..., field_nameK)</span><br><span class="line">) <span class="keyword">ENGINE</span> = engine_name ...;</span><br></pre></td></tr></table></figure></p><h2 id="搜索-MATCH-AGAINST"><a href="#搜索-MATCH-AGAINST" class="headerlink" title="搜索: MATCH, AGAINST"></a>搜索: MATCH, AGAINST</h2><p>用<code>MATCH</code>指定被搜索的列，<code>AGAINST</code>指定要使用的搜索表达式。</p><ul><li>传递给<code>MATCH</code>的值必须与<code>FULLTEXT</code>中定义的相同，如果指定多个列必须列出他们，且次序正确；</li><li>除非使用<code>BINARY</code>方式，否则全文搜索不区分大小写；</li><li>全文本搜索根据行中词的数目、唯一词的数目、整个索引中词的总数、包含该词的行数计算得<strong>等级值</strong>。</li></ul><p>例如<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select note_text</span><br><span class="line">    -&gt; from productnotes</span><br><span class="line">    -&gt; where match(note_text) against ("rabbit");</span><br></pre></td></tr></table></figure></p><p>可以通过以下方式查看等级值<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select note_text, </span><br><span class="line">    -&gt;        match(note_text) against ("rabbit") as rank</span><br><span class="line">    -&gt; from productnotes;</span><br></pre></td></tr></table></figure></p><h2 id="查询扩展-WITH-QUERY-EXPANSION"><a href="#查询扩展-WITH-QUERY-EXPANSION" class="headerlink" title="查询扩展: WITH QUERY EXPANSION"></a>查询扩展: WITH QUERY EXPANSION</h2><p>用于设法放宽所返回的全文本搜索结果的范围，在进行查询扩展时，MySQL对数据和索引进行两遍扫描来完成搜索</p><ol><li>进行一个基本的全文本搜索，找出搜索条件匹配的所有行；</li><li>MySQL检查这些匹配行并选择所有“有用”的词；</li><li>根据原来的条件和所有“有用”的词进行全文本搜索。</li></ol><p>例如<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select note_text</span><br><span class="line">    -&gt; from productnotes</span><br><span class="line">    -&gt; where match(note_text) against ("rabbit" with query expansion);</span><br></pre></td></tr></table></figure></p><h2 id="布尔文本搜索-IN-BOOLEAN-MODE"><a href="#布尔文本搜索-IN-BOOLEAN-MODE" class="headerlink" title="布尔文本搜索: IN BOOLEAN MODE"></a>布尔文本搜索: IN BOOLEAN MODE</h2><p>布尔方式搜索无需用<code>FULLTEXT</code>索引字段，可以提供如下细节的内容</p><ul><li>要匹配的词；</li><li>要排斥的词；</li><li>排列提示；</li><li>表达式分组；</li><li>另外一些内容。</li></ul><div class="table-container"><table><thead><tr><th>布尔操作符</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>词尾通配符</td></tr><tr><td>+</td><td>包含，词必须存在</td></tr><tr><td>-</td><td>排除，词不许不出现</td></tr><tr><td>&gt;</td><td>包含，且增加等级值</td></tr><tr><td>&lt;</td><td>包含，且减少等级值</td></tr><tr><td>~</td><td>取消一个词的排序值</td></tr><tr><td>()</td><td>把词组成子表达式，允许这些子表达式作为一个组被包含、排除、排列等</td></tr><tr><td>“”</td><td>定义一个短语，允许该短语作为整体被包含、排除、排列等</td></tr></tbody></table></div><p>例如查找包含<code>rabbit</code>但排除<code>wolf</code><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select note_text</span><br><span class="line">    -&gt; from productnotes</span><br><span class="line">    -&gt; where match(note_text) against ("+rabbit -wolf" in boolean mode);</span><br></pre></td></tr></table></figure></p><h1 id="存储过程-PROCEDURE"><a href="#存储过程-PROCEDURE" class="headerlink" title="存储过程: PROCEDURE"></a>存储过程: PROCEDURE</h1><p>存储过程即为以后的使用而保存的一条或多条MySQL语句的集合，可以视作批处理文件。</p><h2 id="创建-CREATE-PROCEDURE-procedure-name-…-…"><a href="#创建-CREATE-PROCEDURE-procedure-name-…-…" class="headerlink" title="创建: CREATE PROCEDURE procedure_name(…) …;"></a>创建: CREATE PROCEDURE procedure_name(…) …;</h2><p>可以选择带参数，用<code>IN, OUT</code>指定参数的输入输出(变量用<code>@variable_name</code>表示)。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysel&gt; create procedure productpricing(</span><br><span class="line">    -&gt;    out pl decimal(8, 2),</span><br><span class="line">    -&gt;    out ph decimal(8, 2),</span><br><span class="line">    -&gt;    out pa decimal(8, 2)</span><br><span class="line">    -&gt; )</span><br><span class="line">    -&gt; begin</span><br><span class="line">    -&gt;    select min(prod_price) into pl from products;</span><br><span class="line">    -&gt;    select max(prod_price) into ph from products;</span><br><span class="line">    -&gt;    select avg(prod_price) into pa from products;</span><br><span class="line">    -&gt; end;</span><br></pre></td></tr></table></figure></p><h2 id="删除-DROP-PROCEDURE-procedure-name"><a href="#删除-DROP-PROCEDURE-procedure-name" class="headerlink" title="删除: DROP PROCEDURE procedure_name;"></a>删除: DROP PROCEDURE procedure_name;</h2><h2 id="调用-CALL-procedure-name-…"><a href="#调用-CALL-procedure-name-…" class="headerlink" title="调用: CALL procedure_name(…);"></a>调用: CALL procedure_name(…);</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; call productpricing(@pricelow, @pricehigh, @priceaverage);</span><br><span class="line">mysql&gt; select @pricelow, @pricehigh, @priceaverage;</span><br></pre></td></tr></table></figure><h1 id="视图-VIEW"><a href="#视图-VIEW" class="headerlink" title="视图: VIEW"></a>视图: VIEW</h1><p>视图是用于查看存储于别处数据的一种设施，本事不包含数据，返回的数据是从其他表中检索出来的。常被应用于</p><ul><li>重用SQL语句；</li><li>简化复杂的SQL操作，无需知道基本查询细节；</li><li>使用表的组成而不是整个表；</li><li>给用户授予表的指定部分的访问权限而不是整个表的访问权限；</li><li>视图可返回于底层表的表示和数据格式不同的数据。</li></ul><h2 id="创建-CREATE-VIEW-view-name-AS-…"><a href="#创建-CREATE-VIEW-view-name-AS-…" class="headerlink" title="创建: CREATE VIEW view_name AS …;"></a>创建: CREATE VIEW view_name AS …;</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create view productcustomers AS</span><br><span class="line">    -&gt; select cust_name, cust_contact, prod_id</span><br><span class="line">    -&gt; from customers, orders, orderitems</span><br><span class="line">    -&gt; where customers.cust_id = orders.cust_id</span><br><span class="line">    -&gt;    and orderitems.order_num = orders.order_num</span><br><span class="line"></span><br><span class="line">mysql&gt; select cust_name, cust_contact</span><br><span class="line">    -&gt; from productcustomers</span><br><span class="line">    -&gt; where prod_id = 'TNT2'</span><br></pre></td></tr></table></figure><h2 id="查看-SHOW-CREATE-VIEW-view-name"><a href="#查看-SHOW-CREATE-VIEW-view-name" class="headerlink" title="查看: SHOW CREATE VIEW view_name;"></a>查看: SHOW CREATE VIEW view_name;</h2><h2 id="删除-DROP-VIEW-view-name"><a href="#删除-DROP-VIEW-view-name" class="headerlink" title="删除: DROP VIEW view_name;"></a>删除: DROP VIEW view_name;</h2><h1 id="游标-CURSOR"><a href="#游标-CURSOR" class="headerlink" title="游标: CURSOR"></a>游标: CURSOR</h1><p>游标是一个存储在MySQL服务器上的数据库查询，不是一条<code>SELECT</code>语句，而是被该语句检索出来的结果集，存储游标后应用程序可以根据需要滚动或浏览其中的数据。</p><h2 id="创建-DECLARE-cursor-name-CURSOR-FOR-…"><a href="#创建-DECLARE-cursor-name-CURSOR-FOR-…" class="headerlink" title="创建: DECLARE cursor_name CURSOR FOR …;"></a>创建: DECLARE cursor_name CURSOR FOR …;</h2><h2 id="打开-OPEN-cursor-name"><a href="#打开-OPEN-cursor-name" class="headerlink" title="打开: OPEN cursor_name;"></a>打开: OPEN cursor_name;</h2><h2 id="关闭-CLOSE-cursor-name"><a href="#关闭-CLOSE-cursor-name" class="headerlink" title="关闭: CLOSE cursor_name;"></a>关闭: CLOSE cursor_name;</h2><h1 id="触发器-TRIGGER"><a href="#触发器-TRIGGER" class="headerlink" title="触发器: TRIGGER"></a>触发器: TRIGGER</h1><p>触发器是MySQL响应<code>DELETE, INSERT. UPDATE</code>语句时自动执行的一组语句。略。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://www.runoob.com/mysql/mysql-tutorial.html" target="_blank" rel="noopener">MySQL 教程 - 菜鸟教程</a></li><li><a href="https://launchpad.net/test-db/employees-db-1/1.0.6" target="_blank" rel="noopener">Sample database with test suite 1.0.6 “employees-db-1.0.6”</a></li><li><a href="https://www.cnblogs.com/bjx2020/p/9727898.html" target="_blank" rel="noopener">mysql快速生成批量测试数据 - cnblogs</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>深度学习框架darknet【五】——训练解析</title>
      <link href="/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%BA%94%E3%80%91%E2%80%94%E2%80%94%E8%AE%AD%E7%BB%83%E8%A7%A3%E6%9E%90/"/>
      <url>/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%BA%94%E3%80%91%E2%80%94%E2%80%94%E8%AE%AD%E7%BB%83%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://louishsu.xyz/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%B8%80%E3%80%91%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">深度学习框架darknet【一】——简单使用</a></li><li><a href="https://louishsu.xyz/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%BA%8C%E3%80%91%E2%80%94%E2%80%94%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/" target="_blank" rel="noopener">深度学习框架darknet【二】——目录结构</a></li><li><a href="https://louishsu.xyz/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%B8%89%E3%80%91%E2%80%94%E2%80%94%E8%B0%83%E5%8C%85%E5%A4%A7%E6%B3%95%E5%A5%BD/" target="_blank" rel="noopener">深度学习框架darknet【三】——调包大法好</a></li><li><a href="https://louishsu.xyz/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E5%9B%9B%E3%80%91%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9/" target="_blank" rel="noopener">深度学习框架darknet【四】——网络配置选项</a></li><li><a href="https://louishsu.xyz/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%BA%94%E3%80%91%E2%80%94%E2%80%94%E8%AE%AD%E7%BB%83%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">深度学习框架darknet【五】——训练解析</a></li></ul><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>第三节介绍了如何<strong>调用函数</strong>进行网络的训练，本节扒一扒源码，详细介绍前向、反向、更新部分。查看本节内容要有BP算法的基础，以全连接网络为例详细推导过程查看<a href="https://louishsu.xyz/2019/12/08/%E5%85%A8%E8%BF%9E%E6%8E%A5%E7%BD%91%E7%BB%9CBP%E7%AE%97%E6%B3%95%E6%8E%A8%E5%AF%BC%E3%80%90%E7%9F%A9%E9%98%B5%E5%BD%A2%E5%BC%8F%E3%80%91/" target="_blank" rel="noopener">全连接网络BP算法推导【矩阵形式】</a>。</p><h1 id="Dataflow"><a href="#Dataflow" class="headerlink" title="Dataflow"></a>Dataflow</h1><p>运算过程中最重要的是数据的传递，在整个过程中，向系统申请的内存资源(部分)列表如下</p><div class="table-container"><table><thead><tr><th style="text-align:left">内存地址指针</th><th style="text-align:left">类型</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left"><code>data.X</code></td><td style="text-align:left">matrix</td><td style="text-align:left">输入数据，以二维矩阵存储，每行表示一个样本</td></tr><tr><td style="text-align:left"><code>data.y</code></td><td style="text-align:left">matrix</td><td style="text-align:left">真实标签，以二维矩阵存储，每行表示一个样本</td></tr><tr><td style="text-align:left"><code>net-&gt;input</code></td><td style="text-align:left">float*</td><td style="text-align:left">用于层间<strong>输入数据传递</strong>的指针：(1)初始化为数据读取地址<code>d.X</code>； (2)在forward时更新为第i层输出作为第i+1层输入； (3)在backward时更新为第i+1层输出用于第i层的参数梯度计算。若为特征图，以<code>CHW</code>格式储存</td></tr><tr><td style="text-align:left"><code>net-&gt;delta</code></td><td style="text-align:left">float*</td><td style="text-align:left">用于层间<strong>输出梯度传递</strong>的指针，实现链式求导：在backward时更新为第i+1层输出梯度用于第i层的参数梯度计算</td></tr><tr><td style="text-align:left"><code>net-&gt;truth</code></td><td style="text-align:left">float*</td><td style="text-align:left"><strong>真实标签</strong>数据指针：初始化为<code>d.y</code>(groundtruth)；在损失函数层进行损失计算</td></tr><tr><td style="text-align:left"><code>net-&gt;workspace</code></td><td style="text-align:left">float*</td><td style="text-align:left">运算时可使用的<strong>临时工作区</strong>，如在卷积运算时需要将特征图展开为矩阵形式</td></tr><tr><td style="text-align:left"><code>l.output</code></td><td style="text-align:left">float*</td><td style="text-align:left">网络层的输出，若为特征图，以<code>CHW</code>格式储存</td></tr><tr><td style="text-align:left"><code>l.delta</code></td><td style="text-align:left">float*</td><td style="text-align:left">网络层<strong>输出对输入</strong>的梯度</td></tr><tr><td style="text-align:left"><code>l.weights</code></td><td style="text-align:left">float*</td><td style="text-align:left">网络层的权重，若为特征图，以<code>CHW</code>格式储存</td></tr><tr><td style="text-align:left"><code>l.weight_updates</code></td><td style="text-align:left">float*</td><td style="text-align:left">网络层权重的梯度值，由链式法则可知由<code>l.delta</code>与<code>l.weights</code>计算得到</td></tr><tr><td style="text-align:left"><code>l.biases</code></td><td style="text-align:left">float*</td><td style="text-align:left">网络层的偏置</td></tr><tr><td style="text-align:left"><code>l.bias_updates</code></td><td style="text-align:left">float*</td><td style="text-align:left">网络层偏置的梯度值</td></tr></tbody></table></div><p>示意图如下<br><img src="/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%BA%94%E3%80%91%E2%80%94%E2%80%94%E8%AE%AD%E7%BB%83%E8%A7%A3%E6%9E%90/深度学习框架darknet【五】——训练解析/network.jpg" alt="network"></p><h1 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h1><p>训练的入口函数为<code>train_netwok</code>，获取一批次数据并进行训练，数据由<code>(float*)d.X</code>、<code>(float*)d.y</code>拷贝至<code>(float*)net-&gt;input</code>、<code>(float*)net-&gt;truth</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">train_network</span><span class="params">(network *net, data d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(d.X.rows % net-&gt;batch == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> batch = net-&gt;batch;</span><br><span class="line">    <span class="keyword">int</span> n = d.X.rows / batch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">float</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        get_next_batch(d, batch, i*batch, net-&gt;input, net-&gt;truth);  <span class="comment">// d.X =&gt; net-&gt;input; d.y =&gt; net-&gt;truth</span></span><br><span class="line">        <span class="keyword">float</span> err = train_network_datum(net);</span><br><span class="line">        sum += err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">float</span>)sum/(n*batch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">train_network_datum</span><span class="params">(network *net)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *net-&gt;seen += net-&gt;batch;</span><br><span class="line">    net-&gt;train = <span class="number">1</span>;</span><br><span class="line">    forward_network(net);       <span class="comment">// 网络前向，计算各层输出</span></span><br><span class="line">    backward_network(net);      <span class="comment">// 网络反向，计算各层参数梯度</span></span><br><span class="line">    <span class="keyword">float</span> error = *net-&gt;cost;</span><br><span class="line">    <span class="keyword">if</span>(((*net-&gt;seen)/net-&gt;batch)%net-&gt;subdivisions == <span class="number">0</span>) </span><br><span class="line">        update_network(net);    <span class="comment">// 更新各层参数</span></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Forward"><a href="#Forward" class="headerlink" title="Forward"></a>Forward</h1><p>网络前向运算会依次调用各层的<code>forward</code>函数，通过指针<code>net-&gt;input</code>实现两层间数据传递，第$i$层将<code>net-&gt;input</code>作为输入进行运算，结果保存在<code>l.output</code>，之后将<code>net-&gt;input</code>更新为<code>l.output</code>完成地址传递，用作第$i+1$层的输入。</p><p>那么有疑问，<code>net-&gt;input</code>在创建网络时是分配了空间的，直接替换指针不会造成内存泄露吗？注意到<code>network* netp</code>是原始网络，在前向运算前先定义了局部变量<code>network net</code>，所以运算结束改变的是<code>net.input</code>而不是<code>netp-&gt;input</code>。</p><p>在第$1$层时，先读取<code>d.X</code>作为输入，第$i$层接受第$i-1$层输出<code>net-&gt;input</code>，与自身参数<code>l.weights</code>、<code>l.biases</code>运算得到输出，结果保存在<code>l.output</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forward_network</span><span class="params">(network *netp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> GPU</span></span><br><span class="line">    <span class="keyword">if</span>(netp-&gt;gpu_index &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        forward_network_gpu(netp);   </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    network net = *netp;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; net.n; ++i)&#123;</span><br><span class="line">        net.index = i;</span><br><span class="line">        layer l = net.layers[i];</span><br><span class="line">        <span class="keyword">if</span>(l.delta)&#123;</span><br><span class="line">            fill_cpu(l.outputs * l.batch, <span class="number">0</span>, l.delta, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        l.forward(l, net);      <span class="comment">// 各层前向</span></span><br><span class="line">        net.input = l.output;   <span class="comment">// 指针传递</span></span><br><span class="line">        <span class="keyword">if</span>(l.truth) &#123;</span><br><span class="line">            net.truth = l.output;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    calc_network_cost(netp);    <span class="comment">// 获取总体损失</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%BA%94%E3%80%91%E2%80%94%E2%80%94%E8%AE%AD%E7%BB%83%E8%A7%A3%E6%9E%90/深度学习框架darknet【五】——训练解析/forward_layer_0.jpg" alt="forward_layer_0"></p><p><img src="/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%BA%94%E3%80%91%E2%80%94%E2%80%94%E8%AE%AD%E7%BB%83%E8%A7%A3%E6%9E%90/深度学习框架darknet【五】——训练解析/forward_layer_i.jpg" alt="forward_layer_i"></p><p>以全连接层为例，在线性运算后经激活函数得到最终输出，<code>gemm</code>为BLAS函数，为通用的矩阵乘法接口</p><script type="math/tex; mode=display">l.output_{l.batch \times l.outputs} = net.input_{l.batch \times l.inputs} l.weights_{l.outputs \times l.inputs}^T + l.biases_{l.outputs, broadcast}</script><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forward_connected_layer</span><span class="params">(layer l, network net)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fill_cpu(l.outputs*l.batch, <span class="number">0</span>, l.output, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> m = l.batch;</span><br><span class="line">    <span class="keyword">int</span> k = l.inputs;</span><br><span class="line">    <span class="keyword">int</span> n = l.outputs;</span><br><span class="line">    <span class="keyword">float</span> *a = net.input;</span><br><span class="line">    <span class="keyword">float</span> *b = l.weights;</span><br><span class="line">    <span class="keyword">float</span> *c = l.output;</span><br><span class="line">    gemm(<span class="number">0</span>,<span class="number">1</span>,m,n,k,<span class="number">1</span>,a,k,b,k,<span class="number">1</span>,c,n);</span><br><span class="line">    <span class="keyword">if</span>(l.batch_normalize)&#123;</span><br><span class="line">        forward_batchnorm_layer(l, net);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        add_bias(l.output, l.biases, l.batch, l.outputs, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    activate_array(l.output, l.outputs*l.batch, l.activation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>损失函数层有所不同，运算示意图如下，除计算该层输出(损失)保存于<code>l.output</code>，最终损失<code>l.cost</code>为该批次样本损失的总和，计算<strong>输出对输入的梯度</strong>保存于<code>l.delta</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forward_cost_layer</span><span class="params">(cost_layer l, network net)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!net.truth) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(l.cost_type == MASKED)&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; l.batch*l.inputs; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(net.truth[i] == SECRET_NUM) net.input[i] = SECRET_NUM;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l.cost_type == SMOOTH)&#123;</span><br><span class="line">        smooth_l1_cpu(l.batch*l.inputs, net.input, net.truth, l.delta, l.output);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l.cost_type == L1)&#123;</span><br><span class="line">        l1_cpu(l.batch*l.inputs, net.input, net.truth, l.delta, l.output);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2_cpu(l.batch*l.inputs, net.input, net.truth, l.delta, l.output);</span><br><span class="line">    &#125;</span><br><span class="line">    l.cost[<span class="number">0</span>] = sum_array(l.output, l.batch*l.inputs);  <span class="comment">// 各样本损失总和</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%BA%94%E3%80%91%E2%80%94%E2%80%94%E8%AE%AD%E7%BB%83%E8%A7%A3%E6%9E%90/深度学习框架darknet【五】——训练解析/forward_layer_cost.jpg" alt="forward_layer_cost"></p><h1 id="Backward"><a href="#Backward" class="headerlink" title="Backward"></a>Backward</h1><p>依次调用各层的<code>backward</code>函数，对于第$i$层的反向运算，需要将第$i-1$层输出<code>prev.output</code>与梯度<code>prev.delta</code>传递到<code>net.input</code>与<code>net.delta</code>。实际上，由于<strong>指针的特性</strong>，此时<code>net.input</code>即前层输出<code>prev.output</code>，<code>net.delta</code>即前层梯度<code>prev.delta</code>，<strong>在第$i$层反向时，需依靠第$i-1$层输出，并对第$i-1$层梯度进行更新</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backward_network</span><span class="params">(network *netp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> GPU</span></span><br><span class="line">    <span class="keyword">if</span>(netp-&gt;gpu_index &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        backward_network_gpu(netp);   </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    network net = *netp;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    network orig = net;</span><br><span class="line">    <span class="keyword">for</span>(i = net.n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        layer l = net.layers[i];</span><br><span class="line">        <span class="keyword">if</span>(l.stopbackward) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">            net = orig;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            layer prev = net.layers[i<span class="number">-1</span>];</span><br><span class="line">            net.input = prev.output;</span><br><span class="line">            net.delta = prev.delta;</span><br><span class="line">        &#125;</span><br><span class="line">        net.index = i;</span><br><span class="line">        l.backward(l, net);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>损失函数层为反向运算时的第$1$层，运算较简单</p><script type="math/tex; mode=display">net.delta += l.scale \times l.delta</script><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backward_cost_layer</span><span class="params">(<span class="keyword">const</span> cost_layer l, network net)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    axpy_cpu(l.batch*l.inputs, l.scale, l.delta, <span class="number">1</span>, net.delta, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示意图如下<br><img src="/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%BA%94%E3%80%91%E2%80%94%E2%80%94%E8%AE%AD%E7%BB%83%E8%A7%A3%E6%9E%90/深度学习框架darknet【五】——训练解析/backward_layer_cost_1.jpg" alt="backward_layer_cost_1"></p><p>如果省略指针传递，那么简化的运算如下</p><script type="math/tex; mode=display">l^{prev}.delta += l.scale \times l.delta</script><p><img src="/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%BA%94%E3%80%91%E2%80%94%E2%80%94%E8%AE%AD%E7%BB%83%E8%A7%A3%E6%9E%90/深度学习框架darknet【五】——训练解析/backward_layer_cost_2.jpg" alt="backward_layer_cost_2"></p><p>其余各层调用各自的反传函数，先计算输出对输入的梯度<code>l.delta</code>，利用<code>net.input</code>与<code>l.delta</code>计算<code>l.weight_updates</code>、<code>l.bias_updates</code>，之后更新<code>net.delta</code>，示意图如下<br><img src="/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%BA%94%E3%80%91%E2%80%94%E2%80%94%E8%AE%AD%E7%BB%83%E8%A7%A3%E6%9E%90/深度学习框架darknet【五】——训练解析/backward_layer_i_1.jpg" alt="backward_layer_i_1"></p><p>如果省略指针传递，那么简化的运算如下<br><img src="/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%BA%94%E3%80%91%E2%80%94%E2%80%94%E8%AE%AD%E7%BB%83%E8%A7%A3%E6%9E%90/深度学习框架darknet【五】——训练解析/backward_layer_i_2.jpg" alt="backward_layer_i_2"></p><p>以全连接层为例</p><script type="math/tex; mode=display">\begin{cases}    l.weight\_updates_{l.outputs \times l.inputs} = l.delta_{l.batch \times l.outputs}^T net.input_{l.batch \times l.inputs} \\    l.bias\_updates_{l.outputs} += \sum_{i}^{l.batch} (l.delta^{(i)}_{l.outputs}) \\    l^{prev}.delta_{l.batch \times l.inputs} = l.delta_{l.batch \times l.outputs} l.weights_{l.outputs \times l.inputs}\end{cases}</script><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backward_connected_layer</span><span class="params">(layer l, network net)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gradient_array(l.output, l.outputs*l.batch, l.activation, l.delta);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(l.batch_normalize)&#123;</span><br><span class="line">        backward_batchnorm_layer(l, net);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        backward_bias(l.bias_updates, l.delta, l.batch, l.outputs, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m = l.outputs;</span><br><span class="line">    <span class="keyword">int</span> k = l.batch;</span><br><span class="line">    <span class="keyword">int</span> n = l.inputs;</span><br><span class="line">    <span class="keyword">float</span> *a = l.delta;</span><br><span class="line">    <span class="keyword">float</span> *b = net.input;</span><br><span class="line">    <span class="keyword">float</span> *c = l.weight_updates;</span><br><span class="line">    gemm(<span class="number">1</span>,<span class="number">0</span>,m,n,k,<span class="number">1</span>,a,m,b,n,<span class="number">1</span>,c,n);</span><br><span class="line"></span><br><span class="line">    m = l.batch;</span><br><span class="line">    k = l.outputs;</span><br><span class="line">    n = l.inputs;</span><br><span class="line"></span><br><span class="line">    a = l.delta;</span><br><span class="line">    b = l.weights;</span><br><span class="line">    c = net.delta;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(c) gemm(<span class="number">0</span>,<span class="number">0</span>,m,n,k,<span class="number">1</span>,a,k,b,n,<span class="number">1</span>,c,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h1><p>更新这一步比较简单，调用优化器参数，将当前已计算得到的参数梯度累加到网络层参数上即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_network</span><span class="params">(network *netp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> GPU</span></span><br><span class="line">    <span class="keyword">if</span>(netp-&gt;gpu_index &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        update_network_gpu(netp);   </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    network net = *netp;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    update_args a = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    a.batch = net.batch*net.subdivisions;</span><br><span class="line">    a.learning_rate = get_current_rate(netp);</span><br><span class="line">    a.momentum = net.momentum;</span><br><span class="line">    a.decay = net.decay;</span><br><span class="line">    a.adam = net.adam;</span><br><span class="line">    a.B1 = net.B1;</span><br><span class="line">    a.B2 = net.B2;</span><br><span class="line">    a.eps = net.eps;</span><br><span class="line">    ++*net.t;</span><br><span class="line">    a.t = *net.t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; net.n; ++i)&#123;</span><br><span class="line">        layer l = net.layers[i];</span><br><span class="line">        <span class="keyword">if</span>(l.update)&#123;</span><br><span class="line">            l.update(l, a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%BA%94%E3%80%91%E2%80%94%E2%80%94%E8%AE%AD%E7%BB%83%E8%A7%A3%E6%9E%90/深度学习框架darknet【五】——训练解析/update_layer_0.jpg" alt="update_layer_0"></p><p><img src="/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%BA%94%E3%80%91%E2%80%94%E2%80%94%E8%AE%AD%E7%BB%83%E8%A7%A3%E6%9E%90/深度学习框架darknet【五】——训练解析/update_layer_n_1.jpg" alt="update_layer_n_1"></p><p>以全连接层为例</p><script type="math/tex; mode=display">\begin{cases}    l.biases_{l.outputs} += l.bias\_updates_{l.outputs} \times \frac{learning\_rate}{batch} \\    l.weight\_updates_{l.outputs \times l.inputs} -= l.weights_{l.outputs \times l.inputs} \times decay \times batch \\    l.weights_{l.outputs \times l.inputs} += l.weight\_updates_{l.outputs \times l.inputs} \times \frac{learning\_rate}{batch} \\    l.weight\_updates_{l.outputs \times l.inputs} *= momentum \\    l.bias\_updates_{l.outputs} *= momentum\end{cases}</script><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_connected_layer</span><span class="params">(layer l, update_args a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> learning_rate = a.learning_rate*l.learning_rate_scale;</span><br><span class="line">    <span class="keyword">float</span> momentum = a.momentum;</span><br><span class="line">    <span class="keyword">float</span> decay = a.decay;</span><br><span class="line">    <span class="keyword">int</span> batch = a.batch;</span><br><span class="line">    axpy_cpu(l.outputs, learning_rate/batch, l.bias_updates, <span class="number">1</span>, l.biases, <span class="number">1</span>);</span><br><span class="line">    scal_cpu(l.outputs, momentum, l.bias_updates, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(l.batch_normalize)&#123;</span><br><span class="line">        axpy_cpu(l.outputs, learning_rate/batch, l.scale_updates, <span class="number">1</span>, l.scales, <span class="number">1</span>);</span><br><span class="line">        scal_cpu(l.outputs, momentum, l.scale_updates, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    axpy_cpu(l.inputs*l.outputs, -decay*batch, l.weights, <span class="number">1</span>, l.weight_updates, <span class="number">1</span>);</span><br><span class="line">    axpy_cpu(l.inputs*l.outputs, learning_rate/batch, l.weight_updates, <span class="number">1</span>, l.weights, <span class="number">1</span>);</span><br><span class="line">    scal_cpu(l.inputs*l.outputs, momentum, l.weight_updates, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深度学习框架darknet【四】——网络配置选项</title>
      <link href="/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E5%9B%9B%E3%80%91%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9/"/>
      <url>/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E5%9B%9B%E3%80%91%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://louishsu.xyz/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%B8%80%E3%80%91%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">深度学习框架darknet【一】——简单使用</a></li><li><a href="https://louishsu.xyz/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%BA%8C%E3%80%91%E2%80%94%E2%80%94%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/" target="_blank" rel="noopener">深度学习框架darknet【二】——目录结构</a></li><li><a href="https://louishsu.xyz/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%B8%89%E3%80%91%E2%80%94%E2%80%94%E8%B0%83%E5%8C%85%E5%A4%A7%E6%B3%95%E5%A5%BD/" target="_blank" rel="noopener">深度学习框架darknet【三】——调包大法好</a></li><li><a href="https://louishsu.xyz/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E5%9B%9B%E3%80%91%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9/" target="_blank" rel="noopener">深度学习框架darknet【四】——网络配置选项</a></li><li><a href="https://louishsu.xyz/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%BA%94%E3%80%91%E2%80%94%E2%80%94%E8%AE%AD%E7%BB%83%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">深度学习框架darknet【五】——训练解析</a></li></ul><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一些重要网络层的参数配置可以在<code>network *parse_network_cfg(char *filename)</code>函数中查看，进入对应层的解析函数<code>layer parse_xxx(list *options, size_params params)</code>，部分参数有缺省值。</p><p>配置文件书写，以alexnet为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">[net]</span><br><span class="line">batch&#x3D;1</span><br><span class="line">subdivisions&#x3D;1</span><br><span class="line">height&#x3D;227</span><br><span class="line">width&#x3D;227</span><br><span class="line">channels&#x3D;3</span><br><span class="line">momentum&#x3D;0.9</span><br><span class="line">decay&#x3D;0.0005</span><br><span class="line">max_crop&#x3D;256</span><br><span class="line"></span><br><span class="line">learning_rate&#x3D;0.01</span><br><span class="line">policy&#x3D;poly</span><br><span class="line">power&#x3D;4</span><br><span class="line">max_batches&#x3D;800000</span><br><span class="line"></span><br><span class="line">angle&#x3D;7</span><br><span class="line">hue &#x3D; .1</span><br><span class="line">saturation&#x3D;.75</span><br><span class="line">exposure&#x3D;.75</span><br><span class="line">aspect&#x3D;.75</span><br><span class="line"></span><br><span class="line">[convolutional]</span><br><span class="line">filters&#x3D;96</span><br><span class="line">size&#x3D;11</span><br><span class="line">stride&#x3D;4</span><br><span class="line">pad&#x3D;0</span><br><span class="line">activation&#x3D;relu</span><br><span class="line"></span><br><span class="line">[maxpool]</span><br><span class="line">size&#x3D;3</span><br><span class="line">stride&#x3D;2</span><br><span class="line">padding&#x3D;0</span><br><span class="line"></span><br><span class="line">[convolutional]</span><br><span class="line">filters&#x3D;256</span><br><span class="line">size&#x3D;5</span><br><span class="line">stride&#x3D;1</span><br><span class="line">pad&#x3D;1</span><br><span class="line">activation&#x3D;relu</span><br><span class="line"></span><br><span class="line">[maxpool]</span><br><span class="line">size&#x3D;3</span><br><span class="line">stride&#x3D;2</span><br><span class="line">padding&#x3D;0</span><br><span class="line"></span><br><span class="line">[convolutional]</span><br><span class="line">filters&#x3D;384</span><br><span class="line">size&#x3D;3</span><br><span class="line">stride&#x3D;1</span><br><span class="line">pad&#x3D;1</span><br><span class="line">activation&#x3D;relu</span><br><span class="line"></span><br><span class="line">[convolutional]</span><br><span class="line">filters&#x3D;384</span><br><span class="line">size&#x3D;3</span><br><span class="line">stride&#x3D;1</span><br><span class="line">pad&#x3D;1</span><br><span class="line">activation&#x3D;relu</span><br><span class="line"></span><br><span class="line">[convolutional]</span><br><span class="line">filters&#x3D;256</span><br><span class="line">size&#x3D;3</span><br><span class="line">stride&#x3D;1</span><br><span class="line">pad&#x3D;1</span><br><span class="line">activation&#x3D;relu</span><br><span class="line"></span><br><span class="line">[maxpool]</span><br><span class="line">size&#x3D;3</span><br><span class="line">stride&#x3D;2</span><br><span class="line">padding&#x3D;0</span><br><span class="line"></span><br><span class="line">[connected]</span><br><span class="line">output&#x3D;4096</span><br><span class="line">activation&#x3D;relu</span><br><span class="line"></span><br><span class="line">[dropout]</span><br><span class="line">probability&#x3D;.5</span><br><span class="line"></span><br><span class="line">[connected]</span><br><span class="line">output&#x3D;4096</span><br><span class="line">activation&#x3D;relu</span><br><span class="line"></span><br><span class="line">[dropout]</span><br><span class="line">probability&#x3D;.5</span><br><span class="line"></span><br><span class="line">[connected]</span><br><span class="line">output&#x3D;1000</span><br><span class="line">activation&#x3D;linear</span><br><span class="line"></span><br><span class="line">[softmax]</span><br><span class="line">groups&#x3D;1</span><br></pre></td></tr></table></figure></p><h1 id="net"><a href="#net" class="headerlink" title="net"></a>net</h1><div class="table-container"><table><thead><tr><th>option</th><th>dtype</th><th>default</th><th>function</th></tr></thead><tbody><tr><td>batch</td><td>int</td><td>1</td><td>单个批次数据量</td></tr><tr><td>max_batches</td><td>int</td><td>0</td><td>训练最大迭代次数</td></tr><tr><td>learning_rate</td><td>float</td><td>.001</td><td>学习率</td></tr><tr><td>momentum</td><td>float</td><td>.9</td><td>动量</td></tr><tr><td>decay</td><td>float</td><td>.0001</td><td>权重衰减</td></tr><tr><td>subdivisions</td><td>int</td><td>1</td><td>对批次进行细分</td></tr><tr><td>time_steps</td><td>int</td><td>1</td><td>循环神经网络使用，时间步数</td></tr><tr><td>notruth</td><td>int</td><td>0</td><td>未知</td></tr><tr><td>random</td><td>int</td><td>0</td><td><code>classifier.c</code>中使用，是否随机改变图像载入参数</td></tr><tr><td>adam</td><td>int</td><td>0</td><td>是否使用adam优化器</td></tr><tr><td>B1</td><td>float</td><td>.9</td><td>adam优化器参数</td></tr><tr><td>B2</td><td>float</td><td>.999</td><td>adam优化器参数</td></tr><tr><td>eps</td><td>float</td><td>.0000001</td><td>adam优化器参数</td></tr><tr><td>height</td><td>int</td><td>0</td><td>输入图像高度，必须指定</td></tr><tr><td>width</td><td>int</td><td>0</td><td>输入图像宽度，必须指定</td></tr><tr><td>channels</td><td>int</td><td>0</td><td>输入图像通道数，必须指定</td></tr><tr><td>inputs</td><td>int</td><td>height <em> width </em> channels</td><td>输入图像尺寸</td></tr><tr><td>max_crop</td><td>int</td><td>width * 2</td><td>图像裁剪参数</td></tr><tr><td>min_crop</td><td>int</td><td>width</td><td>图像裁剪参数</td></tr><tr><td>max_ratio</td><td>float</td><td>max_crop / width</td><td>图像裁剪参数</td></tr><tr><td>min_ratio</td><td>float</td><td>max_crop / width</td><td>图像裁剪参数</td></tr><tr><td>center</td><td>int</td><td>0</td><td>未知</td></tr><tr><td>clip</td><td>float</td><td>0</td><td>未知</td></tr><tr><td>angle</td><td>float</td><td>0</td><td>图像扩增参数</td></tr><tr><td>aspect</td><td>float</td><td>1</td><td>图像扩增参数</td></tr><tr><td>saturation</td><td>float</td><td>1</td><td>图像扩增参数</td></tr><tr><td>exposure</td><td>float</td><td>1</td><td>图像扩增参数</td></tr><tr><td>hue</td><td>float</td><td>0</td><td>图像扩增参数</td></tr><tr><td>policy</td><td>char*</td><td>constant</td><td>学习率调整策略，可选<code>random</code>, <code>poly</code>, <code>constant</code>, <code>step</code>, <code>exp</code>, <code>sigmoid</code>, <code>steps</code></td></tr><tr><td>burn_in</td><td>int</td><td>0</td><td>学习率调整策略参数</td></tr><tr><td>power</td><td>float</td><td>4</td><td>学习率调整策略参数</td></tr><tr><td>step</td><td>int</td><td>1</td><td>学习率调整策略参数</td></tr><tr><td>scale</td><td>float</td><td>1</td><td>学习率调整策略参数</td></tr><tr><td>steps</td><td>int,  …</td><td>/</td><td>学习率调整策略参数</td></tr><tr><td>scales</td><td>float,…</td><td>/</td><td>学习率调整策略参数</td></tr><tr><td>gamma</td><td>float</td><td>1</td><td>学习率调整策略参数</td></tr></tbody></table></div><h1 id="layer"><a href="#layer" class="headerlink" title="layer"></a>layer</h1><div class="table-container"><table><thead><tr><th>option</th><th>dtype</th><th>default</th><th>function</th></tr></thead><tbody><tr><td>clip</td><td>float</td><td>net-&gt;clip</td><td>图像裁剪</td></tr><tr><td>truth</td><td>int</td><td>0</td><td>是否以输出作为groundtruth</td></tr><tr><td>onlyforward</td><td>int</td><td>0</td><td>仅前向</td></tr><tr><td>stopbackward</td><td>int</td><td>0</td><td>该层不进行反向</td></tr><tr><td>dontsave</td><td>int</td><td>0</td><td>不保存该层参数</td></tr><tr><td>dontload</td><td>int</td><td>0</td><td>不读取该层参数</td></tr><tr><td>numload</td><td>int</td><td>0</td><td>卷积层使用，指定卷积核个数</td></tr><tr><td>dontloadscales</td><td>int</td><td>0</td><td>不读取batchnorm参数</td></tr><tr><td>learning_rate</td><td>float</td><td>1</td><td>学习率，在网络学习率基础上累乘</td></tr><tr><td>smooth</td><td>float</td><td>0</td><td>平滑</td></tr></tbody></table></div><h1 id="convolutional"><a href="#convolutional" class="headerlink" title="convolutional"></a>convolutional</h1><div class="table-container"><table><thead><tr><th>option</th><th>dtype</th><th>default</th><th>function</th></tr></thead><tbody><tr><td>filters</td><td>int</td><td>1</td><td>卷积核个数</td></tr><tr><td>size</td><td>int</td><td>1</td><td>卷积核尺寸</td></tr><tr><td>stride</td><td>int</td><td>1</td><td>卷积步长</td></tr><tr><td>pad</td><td>int</td><td>0</td><td>卷积是否填充，若填充<code>padding=size/2</code></td></tr><tr><td>padding</td><td>int</td><td>0</td><td>卷积填充值，若<code>pad=1</code>则该值无效指定</td></tr><tr><td>groups</td><td>int</td><td>1</td><td>卷积组个数</td></tr><tr><td>activation</td><td>char*</td><td>logistic</td><td>激活函数类型</td></tr><tr><td>batch_normalize</td><td>int</td><td>0</td><td>是否使用batchnorm</td></tr><tr><td>binary</td><td>int</td><td>0</td><td>是否二值化参数</td></tr><tr><td>xnor</td><td>int</td><td>0</td><td>未知</td></tr><tr><td>flipped</td><td>int</td><td>0</td><td>未知</td></tr><tr><td>dot</td><td>int</td><td>float</td><td>未知</td></tr></tbody></table></div><h1 id="deconvolutional"><a href="#deconvolutional" class="headerlink" title="deconvolutional"></a>deconvolutional</h1><div class="table-container"><table><thead><tr><th>option</th><th>dtype</th><th>default</th><th>function</th></tr></thead><tbody><tr><td>filters</td><td>int</td><td>1</td><td>卷积核个数</td></tr><tr><td>size</td><td>int</td><td>1</td><td>卷积核尺寸</td></tr><tr><td>stride</td><td>int</td><td>1</td><td>卷积步长</td></tr><tr><td>activation</td><td>char*</td><td>logistic</td><td>激活函数类型</td></tr><tr><td>batch_normalize</td><td>int</td><td>0</td><td>是否使用batchnorm</td></tr><tr><td>pad</td><td>int</td><td>0</td><td>卷积是否填充，若填充<code>padding=size/2</code></td></tr><tr><td>padding</td><td>int</td><td>0</td><td>卷积填充值，若<code>pad=1</code>则该值无效指定</td></tr></tbody></table></div><h1 id="rnn"><a href="#rnn" class="headerlink" title="rnn"></a>rnn</h1><div class="table-container"><table><thead><tr><th>option</th><th>dtype</th><th>default</th><th>function</th></tr></thead><tbody><tr><td>output</td><td>int</td><td>1</td><td>输出维数</td></tr><tr><td>activation</td><td>char*</td><td>logistic</td><td>激活函数类型</td></tr><tr><td>batch_normalize</td><td>int</td><td>0</td><td>是否使用batchnorm</td></tr><tr><td>shortcut</td><td>int</td><td>0</td><td>是否使用shortcut</td></tr></tbody></table></div><h1 id="gru"><a href="#gru" class="headerlink" title="gru"></a>gru</h1><div class="table-container"><table><thead><tr><th>option</th><th>dtype</th><th>default</th><th>function</th></tr></thead><tbody><tr><td>output</td><td>int</td><td>1</td><td>输出维数</td></tr><tr><td>batch_normalize</td><td>int</td><td>0</td><td>是否使用batchnorm</td></tr><tr><td>tanh</td><td>int</td><td>0</td><td>是否使用tanh</td></tr></tbody></table></div><h1 id="lstm"><a href="#lstm" class="headerlink" title="lstm"></a>lstm</h1><div class="table-container"><table><thead><tr><th>option</th><th>dtype</th><th>default</th><th>function</th></tr></thead><tbody><tr><td>output</td><td>int</td><td>1</td><td>输出维数</td></tr><tr><td>batch_normalize</td><td>int</td><td>0</td><td>是否使用batchnorm</td></tr></tbody></table></div><h1 id="crnn"><a href="#crnn" class="headerlink" title="crnn"></a>crnn</h1><div class="table-container"><table><thead><tr><th>option</th><th>dtype</th><th>default</th><th>function</th></tr></thead><tbody><tr><td>output_filters</td><td>int</td><td>1</td><td>输出特征通道数</td></tr><tr><td>hidden_filters</td><td>int</td><td>1</td><td>隐层特征通道数</td></tr><tr><td>activation</td><td>char*</td><td>logistic</td><td>激活函数类型</td></tr><tr><td>batch_normalize</td><td>int</td><td>0</td><td>是否使用batchnorm</td></tr><tr><td>shortcut</td><td>int</td><td>0</td><td>是否使用shortcut</td></tr></tbody></table></div><h1 id="connected"><a href="#connected" class="headerlink" title="connected"></a>connected</h1><div class="table-container"><table><thead><tr><th>option</th><th>dtype</th><th>default</th><th>function</th></tr></thead><tbody><tr><td>output</td><td>int</td><td>1</td><td>输出维数</td></tr><tr><td>activation</td><td>char*</td><td>logistic</td><td>激活函数类型</td></tr><tr><td>batch_normalize</td><td>int</td><td>0</td><td>是否使用batchnorm</td></tr></tbody></table></div><h1 id="crop"><a href="#crop" class="headerlink" title="crop"></a>crop</h1><div class="table-container"><table><thead><tr><th>option</th><th>dtype</th><th>default</th><th>function</th></tr></thead><tbody><tr><td>crop_height</td><td>int</td><td>1</td><td>裁剪高度</td></tr><tr><td>crop_width</td><td>int</td><td>1</td><td>裁剪宽度</td></tr><tr><td>flip</td><td>int</td><td>0</td><td>是否翻转</td></tr><tr><td>angle</td><td>float</td><td>0</td><td>旋转角度</td></tr><tr><td>saturation</td><td>float</td><td>1</td><td>饱和度</td></tr><tr><td>exposure</td><td>float</td><td>1</td><td>曝光</td></tr></tbody></table></div><h1 id="cost"><a href="#cost" class="headerlink" title="cost"></a>cost</h1><div class="table-container"><table><thead><tr><th>option</th><th>dtype</th><th>default</th><th>function</th></tr></thead><tbody><tr><td>type</td><td>char*</td><td>sse</td><td>损失类型</td></tr><tr><td>scale</td><td>float</td><td>1</td><td>损失倍率</td></tr><tr><td>ratio</td><td>float</td><td>0</td><td>未知</td></tr><tr><td>noobj</td><td>float</td><td>1</td><td>未知</td></tr><tr><td>thresh</td><td>float</td><td>0</td><td>未知</td></tr></tbody></table></div><h1 id="batchnorm"><a href="#batchnorm" class="headerlink" title="batchnorm"></a>batchnorm</h1><div class="table-container"><table><thead><tr><th>option</th><th>dtype</th><th>default</th><th>function</th></tr></thead><tbody><tr><td>无</td><td>/</td><td>/</td><td>/</td></tr></tbody></table></div><h1 id="maxpool"><a href="#maxpool" class="headerlink" title="maxpool"></a>maxpool</h1><div class="table-container"><table><thead><tr><th>option</th><th>dtype</th><th>default</th><th>function</th></tr></thead><tbody><tr><td>stride</td><td>int</td><td>1</td><td>步长</td></tr><tr><td>size</td><td>int</td><td>stride</td><td>尺寸</td></tr><tr><td>padding</td><td>int</td><td>size - 1</td><td>填充</td></tr></tbody></table></div><h1 id="avgpool"><a href="#avgpool" class="headerlink" title="avgpool"></a>avgpool</h1><div class="table-container"><table><thead><tr><th>option</th><th>dtype</th><th>default</th><th>function</th></tr></thead><tbody><tr><td>无</td><td>/</td><td>/</td><td>/</td></tr></tbody></table></div><h1 id="upsample"><a href="#upsample" class="headerlink" title="upsample"></a>upsample</h1><div class="table-container"><table><thead><tr><th>option</th><th>dtype</th><th>default</th><th>function</th></tr></thead><tbody><tr><td>stride</td><td>int</td><td>2</td><td>步长</td></tr><tr><td>scale</td><td>float</td><td>1</td><td>未知</td></tr></tbody></table></div><h1 id="shortcut"><a href="#shortcut" class="headerlink" title="shortcut"></a>shortcut</h1><div class="table-container"><table><thead><tr><th>option</th><th>dtype</th><th>default</th><th>function</th></tr></thead><tbody><tr><td>from</td><td>int</td><td>/</td><td>指定来自某层的连接，可为相对层数如<code>from=-4</code>表示从4层前连接，或绝对层数如<code>from=4</code>表示第4层连接</td></tr><tr><td>activation</td><td>char*</td><td>linear</td><td>激活函数类型</td></tr><tr><td>alpha</td><td>float</td><td>1</td><td>详情查看<code>shortcut_layer.c/backward_shortcut_layer</code></td></tr><tr><td>beta</td><td>float</td><td>1</td><td>详情查看<code>shortcut_layer.c/backward_shortcut_layer</code></td></tr></tbody></table></div><h1 id="dropout"><a href="#dropout" class="headerlink" title="dropout"></a>dropout</h1><div class="table-container"><table><thead><tr><th>option</th><th>dtype</th><th>default</th><th>function</th></tr></thead><tbody><tr><td>probability</td><td>float</td><td>.5</td><td>dropout概率</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深度学习框架darknet【三】——调包大法好</title>
      <link href="/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%B8%89%E3%80%91%E2%80%94%E2%80%94%E8%B0%83%E5%8C%85%E5%A4%A7%E6%B3%95%E5%A5%BD/"/>
      <url>/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%B8%89%E3%80%91%E2%80%94%E2%80%94%E8%B0%83%E5%8C%85%E5%A4%A7%E6%B3%95%E5%A5%BD/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://louishsu.xyz/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%B8%80%E3%80%91%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">深度学习框架darknet【一】——简单使用</a></li><li><a href="https://louishsu.xyz/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%BA%8C%E3%80%91%E2%80%94%E2%80%94%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/" target="_blank" rel="noopener">深度学习框架darknet【二】——目录结构</a></li><li><a href="https://louishsu.xyz/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%B8%89%E3%80%91%E2%80%94%E2%80%94%E8%B0%83%E5%8C%85%E5%A4%A7%E6%B3%95%E5%A5%BD/" target="_blank" rel="noopener">深度学习框架darknet【三】——调包大法好</a></li><li><a href="https://louishsu.xyz/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E5%9B%9B%E3%80%91%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9/" target="_blank" rel="noopener">深度学习框架darknet【四】——网络配置选项</a></li><li><a href="https://louishsu.xyz/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%BA%94%E3%80%91%E2%80%94%E2%80%94%E8%AE%AD%E7%BB%83%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">深度学习框架darknet【五】——训练解析</a></li></ul><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本节以YOLO为例，介绍如何调用darknet函数来进行网络训练和测试，对框架有一个整体的认识。</p><h1 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h1><p>主函数入口在<code>examples/darknet.c/main</code>，命令行指定参数<code>yolo</code>即可进入yolo的运行函数段<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./darknet yolo</span></span><br><span class="line">usage: ./darknet yolo [train/test/valid] [cfg] [weights (optional)]</span><br></pre></td></tr></table></figure></p><p>由以下代码可知，可选参数2有</p><ul><li><code>test</code>：测试</li><li><code>train</code>：训练</li><li><code>valid</code>：验证</li><li><code>recall</code>：验证，计算召回率等指标</li><li><code>demo</code>：样机，视频演示，需OpenCV支持</li></ul><details><summary><font color="darkred">void run_yolo(int argc, char **argv)</font></summary><pre><code>void run_yolo(int argc, char **argv){    char *prefix = find_char_arg(argc, argv, "-prefix", 0);    float thresh = find_float_arg(argc, argv, "-thresh", .2);    int cam_index = find_int_arg(argc, argv, "-c", 0);    int frame_skip = find_int_arg(argc, argv, "-s", 0);    if(argc < 4){        fprintf(stderr, "usage: %s %s [train/test/valid] [cfg] [weights (optional)]\n", argv[0], argv[1]);        return;    }    int avg = find_int_arg(argc, argv, "-avg", 1);    char *cfg = argv[3];    char *weights = (argc > 4) ? argv[4] : 0;    char *filename = (argc > 5) ? argv[5]: 0;    if(0==strcmp(argv[2], "test")) test_yolo(cfg, weights, filename, thresh);    else if(0==strcmp(argv[2], "train")) train_yolo(cfg, weights);    else if(0==strcmp(argv[2], "valid")) validate_yolo(cfg, weights);    else if(0==strcmp(argv[2], "recall")) validate_yolo_recall(cfg, weights);    else if(0==strcmp(argv[2], "demo")) demo(cfg, weights, thresh, cam_index, filename, voc_names, 20, frame_skip, prefix, avg, .5, 0,0,0,0);}</code></pre></details><p><strong>本节只介绍基本的训练(train)与测试(test)，其余均为拓展。</strong></p><h1 id="Training-Stage"><a href="#Training-Stage" class="headerlink" title="Training Stage"></a>Training Stage</h1><p>指定参数2为<code>train</code>，即可进入训练函数段，提示无训练数据<code>/data/voc/train.txt</code><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./darknet yolo train cfg/yolov3.cfg yolov3.weights</span></span><br><span class="line">yolov3</span><br><span class="line">layer     filters    size              input                output</span><br><span class="line">    0 conv     32  3 x 3 / 1   608 x 608 x   3   -&gt;   608 x 608 x  32  0.639 BFLOPs</span><br><span class="line">    1 conv     64  3 x 3 / 2   608 x 608 x  32   -&gt;   304 x 304 x  64  3.407 BFLOPs</span><br><span class="line">... # 略</span><br><span class="line">  105 conv    255  1 x 1 / 1    76 x  76 x 256   -&gt;    76 x  76 x 255  0.754 BFLOPs</span><br><span class="line">  106 yolo</span><br><span class="line">Loading weights from yolov3.weights...Done!</span><br><span class="line">Learning Rate: 0.001, Momentum: 0.9, Decay: 0.0005</span><br><span class="line">Couldn't open file: /data/voc/train.txt</span><br></pre></td></tr></table></figure></p><p>在训练函数段内，主要做的工作有以下几个部分，分别进行说明</p><ul><li>网络构建</li><li>数据载入</li><li>训练，包括前向、反向、参数更新</li></ul><details><summary><font color="darkred">void train_yolo(char *cfgfile, char *weightfile)</font></summary><pre><code>void train_yolo(char *cfgfile, char *weightfile){    char *train_images = "/data/voc/train.txt";    char *backup_directory = "/home/pjreddie/backup/";    srand(time(0));    char *base = basecfg(cfgfile);    printf("%s\n", base);    float avg_loss = -1;    // 网络构建    network *net = load_network(cfgfile, weightfile, 0);    printf("Learning Rate: %g, Momentum: %g, Decay: %g\n", net->learning_rate, net->momentum, net->decay);    // 数据载入    int imgs = net->batch*net->subdivisions;    int i = *net->seen/imgs;    data train, buffer;    layer l = net->layers[net->n - 1];    int side = l.side;    int classes = l.classes;    float jitter = l.jitter;    list *plist = get_paths(train_images);    //int N = plist->size;    char **paths = (char **)list_to_array(plist);    load_args args = {0};    args.w = net->w;    args.h = net->h;    args.paths = paths;    args.n = imgs;    args.m = plist->size;    args.classes = classes;    args.jitter = jitter;    args.num_boxes = side;    args.d = &buffer;    args.type = REGION_DATA;    args.angle = net->angle;    args.exposure = net->exposure;    args.saturation = net->saturation;    args.hue = net->hue;    pthread_t load_thread = load_data_in_thread(args);    // 开始训练    clock_t time;    while(get_current_batch(net) < net->max_batches){        i += 1;        time=clock();        pthread_join(load_thread, 0);        train = buffer;        load_thread = load_data_in_thread(args);        printf("Loaded: %lf seconds\n", sec(clock()-time));        time=clock();        float loss = train_network(net, train);        if (avg_loss < 0) avg_loss = loss;        avg_loss = avg_loss*.9 + loss*.1;        printf("%d: %f, %f avg, %f rate, %lf seconds, %d images\n", i, loss, avg_loss, get_current_rate(net), sec(clock()-time), i*imgs);        if(i%1000==0 || (i < 1000 && i%100 == 0)){            char buff[256];            sprintf(buff, "%s/%s_%d.weights", backup_directory, base, i);            save_weights(net, buff);        }        free_data(train);    }    char buff[256];    sprintf(buff, "%s/%s_final.weights", backup_directory, base);    save_weights(net, buff);}</code></pre></details><h2 id="Load-Network"><a href="#Load-Network" class="headerlink" title="Load Network"></a>Load Network</h2><p>通过<code>load_network</code>可快速构建网络，来看一下该函数做了哪些事情<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">network *net = load_network(cfgfile, weightfile, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><details><summary><font color="darkred"> network *load_network(char *cfg, char *weights, int clear) </font></summary><pre><code>network *load_network(char *cfg, char *weights, int clear){    network *net = parse_network_cfg(cfg);    if(weights && weights[0] != 0){        load_weights(net, weights);    }    if(clear) (*net->seen) = 0;    return net;}</code></pre></details><ol><li><p>构建框架</p> <details> <summary><font color="darkred"> network *parse_network_cfg(char *filename) </font></summary> <pre><code> network *parse_network_cfg(char *filename) {     list *sections = read_cfg(filename);     node *n = sections->front;     if(!n) error("Config file has no sections");     network *net = make_network(sections->size - 1);     net->gpu_index = gpu_index;     size_params params;     section *s = (section *)n->val;     list *options = s->options;     if(!is_network(s)) error("First section must be [net] or [network]");     parse_net_options(options, net);     params.h = net->h;     params.w = net->w;     params.c = net->c;     params.inputs = net->inputs;     params.batch = net->batch;     params.time_steps = net->time_steps;     params.net = net;     size_t workspace_size = 0;     n = n->next;     int count = 0;     free_section(s);     fprintf(stderr, "layer     filters    size              input                output\n");     while(n){         params.index = count;         fprintf(stderr, "%5d ", count);         s = (section *)n->val;         options = s->options;         layer l = {0};         LAYER_TYPE lt = string_to_layer_type(s->type);         if(lt == CONVOLUTIONAL){             l = parse_convolutional(options, params);         }else if(lt == DECONVOLUTIONAL){             l = parse_deconvolutional(options, params);         }else if(lt == LOCAL){             l = parse_local(options, params);         }else if(lt == ACTIVE){             l = parse_activation(options, params);         }else if(lt == LOGXENT){             l = parse_logistic(options, params);         }else if(lt == L2NORM){             l = parse_l2norm(options, params);         }else if(lt == RNN){             l = parse_rnn(options, params);         }else if(lt == GRU){             l = parse_gru(options, params);         }else if (lt == LSTM) {             l = parse_lstm(options, params);         }else if(lt == CRNN){             l = parse_crnn(options, params);         }else if(lt == CONNECTED){             l = parse_connected(options, params);         }else if(lt == CROP){             l = parse_crop(options, params);         }else if(lt == COST){             l = parse_cost(options, params);         }else if(lt == REGION){             l = parse_region(options, params);         }else if(lt == YOLO){             l = parse_yolo(options, params);         }else if(lt == ISEG){             l = parse_iseg(options, params);         }else if(lt == DETECTION){             l = parse_detection(options, params);         }else if(lt == SOFTMAX){             l = parse_softmax(options, params);             net->hierarchy = l.softmax_tree;         }else if(lt == NORMALIZATION){             l = parse_normalization(options, params);         }else if(lt == BATCHNORM){             l = parse_batchnorm(options, params);         }else if(lt == MAXPOOL){             l = parse_maxpool(options, params);         }else if(lt == REORG){             l = parse_reorg(options, params);         }else if(lt == AVGPOOL){             l = parse_avgpool(options, params);         }else if(lt == ROUTE){             l = parse_route(options, params, net);         }else if(lt == UPSAMPLE){             l = parse_upsample(options, params, net);         }else if(lt == SHORTCUT){             l = parse_shortcut(options, params, net);         }else if(lt == DROPOUT){             l = parse_dropout(options, params);             l.output = net->layers[count-1].output;             l.delta = net->layers[count-1].delta; #ifdef GPU             l.output_gpu = net->layers[count-1].output_gpu;             l.delta_gpu = net->layers[count-1].delta_gpu; #endif         }else{             fprintf(stderr, "Type not recognized: %s\n", s->type);         }         l.clip = net->clip;         l.truth = option_find_int_quiet(options, "truth", 0);         l.onlyforward = option_find_int_quiet(options, "onlyforward", 0);         l.stopbackward = option_find_int_quiet(options, "stopbackward", 0);         l.dontsave = option_find_int_quiet(options, "dontsave", 0);         l.dontload = option_find_int_quiet(options, "dontload", 0);         l.numload = option_find_int_quiet(options, "numload", 0);         l.dontloadscales = option_find_int_quiet(options, "dontloadscales", 0);         l.learning_rate_scale = option_find_float_quiet(options, "learning_rate", 1);         l.smooth = option_find_float_quiet(options, "smooth", 0);         option_unused(options);         net->layers[count] = l;         if (l.workspace_size > workspace_size) workspace_size = l.workspace_size;         free_section(s);         n = n->next;         ++count;         if(n){             params.h = l.out_h;             params.w = l.out_w;             params.c = l.out_c;             params.inputs = l.outputs;         }     }     free_list(sections);     layer out = get_network_output_layer(net);     net->outputs = out.outputs;     net->truths = out.outputs;     if(net->layers[net->n-1].truths) net->truths = net->layers[net->n-1].truths;     net->output = out.output;     net->input = calloc(net->inputs*net->batch, sizeof(float));     net->truth = calloc(net->truths*net->batch, sizeof(float)); #ifdef GPU     net->output_gpu = out.output_gpu;     net->input_gpu = cuda_make_array(net->input, net->inputs*net->batch);     net->truth_gpu = cuda_make_array(net->truth, net->truths*net->batch); #endif     if(workspace_size){         //printf("%ld\n", workspace_size); #ifdef GPU         if(gpu_index >= 0){             net->workspace = cuda_make_array(0, (workspace_size-1)/sizeof(float)+1);         }else {             net->workspace = calloc(1, workspace_size);         } #else         net->workspace = calloc(1, workspace_size); #endif     }     return net; } </code></pre> </details><ul><li><p>首先调用<code>read_cfg</code>读取<code>*.cfg</code>文件，解析为链表结构</p>  <details>  <summary><font color="darkred"> list *read_cfg(char *filename) </font></summary>  <pre><code>  list *read_cfg(char *filename)  {      FILE *file = fopen(filename, "r");      if(file == 0) file_error(filename);      char *line;      int nu = 0;      list *options = make_list();      section *current = 0;      while((line=fgetl(file)) != 0){          ++ nu;          strip(line);          switch(line[0]){              case '[':                  current = malloc(sizeof(section));                  list_insert(options, current);                  current->options = make_list();                  current->type = line;                  break;              case '\0':              case '#':              case ';':                  free(line);                  break;              default:                  if(!read_option(line, current->options)){                      fprintf(stderr, "Config file error line %d, could parse: %s\n", nu, line);                      free(line);                  }                  break;          }      }      fclose(file);      return options;  }  </code></pre>  </details><p>  例如，对于内容为以下的文件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[net]</span><br><span class="line">batch&#x3D;1</span><br><span class="line">height&#x3D;227</span><br><span class="line">width&#x3D;227</span><br><span class="line">channels&#x3D;3</span><br><span class="line"></span><br><span class="line">[convolutional]</span><br><span class="line">filters&#x3D;96</span><br><span class="line">size&#x3D;11</span><br><span class="line">stride&#x3D;4</span><br><span class="line">pad&#x3D;0</span><br><span class="line">activation&#x3D;relu</span><br><span class="line"></span><br><span class="line">[maxpool]</span><br><span class="line">size&#x3D;3</span><br><span class="line">stride&#x3D;2</span><br><span class="line">padding&#x3D;0</span><br></pre></td></tr></table></figure><p>  该函数将其解析为链表<code>list* sections</code>，其元素为<code>section*</code></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *type;     <span class="comment">// 记录`[xxx]`</span></span><br><span class="line">    <span class="built_in">list</span> *options;  <span class="comment">// 记录选项</span></span><br><span class="line">&#125;section;</span><br></pre></td></tr></table></figure><p>  <code>sections -&gt; s -&gt; options</code>也为链表，其元素为<code>kvp*</code>，用以存储键值对</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *key;</span><br><span class="line">    <span class="keyword">char</span> *val;</span><br><span class="line">    <span class="keyword">int</span> used;</span><br><span class="line">&#125; kvp;</span><br></pre></td></tr></table></figure><p>  示意图如下<br>  <img src="/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%B8%89%E3%80%91%E2%80%94%E2%80%94%E8%B0%83%E5%8C%85%E5%A4%A7%E6%B3%95%E5%A5%BD/深度学习框架darknet【三】——调包大法好/cfg.jpg" alt="cfg"></p></li><li><p>之后按上述输出的参数，构建网络</p><ul><li><p>解析网络参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">network *net = make_network(sections-&gt;size - <span class="number">1</span>);</span><br><span class="line">section *s = (section *)n-&gt;val;</span><br><span class="line"><span class="built_in">list</span> *options = s-&gt;options;</span><br><span class="line"><span class="keyword">if</span>(!is_network(s)) error(<span class="string">"First section must be [net] or [network]"</span>);</span><br><span class="line">parse_net_options(options, net);</span><br></pre></td></tr></table></figure><details><summary><font color="darkred"> void parse_net_options(list *options, network *net) </font></summary><pre><code>void parse_net_options(list *options, network *net){    net->batch = option_find_int(options, "batch",1);    net->learning_rate = option_find_float(options, "learning_rate", .001);    net->momentum = option_find_float(options, "momentum", .9);    net->decay = option_find_float(options, "decay", .0001);    int subdivs = option_find_int(options, "subdivisions",1);    net->time_steps = option_find_int_quiet(options, "time_steps",1);    net->notruth = option_find_int_quiet(options, "notruth",0);    net->batch /= subdivs;    net->batch *= net->time_steps;    net->subdivisions = subdivs;    net->random = option_find_int_quiet(options, "random", 0);    net->adam = option_find_int_quiet(options, "adam", 0);    if(net->adam){        net->B1 = option_find_float(options, "B1", .9);        net->B2 = option_find_float(options, "B2", .999);        net->eps = option_find_float(options, "eps", .0000001);    }    net->h = option_find_int_quiet(options, "height",0);    net->w = option_find_int_quiet(options, "width",0);    net->c = option_find_int_quiet(options, "channels",0);    net->inputs = option_find_int_quiet(options, "inputs", net->h * net->w * net->c);    net->max_crop = option_find_int_quiet(options, "max_crop",net->w*2);    net->min_crop = option_find_int_quiet(options, "min_crop",net->w);    net->max_ratio = option_find_float_quiet(options, "max_ratio", (float) net->max_crop / net->w);    net->min_ratio = option_find_float_quiet(options, "min_ratio", (float) net->min_crop / net->w);    net->center = option_find_int_quiet(options, "center",0);    net->clip = option_find_float_quiet(options, "clip", 0);    net->angle = option_find_float_quiet(options, "angle", 0);    net->aspect = option_find_float_quiet(options, "aspect", 1);    net->saturation = option_find_float_quiet(options, "saturation", 1);    net->exposure = option_find_float_quiet(options, "exposure", 1);    net->hue = option_find_float_quiet(options, "hue", 0);    if(!net->inputs && !(net->h && net->w && net->c)) error("No input parameters supplied");    char *policy_s = option_find_str(options, "policy", "constant");    net->policy = get_policy(policy_s);    net->burn_in = option_find_int_quiet(options, "burn_in", 0);    net->power = option_find_float_quiet(options, "power", 4);    if(net->policy == STEP){        net->step = option_find_int(options, "step", 1);        net->scale = option_find_float(options, "scale", 1);    } else if (net->policy == STEPS){        char *l = option_find(options, "steps");        char *p = option_find(options, "scales");        if(!l || !p) error("STEPS policy must have steps and scales in cfg file");        int len = strlen(l);        int n = 1;        int i;        for(i = 0; i < len; ++i){            if (l[i] == ',') ++n;        }        int *steps = calloc(n, sizeof(int));        float *scales = calloc(n, sizeof(float));        for(i = 0; i < n; ++i){            int step    = atoi(l);            float scale = atof(p);            l = strchr(l, ',')+1;            p = strchr(p, ',')+1;            steps[i] = step;            scales[i] = scale;        }        net->scales = scales;        net->steps = steps;        net->num_steps = n;    } else if (net->policy == EXP){        net->gamma = option_find_float(options, "gamma", 1);    } else if (net->policy == SIG){        net->gamma = option_find_float(options, "gamma", 1);        net->step = option_find_int(options, "step", 1);    } else if (net->policy == POLY || net->policy == RANDOM){    }    net->max_batches = option_find_int(options, "max_batches", 0);}</code></pre></details></li><li><p>解析各层参数<br>根据不同类型构建网络，注意不同类型的网络层需定义<code>layer parse_[lt](list *options, size_params params)</code>函数，以申请内存资源等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">size_params params;</span><br><span class="line">...                         <span class="comment">// 尺寸参数</span></span><br><span class="line"></span><br><span class="line">n = n-&gt;next;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">free_section(s);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"layer     filters    size              input                output\n"</span>);</span><br><span class="line"><span class="keyword">while</span>(n)&#123;                   <span class="comment">// 各层遍历</span></span><br><span class="line">    params.index = count;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%5d "</span>, count);</span><br><span class="line">    s = (section *)n-&gt;val;</span><br><span class="line">    options = s-&gt;options;</span><br><span class="line"></span><br><span class="line">    layer l = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    LAYER_TYPE lt = string_to_layer_type(s-&gt;type);</span><br><span class="line">    <span class="keyword">if</span>(lt == CONVOLUTIONAL)&#123;</span><br><span class="line">        l = parse_convolutional(options, params);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(...)&#123;</span><br><span class="line">    ...                     <span class="comment">// 判断类型并构建对应网络层</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Type not recognized: %s\n"</span>, s-&gt;type);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一些其他参数</span></span><br><span class="line">    l.clip = net-&gt;clip;</span><br><span class="line">    ...</span><br><span class="line">    l.smooth = option_find_float_quiet(options, <span class="string">"smooth"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    option_unused(options);</span><br><span class="line">    net-&gt;layers[count] = l;</span><br><span class="line">    <span class="keyword">if</span> (l.workspace_size &gt; workspace_size) workspace_size = l.workspace_size;</span><br><span class="line">    free_section(s);</span><br><span class="line">    n = n-&gt;next;</span><br><span class="line">    ++count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新特征图尺寸，用做下一层网络层的输入尺寸</span></span><br><span class="line">    <span class="keyword">if</span>(n)&#123;</span><br><span class="line">        params.h = l.out_h;</span><br><span class="line">        params.w = l.out_w;</span><br><span class="line">        params.c = l.out_c;</span><br><span class="line">        params.inputs = l.outputs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">free_list(sections);</span><br></pre></td></tr></table></figure><p>以卷积层为例</p><details><summary><font color="darkred"> convolutional_layer parse_convolutional(list *options, size_params params) </font></summary><pre><code>convolutional_layer parse_convolutional(list *options, size_params params){    // 寻找参数，若无指定使用默认值    int n = option_find_int(options, "filters",1);    int size = option_find_int(options, "size",1);    int stride = option_find_int(options, "stride",1);    int pad = option_find_int_quiet(options, "pad",0);    int padding = option_find_int_quiet(options, "padding",0);    int groups = option_find_int_quiet(options, "groups", 1);    if(pad) padding = size/2;    char *activation_s = option_find_str(options, "activation", "logistic");    ACTIVATION activation = get_activation(activation_s);    // 输入尺寸参数    int batch,h,w,c;    h = params.h;    w = params.w;    c = params.c;    batch=params.batch;    if(!(h && w && c)) error("Layer before convolutional layer must output image.");    int batch_normalize = option_find_int_quiet(options, "batch_normalize", 0);    int binary = option_find_int_quiet(options, "binary", 0);    int xnor = option_find_int_quiet(options, "xnor", 0);    // 创建网络层    convolutional_layer layer = make_convolutional_layer(batch,h,w,c,n,groups,size,stride,padding,activation, batch_normalize, binary, xnor, params.net->adam);    layer.flipped = option_find_int_quiet(options, "flipped", 0);    layer.dot = option_find_float_quiet(options, "dot", 0);    return layer;}</code></pre></details></li><li><p>内存指针分配<br>网络输出即最后一层<code>out</code>输出，两者共享内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">layer out = get_network_output_layer(net);</span><br><span class="line">net-&gt;outputs = out.outputs;</span><br><span class="line">net-&gt;truths = out.outputs;</span><br><span class="line"><span class="keyword">if</span>(net-&gt;layers[net-&gt;n<span class="number">-1</span>].truths) net-&gt;truths = net-&gt;layers[net-&gt;n<span class="number">-1</span>].truths;</span><br><span class="line">net-&gt;output = out.output;</span><br><span class="line">net-&gt;input = <span class="built_in">calloc</span>(net-&gt;inputs*net-&gt;batch, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">net-&gt;truth = <span class="built_in">calloc</span>(net-&gt;truths*net-&gt;batch, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(workspace_size)&#123;</span><br><span class="line">    net-&gt;workspace = <span class="built_in">calloc</span>(<span class="number">1</span>, workspace_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>载入权值</p> <details> <summary><font color="darkred"> load_weights(network *net, char *filename) </font></summary> <pre><code> void load_weights(network *net, char *filename) {     load_weights_upto(net, filename, 0, net->n); } void load_weights_upto(network *net, char *filename, int start, int cutoff) {     fprintf(stderr, "Loading weights from %s...", filename);     fflush(stdout);     FILE *fp = fopen(filename, "rb");     if(!fp) file_error(filename);     int major;     int minor;     int revision;     fread(&major, sizeof(int), 1, fp);     fread(&minor, sizeof(int), 1, fp);     fread(&revision, sizeof(int), 1, fp);     if ((major*10 + minor) >= 2 && major < 1000 && minor < 1000){         fread(net->seen, sizeof(size_t), 1, fp);     } else {         int iseen = 0;         fread(&iseen, sizeof(int), 1, fp);         *net->seen = iseen;     }     int transpose = (major > 1000) || (minor > 1000);     int i;     for(i = start; i < net->n && i < cutoff; ++i){         layer l = net->layers[i];         if (l.dontload) continue;         if(l.type == CONVOLUTIONAL || l.type == DECONVOLUTIONAL){             load_convolutional_weights(l, fp);         }         if(l.type == CONNECTED){             load_connected_weights(l, fp, transpose);         }         if(l.type == BATCHNORM){             load_batchnorm_weights(l, fp);         }         if(l.type == CRNN){             load_convolutional_weights(*(l.input_layer), fp);             load_convolutional_weights(*(l.self_layer), fp);             load_convolutional_weights(*(l.output_layer), fp);         }         if(l.type == RNN){             load_connected_weights(*(l.input_layer), fp, transpose);             load_connected_weights(*(l.self_layer), fp, transpose);             load_connected_weights(*(l.output_layer), fp, transpose);         }         if (l.type == LSTM) {             load_connected_weights(*(l.wi), fp, transpose);             load_connected_weights(*(l.wf), fp, transpose);             load_connected_weights(*(l.wo), fp, transpose);             load_connected_weights(*(l.wg), fp, transpose);             load_connected_weights(*(l.ui), fp, transpose);             load_connected_weights(*(l.uf), fp, transpose);             load_connected_weights(*(l.uo), fp, transpose);             load_connected_weights(*(l.ug), fp, transpose);         }         if (l.type == GRU) {             if(1){                 load_connected_weights(*(l.wz), fp, transpose);                 load_connected_weights(*(l.wr), fp, transpose);                 load_connected_weights(*(l.wh), fp, transpose);                 load_connected_weights(*(l.uz), fp, transpose);                 load_connected_weights(*(l.ur), fp, transpose);                 load_connected_weights(*(l.uh), fp, transpose);             }else{                 load_connected_weights(*(l.reset_layer), fp, transpose);                 load_connected_weights(*(l.update_layer), fp, transpose);                 load_connected_weights(*(l.state_layer), fp, transpose);             }         }         if(l.type == LOCAL){             int locations = l.out_w*l.out_h;             int size = l.size*l.size*l.c*l.n*locations;             fread(l.biases, sizeof(float), l.outputs, fp);             fread(l.weights, sizeof(float), size, fp);         }     }     fprintf(stderr, "Done!\n");     fclose(fp); } </code></pre> </details><p> 权值载入比较简单，根据每层的网络参数格式，以二进制格式读取即可。需要注意的是，文件头需读写4个整形<code>int</code>的数据</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> major;</span><br><span class="line"><span class="keyword">int</span> minor;</span><br><span class="line"><span class="keyword">int</span> revision;</span><br><span class="line">fread(&amp;major, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">1</span>, fp);</span><br><span class="line">fread(&amp;minor, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">1</span>, fp);</span><br><span class="line">fread(&amp;revision, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">1</span>, fp);</span><br><span class="line"><span class="keyword">if</span> ((major*<span class="number">10</span> + minor) &gt;= <span class="number">2</span> &amp;&amp; major &lt; <span class="number">1000</span> &amp;&amp; minor &lt; <span class="number">1000</span>)&#123;</span><br><span class="line">    fread(net-&gt;seen, <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>), <span class="number">1</span>, fp);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> iseen = <span class="number">0</span>;</span><br><span class="line">    fread(&amp;iseen, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">1</span>, fp);</span><br><span class="line">    *net-&gt;seen = iseen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 以卷积层为例，需要读取卷积核<code>weights</code>、偏置<code>biases</code>，在无批归一<code>batchnorm</code>的情况下，其读取函数为</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">load_convolutional_weights</span><span class="params">(layer l, FILE *fp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l.numload) l.n = l.numload;</span><br><span class="line">    <span class="keyword">int</span> num = l.c/l.groups*l.n*l.size*l.size;</span><br><span class="line">    fread(l.biases, <span class="keyword">sizeof</span>(<span class="keyword">float</span>), l.n, fp);</span><br><span class="line">    fread(l.weights, <span class="keyword">sizeof</span>(<span class="keyword">float</span>), num, fp);</span><br><span class="line">    <span class="keyword">if</span> (l.flipped) &#123;</span><br><span class="line">        transpose_matrix(l.weights, l.c*l.size*l.size, l.n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Load-Data"><a href="#Load-Data" class="headerlink" title="Load Data"></a>Load Data</h2><p>训练过程中关于数据载入的代码整理如下，通过多线程的方式进行数据读取。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *train_images = <span class="string">"/data/voc/train.txt"</span>;</span><br><span class="line"><span class="keyword">int</span> imgs = net-&gt;batch*net-&gt;subdivisions;</span><br><span class="line"><span class="keyword">int</span> i = *net-&gt;seen/imgs;</span><br><span class="line">data train, buffer;</span><br><span class="line"></span><br><span class="line">layer l = net-&gt;layers[net-&gt;n - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件列表</span></span><br><span class="line"><span class="built_in">list</span> *plist = get_paths(train_images);</span><br><span class="line"><span class="keyword">char</span> **paths = (<span class="keyword">char</span> **)list_to_array(plist);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据读取参数</span></span><br><span class="line">load_args args  = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">args.paths      = paths;</span><br><span class="line">args.w          = net-&gt;w;</span><br><span class="line">args.h          = net-&gt;h;</span><br><span class="line">args.n          = imgs;</span><br><span class="line">args.m          = plist-&gt;size;</span><br><span class="line">args.classes    = l.classes;</span><br><span class="line">args.jitter     = l.jitter;</span><br><span class="line">args.num_boxes  = l.side;</span><br><span class="line">args.d          = &amp;buffer;</span><br><span class="line">args.type       = REGION_DATA;</span><br><span class="line">args.angle      = net-&gt;angle;</span><br><span class="line">args.exposure   = net-&gt;exposure;</span><br><span class="line">args.saturation = net-&gt;saturation;</span><br><span class="line">args.hue        = net-&gt;hue;</span><br><span class="line"><span class="keyword">pthread_t</span> load_thread = load_data_in_thread(args);</span><br><span class="line"></span><br><span class="line"><span class="keyword">clock_t</span> time;</span><br><span class="line"><span class="keyword">while</span>(get_current_batch(net) &lt; net-&gt;max_batches)&#123;</span><br><span class="line">    i += <span class="number">1</span>;</span><br><span class="line">    time = clock();</span><br><span class="line">    pthread_join(load_thread, <span class="number">0</span>);           <span class="comment">// 主线程阻塞，等待load_thread线程结束</span></span><br><span class="line">    train = buffer;</span><br><span class="line">    load_thread = load_data_in_thread(args);<span class="comment">// 创建新线程</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Loaded: %lf seconds\n"</span>, sec(clock()-time));</span><br><span class="line">    </span><br><span class="line">    ... <span class="comment">// 网络训练</span></span><br><span class="line"></span><br><span class="line">    free_data(train);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下两个函数用于读取文本文件，每行存储对应的样本路径，<code>char **paths</code>每个内存单元指向字符串首地址。</p><details><summary><font color="darkred"> list *get_paths(char *filename) </font></summary><pre><code>list *get_paths(char *filename){    char *path;    FILE *file = fopen(filename, "r");    if(!file) file_error(filename);    list *lines = make_list();    while((path=fgetl(file))){        list_insert(lines, path);    }    fclose(file);    return lines;}</code></pre></details><details><summary><font color="darkred"> void **list_to_array(list *l) </font></summary><pre><code>void **list_to_array(list *l){    void **a = calloc(l->size, sizeof(void*));    int count = 0;    node *n = l->front;    while(n){        a[count++] = n->val;        n = n->next;    }    return a;}</code></pre></details><p>重点关注多线程数据载入的部分，先介绍Linux系统下线程控制的函数，以下资料来源于百度百科<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">函数定义：<span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **retval)</span></span>;</span><br><span class="line">描述：pthread_join()函数，以阻塞的方式等待thread指定的线程结束。当函数返回时，被等待线程的资源被收回。如果线程已经结束，那么该函数会立即返回。并且thread指定的线程必须是joinable的</span><br><span class="line">参数：</span><br><span class="line">    - thread: 线程标识符，即线程ID，标识唯一线程；</span><br><span class="line">    - retval: 用户定义的指针，用来存储被等待线程的返回值。</span><br><span class="line">返回值：<span class="number">0</span>代表成功，若失败则返回错误号</span><br><span class="line"></span><br><span class="line">函数定义：<span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *tidp, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr, (<span class="keyword">void</span>*)(*start_rtn)(<span class="keyword">void</span>*),<span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line">描述：pthread_create是类Unix操作系统（Unix、Linux、Mac OS X等）的创建线程的函数。它的功能是创建线程（实际上就是确定调用该线程函数的入口点），在线程创建以后，就开始运行相关的线程函数。</span><br><span class="line">参数：</span><br><span class="line">    - tidp: 指向线程标识符的指针；</span><br><span class="line">    - attr: 设置线程属性；</span><br><span class="line">    - start_rtn: 线程运行函数的起始地址；</span><br><span class="line">    - arg: 运行函数的参数。</span><br><span class="line">返回值：表示成功，返回<span class="number">0</span>；表示出错，返回<span class="number">-1</span>。</span><br></pre></td></tr></table></figure></p><details><summary><font color="darkred"> pthread_t load_data_in_thread(load_args args) </font></summary><pre><code>pthread_t load_data_in_thread(load_args args){    pthread_t thread;    struct load_args *ptr = calloc(1, sizeof(struct load_args));    *ptr = args;    if(pthread_create(&thread, 0, load_thread, ptr)) error("Thread creation failed");    return thread;}</code></pre></details><p>以上函数用于线程启动，在某批次数据读取结束前，主线程将被阻塞。读取结束后，<code>train = buffer</code>将缓冲区指针传递给<code>train</code>，再重新启动线程。注意在线程函数内，缓冲区<code>buffer</code>各指针将被分配新的内存地址，以防止下一批数据对当前批数据造成影响，因此当前批数据所占内存资源需要通过<code>free_data(train)</code>来释放。</p><details><summary><font color="darkred"> void *load_thread(void *ptr) </font></summary><pre><code>void *load_thread(void *ptr){    load_args a = *(struct load_args*)ptr;    if(a.exposure == 0) a.exposure = 1;    if(a.saturation == 0) a.saturation = 1;    if(a.aspect == 0) a.aspect = 1;    if (a.type == OLD_CLASSIFICATION_DATA){        *a.d = load_data_old(a.paths, a.n, a.m, a.labels, a.classes, a.w, a.h);    } else if (a.type == REGRESSION_DATA){        *a.d = load_data_regression(a.paths, a.n, a.m, a.classes, a.min, a.max, a.size, a.angle, a.aspect, a.hue, a.saturation, a.exposure);    } else if (a.type == CLASSIFICATION_DATA){        *a.d = load_data_augment(a.paths, a.n, a.m, a.labels, a.classes, a.hierarchy, a.min, a.max, a.size, a.angle, a.aspect, a.hue, a.saturation, a.exposure, a.center);    } else if (a.type == SUPER_DATA){        *a.d = load_data_super(a.paths, a.n, a.m, a.w, a.h, a.scale);    } else if (a.type == WRITING_DATA){        *a.d = load_data_writing(a.paths, a.n, a.m, a.w, a.h, a.out_w, a.out_h);    } else if (a.type == ISEG_DATA){        *a.d = load_data_iseg(a.n, a.paths, a.m, a.w, a.h, a.classes, a.num_boxes, a.scale, a.min, a.max, a.angle, a.aspect, a.hue, a.saturation, a.exposure);    } else if (a.type == INSTANCE_DATA){        *a.d = load_data_mask(a.n, a.paths, a.m, a.w, a.h, a.classes, a.num_boxes, a.coords, a.min, a.max, a.angle, a.aspect, a.hue, a.saturation, a.exposure);    } else if (a.type == SEGMENTATION_DATA){        *a.d = load_data_seg(a.n, a.paths, a.m, a.w, a.h, a.classes, a.min, a.max, a.angle, a.aspect, a.hue, a.saturation, a.exposure, a.scale);    } else if (a.type == REGION_DATA){        *a.d = load_data_region(a.n, a.paths, a.m, a.w, a.h, a.num_boxes, a.classes, a.jitter, a.hue, a.saturation, a.exposure);    } else if (a.type == DETECTION_DATA){        *a.d = load_data_detection(a.n, a.paths, a.m, a.w, a.h, a.num_boxes, a.classes, a.jitter, a.hue, a.saturation, a.exposure);    } else if (a.type == SWAG_DATA){        *a.d = load_data_swag(a.paths, a.n, a.classes, a.jitter);    } else if (a.type == COMPARE_DATA){        *a.d = load_data_compare(a.n, a.paths, a.m, a.classes, a.w, a.h);    } else if (a.type == IMAGE_DATA){        *(a.im) = load_image_color(a.path, 0, 0);        *(a.resized) = resize_image(*(a.im), a.w, a.h);    } else if (a.type == LETTERBOX_DATA){        *(a.im) = load_image_color(a.path, 0, 0);        *(a.resized) = letterbox_image(*(a.im), a.w, a.h);    } else if (a.type == TAG_DATA){        *a.d = load_data_tag(a.paths, a.n, a.m, a.classes, a.min, a.max, a.size, a.angle, a.aspect, a.hue, a.saturation, a.exposure);    }    free(ptr);    return 0;}</code></pre></details><p>那么线程启动后，执行的函数<code>void *load_thread(void *ptr)</code>做了哪些工作呢？首先初始化数据读取参数，对应不同类型的数据，分别进入对应的数据读取子函数，例如分类、检测、图像等等，读取的数据以指针的形式存放在<code>a.d</code>中，最后释放在线程创建时申请的参数指针<code>ptr</code>。</p><details><summary><font color="darkred"> data load_data_region(int n, char **paths, int m, int w, int h, int size, int classes, float jitter, float hue, float saturation, float exposure) </font></summary><pre><code>data load_data_region(int n, char **paths, int m, int w, int h, int size, int classes, float jitter, float hue, float saturation, float exposure){    char **random_paths = get_random_paths(paths, n, m);    int i;    data d = {0};    d.shallow = 0;    d.X.rows = n;    d.X.vals = calloc(d.X.rows, sizeof(float*));    d.X.cols = h*w*3;    int k = size*size*(5+classes);    d.y = make_matrix(n, k);    for(i = 0; i < n; ++i){        image orig = load_image_color(random_paths[i], 0, 0);        int oh = orig.h;        int ow = orig.w;        int dw = (ow*jitter);        int dh = (oh*jitter);        int pleft  = rand_uniform(-dw, dw);        int pright = rand_uniform(-dw, dw);        int ptop   = rand_uniform(-dh, dh);        int pbot   = rand_uniform(-dh, dh);        int swidth =  ow - pleft - pright;        int sheight = oh - ptop - pbot;        float sx = (float)swidth  / ow;        float sy = (float)sheight / oh;        int flip = rand()%2;        image cropped = crop_image(orig, pleft, ptop, swidth, sheight);        float dx = ((float)pleft/ow)/sx;        float dy = ((float)ptop /oh)/sy;        image sized = resize_image(cropped, w, h);        if(flip) flip_image(sized);        random_distort_image(sized, hue, saturation, exposure);        d.X.vals[i] = sized.data;        fill_truth_region(random_paths[i], d.y.vals[i], classes, size, flip, dx, dy, 1./sx, 1./sy);        free_image(orig);        free_image(cropped);    }    free(random_paths);    return d;}</code></pre></details><p>对于YOLO，其载入的数据类型为<code>REGION_DATA</code>，所以进入到<code>load_data_region</code>函数，这里需要关注的为数据存放的格式。可以看到，<code>d.X</code>为<code>matrix</code>类型，其行数<code>rows</code>与列数<code>cols</code>在下面函数中分别指定为<code>n</code>与<code>h*w*3</code>，即尺寸为<code>n × h*w*3</code>，每行表示一副图像数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">d.X.rows = n;</span><br><span class="line">d.X.cols = h*w*<span class="number">3</span>;</span><br><span class="line">d.X.vals = <span class="built_in">calloc</span>(d.X.rows, <span class="keyword">sizeof</span>(<span class="keyword">float</span>*));    <span class="comment">// 该指针用于存放内存空间的首地址，即“指针的指针”</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">    image orig = load_image_color(random_paths[i], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    ...     <span class="comment">// 数据扩增、缩放等常规操作</span></span><br><span class="line">    d.X.vals[i] = sized.data;</span><br><span class="line">    fill_truth_region(random_paths[i], d.y.vals[i], classes, size, flip, dx, dy, <span class="number">1.</span>/sx, <span class="number">1.</span>/sy); <span class="comment">// 获取groundtrurh，存储在`d.y`中</span></span><br><span class="line">    ...     <span class="comment">// 内存释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Forward-Backward-and-Update"><a href="#Forward-Backward-and-Update" class="headerlink" title="Forward, Backward and Update"></a>Forward, Backward and Update</h2><p>读取数据后，训练网络已被包装为函数<code>train_network</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> loss = train_network(net, train);</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">train_network</span><span class="params">(network *net, data d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(d.X.rows % net-&gt;batch == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> batch = net-&gt;batch;</span><br><span class="line">    <span class="keyword">int</span> n = d.X.rows / batch;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">float</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        get_next_batch(d, batch, i*batch, net-&gt;input, net-&gt;truth);  <span class="comment">// 获取下一批次数据</span></span><br><span class="line">        <span class="keyword">float</span> err = train_network_datum(net);                       <span class="comment">// 前向、反向、更新</span></span><br><span class="line">        sum += err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">float</span>)sum/(n*batch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中获取数据部分，将<code>d.X.vals</code>与<code>d.y.vals</code>内容分别拷贝至<code>net-&gt;input</code>与<code>net-&gt;truth</code></p><details><summary><font color="darkred"> void get_next_batch(data d, int n, int offset, float *X, float *y) </font></summary><pre><code>void get_next_batch(data d, int n, int offset, float *X, float *y){    int j;    for(j = 0; j < n; ++j){        int index = offset + j;        memcpy(X+j*d.X.cols, d.X.vals[index], d.X.cols*sizeof(float));        if(y) memcpy(y+j*d.y.cols, d.y.vals[index], d.y.cols*sizeof(float));    }}</code></pre></details><p>训练部分，<code>net-&gt;input</code>作为输入，前向计算得到<code>net-&gt;cost</code>，再反向计算得到各层梯度，之后梯度累加到各层参数上进行参数更新</p><details><summary><font color="darkred"> float train_network_datum(network *net) </font></summary><pre><code>float train_network_datum(network *net){    *net->seen += net->batch;    net->train = 1;    forward_network(net);    backward_network(net);    float error = *net->cost;    if(((*net->seen)/net->batch)%net->subdivisions == 0) update_network(net);    return error;}</code></pre></details><p>依次调用各层的<code>l.forward</code>，<code>l.backward</code>，<code>l.update</code></p><details><summary><font color="darkred"> forward, backward, update </font></summary><pre><code>void forward_network(network *netp){    network net = *netp;    int i;    for(i = 0; i < net.n; ++i){        net.index = i;        layer l = net.layers[i];        if(l.delta){            fill_cpu(l.outputs * l.batch, 0, l.delta, 1);        }        l.forward(l, net);        net.input = l.output;        if(l.truth) {            net.truth = l.output;        }    }    calc_network_cost(netp);}void backward_network(network *netp){    network net = *netp;    int i;    network orig = net;    for(i = net.n-1; i >= 0; --i){        layer l = net.layers[i];        if(l.stopbackward) break;        if(i == 0){            net = orig;        }else{            layer prev = net.layers[i-1];            net.input = prev.output;            net.delta = prev.delta;        }        net.index = i;        l.backward(l, net);    }}void update_network(network *netp){    network net = *netp;    int i;    update_args a = {0};    a.batch = net.batch*net.subdivisions;    a.learning_rate = get_current_rate(netp);    a.momentum = net.momentum;    a.decay = net.decay;    a.adam = net.adam;    a.B1 = net.B1;    a.B2 = net.B2;    a.eps = net.eps;    ++*net.t;    a.t = *net.t;    for(i = 0; i < net.n; ++i){        layer l = net.layers[i];        if(l.update){            l.update(l, a);        }    }}</code></pre></details><p>注意在初始化网络层时，结构体<code>struct layer</code>中已初始化三个函数指针<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">layer</span>&#123;</span></span><br><span class="line">    ...             <span class="comment">// 略</span></span><br><span class="line">    <span class="keyword">void</span> (*forward)   (struct layer, struct network);</span><br><span class="line">    <span class="keyword">void</span> (*backward)  (struct layer, struct network);</span><br><span class="line">    <span class="keyword">void</span> (*update)    (struct layer, update_args);</span><br><span class="line">    ...             <span class="comment">// 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以卷积层为例，<code>make_convolutional_layer</code>中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l.forward  = forward_convolutional_layer;</span><br><span class="line">l.backward = backward_convolutional_layer;</span><br><span class="line">l.update   = update_convolutional_layer;</span><br></pre></td></tr></table></figure></p><h1 id="Test-Stage"><a href="#Test-Stage" class="headerlink" title="Test Stage"></a>Test Stage</h1><p>指定参数2为<code>test</code>，可进入测试函数段，提示输入图片路径<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./darknet yolo <span class="built_in">test</span> cfg/yolov3.cfg yolov3.weights</span></span><br><span class="line">layer     filters    size              input                output</span><br><span class="line">    0 conv     32  3 x 3 / 1   608 x 608 x   3   -&gt;   608 x 608 x  32  0.639 BFLOPs</span><br><span class="line">    1 conv     64  3 x 3 / 2   608 x 608 x  32   -&gt;   304 x 304 x  64  3.407 BFLOPs</span><br><span class="line">... # 略</span><br><span class="line">  105 conv    255  1 x 1 / 1    76 x  76 x 256   -&gt;    76 x  76 x 255  0.754 BFLOPs</span><br><span class="line">  106 yolo</span><br><span class="line">Loading weights from yolov3.weights...Done!</span><br><span class="line">Enter Image Path:</span><br></pre></td></tr></table></figure></p><p>原始测试函数<code>examples/yolo.c/test_yolo</code>并不能实现检测功能(<code>detector.c/test_detector</code>可以使用)，所以将其修改为以下</p><details><summary><font color="darkred"> void test_yolo(char *cfgfile, char *weightfile, char *filename, float thresh) </font></summary><pre><code>void test_yolo(char *cfgfile, char *weightfile, char *filename, float thresh){    // 获取标签名称、字母表等    list *options = read_data_cfg("cfg/coco.data");    char *name_list = option_find_str(options, "names", "data/names.list");    char **names = get_labels(name_list);    image **alphabet = load_alphabet();    // 构建网络    network *net = load_network(cfgfile, weightfile, 0);    set_batch_network(net, 1);    // 一些参数。。。    srand(2222222);    double time;    char buff[256];    char *input = buff;    float nms=.45;    while(1){        if(filename){            strncpy(input, filename, 256);        } else {            printf("Enter Image Path: ");            fflush(stdout);            input = fgets(input, 256, stdin);            if(!input) return;            strtok(input, "\n");        }        image im = load_image_color(input,0,0);        image sized = letterbox_image(im, net->w, net->h);        layer l = net->layers[net->n-1];        float *X = sized.data;        time=what_time_is_it_now();        network_predict(net, X);        printf("%s: Predicted in %f seconds.\n", input, what_time_is_it_now()-time);        int nboxes = 0;        detection *dets = get_network_boxes(net, im.w, im.h, thresh, 0, 0, 1, &nboxes);        if (nms) do_nms_sort(dets, nboxes, l.classes, nms);        draw_detections(im, dets, nboxes, thresh, names, alphabet, l.classes);        free_detections(dets, nboxes);        save_image(im, "predictions");#ifdef OPENCV        make_window("predictions", 512, 512, 0);        show_image(im, "predictions", 0);#endif        free_image(im);        free_image(sized);        if(filename) break;    }}</code></pre></details><p>主要的过程如下</p><ol><li><p>读取图像、裁剪并缩放</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">image im = load_image_color(input,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">image sized = letterbox_image(im, net-&gt;w, net-&gt;h);</span><br></pre></td></tr></table></figure> <details> <summary><font color="darkred"> image letterbox_image(image im, int w, int h) </font></summary> <pre><code> image letterbox_image(image im, int w, int h) {     int new_w = im.w;     int new_h = im.h;     if (((float)w/im.w) < ((float)h/im.h)) {         new_w = w;         new_h = (im.h * w)/im.w;     } else {         new_h = h;         new_w = (im.w * h)/im.h;     }     image resized = resize_image(im, new_w, new_h);     image boxed = make_image(w, h, im.c);     fill_image(boxed, .5);     //int i;     //for(i = 0; i < boxed.w*boxed.h*boxed.c; ++i) boxed.data[i] = 0;     embed_image(resized, boxed, (w-new_w)/2, (h-new_h)/2);      free_image(resized);     return boxed; } </code></pre> </details></li><li><p>前向运算</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">layer l  = net-&gt;layers[net-&gt;n<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">float</span> *X = sized.data;</span><br><span class="line">time = what_time_is_it_now();</span><br><span class="line">network_predict(net, X);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s: Predicted in %f seconds.\n"</span>, input, what_time_is_it_now()-time);</span><br></pre></td></tr></table></figure></li><li><p>根据结果生成候选框</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nboxes = <span class="number">0</span>;   </span><br><span class="line">detection *dets = get_network_boxes(net, im.w, im.h, thresh, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, &amp;nboxes);</span><br></pre></td></tr></table></figure> <details> <summary><font color="darkred"> detection *get_network_boxes(network *net, int w, int h, float thresh, float hier, int *map, int relative, int *num) </font></summary> <pre><code> detection *get_network_boxes(network *net, int w, int h, float thresh, float hier, int *map, int relative, int *num) {     detection *dets = make_network_boxes(net, thresh, num);     fill_network_boxes(net, w, h, thresh, hier, map, relative, dets);     return dets; } </code></pre> </details><p> YOLO详细算法不过多介绍。</p></li><li><p>非极大值抑制(NMS)</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nms) do_nms_sort(dets, nboxes, l.classes, nms);</span><br></pre></td></tr></table></figure> <details> <summary><font color="darkred"> void do_nms_sort(detection *dets, int total, int classes, float thresh) </font></summary> <pre><code> void do_nms_sort(detection *dets, int total, int classes, float thresh) {     int i, j, k;     k = total-1;     for(i = 0; i <= k;="" ++i){="" if(dets[i].objectness="=" 0){="" detection="" swap="dets[i];" dets[i]="dets[k];" dets[k]="swap;" --k;="" --i;="" }="" total="k+1;" for(k="0;" k="" <="" classes;="" ++k){="" for(i="0;" i="" total;="" dets[i].sort_class="k;" qsort(dets,="" total,="" sizeof(detection),="" nms_comparator);="" if(dets[i].prob[k]="=" 0)="" continue;="" box="" a="dets[i].bbox;" for(j="i+1;" j="" ++j){="" b="dets[j].bbox;" if="" (box_iou(a,="" b)=""> thresh){                     dets[j].prob[k] = 0;                 }             }         }     } } </=></code></pre> </details></li><li><p>绘制并显示</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">draw_detections(im, dets, nboxes, thresh, names, alphabet, l.classes);</span><br><span class="line">save_image(im, <span class="string">"predictions"</span>);</span><br><span class="line">make_window(<span class="string">"predictions"</span>, <span class="number">512</span>, <span class="number">512</span>, <span class="number">0</span>);</span><br><span class="line">show_image(im, <span class="string">"predictions"</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li><li><p>释放资源</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">free_detections(dets, nboxes);</span><br><span class="line">free_image(im);</span><br><span class="line">free_image(sized);</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深度学习框架darknet【二】——目录结构</title>
      <link href="/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%BA%8C%E3%80%91%E2%80%94%E2%80%94%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
      <url>/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%BA%8C%E3%80%91%E2%80%94%E2%80%94%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://louishsu.xyz/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%B8%80%E3%80%91%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">深度学习框架darknet【一】——简单使用</a></li><li><a href="https://louishsu.xyz/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%BA%8C%E3%80%91%E2%80%94%E2%80%94%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/" target="_blank" rel="noopener">深度学习框架darknet【二】——目录结构</a></li><li><a href="https://louishsu.xyz/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%B8%89%E3%80%91%E2%80%94%E2%80%94%E8%B0%83%E5%8C%85%E5%A4%A7%E6%B3%95%E5%A5%BD/" target="_blank" rel="noopener">深度学习框架darknet【三】——调包大法好</a></li><li><a href="https://louishsu.xyz/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E5%9B%9B%E3%80%91%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9/" target="_blank" rel="noopener">深度学习框架darknet【四】——网络配置选项</a></li><li><a href="https://louishsu.xyz/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%BA%94%E3%80%91%E2%80%94%E2%80%94%E8%AE%AD%E7%BB%83%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">深度学习框架darknet【五】——训练解析</a></li></ul><h1 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tree -L 1</span></span><br><span class="line">.</span><br><span class="line">├── cfg/</span><br><span class="line">├── data/</span><br><span class="line">├── examples/</span><br><span class="line">├── include/</span><br><span class="line">├── python/</span><br><span class="line">├── scripts/</span><br><span class="line">├── src/</span><br><span class="line">├── LICENSE</span><br><span class="line">├── LICENSE.fuck</span><br><span class="line">├── LICENSE.gen</span><br><span class="line">├── LICENSE.gpl</span><br><span class="line">├── LICENSE.meta</span><br><span class="line">├── LICENSE.mit</span><br><span class="line">├── LICENSE.v1</span><br><span class="line">├── Makefile</span><br><span class="line">└── README.md</span><br><span class="line"></span><br><span class="line">7 directories, 9 files</span><br></pre></td></tr></table></figure><h1 id="cfg-：网络结构"><a href="#cfg-：网络结构" class="headerlink" title="cfg/：网络结构"></a><code>cfg/</code>：网络结构</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">darknet/cfg$ tree</span><br><span class="line">.</span><br><span class="line">├── alexnet.cfg</span><br><span class="line">├── ... # 略</span><br><span class="line">├── yolo9000.cfg</span><br><span class="line">├── yolov1.cfg</span><br><span class="line">├── yolov1-tiny.cfg</span><br><span class="line">├── yolov2.cfg</span><br><span class="line">├── yolov2-tiny.cfg</span><br><span class="line">├── yolov2-tiny-voc.cfg</span><br><span class="line">├── yolov2-voc.cfg</span><br><span class="line">├── yolov3.cfg</span><br><span class="line">├── yolov3-openimages.cfg</span><br><span class="line">├── yolov3-spp.cfg</span><br><span class="line">├── yolov3-tiny.cfg</span><br><span class="line">└── yolov3-voc.cfg</span><br><span class="line"></span><br><span class="line">0 directories, 52 files</span><br></pre></td></tr></table></figure><p><code>cfg/</code>内存放的<code>*.cfg</code>文件，用于记录网络结构，类似Caffe的<code>*.prototxt</code>文件，通过调用<code>darknet.h/network *parse_network_cfg(char *filename)</code>，可读取指定的<code>*.cfg</code>文件，快速构建深度神经网络。</p><h1 id="include-，src-：底层实现"><a href="#include-，src-：底层实现" class="headerlink" title="include/，src/：底层实现"></a><code>include/</code>，<code>src/</code>：底层实现</h1><p><code>include/</code>内仅包含全局头文件<code>darknet.h</code>，主要用于定义枚举(enum)、结构体(struct)和声明常用函数，几个重要的定义声明整理如下(不全)</p><div class="table-container"><table><thead><tr><th>名称</th><th>类型</th><th>作用</th></tr></thead><tbody><tr><td>ACTIVATION</td><td>enum</td><td>激活函数类型</td></tr><tr><td>LAYER_TYPE</td><td>enum</td><td>网络层类型</td></tr><tr><td>COST_TYPE</td><td>enum</td><td>损失类型</td></tr><tr><td>learning_rate_policy</td><td>enum</td><td>学习率调整策略类型</td></tr><tr><td>data_type</td><td>enum</td><td>数据载入类型</td></tr><tr><td>image</td><td>struct</td><td>图像结构，数据存放格式为<code>CHW</code></td></tr><tr><td>update_args</td><td>struct</td><td>优化器参数</td></tr><tr><td>layer</td><td>struct</td><td>面向网络层对象，通用的网络层结构定义，除必要的内存指针(weight, delta, output等)，还包括前向(forward)、反向(backward)、参数更新(update)等函数指针</td></tr><tr><td>network</td><td>struct</td><td>面向网络对象，通用的网络结构定义，包括网络层指针(layers)、优化参数(batch, epoch, learning_rate, momentum, decay等)、输入输出内存指针(input, truth, delta, workspace等)</td></tr><tr><td>augment_args</td><td>struct</td><td>图像扩增属性</td></tr><tr><td>box</td><td>struct</td><td>边界框，包含<code>x, y, w, h</code></td></tr><tr><td>data</td><td>struct</td><td>用于读取数据，<code>X</code>与<code>y</code>为二维矩阵<code>matrix</code>，每行表示一个样本</td></tr><tr><td>load_args</td><td>struct</td><td>数据读取参数</td></tr><tr><td>network <em>load_network(char </em>cfg, char *weights, int clear)</td><td>function</td><td>载入网络，内部调用<code>parse_network_cfg</code>与<code>load_weights</code></td></tr><tr><td>float train_networks(network **nets, int n, data d, int interval)</td><td>function</td><td>训练网络，内部调用前向、反向、更新等函数</td></tr><tr><td>network <em>parse_network_cfg(char </em>filename)</td><td>function</td><td>解析<code>*.cfg</code>文件以快速构建网络</td></tr><tr><td>list <em>read_cfg(char </em>filename)</td><td>function</td><td>读取配置文件</td></tr><tr><td>void save_weights(network <em>net, char </em>filename)</td><td>function</td><td>保存网络权重</td></tr><tr><td>void load_weights(network <em>net, char </em>filename)</td><td>function</td><td>读取网络权重</td></tr><tr><td>void save_weights_upto(network <em>net, char </em>filename, int cutoff)</td><td>function</td><td>可指定截断的网络权重保存</td></tr><tr><td>void load_weights_upto(network <em>net, char </em>filename, int start, int cutoff)</td><td>function</td><td>可指定截断的网络权重读取</td></tr><tr><td>void forward_network(network *net)</td><td>function</td><td>网络前向运算，依次调用各层前向运算函数</td></tr><tr><td>void backward_network(network *net)</td><td>function</td><td>网络反向运算求取梯度，依次调用各层反向运算函数</td></tr><tr><td>void update_network(network *net)</td><td>function</td><td>更新网络参数，依次调用各层参数更新函数</td></tr><tr><td>void forward_network_gpu(network *net)</td><td>function</td><td>网络前向运算，CPU加速</td></tr><tr><td>void backward_network_gpu(network *net)</td><td>function</td><td>网络反向运算求取梯度，CPU加速</td></tr><tr><td>void update_network_gpu(network *net)</td><td>function</td><td>更新网络参数，CPU加速</td></tr><tr><td>void cuda_set_device(int n)</td><td>function</td><td>指定GPU设备</td></tr><tr><td>void cuda_free(float *x_gpu)</td><td>function</td><td>释放指针对应的显存</td></tr><tr><td>float <em>cuda_make_array(float </em>x, size_t n)</td><td>function</td><td>申请固定字节数的显存</td></tr><tr><td>void cuda_pull_array(float <em>x_gpu, float </em>x, size_t n)</td><td>function</td><td>从显存读取数据，存放至内存</td></tr><tr><td>void cuda_push_array(float <em>x_gpu, float </em>x, size_t n)</td><td>function</td><td>从内存读取数据，存放至显存</td></tr><tr><td>float <em>network_predict(network </em>net, float *input)</td><td>function</td><td>指定输入，前向运算并输出结果</td></tr><tr><td>int resize_network(network *net, int w, int h)</td><td>function</td><td>调整网络输入尺寸，相应改变各层尺寸</td></tr><tr><td>void free_network(network *net)</td><td>function</td><td>释放网络所占资源，内部释放各层资源</td></tr><tr><td>void free_layer(layer)</td><td>function</td><td>释放网络层所占资源</td></tr><tr><td>list <em>read_data_cfg(char </em>filename)</td><td>function</td><td>读取数据参数配置文件</td></tr><tr><td>load_args get_base_args(network *net)</td><td>function</td><td>读取网络参数以确定数据读取参数</td></tr><tr><td>pthread_t load_data(load_args args)</td><td>function</td><td>创建数据读取线程</td></tr><tr><td>void free_data(data d)</td><td>function</td><td>释放网络层所占资源</td></tr><tr><td>image load_image_color(char *filename, int w, int h)</td><td>function</td><td>读取3通道图</td></tr><tr><td>image resize_image(image im, int w, int h)</td><td>function</td><td>图像尺寸调整</td></tr><tr><td>image crop_image(image im, int dx, int dy, int w, int h)</td><td>function</td><td>图像裁剪</td></tr><tr><td>image rotate_image(image m, float rad)</td><td>function</td><td>图像旋转</td></tr><tr><td>void flip_image(image a)</td><td>function</td><td>图像翻转</td></tr><tr><td>int show_image(image p, const char *name, int ms)</td><td>function</td><td>图像显示，若OpenCV可用则显示，否则保存图像</td></tr><tr><td>void free_image(image m)</td><td>function</td><td>释放图像所占资源</td></tr><tr><td>…</td><td>…</td><td>…</td></tr></tbody></table></div><h1 id="examples-：算法实现"><a href="#examples-：算法实现" class="headerlink" title="examples/：算法实现"></a><code>examples/</code>：算法实现</h1><p>调用<code>include/</code>与<code>src/</code>底层函数，实现如<code>yolo</code>、<code>darknet</code>、<code>rnn</code>等算法，如<code>yolo</code>主函数内可进行训练、测试、演示等操作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run_yolo</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *prefix = find_char_arg(argc, argv, <span class="string">"-prefix"</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">float</span> thresh = find_float_arg(argc, argv, <span class="string">"-thresh"</span>, <span class="number">.2</span>);</span><br><span class="line">    <span class="keyword">int</span> cam_index = find_int_arg(argc, argv, <span class="string">"-c"</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> frame_skip = find_int_arg(argc, argv, <span class="string">"-s"</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s %s [train/test/valid] [cfg] [weights (optional)]\n"</span>, argv[<span class="number">0</span>], argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> avg = find_int_arg(argc, argv, <span class="string">"-avg"</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">char</span> *cfg = argv[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">char</span> *weights = (argc &gt; <span class="number">4</span>) ? argv[<span class="number">4</span>] : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *filename = (argc &gt; <span class="number">5</span>) ? argv[<span class="number">5</span>]: <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span>==<span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">"test"</span>)) test_yolo(cfg, weights, filename, thresh);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span>==<span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">"train"</span>)) train_yolo(cfg, weights);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span>==<span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">"valid"</span>)) validate_yolo(cfg, weights);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span>==<span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">"recall"</span>)) validate_yolo_recall(cfg, weights);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span>==<span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">"demo"</span>)) demo(cfg, weights, thresh, cam_index, filename, voc_names, <span class="number">20</span>, frame_skip, prefix, avg, <span class="number">.5</span>, <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="python-：提供接口"><a href="#python-：提供接口" class="headerlink" title="python/：提供接口"></a><code>python/</code>：提供接口</h1><p>调用<code>ctypes</code>模块，可在python中调用darknet库，如检测算法调用<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detect</span><span class="params">(net, meta, image, thresh=<span class="number">.5</span>, hier_thresh=<span class="number">.5</span>, nms=<span class="number">.45</span>)</span>:</span></span><br><span class="line">    im = load_image(image, <span class="number">0</span>, <span class="number">0</span>)    <span class="comment"># 读取图片</span></span><br><span class="line">    num = c_int(<span class="number">0</span>)</span><br><span class="line">    pnum = pointer(num)</span><br><span class="line">    predict_image(net, im)          <span class="comment"># 前向运算</span></span><br><span class="line">    dets = get_network_boxes(net, im.w, im.h, thresh, hier_thresh, <span class="keyword">None</span>, <span class="number">0</span>, pnum) <span class="comment"># 获取边界框</span></span><br><span class="line">    num = pnum[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> (nms): do_nms_obj(dets, num, meta.classes, nms)  <span class="comment"># NMS</span></span><br><span class="line"></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(num):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(meta.classes):</span><br><span class="line">            <span class="keyword">if</span> dets[j].prob[i] &gt; <span class="number">0</span>:</span><br><span class="line">                b = dets[j].bbox</span><br><span class="line">                res.append((meta.names[i], dets[j].prob[i], (b.x, b.y, b.w, b.h)))</span><br><span class="line">    res = sorted(res, key=<span class="keyword">lambda</span> x: -x[<span class="number">1</span>])</span><br><span class="line">    free_image(im)</span><br><span class="line">    free_detections(dets, num)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h1 id="scripts-：功能脚本"><a href="#scripts-：功能脚本" class="headerlink" title="scripts/：功能脚本"></a><code>scripts/</code>：功能脚本</h1><p>一些自动化脚本，如下载数据、生成样本标签等，略。</p>]]></content>
      
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深度学习框架darknet【一】——简单使用</title>
      <link href="/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%B8%80%E3%80%91%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%B8%80%E3%80%91%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://louishsu.xyz/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%B8%80%E3%80%91%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">深度学习框架darknet【一】——简单使用</a></li><li><a href="https://louishsu.xyz/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%BA%8C%E3%80%91%E2%80%94%E2%80%94%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/" target="_blank" rel="noopener">深度学习框架darknet【二】——目录结构</a></li><li><a href="https://louishsu.xyz/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%B8%89%E3%80%91%E2%80%94%E2%80%94%E8%B0%83%E5%8C%85%E5%A4%A7%E6%B3%95%E5%A5%BD/" target="_blank" rel="noopener">深度学习框架darknet【三】——调包大法好</a></li><li><a href="https://louishsu.xyz/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E5%9B%9B%E3%80%91%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9/" target="_blank" rel="noopener">深度学习框架darknet【四】——网络配置选项</a></li><li><a href="https://louishsu.xyz/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%BA%94%E3%80%91%E2%80%94%E2%80%94%E8%AE%AD%E7%BB%83%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">深度学习框架darknet【五】——训练解析</a></li></ul><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>目前可用于深度学习的著名框架有</p><ul><li>tensorflow</li><li>pytorch</li><li>keras</li><li>theano</li><li>caffe</li><li>…</li></ul><p>这些给广大调参狗带来便利，但不利于学生党理解底层实现，例如神经网络的BP算法。</p><p>darknet是C语言实现的深度学习开源代码，细细品读，收获颇丰，开源万岁！</p><p><img src="/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%B8%80%E3%80%91%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/深度学习框架darknet【一】——简单使用/darknet.png" alt="darknet"></p><p>附上官网链接和<code>Github</code>地址</p><ul><li><a href="https://pjreddie.com/darknet/yolo/" target="_blank" rel="noopener">YOLO: Real-Time Object Detection</a></li><li><a href="https://github.com/pjreddie/darknet" target="_blank" rel="noopener">pjreddie/darknet: Convolutional Neural Networks</a></li><li><a href="https://github.com/AlexeyAB/darknet" target="_blank" rel="noopener">AlexeyAB/darknet: Windows and Linux version of Darknet Yolo v3 &amp; v2 Neural Networks for object detection (Tensor Cores are used)</a></li></ul><h1 id="Linux安装与使用"><a href="#Linux安装与使用" class="headerlink" title="Linux安装与使用"></a>Linux安装与使用</h1><p>首先，从Github下载作者的源码<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/pjreddie/darknet.git</span></span><br><span class="line">Cloning into 'darknet'...</span><br><span class="line">remote: Enumerating objects: 5901, done.</span><br><span class="line">remote: Total 5901 (delta 0), reused 0 (delta 0), pack-reused 5901</span><br><span class="line">Receiving objects: 100% (5901/5901), 6.16 MiB | 10.00 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (3915/3915), done.</span><br></pre></td></tr></table></figure></p><p>其目录结构如下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> darknet</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tree -L 1</span></span><br><span class="line">.</span><br><span class="line">├── cfg/</span><br><span class="line">├── data/</span><br><span class="line">├── examples/</span><br><span class="line">├── include/</span><br><span class="line">├── python/</span><br><span class="line">├── scripts/</span><br><span class="line">├── src/</span><br><span class="line">├── LICENSE</span><br><span class="line">├── LICENSE.fuck</span><br><span class="line">├── LICENSE.gen</span><br><span class="line">├── LICENSE.gpl</span><br><span class="line">├── LICENSE.meta</span><br><span class="line">├── LICENSE.mit</span><br><span class="line">├── LICENSE.v1</span><br><span class="line">├── Makefile</span><br><span class="line">└── README.md</span><br><span class="line"></span><br><span class="line">7 directories, 9 files</span><br></pre></td></tr></table></figure></p><p>这其中包括<a href="https://pjreddie.com/darknet/yolo/" target="_blank" rel="noopener">YOLO</a>的算法实现，若需尝试检测算法先进行编译，在<strong>Makefile中指定编译选项</strong>，由于现在使用的PC显存较小(1G)，暂时不采用CUDA加速(GPU=0, CUDNN=0)；Darknet可不安装图像库，但不支持图像显示，为了便于展示，编译加入本机已安装的OpenCV(OPENCV=1)<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GPU=0</span><br><span class="line">CUDNN=0</span><br><span class="line">OPENCV=1</span><br><span class="line">OPENMP=0</span><br><span class="line">DEBUG=0</span><br></pre></td></tr></table></figure></p><p>开始编译，编译完成后，除了新建三个目录<code>obj/</code>, <code>backup/</code>, <code>results/</code>外，还生成<strong>可执行文件<code>darknet</code>, 静态连接库<code>libdarknet.a</code>, 动态链接库<code>libdarknet.so</code></strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">  make</span></span><br><span class="line">mkdir -p obj        # 新建目录 obj/</span><br><span class="line">mkdir -p backup     # 新建目录 backup/</span><br><span class="line">mkdir -p results    # 新建目录 results/</span><br><span class="line">gcc -Iinclude/ -Isrc/ -DOPENCV `pkg-config --cflags opencv`  -Wall -Wno-unused-result -Wno-unknown-pragmas -Wfatal-errors -fPIC -Ofast -DOPENCV -c ./src/gemm.c -o obj/gemm.o</span><br><span class="line">... # 略</span><br><span class="line">gcc -Iinclude/ -Isrc/ -DOPENCV `pkg-config --cflags opencv`  -Wall -Wno-unused-result -Wno-unknown-pragmas -Wfatal-errors -fPIC -Ofast -DOPENCV -c ./examples/darknet.c -o obj/darknet.o</span><br><span class="line">gcc -Iinclude/ -Isrc/ -DOPENCV `pkg-config --cflags opencv`  -Wall -Wno-unused-result -Wno-unknown-pragmas -Wfatal-errors -fPIC -Ofast -DOPENCV obj/captcha.o obj/lsd.o obj/super.o obj/art.o obj/tag.o obj/cifar.o obj/go.o obj/rnn.o obj/segmenter.o obj/regressor.o obj/classifier.o obj/coco.o obj/yolo.o obj/detector.o obj/nightmare.o obj/instance-segmenter.o obj/darknet.o libdarknet.a -o darknet -lm -pthread  `pkg-config --libs opencv` -lstdc++ libdarknet.a</span><br></pre></td></tr></table></figure></p><p>尝试运行YOLO3检测算法，下载权重、选择cfg文件，并指定图片进行检测<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget https://pjreddie.com/media/files/yolov3.weights</span></span><br><span class="line">... # 略</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./darknet detect cfg/yolov3.cfg yolov3.weights data/fastfurious.jpeg </span></span><br><span class="line">layer     filters    size              input                output</span><br><span class="line">    0 conv     32  3 x 3 / 1   608 x 608 x   3   -&gt;   608 x 608 x  32  0.639 BFLOPs</span><br><span class="line">    1 conv     64  3 x 3 / 2   608 x 608 x  32   -&gt;   304 x 304 x  64  3.407 BFLOPs</span><br><span class="line">    2 conv     32  1 x 1 / 1   304 x 304 x  64   -&gt;   304 x 304 x  32  0.379 BFLOPs</span><br><span class="line">... # 略</span><br><span class="line">  105 conv    255  1 x 1 / 1    76 x  76 x 256   -&gt;    76 x  76 x 255  0.754 BFLOPs</span><br><span class="line">  106 yolo</span><br><span class="line">Loading weights from yolov3.weights...Done!</span><br><span class="line">data/fastfurious.jpeg: Predicted in 27.746693 seconds.</span><br><span class="line">car: 100%</span><br><span class="line">person: 100%</span><br></pre></td></tr></table></figure></p><p>放上大光头靓照，检测效果非常好，由于未使用CUDA，所以检测速度较慢(27.7s)</p><p><img src="/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%B8%80%E3%80%91%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/深度学习框架darknet【一】——简单使用/fastfurious.jpeg" alt="fastfurious"></p><p><img src="/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%B8%80%E3%80%91%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/深度学习框架darknet【一】——简单使用/fastfurious_predictions.jpg" alt="fastfurious_predictions"></p><h1 id="Windows安装与使用"><a href="#Windows安装与使用" class="headerlink" title="Windows安装与使用"></a>Windows安装与使用</h1><ol><li>新建项目文件夹<code>project</code>，复制<code>darknet_AlexeyAB</code>中文件到该目录下</li><li>选择无gpu版本，打开<code>project/build/darknet/darknet_no_gpu.sln</code><br> <img src="/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%B8%80%E3%80%91%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/深度学习框架darknet【一】——简单使用/darknet_build_win_no_gpu_sln.png" alt="darknet_build_win_no_gpu_sln"></li><li>修改版本为<code>release</code><br> <img src="/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%B8%80%E3%80%91%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/深度学习框架darknet【一】——简单使用/darknet_build_win_release.png" alt="darknet_build_win_release"></li><li>安装<code>OpenCV3</code></li><li>一键<code>build</code>！如果需要生成<code>.dll</code>动态链接库，则配置<code>项目属性 -&gt; 常规 -&gt; 目标文件扩展名</code>为<code>.dll</code><br> <img src="/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%B8%80%E3%80%91%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/深度学习框架darknet【一】——简单使用/darknet_build_win_build.png" alt="darknet_build_win_build"><br> <img src="/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%B8%80%E3%80%91%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/深度学习框架darknet【一】——简单使用/darknet_build_win_success.png" alt="darknet_build_win_success"></li></ol><p>从<code>https://pjreddie.com/media/files/yolov3.weights</code>下载<code>yolo_v3</code>权重，放到放在<code>project/build/darknet/x64</code>目录，执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt; .&#x2F;darknet_no_gpu.exe detect cfg&#x2F;yolov3.cfg yolov3.weights data&#x2F;dog.jpg</span><br><span class="line">layer     filters    size              input                output</span><br><span class="line">   0 conv     32  3 x 3 &#x2F; 1   416 x 416 x   3   -&gt;   416 x 416 x  32 0.299 BF</span><br><span class="line">   1 conv     64  3 x 3 &#x2F; 2   416 x 416 x  32   -&gt;   208 x 208 x  64 1.595 BF</span><br><span class="line">   2 conv     32  1 x 1 &#x2F; 1   208 x 208 x  64   -&gt;   208 x 208 x  32 0.177 BF</span><br><span class="line">   3 conv     64  3 x 3 &#x2F; 1   208 x 208 x  32   -&gt;   208 x 208 x  64 1.595 BF</span><br><span class="line">   4 Shortcut Layer: 1</span><br><span class="line">   5 conv    128  3 x 3 &#x2F; 2   208 x 208 x  64   -&gt;   104 x 104 x 128 1.595 BF</span><br><span class="line">   6 conv     64  1 x 1 &#x2F; 1   104 x 104 x 128   -&gt;   104 x 104 x  64 0.177 BF</span><br><span class="line">   7 conv    128  3 x 3 &#x2F; 1   104 x 104 x  64   -&gt;   104 x 104 x 128 1.595 BF</span><br><span class="line">   </span><br><span class="line">   ...</span><br><span class="line">  </span><br><span class="line">  94 yolo</span><br><span class="line">  95 route  91</span><br><span class="line">  96 conv    128  1 x 1 &#x2F; 1    26 x  26 x 256   -&gt;    26 x  26 x 128 0.044 BF</span><br><span class="line">  97 upsample            2x    26 x  26 x 128   -&gt;    52 x  52 x 128</span><br><span class="line">  98 route  97 36</span><br><span class="line">  99 conv    128  1 x 1 &#x2F; 1    52 x  52 x 384   -&gt;    52 x  52 x 128 0.266 BF</span><br><span class="line"> 100 conv    256  3 x 3 &#x2F; 1    52 x  52 x 128   -&gt;    52 x  52 x 256 1.595 BF</span><br><span class="line"> 101 conv    128  1 x 1 &#x2F; 1    52 x  52 x 256   -&gt;    52 x  52 x 128 0.177 BF</span><br><span class="line"> 102 conv    256  3 x 3 &#x2F; 1    52 x  52 x 128   -&gt;    52 x  52 x 256 1.595 BF</span><br><span class="line"> 103 conv    128  1 x 1 &#x2F; 1    52 x  52 x 256   -&gt;    52 x  52 x 128 0.177 BF</span><br><span class="line"> 104 conv    256  3 x 3 &#x2F; 1    52 x  52 x 128   -&gt;    52 x  52 x 256 1.595 BF</span><br><span class="line"> 105 conv    255  1 x 1 &#x2F; 1    52 x  52 x 256   -&gt;    52 x  52 x 255 0.353 BF</span><br><span class="line"> 106 yolo</span><br><span class="line">Total BFLOPS 65.864</span><br><span class="line">Loading weights from yolov3.weights...Done!</span><br></pre></td></tr></table></figure></p><p><img src="/2019/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6darknet%E3%80%90%E4%B8%80%E3%80%91%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/深度学习框架darknet【一】——简单使用/darknet_build_win_predict_dog.png" alt="darknet_build_win_predict_dog"></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://blog.csdn.net/KayChanGEEK/article/details/84979441" target="_blank" rel="noopener">Windows配置darknet - 楷尘·极客 - CSDN博客</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>全连接网络BP算法推导【矩阵形式】</title>
      <link href="/2019/12/08/%E5%85%A8%E8%BF%9E%E6%8E%A5%E7%BD%91%E7%BB%9CBP%E7%AE%97%E6%B3%95%E6%8E%A8%E5%AF%BC%E3%80%90%E7%9F%A9%E9%98%B5%E5%BD%A2%E5%BC%8F%E3%80%91/"/>
      <url>/2019/12/08/%E5%85%A8%E8%BF%9E%E6%8E%A5%E7%BD%91%E7%BB%9CBP%E7%AE%97%E6%B3%95%E6%8E%A8%E5%AF%BC%E3%80%90%E7%9F%A9%E9%98%B5%E5%BD%A2%E5%BC%8F%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在<a href="https://louishsu.xyz/2018/10/20/Feedforward-Neural-Network/" target="_blank" rel="noopener">Feedforward Neural Network/5. 梯度推导</a>中介绍了前馈神经网络的BP算法，但是推导结果为<strong>对元素的梯度</strong>，不便于编程且影响计算效率。本节<strong>以3层前馈全连接神经网络为例</strong>，介绍矩阵形式的BP算法推导。</p><h1 id="网络定义"><a href="#网络定义" class="headerlink" title="网络定义"></a>网络定义</h1><p>定义多层全连接网络：<br>【输入(input)】 -&gt; 全连接层 -&gt; sigmoid -&gt; 【隐藏层(hidden)】-&gt; 全连接层 -&gt; 【输出(output)】 -&gt; 损失函数层 -&gt; 损失值(loss)。</p><p>示意图如下(已省略激活函数层)</p><p><img src="/2019/12/08/%E5%85%A8%E8%BF%9E%E6%8E%A5%E7%BD%91%E7%BB%9CBP%E7%AE%97%E6%B3%95%E6%8E%A8%E5%AF%BC%E3%80%90%E7%9F%A9%E9%98%B5%E5%BD%A2%E5%BC%8F%E3%80%91/全连接网络BP算法推导【矩阵形式】/nn.svg" alt="nn"></p><p>其<strong>符号定义</strong>为</p><ul><li>$\vec{x}^{(l-1)}$: 第$l$层的输入向量，维度为$n_{l-1} \times 1$；</li><li>$\vec{x}^{(l)}$: 第$l$层的输出向量，维度为$n_l \times 1$；</li><li><p>$f^{(l)}(\vec{x})$: 第$l$层输入输出映射，即</p><script type="math/tex; mode=display">\vec{x}^{(l)} = f^{(l)}(\vec{x}_{l-1}) \tag{1}</script><ul><li><p>全连接层: </p><script type="math/tex; mode=display">f^{(l)}(\vec{x}) = W^{(l)} \vec{x} + \vec{b}^{(l)} \tag{1.1}</script><p>  其中$W^{(l)}$, $\vec{b}^{(l)}$分别表示权重与偏置，维度分别为$n_l \times n_{l-1}$, $n_l \times 1$；</p></li><li><p>激活函数层: </p><script type="math/tex; mode=display">f^{(l)}(\vec{x}) = \sigma(\vec{x}) \tag{1.2.1}</script><p>  当激活函数采用sigmoid函数时，有</p><script type="math/tex; mode=display">f^{(l)}(x_j) = \frac{1}{1 + e^{- x_j}} \tag{1.2.2}</script></li><li><p>损失函数层：</p><script type="math/tex; mode=display">f^{(l)}(\vec{x}) = L(\vec{x}, \vec{t}) \tag{1.3.1}</script><p>  取MSE损失时，有</p><script type="math/tex; mode=display">L(\vec{x}, \vec{t}) = \frac{1}{2} ||\vec{x} - \vec{t}||_2^2 = \frac{1}{2} (\vec{x} - \vec{t})^T (\vec{x} - \vec{t}) \tag{1.3.2}</script><p>  其中$\vec{t}$表示groudtruth，$\vec{x}$表示网络的输出。</p></li></ul></li></ul><p>则有</p><script type="math/tex; mode=display">\begin{aligned}    \vec{x}^{(1)} = W^{(1)} \vec{x}^{(0)} + \vec{b}^{(1)} \\    \vec{x}^{(2)} = \sigma(\vec{x}^{(1)}) \\    \vec{x}^{(3)} = W^{(3)} \vec{x}^{(2)} + \vec{b}^{(3)} \\    x^{(4)} = L(\vec{x}^{(3)}, \vec{t}) \\\end{aligned} \tag{2}</script><blockquote><script type="math/tex; mode=display">W^{(l)} \vec{x}^{(l-1)} + \vec{b}^{(l)} = \begin{bmatrix}  W^{(l)}_{11} & W^{(l)}_{12} & \cdots & W^{(l)}_{1n_{l-1}} \\  \vdots & \vdots & \ddots & \vdots \\  W^{(l)}_{n_l1} & W^{(l)}_{n_l2} & \cdots & W^{(l)}_{n_l n_{l-1}} \\\end{bmatrix}\begin{bmatrix}  x^{(l-1)}_1 \\  \vdots \\  x^{(l-1)}_{n_{l-1}} \\\end{bmatrix} + \begin{bmatrix}  \vec{b}^{(l)}_1 \\  \vdots \\  \vec{b}^{(l)}_{n_l} \\\end{bmatrix}</script></blockquote><h1 id="梯度推导"><a href="#梯度推导" class="headerlink" title="梯度推导"></a>梯度推导</h1><blockquote><p>标量对矩阵、向量的梯度见<a href="#%e9%99%84%e5%bd%95">附录</a>。</p></blockquote><p>每层输出$\vec{x}^{(l)} = f^{(l)}(\vec{x}^{(l-1)})$对输入$\vec{x}^{(l-1)}$的梯度为$f’^{(l)}(\vec{x}^{(l-1)})$(雅可比矩阵)，记作$p^{(l)}$，即</p><script type="math/tex; mode=display">p^{(l)} = \frac{\partial f^{(l)}(\vec{x}^{(l-1)})}{\partial \vec{x}^{(l-1)T}} \tag{3}</script><p>则对于已定义的网络，有</p><ul><li><p>全连接层(1)(向量对向量的梯度)：</p><script type="math/tex; mode=display">  p^{(1)} = \frac{\partial }{\partial \vec{x}^{(0)T}} (W^{(1)} \vec{x}^{(0)} + \vec{b}^{(1)}) = \frac{\partial \vec{x}^{(1)}}{\partial \vec{x}^{(0)T}} = W^{(1)} \tag{3.1}</script></li><li><p>激活函数层(2)(向量对向量的梯度)：</p><script type="math/tex; mode=display">  p^{(2)} = \frac{\partial }{\partial \vec{x}^{(1)T}} \sigma(\vec{x}^{(1)}) = \frac{\partial \vec{x}^{(2)}}{\partial \vec{x}^{(1)T}} = \rm{diag}[\sigma(\vec{x}^{(1)}) \odot (1 - \sigma(\vec{x}^{(1)}))] \tag{3.2}</script></li><li><p>全连接层(3)(向量对向量的梯度)：</p><script type="math/tex; mode=display">  p^{(3)} = \frac{\partial }{\partial \vec{x}^{(2)T}} (W^{(3)} \vec{x}^{(2)} + \vec{b}^{(3)}) = \frac{\partial \vec{x}^{(3)}}{\partial \vec{x}^{(2)T}} = W^{(3)} \tag{3.3}</script></li><li><p>损失函数层(4)(标量对向量的梯度)：</p><script type="math/tex; mode=display">  p^{(4)} = \frac{\partial }{\partial \vec{x}^{(3)}} [\frac{1}{2} (\vec{x}^{(3)} - \vec{t})^T (\vec{x}^{(3)} - \vec{t})] = \frac{\partial x^{(4)}}{\partial \vec{x}^{(3)}} = \vec{x}^{(3)} - \vec{t} \tag{3.4}</script></li></ul><blockquote><script type="math/tex; mode=display">n_1 = n_2; \quad n_4 = 1</script></blockquote><p>待更新参数为$W^{(1)}, \vec{b}^{(1)}, W^{(3)}, \vec{b}^{(3)}$。</p><ol><li><p>损失函数$L$对第$3$层参数$W^{(3)}, \vec{b}^{(3)}$的梯度，有</p><script type="math/tex; mode=display"> \frac{\partial L(\vec{x}^{(3)}, \vec{t})}{\partial W^{(3)}} =  \frac{\partial x^{(4)}}{\partial \vec{x}^{(3)}} \frac{\partial f^{(3)}(\vec{x}^{(2)})}{\partial W^{(3)}} =  \underbrace{p^{(4)}}_{n_3 \times 1}  \underbrace{\frac{\partial}{\partial W^{(3)}} (W^{(3)} \vec{x}^{(2)} + \vec{b}^{(3)})}_{1 \times n_2} =  p^{(4)} \vec{x}^{(2)T} \tag{4.1}</script><script type="math/tex; mode=display"> \frac{\partial L(\vec{x}^{(3)}, \vec{t})}{\partial \vec{b}^{(3)}} =  (\frac{\partial f^{(3)}(\vec{x}^{(2)})}{\partial \vec{b}^{(3)T}})^T \frac{\partial x^{(4)}}{\partial \vec{x}^{(3)}} = \underbrace{\frac{\partial}{\partial \vec{b}^{(3)T}} (W^{(3)} \vec{x}^{(2)} + \vec{b}^{(3)})}_{I_{n_3 \times n_3}} \underbrace{p^{(4)}}_{n_3 \times 1} = p^{(4)} \tag{4.2}</script></li><li><p>损失函数$L$对第$1$层参数$W^{(1)}, \vec{b}^{(1)}$的梯度，有</p><script type="math/tex; mode=display"> \frac{\partial L(\vec{x}^{(3)}, \vec{t})}{\partial W^{(1)}} =  \frac{\partial x^{(4)}}{\partial \vec{x}^{(1)}} \frac{\partial f^{(1)}(\vec{x}^{(0)})}{\partial W^{(1)}} \tag{5.1}</script><p> 其中$\frac{\partial x^{(4)}}{\partial \vec{x}^{(1)}}$为标量对向量的梯度，由式$(7.2)$可得</p><script type="math/tex; mode=display"> \frac{\partial x^{(4)}}{\partial \vec{x}^{(1)}} =  (\frac{\partial \vec{x}^{(3)}}{\partial \vec{x}^{(1)}})^T  \frac{\partial x^{(4)}}{\partial \vec{x}^{(3)}} =  (\frac{\partial \vec{x}^{(3)}}{\partial \vec{x}^{(2)}}  \frac{\partial \vec{x}^{(2)}}{\partial \vec{x}^{(1)}})^T  \frac{\partial x^{(4)}}{\partial \vec{x}^{(3)}} \tag{5.2}</script><p> 代入式$(5.1)$得</p><script type="math/tex; mode=display"> \begin{aligned}     \frac{\partial L(\vec{x}^{(3)}, \vec{t})}{\partial W^{(1)}} \\     = \left[         (\frac{\partial \vec{x}^{(3)}}{\partial \vec{x}^{(2)}}          \frac{\partial \vec{x}^{(2)}}{\partial \vec{x}^{(1)}})^T          \frac{\partial x^{(4)}}{\partial \vec{x}^{(3)}}      \right]     \frac{\partial f^{(1)}(\vec{x}^{(0)})}{\partial W^{(1)}} \\     = \underbrace{p^{(2)T}}_{n_2 \times n_2}     \underbrace{p^{(3)T}}_{n_2 \times n_3}     \underbrace{p^{(4)}}_{n_3 \times 1}     \underbrace{\frac{\partial}{\partial W^{(1)}} (W^{(1)} \vec{x}^{(0)} + \vec{b}^{(1)})}_{1 \times n_0} =      p^{(2)T} p^{(3)T} p^{(4)} \vec{x}^{(0)T} \end{aligned} \tag{5.3}</script><script type="math/tex; mode=display"> \begin{aligned}     \frac{\partial L(\vec{x}^{(3)}, \vec{t})}{\partial \vec{b}^{(1)}}      = \frac{\partial x^{(4)}}{\partial \vec{x}^{(3)}} \\     = \left[         (\frac{\partial \vec{x}^{(3)}}{\partial \vec{x}^{(2)}}          \frac{\partial \vec{x}^{(2)}}{\partial \vec{x}^{(1)}})^T          \frac{\partial x^{(4)}}{\partial \vec{x}^{(3)}}      \right]     \frac{\partial f^{(1)}(\vec{x}^{(0)})}{\partial \vec{b}^{(1)}} \\     = \underbrace{p^{(2)T}}_{n_2 \times n_2}     \underbrace{p^{(3)T}}_{n_2 \times n_3}     \underbrace{p^{(4)}}_{n_3 \times 1}     \underbrace{\frac{\partial}{\partial \vec{b}^{(1)}} (W^{(1)} \vec{x}^{(0)} + \vec{b}^{(1)})}_{I_{n_0 \times n_0}} =     p^{(2)T} p^{(3)T} p^{(4)} \end{aligned} \tag{5.4}</script></li></ol><p>如果记</p><script type="math/tex; mode=display">\begin{aligned}    \vec{\delta}^{(4)} = p^{(4)} = \vec{x}^{(3)} - \vec{t} \\    \vec{\delta}^{(3)} = p^{(3)T} \vec{\delta}^{(4)} = W^{(3)T} \vec{\delta}^{(4)} \\    \vec{\delta}^{(2)} = p^{(2)T} \vec{\delta}^{(3)} = \rm{diag}[\sigma(\vec{x}^{(1)}) \odot (1 - \vec{x}^{(1)})]^T \vec{\delta}^{(3)} \\\end{aligned}</script><p>最终得到梯度表达式</p><script type="math/tex; mode=display">\begin{aligned}    \frac{\partial L(\vec{x}^{(3)}, \vec{t})}{\partial W^{(3)}} = \vec{\delta}^{(4)} x^{(2)T} \\    \frac{\partial L(\vec{x}^{(3)}, \vec{t})}{\partial \vec{b}^{(3)}} = \vec{\delta}^{(4)} \\    \frac{\partial L(\vec{x}^{(3)}, \vec{t})}{\partial W^{(1)}} =         \vec{\delta}^{(2)} \vec{x}^{(0)T} \\    \frac{\partial L(\vec{x}^{(3)}, \vec{t})}{\partial \vec{b}^{(1)}} =        \vec{\delta}^{(2)}\end{aligned} \tag{*}</script><h1 id="附录：矩阵形式的链式求导"><a href="#附录：矩阵形式的链式求导" class="headerlink" title="附录：矩阵形式的链式求导"></a>附录：矩阵形式的链式求导</h1><ol><li><p>向量对向量<br> 假设三个向量满足依赖关系$\vec{x} \rightarrow \vec{y} \rightarrow \vec{z}$，分别为$m, n, p$维向量，则满足</p><script type="math/tex; mode=display"> \underbrace{\frac{\partial \vec{z}}{\partial \vec{x}}}_{p \times m} =  \underbrace{\frac{\partial \vec{z}}{\partial \vec{y}}}_{p \times n}  \underbrace{\frac{\partial \vec{y}}{\partial \vec{x}}}_{n \times m} \tag{7.1}</script><p> 注意：若其中任意变量为矩阵时上式子不成立，如$\vec{x} \rightarrow Y \rightarrow \vec{z}$</p></li><li><p>标量对向量<br> 假设有依赖关系$\vec{\vec{x}} \rightarrow \vec{\vec{y}} \rightarrow z$，分别为$m, n$维向量与标量，则$\frac{\partial z}{\partial \vec{x}}$维度为$m \times 1$，$\frac{\partial z}{\partial \vec{y}}$维度为$n \times 1$，$\frac{\partial \vec{y}}{\partial \vec{x}}$维度为$n \times m$，为保证矩阵维度相容，需增加转置</p><script type="math/tex; mode=display"> \underbrace{\frac{\partial z}{\partial \vec{x}}}_{m \times 1} =  \underbrace{(\frac{\partial \vec{y}}{\partial \vec{x}})^T}_{m \times n} \underbrace{\frac{\partial z}{\partial \vec{y}}}_{n \times 1} \tag{7.2}</script></li><li><p>标量对矩阵<br> 矩阵对矩阵求导定义复杂，不给出整体的求导法则，仅对矩阵中某元素进行求导。假设有依赖关系$X \rightarrow Y \rightarrow z$，则满足</p><script type="math/tex; mode=display"> \frac{\partial z}{\partial X_{ij}} = \sum_{k, l} \frac{\partial z}{\partial Y_{kl}} \frac{\partial Y_{kl}}{\partial X_{ij}} \tag{7.3}</script></li></ol><p><strong>特别地</strong>，对于$z = f(Y), Y = AX + B$，求$\frac{\partial z}{\partial X}$时，由上式应满足</p><script type="math/tex; mode=display">\frac{\partial z}{\partial X_{ij}} = \sum_{k, l} \frac{\partial z}{\partial Y_{kl}} \frac{\partial Y_{kl}}{\partial X_{ij}}</script><p>其中</p><script type="math/tex; mode=display">\frac{\partial Y_{kl}}{\partial X_{ij}} = \frac{\partial \sum_s A_{ks} X_{sl}}{\partial X_{ij}} = \frac{\partial A_{ki} X_{il}}{\partial X_{ij}} = A_{ki} \delta_{lj}, \quad\delta_{lj} =   \begin{cases}      1 & l = j \\      0 & \rm{otherwise}  \end{cases}</script><p>那么</p><script type="math/tex; mode=display">\frac{\partial z}{\partial X_{ij}} = \sum_{k, l} \frac{\partial z}{\partial Y_{kl}} A_{ki} \delta_{lj} =\sum_{k} \frac{\partial z}{\partial Y_{kj}} A_{ki}</script><p>也即$A^T$第$i$行与$\frac{\partial z}{\partial Y}$第$j$列内积，即</p><script type="math/tex; mode=display">\frac{\partial z}{\partial X} = A^T \frac{\partial z}{\partial Y} \tag{8.1}</script><p>类似的，对于$z = f(\vec{y}), \vec{y} = A\vec{x} + \vec{b}$</p><script type="math/tex; mode=display">\frac{\partial z}{\partial \vec{x}} = A^T \frac{\partial z}{\partial \vec{y}} \tag{8.2}</script><p>对于$z = f(Y), Y = XA + B$</p><script type="math/tex; mode=display">\frac{\partial z}{X} = \frac{\partial z}{\partial Y} A^T \tag{8.3}</script><p>对于$z = f(\vec{y}), \vec{y} = X\vec{a} + \vec{b}$</p><script type="math/tex; mode=display">\frac{\partial z}{\partial X} = \frac{\partial z}{\partial \vec{y}} \vec{a}^T \tag{8.4}</script>]]></content>
      
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gcc/g++版本切换</title>
      <link href="/2019/12/04/gcc-g-%E7%89%88%E6%9C%AC%E5%88%87%E6%8D%A2/"/>
      <url>/2019/12/04/gcc-g-%E7%89%88%E6%9C%AC%E5%88%87%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>gcc/g++为Linux下C/C++编译器，但版本差异较大，如CUDA编译时不支持gcc-6之后的版本，故需要安装多个版本适应开发任务。</p><h1 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h1><p>Ubuntu 18.04预装gcc/g++ 7.3，若需要安装gcc/g++-5，详细操作步骤如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看当前所有已安装版本</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls /usr/bin/gcc*</span></span><br><span class="line">/usr/bin/gcc    /usr/bin/gcc-7   /usr/bin/gcc-ar-6  /usr/bin/gcc-nm    /usr/bin/gcc-nm-7    /usr/bin/gcc-ranlib-6</span><br><span class="line">/usr/bin/gcc-6  /usr/bin/gcc-ar  /usr/bin/gcc-ar-7  /usr/bin/gcc-nm-6  /usr/bin/gcc-ranlib  /usr/bin/gcc-ranlib-7</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls /usr/bin/g++*</span></span><br><span class="line">/usr/bin/g++    /usr/bin/g++-6   /usr/bin/g++-7</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装gcc-5与g++-5</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install gcc-5</span></span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree       </span><br><span class="line">Reading state information... Done</span><br><span class="line">The following packages were automatically installed and are no longer required:</span><br><span class="line">  javascript-common libjs-jquery libjs-sphinxdoc libjs-underscore python-apt python-m2crypto python-pkg-resources python-typing</span><br><span class="line">Use 'sudo apt autoremove' to remove them.</span><br><span class="line">The following additional packages will be installed:</span><br><span class="line">  cpp-5 gcc-5-base libasan2 libgcc-5-dev libisl15 libmpx0</span><br><span class="line">Suggested packages:</span><br><span class="line">  gcc-5-locales gcc-5-multilib gcc-5-doc libgcc1-dbg libgomp1-dbg libitm1-dbg libatomic1-dbg libasan2-dbg liblsan0-dbg libtsan0-dbg libubsan0-dbg libcilkrts5-dbg libmpx0-dbg</span><br><span class="line">  libquadmath0-dbg</span><br><span class="line">The following NEW packages will be installed:</span><br><span class="line">  cpp-5 gcc-5 gcc-5-base libasan2 libgcc-5-dev libisl15 libmpx0</span><br><span class="line">0 upgraded, 7 newly installed, 0 to remove and 2 not upgraded.</span><br><span class="line">Need to get 19.2 MB of archives.</span><br><span class="line">After this operation, 61.5 MB of additional disk space will be used.</span><br><span class="line">Do you want to continue? [Y/n]</span><br><span class="line">Get:1 http://mirrors.aliyun.com/ubuntu bionic/universe amd64 gcc-5-base amd64 5.5.0-12ubuntu1 [17.1 kB]</span><br><span class="line">Get:2 http://mirrors.aliyun.com/ubuntu bionic/universe amd64 libisl15 amd64 0.18-4 [548 kB]</span><br><span class="line">Get:3 http://mirrors.aliyun.com/ubuntu bionic/universe amd64 cpp-5 amd64 5.5.0-12ubuntu1 [7,785 kB]                                                                                         </span><br><span class="line">Get:4 http://mirrors.aliyun.com/ubuntu bionic/universe amd64 libasan2 amd64 5.5.0-12ubuntu1 [264 kB]                                                                                       </span><br><span class="line">Get:5 http://mirrors.aliyun.com/ubuntu bionic/universe amd64 libmpx0 amd64 5.5.0-12ubuntu1 [9,888 B]                                                                                       </span><br><span class="line">Get:6 http://mirrors.aliyun.com/ubuntu bionic/universe amd64 libgcc-5-dev amd64 5.5.0-12ubuntu1 [2,224 kB]                                                                                 </span><br><span class="line">Get:7 http://mirrors.aliyun.com/ubuntu bionic/universe amd64 gcc-5 amd64 5.5.0-12ubuntu1 [8,357 kB]                                                                                         </span><br><span class="line">Fetched 19.2 MB in 9s (2,082 kB/s)                                                                                                                                                         </span><br><span class="line">Selecting previously unselected package gcc-5-base:amd64.</span><br><span class="line">(Reading database ... 183097 files and directories currently installed.)</span><br><span class="line">Preparing to unpack .../0-gcc-5-base_5.5.0-12ubuntu1_amd64.deb ...</span><br><span class="line">Unpacking gcc-5-base:amd64 (5.5.0-12ubuntu1) ...</span><br><span class="line">Selecting previously unselected package libisl15:amd64.</span><br><span class="line">Preparing to unpack .../1-libisl15_0.18-4_amd64.deb ...</span><br><span class="line">Unpacking libisl15:amd64 (0.18-4) ...</span><br><span class="line">Selecting previously unselected package cpp-5.</span><br><span class="line">Preparing to unpack .../2-cpp-5_5.5.0-12ubuntu1_amd64.deb ...</span><br><span class="line">Unpacking cpp-5 (5.5.0-12ubuntu1) ...</span><br><span class="line">Selecting previously unselected package libasan2:amd64.</span><br><span class="line">Preparing to unpack .../3-libasan2_5.5.0-12ubuntu1_amd64.deb ...</span><br><span class="line">Unpacking libasan2:amd64 (5.5.0-12ubuntu1) ...</span><br><span class="line">Selecting previously unselected package libmpx0:amd64.</span><br><span class="line">Preparing to unpack .../4-libmpx0_5.5.0-12ubuntu1_amd64.deb ...</span><br><span class="line">Unpacking libmpx0:amd64 (5.5.0-12ubuntu1) ...</span><br><span class="line">Selecting previously unselected package libgcc-5-dev:amd64.</span><br><span class="line">Preparing to unpack .../5-libgcc-5-dev_5.5.0-12ubuntu1_amd64.deb ...</span><br><span class="line">Unpacking libgcc-5-dev:amd64 (5.5.0-12ubuntu1) ...</span><br><span class="line">Selecting previously unselected package gcc-5.</span><br><span class="line">Preparing to unpack .../6-gcc-5_5.5.0-12ubuntu1_amd64.deb ...</span><br><span class="line">Unpacking gcc-5 (5.5.0-12ubuntu1) ...</span><br><span class="line">Setting up libisl15:amd64 (0.18-4) ...</span><br><span class="line">Processing triggers for libc-bin (2.27-3ubuntu1) ...</span><br><span class="line">Processing triggers for man-db (2.8.3-2ubuntu0.1) ...</span><br><span class="line">Setting up gcc-5-base:amd64 (5.5.0-12ubuntu1) ...</span><br><span class="line">Setting up libmpx0:amd64 (5.5.0-12ubuntu1) ...</span><br><span class="line">Setting up libasan2:amd64 (5.5.0-12ubuntu1) ...</span><br><span class="line">Setting up libgcc-5-dev:amd64 (5.5.0-12ubuntu1) ...</span><br><span class="line">Setting up cpp-5 (5.5.0-12ubuntu1) ...</span><br><span class="line">Setting up gcc-5 (5.5.0-12ubuntu1) ...</span><br><span class="line">Processing triggers for libc-bin (2.27-3ubuntu1) ...</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install g++-5</span></span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree       </span><br><span class="line">Reading state information... Done</span><br><span class="line">The following packages were automatically installed and are no longer required:</span><br><span class="line">  javascript-common libjs-jquery libjs-sphinxdoc libjs-underscore python-apt python-m2crypto python-pkg-resources python-typing</span><br><span class="line">Use 'sudo apt autoremove' to remove them.</span><br><span class="line">The following additional packages will be installed:</span><br><span class="line">  libstdc++-5-dev</span><br><span class="line">Suggested packages:</span><br><span class="line">  g++-5-multilib gcc-5-doc libstdc++6-5-dbg libstdc++-5-doc</span><br><span class="line">The following NEW packages will be installed:</span><br><span class="line">  g++-5 libstdc++-5-dev</span><br><span class="line">0 upgraded, 2 newly installed, 0 to remove and 2 not upgraded.</span><br><span class="line">Need to get 9,864 kB of archives.</span><br><span class="line">After this operation, 38.6 MB of additional disk space will be used.</span><br><span class="line">Do you want to continue? [Y/n]</span><br><span class="line">Get:1 http://mirrors.aliyun.com/ubuntu bionic/universe amd64 libstdc++-5-dev amd64 5.5.0-12ubuntu1 [1,415 kB]</span><br><span class="line">Get:2 http://mirrors.aliyun.com/ubuntu bionic/universe amd64 g++-5 amd64 5.5.0-12ubuntu1 [8,450 kB]</span><br><span class="line">Fetched 9,864 kB in 45s (220 kB/s)                                                                                                                                                         </span><br><span class="line">Selecting previously unselected package libstdc++-5-dev:amd64.</span><br><span class="line">(Reading database ... 183333 files and directories currently installed.)</span><br><span class="line">Preparing to unpack .../libstdc++-5-dev_5.5.0-12ubuntu1_amd64.deb ...</span><br><span class="line">Unpacking libstdc++-5-dev:amd64 (5.5.0-12ubuntu1) ...</span><br><span class="line">Selecting previously unselected package g++-5.</span><br><span class="line">Preparing to unpack .../g++-5_5.5.0-12ubuntu1_amd64.deb ...</span><br><span class="line">Unpacking g++-5 (5.5.0-12ubuntu1) ...</span><br><span class="line">Processing triggers for man-db (2.8.3-2ubuntu0.1) ...</span><br><span class="line">Setting up libstdc++-5-dev:amd64 (5.5.0-12ubuntu1) ...</span><br><span class="line">Setting up g++-5 (5.5.0-12ubuntu1) ...</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置版本优先级</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-5 10</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 10</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-6 10</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-6 10</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-7 10</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-7 10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 选择对应版本的gcc/g++</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo update-alternatives --config gcc</span></span><br><span class="line">There are 3 choices for the alternative gcc (providing /usr/bin/gcc).</span><br><span class="line"></span><br><span class="line">  Selection    Path            Priority   Status</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">  0            /usr/bin/gcc-6   10        auto mode</span><br><span class="line">  1            /usr/bin/gcc-5   10        manual mode</span><br><span class="line">* 2            /usr/bin/gcc-6   10        manual mode</span><br><span class="line">  3            /usr/bin/gcc-7   10        manual mode</span><br><span class="line"></span><br><span class="line">Press &lt;enter&gt; to keep the current choice[*], or type selection number: 1    # 输入标签</span><br><span class="line">update-alternatives: using /usr/bin/gcc-5 to provide /usr/bin/gcc (gcc) in manual mode</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo update-alternatives --config g++</span></span><br><span class="line">There are 3 choices for the alternative g++ (providing /usr/bin/g++).</span><br><span class="line"></span><br><span class="line">  Selection    Path            Priority   Status</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">  0            /usr/bin/g++-6   10        auto mode</span><br><span class="line">  1            /usr/bin/g++-5   10        manual mode</span><br><span class="line">* 2            /usr/bin/g++-6   10        manual mode</span><br><span class="line">  3            /usr/bin/g++-7   10        manual mode</span><br><span class="line"></span><br><span class="line">Press &lt;enter&gt; to keep the current choice[*], or type selection number: 1    # 输入标签</span><br><span class="line">update-alternatives: using /usr/bin/g++-5 to provide /usr/bin/g++ (g++) in manual mode</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前版本号</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -v</span></span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=gcc</span><br><span class="line">COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/5/lto-wrapper</span><br><span class="line">Target: x86_64-linux-gnu</span><br><span class="line">Configured with: ../src/configure -v --with-pkgversion='Ubuntu 5.5.0-12ubuntu1' --with-bugurl=file:///usr/share/doc/gcc-5/README.Bugs --enable-languages=c,ada,c++,go,d,fortran,objc,obj-c++ --prefix=/usr --program-suffix=-5 --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-libmpx --enable-plugin --enable-default-pie --with-system-zlib --enable-objc-gc --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --enable-multilib --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu</span><br><span class="line">Thread model: posix</span><br><span class="line">gcc version 5.5.0 20171010 (Ubuntu 5.5.0-12ubuntu1)</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> g++ -v</span></span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=g++</span><br><span class="line">COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/5/lto-wrapper</span><br><span class="line">Target: x86_64-linux-gnu</span><br><span class="line">Configured with: ../src/configure -v --with-pkgversion='Ubuntu 5.5.0-12ubuntu1' --with-bugurl=file:///usr/share/doc/gcc-5/README.Bugs --enable-languages=c,ada,c++,go,d,fortran,objc,obj-c++ --prefix=/usr --program-suffix=-5 --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-libmpx --enable-plugin --enable-default-pie --with-system-zlib --enable-objc-gc --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --enable-multilib --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu</span><br><span class="line">Thread model: posix</span><br><span class="line">gcc version 5.5.0 20171010 (Ubuntu 5.5.0-12ubuntu1)</span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.jianshu.com/p/f66eed3a3a25" target="_blank" rel="noopener">linux下gcc、g++不同版本的安装和切换</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CenterNet - Objects as Points</title>
      <link href="/2019/10/09/CenterNet-Objects-as-Points/"/>
      <url>/2019/10/09/CenterNet-Objects-as-Points/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>目前大多检测算法将物体视作边界框进行检测，并采用锚框(Anchor)，能很大程度提升检测算法的表现，但是Anchor难以确定参数，且增加大量网络运算量。目前的物体检测算法开始向无Anchor的方向发展，如本文的CenterNet，是把物体所在包围框作为点，并结合热图的形式进行。除物体检测外，此算法还可用于人体姿态识别、3D物体检测等。</p><p>个人理解，采用热图的形式，是将Anchor一定程度地连续化了。</p><h1 id="论文阅读"><a href="#论文阅读" class="headerlink" title="论文阅读"></a>论文阅读</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><blockquote><p>In this paper, we provide a much simpler and more efficient alternative. We <strong>represent objects by a single point at their bounding box center</strong> (see Figure 2). Other properties, such as object size, dimension, 3D extent, orientation, and pose are then <strong>regressed directly from image features at the center location</strong>. Object detection is then a standard keypoint estimation problem [3,39,60]. We simply feed the input image to a fully convolutional network [37, 40] that generates a heatmap. <strong>Peaks in this heatmap correspond to object centers</strong>. Image features at each peak predict the objects bounding box height and weight. The model trains using standard dense supervised learning [39,60]. Inference is a single network forward-pass, <strong>without non-maximal suppression for post-processing</strong>.<br><img src="/2019/10/09/CenterNet-Objects-as-Points/Fig2.png" alt="Figure 2"><br><img src="/2019/10/09/CenterNet-Objects-as-Points/Fig3.png" alt="Figure 3"></p></blockquote><h2 id="Preliminary"><a href="#Preliminary" class="headerlink" title="Preliminary"></a>Preliminary</h2><p>若有某三通道图片$I \in \mathcal{R}^{W \times H \times 3}$，经卷积神经网络后得到输出特征图$\left[\hat{Y} || \hat{O} || \hat{S} \right] \in [0, 1]^{\frac{W}{R} \times \frac{H}{R} \times (C + 4)}$。其中$R$为降采样系数，表示特征图上单个位置处的点映射回原图后网格的大小，文中默认为$R=4$；$C$可根据关键点类型指定，如人体姿态估计时指定$C=17$(17个关键点)，物体检测时指定$C=80$(80类物体)。$\hat{Y}_{x, y, c} = 1$表示对应关键点，$\hat{Y}_{x, y, c} = 0$表示为背景。</p><p><img src="/2019/10/09/CenterNet-Objects-as-Points/Fig4.png" alt="Figure 4"></p><p>ground truth设置为热图(heatmap)的形式，采用高斯核</p><script type="math/tex; mode=display">Y_{x, y, c} =     \exp\left(        - \frac{(x - \tilde{p}_x)^2 + (y - \tilde{p}_y)^2}{2 \sigma_p^2}    \right) \tag{1}</script><p>其中$\tilde{p} = \lfloor \frac{p}{R} \rfloor$，$p$为物体中心点在原图中的坐标；$\sigma_p$称对象尺寸自适应标准差(object size-adaptive standard deviation)，以解决物体尺寸不一致的问题。若两个同类别对象相距过近，其对应类别特征图上重叠部分用逐元素取大的策略(element-wise maximun)。</p><p><strong>关键点</strong>为热图的回归(keypoint regression)，损失函数参考Focal Loss，添加$(1 - Y_{x, y, z})^{\beta}$项，使其适应回归任务</p><script type="math/tex; mode=display">L_k = - \frac{1}{N} \sum_{x, y, z}\begin{cases}    (1 - \hat{Y}_{x, y, z})^{\alpha} \log (\hat{Y}_{x, y, z}) & Y_{x, y, z} = 1 \\    (1 - Y_{x, y, z})^{\beta} (\hat{Y}_{x, y, z})^{\alpha} \log (1 - \hat{Y}_{x, y, z}) & \rm{otherwsie} \\\end{cases} \tag{2.1}</script><p>其中$\alpha, \beta$为超参数，文中指定$\alpha=2, \beta=4$；$N$为图片$I$中关键点的个数。</p><blockquote><p>Focal Loss定义为</p><script type="math/tex; mode=display">FL(p_t) = - \alpha_t (1 - p_t)^{\gamma} \log p_t</script><p>其中$\gamma &gt; 0$</p><script type="math/tex; mode=display">\begin{aligned}    p_t =      \begin{cases} p      & y = 1 \\ 1 - p      & \rm{otherwsie} \end{cases} \in [0, 1] \\    \alpha_t = \begin{cases} \alpha & y = 1 \\ 1 - \alpha & \rm{otherwsie} \end{cases} \in [0, 1]\end{aligned}</script></blockquote><p>由于网络的降采样，设置物体坐标偏置(local offset)<strong>修正物体中心坐标</strong>，即特征图$\hat{O} \in \mathcal{R}^{\frac{W}{R} \times \frac{H}{R} \times 2}$，该特征图所有类别共享。采用$L_1$损失，且仅对包含关键点的位置计算损失值。</p><script type="math/tex; mode=display">L_{off} = \frac{1}{N} \sum_p \left| \hat{O}_{\tilde{p}} - \left( \frac{p}{R} - \tilde{p} \right) \right| \tag{2.2}</script><p>同样地，物体的<strong>边界框尺寸回归</strong>设置特征图$\hat{S} \in \mathcal{R}^{\frac{W}{R} \times \frac{H}{R} \times 2}$，$s_k = (x^{(k)}_2 - x^{(k)}_1, y^{(k)}_2 - y^{(k)}_1)$，也采用$L_1$损失，那么</p><script type="math/tex; mode=display">L_{size} = \frac{1}{N} \sum_k \left| \hat{S}_{p_k} - s_k \right| \tag{2.3}</script><p>总体损失为以上几项的加权和，原文中$\lambda_{off} = 1, \lambda_{size} = 0.1$。</p><script type="math/tex; mode=display">L = L_k + \lambda_{off} L_{off} + \lambda_{size} L_{size} \tag{2}</script><p>基于以上，在测试阶段时，先在类别输出特征图$\hat{Y}$上确定位置，即保留100个峰(peak)(某处值在比其8领域值都大)的坐标$(\hat{x}_i, \hat{y}_i), i = 1, \cdots, 100$，各位置处的预测输出为</p><script type="math/tex; mode=display">\begin{aligned}    \begin{cases}        \hat{O}_{\hat{x}_i, \hat{y}_i} = (\delta_{\hat{x}_i}, \delta_{\hat{y}_i}) \\        \hat{S}_{\hat{x}_i, \hat{y}_i} = (\hat{w}_i, \hat{h}_i)    \end{cases}    \Rightarrow \\    (        \hat{x}_i + \delta_{\hat{x}_i} - \hat{w}_i / 2,         \hat{y}_i + \delta_{\hat{y}_i} - \hat{h}_i / 2, \\        \hat{x}_i + \delta_{\hat{x}_i} + \hat{w}_i / 2,         \hat{y}_i + \delta_{\hat{y}_i} + \hat{h}_i / 2    )\end{aligned} \tag{3}</script><h2 id="Implementation-details"><a href="#Implementation-details" class="headerlink" title="Implementation details"></a>Implementation details</h2><p>原文中分别采用ResNet-18, ResNet101, DLA-34, and Hourglass-104作为网络框架进行实验，效果对比如下<br><img src="/2019/10/09/CenterNet-Objects-as-Points/Tab1.png" alt="Table 1"></p><p>训练细节如下</p><ol><li>输入图像分辨率为$512 \times 512$，输出特征图分辨率为$128 \times 128$；</li><li>数据集扩增：随机翻转、尺度缩放($0.6$~$1.3$)、随即裁剪、颜色抖动；</li><li>使用Adam优化器，批次大小、初始学习率、学习率调整策略与不同网络框架相关。</li></ol><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><p><img src="/2019/10/09/CenterNet-Objects-as-Points/Tab2.png" alt="Table 2"></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://arxiv.org/abs/1904.07850v1" target="_blank" rel="noopener">Objects as Points - arXiv</a></li><li><a href="https://arxiv.org/abs/1708.02002" target="_blank" rel="noopener">Focal Loss for Dense Object Detection - arXiv</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Object Detection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《教父》三部曲：充满腐败而不失庄重的资本主义气息</title>
      <link href="/2019/10/05/%E3%80%8A%E6%95%99%E7%88%B6%E3%80%8B%E4%B8%89%E9%83%A8%E6%9B%B2%EF%BC%9A%E5%85%85%E6%BB%A1%E8%85%90%E8%B4%A5%E8%80%8C%E4%B8%8D%E5%A4%B1%E5%BA%84%E9%87%8D%E7%9A%84%E8%B5%84%E6%9C%AC%E4%B8%BB%E4%B9%89%E6%B0%94%E6%81%AF/"/>
      <url>/2019/10/05/%E3%80%8A%E6%95%99%E7%88%B6%E3%80%8B%E4%B8%89%E9%83%A8%E6%9B%B2%EF%BC%9A%E5%85%85%E6%BB%A1%E8%85%90%E8%B4%A5%E8%80%8C%E4%B8%8D%E5%A4%B1%E5%BA%84%E9%87%8D%E7%9A%84%E8%B5%84%E6%9C%AC%E4%B8%BB%E4%B9%89%E6%B0%94%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/10/05/%E3%80%8A%E6%95%99%E7%88%B6%E3%80%8B%E4%B8%89%E9%83%A8%E6%9B%B2%EF%BC%9A%E5%85%85%E6%BB%A1%E8%85%90%E8%B4%A5%E8%80%8C%E4%B8%8D%E5%A4%B1%E5%BA%84%E9%87%8D%E7%9A%84%E8%B5%84%E6%9C%AC%E4%B8%BB%E4%B9%89%E6%B0%94%E6%81%AF/《教父》三部曲：充满腐败而不失庄重的资本主义气息/timg.jpg" alt="timg.jpg"></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>《教父》三部曲每一部都很精彩，第二部主角是个活生生的反例，可能稍逊一筹。</p><p>第一部《教父》介绍的是柯里昂家族反对毒品交易而引起的大风波，是三部曲中唯一一部被拍成电影的书(电影《教父Ⅰ》完美还原，表现力很强，但缺少细节导致剧情不太连续)。个人认为，维托·唐·柯里昂是三部曲中唯一一位称得上是教父的人，其度量、耐心、冷静与智慧让人折服。教父因拒绝毒品交易被枪击，随后小儿子迈克·柯里昂替父报仇潜逃西西里，长子桑提诺·柯里昂性格鲁莽在之后的大战中被击毙，唐请求各大家族协商和谈停止战争，让迈克返回纽约继承教父衣钵。迈克与父亲一样沉着、冷静、精明、坚强，整本书也像是讲述他褪茧化蝶的过程，最终成为了第二代教父。每一个男人都必须像他一样，让自己的心智不断变得成熟，让自己变得足够强大，可以保护自己、家人和别人。</p><p>第二部《教父：西西里人》故事发生在黑手党之乡西西里，整本书的格调非常浪漫，结局悲惨令人唏嘘。图里·吉里安诺劫富济贫、反抗政府、藐视黑手党，是西西里的英雄人物，在政府、黑手党的阴谋之下，各种矛盾激发，最终被他的忠实追随者阿斯帕努·皮肖塔背叛而惨遭杀害。图里失败的原因有很多，他是是理想主义者，信奉个人英雄主义。第二，不具有大局观，被政府与黑手党联手利用以对抗共产党人时，不曾想到长远利益。第三，他也不善于领导下属，他以“属下”而不是“伙伴”的态度来对待和尊重他的团队，最后计划潜逃美国时，没有考虑他的好友阿斯帕努的后路，导致亲密伙伴的叛变。</p><p>第三部《教父：最后的教父》，讲述克莱里库齐尼奥家族消灭敌人库奇奥家族后发生的故事，穿插家族与好莱坞两条主线，故事内容较前两部更加丰富、情节更加复杂。全书最精彩的是结尾，唐·克莱里库齐尼奥为完成使家族产业合法化的大局，借用外孙克罗斯·德·莱纳之手除去孙子丹特·克莱里库齐尼奥。这两个人辈分相同，背景与性情却大相径庭：克罗斯·德·莱纳跟随父亲皮皮·德·莱纳长大，他彬彬有礼、勇敢果断；而丹特的父亲是库奇奥家族长子乔治·库奇奥(类似罗密欧与朱丽叶之间的家族纠纷，乔治在结婚之日被皮皮所杀)，继承了库奇奥家族残暴的性情。唐其实不愿将教父之位传与丹特，在丹特为父报仇杀害皮皮后，没有主持所谓的公道，假装不知情，任由克罗斯将丹特杀害，再将克罗斯驱逐。最终克罗斯退出了家族，但个人认为他是天生的黑手党首领，是“最后的教父”。</p><h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><ol><li>有个道理他早就弄清楚了，那就是你必须承受社会强加的侮辱，因为他明白，连最卑微的人，只要时刻擦亮眼睛，就迟早能抓住机会，报复最有权势的人。正是明白这个道理，唐才从不放弃他的谦逊风度，所有朋友都对此敬佩有加。</li><li>友谊就是一切。比天赋更重要，比政府更重要。和家人差不多同样重要。</li><li>“我会给他一个他无法拒绝的条件。”</li><li>知道极地探险家在通往北极的路上要沿途存放口粮，防止日后某天会需要食物吗？那就是我父亲的人情。</li><li>黑根的谈判技巧是唐亲自传授的。“永远不要动怒，”唐这么教导他，“决不要威胁，要讲道理。”用意大利语说“讲道理”听上去像“应对”。关键是忽视所有的侮辱和威胁，一边脸挨了打，就把另一边脸也凑上去。</li><li>意大利人有个玩笑话，说世界太残酷，所以一个人非得有两个父亲照看他，这就是教父的由来。</li><li>在黑根的世界里，柯里昂家族的世界里，女性的美丽肉体和性魅力对世俗事务毫无重要性可言。只要不涉及婚姻和家族的脸面，这就只是私人事务。</li><li>动作不慌不忙得吓人，像是全世界的时间都归他们支配。他们不是慌乱地瞎打一通，而是一板一眼，用上躯体的全部力量，慢镜头似的慢慢收拾他。每一拳下去都带着皮开肉绽的声音。</li><li>没有一句警告，不装腔作势，不按理出牌，不留任何余地。这种冷酷无情，这种对一切价值的全然蔑视，意味着这个人只认他自己的法律，甚至把自己视为上帝。</li><li>绝对不要让家族外的人知道你在想什么。绝对不要让他们知道你手里有什么牌。</li><li>可是，克莱门扎有个强烈的感觉，那就是遵守良好的工作习惯很重要，务必做到万无一失。论到生死问题，谁也说不准会发生什么。</li><li>将来有可能会出现有人会因为利益而出卖他的情况，要是只有一名同伙，那就是正反双方各执一词。但要是还有第二名同伙作旁证，平衡就会被打破。不，办事必须严格按照程序。</li><li>你不能说他走运，彼得，那太低估他了。我们最近太过于低估别人。</li><li>“这种事每隔十来年就要发生一次，能释放彼此的仇怨。另外，要是放任他们在小事上随便摆布我们，那他们就会想要夺走我们的一切。必须一冒头就斩断。就像他们当初在慕尼黑就该阻止希特勒，他干了那种事，怎么能随便放过他，放过他就意味着后面的大麻烦都是自找苦吃。”</li><li>有些事情非做不可，做了也不值得再次提起，不需要给自己找正当的借口。这种事情正当不起来。反正做就是了，然后忘掉。</li><li>当然了，谁都不可能以任何理由挑拨唐，唐的情感只受他自己左右。</li><li>尼诺的反应与成功之路背道而驰，无论别人怎么帮他，他都觉得受了羞辱。</li><li>一个向警方通风报信的人，一个收钱就可以不寻仇的人，肯定没有过硬的后台。</li><li>这段经验催生了他的座右铭：一个人只能有一种命运。</li><li>“我会和他讲道理。”维托·柯里昂说，这句话后来成了他的名言，致命攻击前的最后警告。后来他成为唐，每次请对手坐下来和他讲道理，对手就明白这是解决争端而不流血杀人的最后一次机会了。</li><li>当时维托·柯里昂还不知道这个笑容的威力。之所以让人毛骨悚然，正是因为毫无威胁的意思，像是听到了只有自己才明白的什么私人玩笑。可是，他只在性命攸关的事情上露出这个笑容，玩笑也并不真的私密，他的双眼毫无笑意，外在性格平时又是那么通情达理和沉默寡言，因此突然摘下面具，露出真实的自我才那么吓人。</li><li>伟大的人并非生而伟大，而是越活越伟大，维托·柯里昂就是明证。</li><li>他掂量了一下他们的威胁，发现没什么说服力，于是降低了对新伙伴的评价，因为他们太愚蠢，在毫无必要的情况下滥用威胁。</li><li>你难道不想好好上学，不想当个律师？律师拎着手提箱能偷的钱，一千个强盗戴着面具拿着枪也比不上。</li><li>除了他时常重复的“一个人只有一种命运”理论，唐还喜欢责备桑尼动不动就发脾气的毛病。唐认为威胁是最愚蠢的自我暴露，不假思索就释放怒火是最危险的任性表现。没有谁听唐发出过赤裸裸的威胁，没有谁见过他陷入无法控制的狂怒。那是难以想象的事情。他就这么尽量向桑尼传授自己的准则。他说除了朋友低估你的优点，世上最大的天然优势就是敌人高估你的缺陷。</li><li>和历史上所有伟大的统治者和立法者一样，唐·柯里昂看明白了，除非把王国的数量缩减到可控范围之内，否则就不可能缔造秩序与和平。</li><li>一个人靠汗水挣面包钱，做什么职业都值得尊敬。</li><li>时间能治好创伤。痛苦和恐惧不是死亡，还有挽回的余地，</li><li>卡洛觉察到桑尼会杀了他，明白桑尼拥有动物本性，能杀死另一名人类；而他要想杀人，却必须聚集起全部勇气和全部意志力。卡洛从没想到过，这是因为他比桑尼·柯里昂更有人情味——如果“人情味”能用在他们头上的话；他嫉妒桑尼身上那种被镀上传奇色彩的、可怕的凶残。</li><li>明白如果她有必要知道的坏事，那么马上就会有人来通知她；如果是坏事但她不知道也无所谓，那么她还是不要知道为妙。</li><li>朋友不会轻易求你帮忙，你也不能轻易拒绝。</li><li>没有理性，我们和丛林野兽还有什么分别？但是，我们毕竟有理性，能够彼此说理，能够和自己说理。</li><li>他没有详细解释，在唐这样的人看来，一个人试图自杀是多么不可思议的事情。</li><li>唉，人生又不完全是甜美的音乐，你要是愿意在医院里走一圈，就会看见什么是真正的苦难，就会给肉赘唱一首小情歌了。</li><li>面对残暴的绝对权力，苦难中的人民害怕被击垮，学会了决不泄露怒火和恨意，决不空口威胁而让自己受到伤害，因为那就等于提醒对手，会迅速遭到报复。他们学会了社会就是敌人，于是在受到冤屈而寻找救济的时候，转而求助于叛逆的地下王国——黑手党。黑手党通过缄默规则巩固权力。在西西里乡村，陌生人连问怎么去最近的村镇都得不到礼遇和回答。黑手党成员能犯下的最大罪错莫过于告诉警察，他吃了谁的枪子或者被谁以任何方式伤害了。缄默规则成了人们的宗教。一个女人就算丈夫被杀、儿子被杀、女儿被强奸，也不能向警方透露罪犯的姓名。</li><li>我经常这么和别人说，‘肉别吃那么多，否则你会死；烟别抽那么多，否则你会死；工作别那么卖力，否则你会死；酒别喝那么凶，否则你会死。’谁也不听我的。知道为什么吗？因为我说的不是‘明天你就会死’。</li><li>唐帮助不幸的人，而这些人的不幸又有一部分要归咎于他。不一定出于狡诈或计划，很可能只是因为他在各方面都有利益，也许这就是宇宙的固有性质：善与恶内在联系，宇宙本身就是这样。</li><li>她知道全世界只有她能压迈克尔一头，但也知道经常这么做只会毁掉这种能力。</li><li>忒西奥看好迈克尔。他感觉到这个年轻人没这么简单，巧妙地隐藏起了某种力量，他戒心很重，生怕把真正的实力暴露在公众视线之下，遵循唐的教诲：让朋友低估你的优点，敌人高估你的缺陷。</li><li>你不能对你爱的人说不，至少不能经常说。这就是秘诀。要是非说不可，也得听起来像是肯定。或者想办法让他们自己说。你得耐心，不怕麻烦。</li><li>他已在弥留之际。他闻着花园的香味，黄色的光球刺得眼睛生疼，他悄声说：“生活如此美丽。”</li><li>要是不赞同某个团体或个人的看法，他要么避而不谈，要么直截了当地说出他的不满。他从不礼节性地随意附和。</li><li>很多年轻人在拥抱真正的命运之前都走错过路。时间和运气会改正错误。</li><li>既然他不怕死，存心找死，那么诀窍就在于，让他唯独不想死在你的手里。他害怕的事情只有一件——不是死亡，而是他或许会死在你手里。到那个时候，他就完全属于你了。</li><li>因为背叛是不能宽恕的罪行。迈克尔可以宽恕他们，但他们永远无法宽恕自己，因此反而更危险。迈克尔真的很喜欢忒西奥，更爱自己的妹妹。可是，如果放过忒西奥和卡洛，那就是对你和孩子、对他的整个家庭、对我和我的家人的失职。他们会对我们所有人、所有人的生命构成危险。</li><li>他显然是一个“值得尊敬”的人。</li><li>西西里人害怕真相。过去几千年里，暴君和宗教法庭用酷刑逼迫他们说真话，罗马政府用法律要求人们说真话，教堂忏悔处的神父用下地狱的痛苦敦促人们说真话，可是真话是力量的源泉，是控制的杠杆，为什么要拱手交给别人呢？</li><li>天生的恶棍对天生的英雄有着天然的敌意。</li><li>穷人总是上当受骗，甚至被那些指引他们通往救赎之路的人欺骗。</li><li>我们真正的信仰在于我们相信奇迹会发生。</li><li>一个对人类过去两千年历史一无所知的人，是一个在黑暗中生活的人。</li><li>唐·克罗切最厉害的地方就是不理会别人对他的侮辱和不恭，但是他会把它牢记在心里。</li><li>我们小时候，我们年轻的时候，热爱我们的朋友，慷慨地对待他们，原谅他们的错误，这些都是很自然的。每一天都很新鲜。我们愉快地期待未来，毫无畏惧之心。世界本身并没有那么危险；那是一段欢乐的时光。可是我们长大了，要自食其力了，朋友的情谊就不那么容易维系下去。我们必须随时保持警惕。我们的长辈不再照顾我们，我们也不再对儿时简单的乐趣感到满足。我们开始有了自豪感——我们希望成为了不起的人、有权的人或者有钱的人，或者只是为了使自己免遭不幸。我知道你非常热爱图里·吉里安诺，可是现在你必须问问自己，这样的爱要付出什么代价？经过这么多年，这样的爱是否还存在？是不是只存在于记忆之中？</li><li>皮肖塔很聪明，但只是年轻人的那种聪明——也就是说，他没有充分认识到，最好的人心里也有潜在的恐怖与邪恶。</li><li>如果皮肖塔继续对吉里安诺忠心耿耿，他也会被人们所遗忘，因为那样整个传奇故事就将是关于吉里安诺一个人的。但是他犯下了弥天大罪，这样他就会与他热爱的图里永远并列在一起了。</li><li>你是不是想成为像吉里安诺一样的英雄？一个传奇人物？一个死人？我喜欢他，因为他是我最好的朋友的儿子，可是我并不羡慕他的名声。你还活着，可是他死了。永远不要忘记这一点。活着不要当英雄，只要活着就行。时过境迁之后，英雄似乎就有点儿愚蠢了。</li><li>在熟铁框架上锻造了一行字，是给那些自鸣得意的凭吊者看的：我们曾经像你们一样——你们也会像我们一样。</li><li>“我们要做的是助人为乐，”唐说道，“不是舍己为人。”</li><li>永远别回头。无论是为了找借口、为自己辩解还是找乐子，永远都不要回头。你现在是什么人，就是什么人，世界眼下是什么样，就是什么样。</li><li>自杀——如今这种事儿还属于“政治不正确”吗？</li><li>暴力这种武器太宝贵了，浪费不得，必须用以达到重要目的才行。</li><li>每个男人、女人和孩童，在压力之下、悔恨之中，或是艰难的环境面前，都要完全对自己的行为负责。决定一个人的是行为，言语只不过是个屁。</li><li>不轻易动怒，不谈论自己。要用行动而不是言语来赢得尊重。尊重家庭的每一分子。赌博是消遣，可不是营生。爱父母和妹妹，但是小心，别爱上老婆以外的女人。老婆就是给你生孩子的女人。有了妻儿，就要牺牲自己的生活去养活他们。</li><li>聪明的、理智的男人，绝大多数情况下都不必害怕女人。两种人你必须警惕：第一种是最危险的，那就是遭遇了不幸的小姑娘；第二种就是比你还有野心的女人。</li><li>显然他的行为都是让她主动离开的小伎俩，可她这么长时间都不知趣。想想真丢脸。她怎么能这么傻呢？</li><li>事实证明，谨慎地镇压自由意志对人类生存很有必要。</li><li>法兰西国王露出屁股，当众大便，以示对教皇的轻蔑。而那个红衣主教则高呼：“噢，这是天使的屁股！”然后冲上去大亲特亲。</li><li>迪尔最喜欢用“脆弱”形容他认为愚蠢的人。</li><li>皮皮大笑道：“别让任何人告诉你该怎么做，不要让别人插手你的事。他们只能告诉你他们的期望，而且我们只找最有利于我们的方法办事。最简单的就是最好的。如果你必须把事情搞复杂，那就搞到最复杂。”</li><li>唐也知道，无论爱有多么深，这种情感都不可靠。爱不一定带来感激和顺从，也不一定能在如此艰难的世界里带来和睦。所以，为了激励真正的爱，必须让人有所畏惧。爱本身一钱不值，必须包括信任和服从才有意义。</li><li>他对萝塞·玛丽耶说：“像这样的世界，谁都可以为所欲为，怎么能生活得下去呢？谁都不会受到上帝或者他人的惩罚，谁都不必养活自己？真有这种为所欲为的女人吗？真有男人如此愚蠢和软弱，任何一点欲望、梦想或者快乐都可以使他们屈服吗？那些诚实的丈夫在哪？他们为了食物而工作，想方设法保护孩子们不受命运和这个残酷的世界摆布。谁能真正明白一片奶酪、一杯酒、一个温暖的家，人生就足够了？向往虚无缥缈的幸福的都是什么人？看看他们把生活搞得多么乱七八糟、凭空制造了多少悲剧。”唐拍了拍女儿的头，冲着电视荧幕不屑地摆摆手，说，“让他们都下地狱吧。”最后，他又加了一句金玉良言，“每个人都要为自己的所作所为负责。”</li><li>任何形式的伟大都会招致嫉妒。</li><li>怪人做怪事，是为了让人们注意不到他们的真面目。他们自卑。</li><li>这就是真相。他对人类失望了。他见到了太多的背叛、太多可怜的软弱、太多争名逐利的贪婪。相爱的人之间却都是逢场作戏，夫妻也好、父子也好、母女也好，都是一样。</li><li>我没胆子跳出窗户。我想象力丰富，在落地之前就能想到一千种自己落地后摔得七零八落的样子，还有可能会砸到别人；我不敢割腕，见血就晕；我也不敢用刀、枪或者撞车、卧轨。</li><li>人可以不断犯错，但绝不能犯要命的错。</li><li>阅读是永远不会背叛他的一种快乐。</li><li>那些笔触优雅的散文，那么受人欢迎，现在看来都是无病呻吟，夸张做作而且自命不凡。</li><li>“你不能认栽，”唐对克罗斯说，“这样的话，大家都把你当傻子看，全世界的人谁也不会尊重你了。”</li><li>他是个好孩子，但还年轻，年轻人必须得承担风险。</li><li>克罗斯想知道他什么时候最爱她，是当她生气勃勃的时候，当她严肃认真的时候，还是她闷闷不乐的时候。她美丽的面容不断变化，似乎有种魔力，克罗斯自己的情绪也随她一起变化。</li><li>他急切地想牺牲自己成全自己爱的女人，很多男人都有过这种感觉，现在轮到他了。</li><li>唐说过，绝大多数悲剧都是荒诞的。</li><li>下午剩下的时间，克罗斯在片场观看拍摄。有这么一场戏，主角赤手空拳干掉了三个全副武装的敌人。这把他惹毛了。是英雄就不应该让自己陷入这么绝望的局面。这种事只能证明这家伙太蠢，根本不配当英雄。</li><li>要知道，世界眼下是什么样，就是什么样；你现在是什么人，就是什么人。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Reading </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PCA and LDA with Kernel</title>
      <link href="/2019/09/05/PCA-and-LDA-with-Kernel/"/>
      <url>/2019/09/05/PCA-and-LDA-with-Kernel/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>核函数可将数据进行升维，在更高维度的空间进行数据分析，可以将线性不可分问题转换为线性可分问题，关于核函数，详细可查看<a href="https://louishsu.xyz/2019/05/27/Support-Vector-Machine/" target="_blank" rel="noopener">Support Vector Machine 2.2核技巧</a>。在<a href="https://louishsu.xyz/2018/10/22/PCA/" target="_blank" rel="noopener">PCA</a>与<a href="https://louishsu.xyz/2019/04/22/LDA/" target="_blank" rel="noopener">LDA</a>中分别介绍了主成分分析与线性鉴别分析，但这两种均为线性方法，本文利用核技巧将数据映射到高维空间，然后再用两种降维方法进行降维。</p><p><strong>先升维再降维！</strong></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>假设有$M$个$N$维样本组成数据矩阵$X_{N \times M}$</p><script type="math/tex; mode=display">X = \begin{bmatrix}         | & | &   & | \\        x^{(1)} & x^{(2)} & \cdots & x^{(M)} \\        | & | &   & |    \end{bmatrix} \tag{1}</script><p>其中$x^{(i)} = \begin{bmatrix} x^{(i)}_1 &amp; x^{(i)}_2 &amp; \cdots &amp; x^{(i)}_N \end{bmatrix}^T$，属于$C$个类别，第$j$类的样本数为$M_j$。</p><p>核函数一般定义为$\kappa(x, y) = \Phi(x)^T \Phi(y) $，注意到，核函数是升维后数据的<strong>内积形式</strong>，利用隐式映射$\Phi(x)$将样本维度增加。</p><h2 id="Kernel-PCA"><a href="#Kernel-PCA" class="headerlink" title="Kernel PCA"></a>Kernel PCA</h2><p>同样地，求取升维后数据的协方差矩阵，需要对样本去均值化，即</p><script type="math/tex; mode=display">C = \frac{1}{M} \sum_{i=1}^M \left[\Phi(x^{(i)}) - \Phi(\mu)\right] \left[\Phi(x^{(i)}) - \Phi(\mu)\right]^T \tag{2}</script><p>其中$\Phi(\mu) = \frac{1}{M} \sum_{i=1}^M \Phi(x^{(i)})$。将其特征分解，记高维空间的第一主轴为$\Phi(u_1)$，有</p><script type="math/tex; mode=display">C \Phi(u_1) = \lambda_1 \Phi(u_1) \tag{3}</script><p>现在有个问题，由于$\Phi(x)$为隐式映射，<strong>实际上$C$是不能直接求解的</strong>。将$(2)$代入$(3)$，有</p><script type="math/tex; mode=display">\underbrace{        \frac{1}{M} \sum_{i=1}^M         \left[\Phi(x^{(i)}) - \Phi(\mu)\right]        \left[\Phi(x^{(i)}) - \Phi(\mu)\right]^T    }_C \Phi(u_1) = \lambda_1 \Phi(u_1) \tag{4}</script><p>其中$\left[\Phi(x^{(i)}) - \Phi(\mu)\right]^T \Phi(u_1)$部分为参数，可记作$a^{(i)}_1$，所以</p><script type="math/tex; mode=display">\frac{1}{M} \sum_{i=1}^M     \left[\Phi(x^{(i)}) - \Phi(\mu)\right]    a^{(i)}_1 = \lambda_1 \Phi(u_1)</script><p>记$\Psi(x^{(i)})=\Phi(x^{(i)}) - \Phi(\mu)$，也即</p><script type="math/tex; mode=display">\Phi(u_1) = \frac{1}{\lambda_1 M} \sum_{i=1}^M     a^{(i)}_1 \Psi(x^{(i)}) \tag{5}</script><p>所以可以看到，主轴$\Phi(u_1)$是由高维空间样本去均值化后的数据点$\Psi(x^{(i)})$<strong>张成</strong>的，这个式子很重要，<strong>只需求出$a^{(i)}_1$，即可表示出主轴</strong>，用于高维数据$\Phi(x^{(i)})$的降维。继续，将式$(1), (5)$代入$C \Phi(u_1) = \lambda_1 \Phi(u_1)$，得到</p><script type="math/tex; mode=display">\begin{aligned}    \underbrace{        \frac{1}{M} \sum_{i=1}^M             \Psi(x^{(i)})            \Psi(x^{(i)})^T    }_C     \underbrace{        \cancel{\frac{1}{\lambda_1 M}}         \sum_{i=1}^M \Psi(x^{(i)}) a^{(i)}_1    }_{\Phi(u_1)}     = \lambda_1     \underbrace{        \cancel{\frac{1}{\lambda_1 M}}         \sum_{i=1}^M \Psi(x^{(i)}) a^{(i)}_1    }_{\Phi(u_1)} \\    \frac{1}{M} \sum_{i=1}^M         \Psi(x^{(i)})    \sum_{j=1}^M         a^{(j)}_1 \Psi(x^{(i)})^T \Psi(x^{(j)})    = \lambda_1 \sum_{i=1}^M a^{(i)}_1 \Psi(x^{(i)})\end{aligned}</script><p>上式左右同乘$\Psi(x^{(l)})^T$，凑出核函数的形式，得到</p><script type="math/tex; mode=display">\begin{aligned}    \frac{1}{M} \Psi(x^{(l)})^T    \left[        \sum_{i=1}^M             \Psi(x^{(i)})        \sum_{j=1}^M             a^{(j)}_1 \Psi(x^{(i)})^T \Psi(x^{(j)})    \right]    = \lambda_1 \Psi(x^{(l)})^T    \left[        \sum_{i=1}^M a^{(i)}_1 \Psi(x^{(i)})    \right] \\    \frac{1}{M}        \sum_{i=1}^M             \underbrace{\Psi(x^{(l)})^T \Psi(x^{(i)})}_{\kappa(x^{(l)}, x^{(i)}))}        \sum_{j=1}^M             a^{(j)}_1 \underbrace{\Psi(x^{(i)})^T \Psi(x^{(j)})}_{\kappa(x^{(i)}, x^{(j)}))}    = \lambda_1         \sum_{i=1}^M             a^{(i)}_1 \underbrace{\Psi(x^{(l)})^T \Psi(x^{(i)})}_{\kappa(x^{(l)}, x^{(i)}))} \\    \frac{1}{M}        \sum_{i=1}^M             \kappa(x^{(l)}, x^{(i)})        \underbrace{            \sum_{j=1}^M                 a^{(j)}_1 \kappa(x^{(i)}, x^{(j)})        }    = \lambda_1         \underbrace{            \sum_{i=1}^M                 a^{(i)}_1 \kappa(x^{(l)}, x^{(i)})        }\end{aligned}</script><p>记$a_1 = \begin{bmatrix} a^{(1)}_1 &amp; a^{(2)}_1 &amp; \cdots &amp; a^{(M)}_1 \end{bmatrix}^T$，核矩阵$K = \begin{bmatrix} \kappa(x^{(i)}, x^{(j)}) \end{bmatrix}, i, j \in {1, 2, \cdots, M}$，则有</p><script type="math/tex; mode=display">\sum_{i=1}^M a^{(i)}_1 \kappa(x^{(j)}, x^{(i)}) = K_{j} a_1 (K的第j行) \tag{6}</script><p>代入后</p><script type="math/tex; mode=display">\sum_{i=1}^M \kappa(x^{(l)}, x^{(i)}) K_{i} a_1 = \lambda_1 M K_{l} a_1</script><p>等号左边再使用一次$(6)$，有</p><script type="math/tex; mode=display">K_l \begin{bmatrix} K_1 a_1 \\ K_2 a_1 \\ \cdots \\ K_M a_1 \end{bmatrix} = \lambda_1 M K_{l} a_1</script><p>其中$K a_1 = \begin{bmatrix} K_1 a_1 &amp; K_2 a_1 &amp; \cdots &amp; K_M a_1 \end{bmatrix}^T$，故$K_l K a_1 = \lambda_1 M K_{l} a_1$，由于$K_l \neq 0$，所以</p><script type="math/tex; mode=display">K a_1 = \lambda_1 M a_1 \tag{7}</script><p>所以<strong>对矩阵$K$进行特征分解即可计算得到$a_1$</strong>，同PCA一样，按特征值降序对特征向量排序，选取前$k$个<strong>主轴对应的权值向量</strong>${a_1, a_2, \cdots, a_k}$，注意$a_k=\Psi(x^{(i)})^T \Phi(u_1)$并不是投影的轴，那么对于输入的样本点$x$进行降维时，应有</p><script type="math/tex; mode=display">y = \Phi(u_1)^T \Phi(x)</script><p>其中$\Phi(u_1) = \frac{1}{\lambda_1 M} \sum_{i=1}^M a^{(i)}_1 \Psi(x^{(i)})$，，仅考虑方向省略$\frac{1}{\lambda_1 M}$，所以</p><script type="math/tex; mode=display">\begin{aligned}    y_1 = \left[\sum_{i=1}^M a^{(i)}_1 \Psi(x^{(i)})\right]^T \Phi(x) \\    = \sum_{i=1}^M a^{(i)}_1 \kappa(x^{(i)}, x)\end{aligned} \tag{8}</script><p>至于数据的重建，应该有$\hat{\Phi}(x) = \sum y_k \Phi(u_k)$，而$\Phi(u_k)$未知，故只能通过迭代优化的形式进行重建，最小化目标可使用MSE，即最小化</p><script type="math/tex; mode=display">J = \min \{|| \Phi(x) - \hat{\Phi}(x) ||^2\} \tag{9}</script><p><strong>整理一下上面的算法</strong></p><ol><li>选择核函数，如高斯核$\kappa(x, y) = - \frac{||x - y||^2}{2 \sigma^2}$，多项式核$\kappa(x, y) = (x^T y + c)^d$；</li><li>根据选用的核函数，计算核矩阵$K_{M \times M} = \begin{bmatrix} \kappa(x^{(i)}, x^{(j)}) \end{bmatrix}, i, j \in {1, 2, \cdots, M}$；</li><li>对$K$进行特征分解，根据特征值降序对特征向量进行排序，计算得到各个主轴方向上的权重参数${a_1, a_2, \cdots, a_k}$；</li><li>对于输入的样本点$x$，根据$y_1 = \sum_{i=1}^M a^{(i)}_1 \kappa(x^{(i)}, x)$进行降维，可以看到，Kernel PCA主轴的计算与训练样本$x^{(i)}$有关，需要进行保存。</li></ol><h2 id="Kernel-LDA"><a href="#Kernel-LDA" class="headerlink" title="Kernel LDA"></a>Kernel LDA</h2><p>对于<strong>映射后数据$\Phi(x)$</strong> ，其类内离差阵$S_W$与类间离差阵$S_B$为</p><script type="math/tex; mode=display">\begin{aligned}    S_W = \sum_{j=1}^C \frac{M_j}{M}         \left\{            \frac{1}{M_j} \sum_{i=1}^{M_j}                 \left[\Phi(x^{(i)}) - \Phi(\mu^{(j)})\right]                \left[\Phi(x^{(i)}) - \Phi(\mu^{(j)})\right]^T        \right\} \\    S_B = \sum_{j=1}^C \frac{M_j}{M}         \left\{                \left[\Phi(\mu^{(j)}) - \Phi(\mu)\right]                \left[\Phi(\mu^{(j)}) - \Phi(\mu)\right]^T        \right\}\end{aligned} \tag{10}</script><p>其中$\Phi(\mu^{(j)}) = \frac{1}{M_j} \sum_{i=1} \Phi(x^{(i)}), \Phi(\mu) = \frac{1}{C} \sum_{j} \Phi(\mu^{(j)})$。现以第一主轴为例，$\tilde{S_W}$与$\tilde{S_B}$分别表示<strong>映射后数据$\Phi(x)$</strong> 在第$1$主轴$\Phi(u_1)$上分布的类内离差阵与类间离差阵，即</p><script type="math/tex; mode=display">\begin{aligned}    \tilde{S_W} = \sum_{j=1}^C \frac{M_j}{M}         \left\{            \frac{1}{M_j} \sum_{i=1}^{M_j}                 \left[\tilde{\Phi}(x^{(i)}) - \tilde{\Phi}(\mu^{(j)})\right]                \left[\tilde{\Phi}(x^{(i)}) - \tilde{\Phi}(\mu^{(j)})\right]^T        \right\} \\    \tilde{S_B} = \sum_{j=1}^C \frac{M_j}{M}         \left\{                \left[\tilde{\Phi}(\mu^{(j)}) - \tilde{\Phi}(\mu)\right]                \left[\tilde{\Phi}(\mu^{(j)}) - \tilde{\Phi}(\mu)\right]^T        \right\}\end{aligned} \tag{11}</script><p>其中$\tilde{\Phi}(\mu^{(j)}) = \frac{1}{M_j} \sum_{i=1} \tilde{\Phi}(x^{(i)}), \tilde{\Phi}(\mu) = \frac{1}{C} \sum_{j} \tilde{\Phi}(\mu^{(j)})$，且由投影可知</p><script type="math/tex; mode=display">\tilde{\Phi} (x^{(i)}) = \Phi(u_1)^T \Phi(x^{(i)});\quad \tilde{\Phi} (\mu^{(j)}) = \Phi(u_1)^T \Phi(\mu^{(j)});\quad \tilde{\Phi} (\mu) = \Phi(u_1)^T \Phi(\mu)</script><p>将以上代入$\tilde{S_W}$与$\tilde{S_B}$，有</p><script type="math/tex; mode=display">\begin{aligned}    \tilde{S_W} = \Phi(u_1)^T S_W \Phi(u_1) \\    \tilde{S_B} = \Phi(u_1)^T S_B \Phi(u_1)\end{aligned} \tag{12}</script><p>与LDA思路一致，定义优化目标为</p><script type="math/tex; mode=display">J = \min\left\{            \frac{\tilde{S_W}}{\tilde{S_B}}        \right\} =     \min\left\{            \frac{\Phi(u_1)^T S_W \Phi(u_1)}{\Phi(u_1)^T S_B \Phi(u_1)}         \right\} \tag{13}</script><p>最终同LDA，有$S_B \Phi(u_1) = \lambda_1 S_W \Phi(u_1)$或$S_W^{-1} S_B \Phi(u_1) = \lambda_1 \Phi(u_1)$，但是有同样的问题，<strong>由于隐式映射$\Phi(x)$，$S_W, S_B$不能直接求解</strong>。由PCA可知，<strong>主轴$\Phi(u_1)$一定由高维数据样本点$\Phi(x^{(i)})$张成</strong>，即</p><script type="math/tex; mode=display">\Phi(u_1) = \sum_{i=1}^M a^{(i)}_1 \Phi(x^{(i)}) \tag{14}</script><p>$(10), (15)$代入$\Phi(u_1)^T S_W \Phi(u_1), \Phi(u_1)^T S_B \Phi(u_1)$，有</p><script type="math/tex; mode=display">\begin{aligned}    \Phi(u_1)^T S_W \Phi(u_1) =         \underbrace{            \left[                \sum_{i=1}^M a^{(i)}_1 \Phi(x^{(i)})            \right]^T        }_{\Phi(u_1)^T}        \underbrace{            \frac{1}{M} \sum_{j=1}^C \sum_{i=1}^{M_j}            \left\{                \left[\Phi(x^{(i)}_j) - \Phi(\mu^{(j)})\right]                \left[\Phi(x^{(i)}_j) - \Phi(\mu^{(j)})\right]^T            \right\}        }_{S_W}        \underbrace{            \left[                \sum_{i=1}^M a^{(i)}_1 \Phi(x^{(i)})            \right]        }_{\Phi(u_1)} \\            \frac{1}{M} \sum_{j=1}^C \sum_{i=1}^{M_j}            \left\{                \underbrace{                    \left[                        \sum_{k=1}^M a^{(k)}_1 \Phi(x^{(k)})                    \right]^T                    \left[\Phi(x^{(i)}_j) - \Phi(\mu^{(j)})\right]                }                \underbrace{                    \left[\Phi(x^{(i)}_j) - \Phi(\mu^{(j)})\right]^T                    \left[                        \sum_{k=1}^M a^{(k)}_1 \Phi(x^{(k)})                    \right]                }            \right\}\end{aligned}</script><p>其中</p><script type="math/tex; mode=display">\begin{aligned}    \left[        \sum_{k=1}^M a^{(k)}_1 \Phi(x^{(k)})    \right]^T    \left[        \Phi(x^{(i)}_j) - \Phi(\mu^{(j)})    \right] \\     = \sum_{k=1}^M a^{(k)}_1 \kappa(x^{(k)}, x^{(i)}_j) -         \left[            \sum_{k=1}^M a^{(k)}_1 \Phi(x^{(k)})        \right]^T         \left[            \frac{1}{M_j} \sum_{i=1}^{M_j} \Phi(x^{(i)}_j)        \right] \\    = \sum_{k=1}^M a^{(k)}_1 \kappa(x^{(k)}, x^{(i)}_j)        - \sum_{k=1}^M a^{(k)}_1 \frac{1}{M_j} \sum_{i=1}^{M_j} \kappa(x^{(k)}, x^{(i)}_j) \\    = \sum_{k=1}^M a^{(k)}_1 \left[            \underbrace{                \kappa(x^{(k)}, x^{(i)}_j)            }_{K^{(j)}_{k, i}} -             \underbrace{                \frac{1}{M_j} \sum_{i=1}^{M_j} \kappa(x^{(k)}, x^{(i)}_j)            }_{\mu_{\kappa^{(j)} k}}        \right]     = a_1^T (K^{(j)}_i - \mu_{\kappa^{(j)}})\end{aligned}</script><blockquote><p>$K^{(k)}_{:, i}$表示第$k$类的第$i$列，为列向量；$K^{(k)}_i$表示第$k$类的第$i$行，为行向量。</p></blockquote><p>所以</p><script type="math/tex; mode=display">\Phi(u_1)^T S_W \Phi(u_1) = \frac{1}{M} \sum_{j=1}^C \sum_{i=1}^{M_j} a_1^T (K^{(j)}_i - \mu_{\kappa^{(j)}}) (K^{(j)}_i - \mu_{\kappa^{(j)}})^T a_1 \tag{15}</script><p>记$M = \frac{1}{M} \sum_{j=1}^C \sum_{i=1}^{M_j}(K^{(j)}_i - \mu_{\kappa^{(j)}}) (K^{(j)}_i - \mu_{\kappa^{(j)}})^T$，则</p><script type="math/tex; mode=display">\Phi(u_1)^T S_W \Phi(u_1) = a_1^T M a_1 \tag{16}</script><p>同理</p><script type="math/tex; mode=display">\begin{aligned}    \Phi(u_1)^T S_B \Phi(u_1) =         \underbrace{            \left[                \sum_{i=1}^M a^{(i)}_1 \Phi(x^{(i)})            \right]^T        }_{\Phi(u_1)^T}        \underbrace{            \sum_{j=1}^C \frac{M_j}{M}             \left\{                    \left[\Phi(\mu^{(j)}) - \Phi(\mu)\right]                    \left[\Phi(\mu^{(j)}) - \Phi(\mu)\right]^T            \right\}        }_{S_B}        \underbrace{            \left[                \sum_{i=1}^M a^{(i)}_1 \Phi(x^{(i)})            \right]        }_{\Phi(u_1)} \\        \sum_{j=1}^C \frac{M_j}{M}         \left\{            \underbrace{                \left[                    \sum_{i=1}^M a^{(i)}_1 \Phi(x^{(i)})                \right]^T                \left[\Phi(\mu^{(j)}) - \Phi(\mu)\right]            }            \underbrace{                \left[\Phi(\mu^{(j)}) - \Phi(\mu)\right]^T                \left[                    \sum_{i=1}^M a^{(i)}_1 \Phi(x^{(i)})                \right]            }        \right\}\end{aligned}</script><p>其中</p><script type="math/tex; mode=display">\begin{aligned}    \left[\sum_{k=1}^M a^{(k)}_1 \Phi(x^{(k)})\right]^T    \left[\Phi(\mu^{(j)}) - \Phi(\mu)\right] \\    = \left[\sum_{k=1}^M a^{(k)}_1 \Phi(x^{(k)})\right]^T    \left[        \frac{1}{M_j} \sum_{i=1}^{M_j} \Phi(x^{(i)}_j) - \frac{1}{M} \sum_{i=1}^M \Phi(x^{(i)})    \right] \\    = \sum_{k=1}^M a^{(k)}_1 \frac{1}{M_j} \sum_{i=1}^{M_j} \kappa(x^{(k)}, x^{(i)}_j) -        \sum_{k=1}^M a^{(k)}_1 \frac{1}{M} \sum_{i=1}^M \kappa(x^{(k)}, x^{(i)}) \\    = \sum_{k=1}^M a^{(k)}_1 \left[            \underbrace{                \frac{1}{M_j} \sum_{i=1}^{M_j} \kappa(x^{(k)}, x^{(i)}_j)            }_{\mu_{\kappa^{(j)} k}}            - \underbrace{                \frac{1}{M} \sum_{i=1}^M \kappa(x^{(k)}, x^{(i)})            }_{\mu_{\kappa k}}        \right] \\    = a_1^T (\mu_{\kappa^{(j)}} - \mu_{\kappa})\end{aligned}</script><p>所以</p><script type="math/tex; mode=display">\Phi(u_1)^T S_B \Phi(u_1) = \sum_{j=1}^C \frac{M_j}{M} a_1^T (\mu_{\kappa^{(j)}} - \mu_{\kappa}) (\mu_{\kappa^{(j)}} - \mu_{\kappa})^T a_1</script><p>记$N = \sum_{j=1}^C \frac{M_j}{M} (\mu_{\kappa^{(j)}} - \mu_{\kappa}) (\mu_{\kappa^{(j)}} - \mu_{\kappa})^T$，则</p><script type="math/tex; mode=display">\Phi(u_1)^T S_B \Phi(u_1) = a_1^T N a_1 \tag{17}</script><p>所以优化目标改为</p><script type="math/tex; mode=display">J = \min \left\{\frac{a_1^T M a_1} {a_1^T N a_1}\right\} \tag{18}</script><p>即求解</p><script type="math/tex; mode=display">M^{-1} N a_1 = \lambda_1 a_1 \tag{19}</script><p>对于新的投影数据，同Kernel PCA，有</p><script type="math/tex; mode=display">y_1 = \sum_{i=1}^M a^{(i)}_1 \kappa(x^{(i)}, x)</script><p><strong>整理一下上述算法</strong></p><ol><li>选择核函数$\kappa(x, y)$；</li><li>计算整体的核矩阵$K_{M \times M}$，利用类别标签从中截取每个类别下的核矩阵$K^{(j)}_{M \times M_j}$；</li><li><p>根据下式计算$M$与$N$；</p><script type="math/tex; mode=display">M = \frac{1}{M} \sum_{j=1}^C \sum_{i=1}^{M_j}(K^{(j)}_i - \mu_{\kappa^{(j)}}) (K^{(j)}_i - \mu_{\kappa^{(j)}})^T</script><script type="math/tex; mode=display">N = \sum_{j=1}^C \frac{M_j}{M} (\mu_{\kappa^{(j)}} - \mu_{\kappa}) (\mu_{\kappa^{(j)}} - \mu_{\kappa})^T</script></li><li><p>对矩阵$M^{-1}N$进行特征分解，将特征向量按特征值降序排序，选择$k$个主分量对于的权值${a_1, a_2, \cdots, a_k}$；</p><script type="math/tex; mode=display">M^{-1} N a_k = \lambda_k a_k</script></li><li><p>对于需要降维的数据$x$，计算各维度上的坐标，同样的，主轴的计算与训练样本$x^{(i)}$有关，需要进行保存。</p><script type="math/tex; mode=display">y_k = \sum_{i=1}^M a^{(i)}_k \kappa(x^{(i)}, x)</script></li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>详细代码见<a href="https://github.com/isLouisHsu/Basic-Machine-Learning-Algorithm/blob/master/algorithm/kernelPCA.py" target="_blank" rel="noopener">Basic-Machine-Learning-Algorithm/algorithm/kernelPCA.py</a>与<a href="https://github.com/isLouisHsu/Basic-Machine-Learning-Algorithm/blob/master/algorithm/kernelFDA.py" target="_blank" rel="noopener">Basic-Machine-Learning-Algorithm/algorithm/kernelFDA.py</a>。</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>构造下图数据，明显为非线性数据，利用线性方法不能提取有效性息用于分类。</p><p><img src="/2019/09/05/PCA-and-LDA-with-Kernel/data.png" alt="data"></p><p>利用Kernel PCA进行降维结果如下</p><p><img src="/2019/09/05/PCA-and-LDA-with-Kernel/kpca.png" alt="kpca"></p><p>利用Kernel FDA进行降维结果如下</p><p><img src="/2019/09/05/PCA-and-LDA-with-Kernel/kfda.png" alt="kfda"></p><p>相比较于PCA，FDA效果更好。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li>G. Baudat and F. Anouar. Generalized discriminant analysis using a kernel approach. Neural Computation, 12:2385-2404, 2000.</li><li><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=788121&amp;tag=1" target="_blank" rel="noopener">S. Mika, G. Ratsch, J. Weston, B. Scholkopf, and K. Muller. Fisher discriminant analysis with kernels. In IEEE Neural Networks for Signal Processing Workshop, pages 41-48, 1999.</a></li><li>Wang Q . Kernel Principal Component Analysis and its Applications in Face Recognition and Active Shape Models[J]. Computer Science, 2012.</li></ol>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 降维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSD: Single Shot MultiBox Detector</title>
      <link href="/2019/09/02/SSD-Single-Shot-MultiBox-Detector/"/>
      <url>/2019/09/02/SSD-Single-Shot-MultiBox-Detector/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>SSD主要做了以下工作</p><ol><li>设计了one-stage检测算法，比同样是one-stage的YOLOv1更快更准确，相比较Faster R-CNN等two-stage检测算法，在不降低准确率的情况下速度更快；</li><li>其核心是用小卷积核，对特征图进行卷积运算，通过一系列的固定回归框进行预测；</li><li>用不同尺度的特征图产生不同尺度的预测，并且明确指定多种纵横比；</li><li>可进行端到端训练，即使是低分辨率图像输入，准确率也很高；</li><li>在PASCAL VOC、MSCOCO、ILSVRC等数据集上得到state-of-art的结果。</li></ol><h1 id="Data-Preparation"><a href="#Data-Preparation" class="headerlink" title="Data Preparation"></a>Data Preparation</h1><h2 id="多层特征图"><a href="#多层特征图" class="headerlink" title="多层特征图"></a>多层特征图</h2><p>一般来说，深层特征图感受野更大，具有更多的语义信息，而浅层特征图保留了更多的细节，因此SSD对两者都加以应用。</p><p>对于某层网络输出的特征图，需要确定用特征图上哪个位置的cell负责对应ground truth边界库那个的预测。<strong>和YOLO不同，SSD使用杰卡德相似度(jaccard overlap)来确定</strong>，也即交并比，$J(A, B) = \frac{|A \bigcap B|}{|A \bigcup B|}$，当该值超过阈值，则该位置负责边界框的回归。</p><p>例如对于下图，在$4 \times 4$、$6 \times 6$与$8 \times 8$的特征图上，指定两种anchor：$2.5: 1.5$与$1.5: 2.5$，选择IoU阈值$0.5$，<a href="https://github.com/isLouisHsu/isLouisHsu.github.io/tree/master/2019/09/02/SSD-Single-Shot-MultiBox-Detector/ssd_anchor_visualize.py" target="_blank" rel="noopener">可视化</a>情况如下。可以看到，浅层特征分辨率较高，对细小物体的检测比较有效，而深层特征分辨率低，对大的物体比较敏感。</p><p>另外，真实框相对于锚框的计算方法如下，其中$(x_g, y_g, w_g, h_g)$与$(x_a, y_a, w_a, h_a)$分别表示真实框$g$与锚框$a$的中心位置坐标、边长</p><script type="math/tex; mode=display">\begin{aligned}    t_x = \frac{x_g - x_a}{w_a} \quad &    t_y = \frac{y_g - y_a}{h_a} \quad &    t_w = \log (\frac{w_g}{w_a}) \quad &    t_h = \log (\frac{h_g}{h_a})\end{aligned}</script><p><img src="/2019/09/02/SSD-Single-Shot-MultiBox-Detector/im4x4_6x6_8x8_anchor.jpg" alt="im4x4_6x6_8x8_anchor"></p><h2 id="关于anchor参数的设置"><a href="#关于anchor参数的设置" class="headerlink" title="关于anchor参数的设置"></a>关于anchor参数的设置</h2><p>这样带来的问题是，对于各个分辨率下的特征图，每个点处anchor参数是不同的，如上面随意设置的参数，可能实际使用时不适合，SSD是这样解决的。</p><p>对于某一层特征图，设置五种纵横比：$a_r \in {\frac{1}{3}, \frac{1}{2}, 1, 2, 3}$，纵横比为$1$的anchor再缩放形成另一尺度的anchor，$s_k’ = \sqrt{s_k s_{k+1}}$，那么该层每个点处包含$6$个anchor。</p><p>对于不同层间，特征图的尺度改变，anchor大小也需随之变化。设置$s_{min}=0.2, s_{max}=0.9$，若所用特征图总层数为$m$，则从浅层到深层，各层的anchor尺度为$s_k = s_{min} + \frac{k - 1}{m - 1}(s_{max} - s_{min}), k \in [1, m]$，在第$k$层，anchor尺寸为$w^a_k = h^a_k = \frac{s_k}{\sqrt{a_r}}$。</p><p>anchor的中心定于$(\frac{i + 0.5}{|f_k|}, \frac{j + 0.5}{|f_k|})$，$|f_k|$为第$k$层特征图某点对应原图中网格的边长。实际上，锚框参数是人为指定的，是需要被解决的一个问题，应根据实际情况进行修改。</p><h1 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h1><p><img src="/2019/09/02/SSD-Single-Shot-MultiBox-Detector/Fig2.png" alt="Fig2"></p><p>SSD接受$300 \times 300$的图像输入，以VGG-16作为backbone网络，从Conv5-3层截断，后面加上一些卷积层作为特征提取器($1 \times 1$与$3 \times 3$卷积层堆叠的形式)。SSD在多个特征图上进行候选框的预测，例如对于$m \times n \times p$的特征图，在该尺度上每个位置指定$k$种尺度的anchor，用$p \times 3 \times 3 \times [k \times (classes + 4)]$的卷积核进行运算，得到$m \times n \times [k \times (classes + 4)]$的特征图。注意，对于$C$个类别的识别，应包含背景，所以$classes = C + 1$。</p><p>如上图，共生成$38^2 \times 4 + 19^2 \times 6 + 10^2 \times 6 + 5^2 \times 6 + 3^2 \times 4 + 1^2 \times 4 = 8732$个候选框。</p><p>根据置信度，滤除一大部分候选框，再用NMS算法删除冗余框。</p><h1 id="Training-Step"><a href="#Training-Step" class="headerlink" title="Training Step"></a>Training Step</h1><p>设置参数$1^{ij_k}_l$，表示在特征图$(i, j)$处的第$k$个锚框$a^{ij_k}$，用于预测真实框$g_l$，即</p><script type="math/tex; mode=display">1^{ij_k}_l =     \begin{cases}        1 & \text{IoU}(a^{ij_k}, g_l) > \text{threshold} \\        0 & \text{otherwise}    \end{cases}</script><p>总体损失由定位损失$L_{loc}$与分类损失$L_{conf}$加权组成，定义在特征图位置$(i, j)$处，对于锚框$k$，网络输出为$\hat{y}^{ij_k} = (\hat{t}^{ij_k}_x, \hat{t}^{ij_k}_y, \hat{t}^{ij_k}_w, \hat{t}^{ij_k}_h, \hat{c}^{ij_k}_0, \hat{c}^{ij_k}_1, \hat{c}^{ij_k}_2, \cdots, \hat{c}^{ij_k}_C)$</p><script type="math/tex; mode=display">L_{total} = \frac{1}{N} \left[\alpha \underbrace{\sum_{i, j, k, l} 1^{ij_k}_l \sum_{* \in \{x, y, w, h\}} \text{SmoothL1}(\hat{t}^{ij_k}_*, t^{ij_k}_*)}_{L_{loc}} + \underbrace{\sum_{i, j, k} - \log \hat{c}^{ij_k}_{c}}_{L_{conf}}\right]</script><p>其中$\hat{c}^{ij_k}_{c} = \frac{\hat{c}^{ij_k}_{c}}{\sum \hat{c}^{ij_k}_{c}}$</p><p>另外，由于物体分布稀疏，分类负样本数目(背景)远大于正样本，所以用困难样本挖掘(hard negative mining)的方法，保留损失值最大的负样本，使分类正负样本的比例保持在$neg: pos = 3: 1$左右。</p><p>同样地，SSD训练时也使用了数据集扩增，数据来源于以下三种途径</p><ol><li>整个原始图像；</li><li>在标注框附近采样，使得杰卡德相似度系数在$0.1, 0.3, 0.5, 0.7, 0.9$；</li><li>随机采样截取。</li></ol><p>随机产生的patch边长在原始边长的$[0.1, 1]$范围内，纵横比范围为$[0.5, 2]$。此外依照$50\%$的概率进行水平翻转，并添加其余干扰。</p><p>用SGD进行优化，批次大小32，初始学习率0.001，动量0.9，权重衰减0.0005。</p><h1 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h1><p><img src="/2019/09/02/SSD-Single-Shot-MultiBox-Detector/Tab1.png" alt="Tab1"></p><p><img src="/2019/09/02/SSD-Single-Shot-MultiBox-Detector/Fig3.png" alt="Fig3"></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://arxiv.org/abs/1512.02325" target="_blank" rel="noopener">SSD: Single Shot MultiBox Detector - arXiv.org</a></li><li><a href="https://github.com/weiliu89/caffe/tree/ssd" target="_blank" rel="noopener">weiliu89/caffe - Github</a></li><li><a href="http://www.cs.unc.edu/~wliu/papers/ssd_eccv2016_slide.pdf" target="_blank" rel="noopener">ssd_eccv2016_slide - cs.unc.edu</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Object Detection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YOLO! v1, v2, v3</title>
      <link href="/2019/09/01/YOLO-v1-v2-v3/"/>
      <url>/2019/09/01/YOLO-v1-v2-v3/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>YOLO是You Only Look Once的简称，是one-stage检测算法，在2016年刚提出时风靡一时，现在看可能存在一些缺点，后续有许多one-stage检测算法都参考YOLO的思路，如SSD。目前位置，YOLO共发布了3代，论文链接在<a href="#reference">Reference</a>中。</p><h1 id="YOLOv1"><a href="#YOLOv1" class="headerlink" title="YOLOv1"></a>YOLOv1</h1><p>YOLO的一个关键点是，将目标检测作为回归任务，将分离的边界框回归和分类联合起来，可进行端到端的优化。</p><blockquote><p>We reframe object detection as a single regression problem, straight from image pixels to bounding box coordinates and class probabilities. Using our system, you only look once (YOLO) at an image to predict what objects are present and where they are.</p></blockquote><p>YOLO算法具有以下几个特性</p><ol><li><strong>Extremely fast.</strong> 将检测作为回归问题后，不需要候选框生成、分类、回归框矫正等几个步骤，可达到45FPS的速度，Fast YOLO甚至能达到155FPS；</li><li><strong>Reasons globally.</strong> YOLO接受整个图像的输入，而不是将感兴趣区域单独提取，这相比于R-CNN算法，对上下文信息的使用更加全面；</li><li><strong>Highly generalizable.</strong> 当在艺术图上进行识别时，也具有较好的识别效果。</li></ol><h2 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h2><p>YOLO的思路是，将一张指定尺寸输入的图片分割为$S \times S$个网格，每个网格负责落在它内部的物体的检测，并且每个网格将负责$B$个回归框的检测，每个回归框的参数包括$(x, y, w, h, c)$，$x, y$表示回归框的中心点坐标，$w, h$表示回归框的边长，$c$表示回归框的置信度表示cell内是否包含真实框中心点。此外，每个网格也负责$C$类的物体分类任务，输出$C$维的分类向量。因此输入图片经过深度卷积网络后，得到的特征图尺寸应为$S \times S \times [B \times (4 + 1) + C]$，如在论文中提到，在PSCAL VOC数据集上，指定$S=7, B=2, C=20$，则特征图尺寸为$7 \times 7 \times 30$。</p><blockquote><p>这里有个疑问，是训练样本confidence真实值如何确定，难道是计算cell与真实框的IoU？这样计算得到的值很小。</p></blockquote><p>下图为论文前3个版本中的示意图。</p><p><img src="/2019/09/01/YOLO-v1-v2-v3/prepareDataV1.png" alt="prepareDataV1"></p><p>上述说明比较抽象，用代码说明生成的target是个什么玩意。假如我们有图像如下</p><p><img src="/2019/09/01/YOLO-v1-v2-v3/dog.jpg" alt="dog"></p><p>首先将其裁剪为正方形，并缩放至$448 \times 448$，得到</p><p><img src="/2019/09/01/YOLO-v1-v2-v3/resized.jpg" alt="resized"></p><p>将图像分成$7 \times 7$个网格，并假设其标注位置为：狗$( 95, 295, 140, 250)$、自行车$(205, 212, 340, 214)$、汽车$(365,  92, 150,  64)$，在图上为</p><p><img src="/2019/09/01/YOLO-v1-v2-v3/annotated.jpg" alt="annotated"></p><p>假设在$7 \times 7$特征图上，某cell的位置为$(i, j)$，其中$0 \leq i, j &lt; 7$，应有$i = \lfloor\frac{x}{cellsize}\rfloor, j = \lfloor\frac{y}{cellsize}\rfloor$。若映射回原图后，该cell内包含某真实标记框$(x, y, h, w)$的中心，则置$c=1$，且对应类别的特征图上置$(i, j, class)$处类别信息为1。关于ground truth标记框相对于cell的各个偏移量计算与可视化输出如下</p><script type="math/tex; mode=display">\begin{cases}    t_x = \frac{x - x'}{cellsize}, x' = (i + \frac{1}{2}) \times cellsize\\    t_y = \frac{y - y'}{cellsize}, y' = (j + \frac{1}{2}) \times cellsize\\    t_h = \frac{h}{cellsize} \\    t_w = \frac{w}{cellsize}\end{cases}</script><p>其中$x, y, cellsize$等都除以图像尺寸进行归一化。</p><p><img src="/2019/09/01/YOLO-v1-v2-v3/groudtruth.jpg" alt="groudtruth"></p><p>类别特征图$(S \times S \times C)$比较好理解，在上图中用颜色表示，展开为张量即可。</p><h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><p><img src="/2019/09/01/YOLO-v1-v2-v3/YOLOv1-architecture.PNG" alt="YOLOv1-architecture"></p><p>网络共包含24个卷积层与2个全连接层。卷积的基本结构是先通过$1 \times 1$卷积层减少前层输出特征图的通道数，再紧接用$3 \times 3$卷积层进行运算。其使用darknet训练的配置文件如<a href="https://github.com/pjreddie/darknet/blob/master/cfg/yolov1.cfg" target="_blank" rel="noopener">yolov1.cfg</a>，PyTorch实现可查看<a href="https://github.com/isLouisHsu/isLouisHsu.github.io/blob/master/2019/09/01/YOLO-v1-v2-v3/yolo.py" target="_blank" rel="noopener">yolo.py</a>，文中插代码很不地道。</p><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>损失函数由三部分组成，使用sum-square error作为误差函数，因为易于优化</p><script type="math/tex; mode=display">L = \sum_i (y_i - \hat{y_i})^2</script><p>定义</p><script type="math/tex; mode=display">1^{\rm{condition}}_{\rm{index}} =     \begin{cases}        1 & \text{if meets condition} \\        0 & \text{otherwise}    \end{cases}</script><ol><li><p>坐标</p><p> 考虑到，小物体定位惩罚应该比大物体的惩罚更大。所以在边长回归时，考虑回归边长的开方值，以平衡大小物体的惩罚。</p><script type="math/tex; mode=display"> \begin{aligned}     L_{\rm{coord}} = \sum_{i=0}^{S^2} \sum_{j=0}^B 1^{\rm{obj}}_{\rm{ij}} \left[ (x_i - \hat{x}_i)^2 + (y_i - \hat{y}_i)^2 \right. \\     \left. + (\sqrt{w_i} - \sqrt{\hat{w}_i})^2 + (\sqrt{h_i} - \sqrt{\hat{h}_i})^2 \right] \end{aligned}</script></li><li><p>置信度</p><p> 图像中具有物体的网格是非常稀疏的，导致正负样本数目不均衡，这些作为负样本的cell会将置信度分数推向$0$，影响网络模型的稳定性,通过系数$\lambda_{\rm{noobj}}$进行平衡</p><script type="math/tex; mode=display"> \begin{aligned}     L_{\rm{confid}} = \sum_{i=0}^{S^2} \sum_{j=0}^B 1^{\rm{obj}}_{\rm{ij}} (C_i - \hat{C}_i)^2 \\     + \lambda_{\rm{noobj}} \sum_{i=0}^{S^2} \sum_{j=0}^B 1^{\rm{noobj}}_{\rm{ij}} (C_i - \hat{C}_i)^2 \end{aligned}</script></li><li><p>类别</p><p> 注意到，分类任务仅对包含物体的cell进行惩罚。</p><script type="math/tex; mode=display">L_{\rm{classify}} = \sum_{i=0}^{S^2} 1^{\rm{obj}}_{\rm{i}} \sum_{c \in classes} (p_i(c) - \hat{p}_i(c))^2</script></li></ol><p>如果将定位误差和分类误差相等地加权，可能不理想。所以，通过设置系数$\lambda_{\rm{coord}}$进行平衡，增大边界框回归的惩罚，降低分类的惩罚。</p><script type="math/tex; mode=display">\begin{aligned}    \lambda_{\rm{coord}} \underbrace{\sum_{i=0}^{S^2} \sum_{j=0}^B 1^{\rm{obj}}_{\rm{ij}} \left[ (x_i - \hat{x}_i)^2 + (y_i - \hat{y}_i)^2 + (\sqrt{w_i} - \sqrt{\hat{w}_i})^2 + (\sqrt{h_i} - \sqrt{\hat{h}_i})^2 \right]}_{L_{\rm{coord}}} \\    + \underbrace{\sum_{i=0}^{S^2} \sum_{j=0}^B 1^{\rm{obj}}_{\rm{ij}} (C_i - \hat{C}_i)^2     + \lambda_{\rm{noobj}} \sum_{i=0}^{S^2} \sum_{j=0}^B 1^{\rm{noobj}}_{\rm{ij}} (C_i - \hat{C}_i)^2}_{L_{\rm{confid}}} \\    + \underbrace{\sum_{i=0}^{S^2} 1^{\rm{obj}}_{\rm{i}} \sum_{c \in classes} (p_i(c) - \hat{p}_i(c))^2}_{L_{\rm{classify}}}\end{aligned}</script><p>论文中设置$\lambda_{\rm{coord}}=5, \lambda_{\rm{noobj}}=0.5$。</p><h2 id="训练步骤"><a href="#训练步骤" class="headerlink" title="训练步骤"></a>训练步骤</h2><p>首先，将网络的前20层卷积分离，添加全局均值池化与全连接层，在ImageNet数据集上进行预训练，输入图像的尺寸为$224 \times 224$。大约训练了一周，并取得了top-5达到$88\%$的准确率。</p><p>之后，将模型用于检测的训练。Ren等人提出，全连接层可提高网络的performance，所以在预训练的20层卷积后，添加4层卷积层与2层全连接层，权值随机初始化。图像的分辨率升高到$448 \times 448$。</p><p>在测试时，每个cell将负责多个框的生成；在训练时，每个cell对每个回归框负责，也就是说，如果某个cell内出现两个重复的真实标记框，将对这两个框分别计算损失并累加。</p><p>训练超参数设置。在PASCAL VOC 2007和2012的训练集与验证集上进行训练，注意在测试2012数据集时，也包含2017测试数据。批次大小设置为$64$，动量(momentum)设置为$0.9$，权值衰减设置为$0.0005$。</p><blockquote><p>祖传参数。</p></blockquote><p>学习率调节。如果一开始设置较大的学习率，不稳定的梯度会导致网络发散。因此从第一个epoch开始，缓慢将学习率从$10^{-3}$升高到$10^{-2}$，之后在$10^{-2}$保持$75$代，然后在$10^{-3}$保持$30$代，最后在$10^{-4}$保持$30$代。</p><h2 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h2><p>测试阶段，置信度的计算包含两个部分的乘积，即框内是否含物体$\rm{Pr}(\rm{object})$与候选框与真实框之间的交并比$\rm{IoU}(truth, pred)$，计算方法如下</p><script type="math/tex; mode=display">\rm{Confidence} = \rm{Pr}(Class_i | Object) * \rm{Pr}(Object) * \rm{IoU}^{truth}_{pred} = \rm{Pr}(Class_i) * \rm{IoU}^{truth}_{pred}</script><p>根据置信度，先删除一些评分较低的候选框，之后用NMS算法删除冗余框。其最终输出可由下图说明</p><p><img src="/2019/09/01/YOLO-v1-v2-v3/test_step.png" alt="test_step"></p><h2 id="结果对比"><a href="#结果对比" class="headerlink" title="结果对比"></a>结果对比</h2><p><img src="/2019/09/01/YOLO-v1-v2-v3/VOC2012_Leaderboard.png" alt="VOC2012_Leaderboard"></p><h2 id="缺点和限制"><a href="#缺点和限制" class="headerlink" title="缺点和限制"></a>缺点和限制</h2><ol><li>每个单元网格只能预测两个框，且两个框同属于一类，这限制了模型对相邻物体的检测；</li><li>另外，对于聚集的小物体，如鸟群等，很难检测到；</li><li>由于网络经过已有标注训练，对于新的纵横比很难适应；</li><li>网络多次进行下采样，特征较为粗略；</li><li>小物体检测比大物体检测错误率高，这是由于错误定位造成的。</li></ol><h1 id="YOLOv2"><a href="#YOLOv2" class="headerlink" title="YOLOv2"></a>YOLOv2</h1><p>YOLOv2即YOLO9000，在上一代YOLO的基础上进行改进。首先，它可以接受任意尺寸图像的输入而不是固定的$448 \times 448$，速度更快。此外，一个比较重要的点是，在训练YOLO9000时，联合使用分类数据，用带标记的图像进行学习精确定位，而分类图像添加到样本集中，用作分类部分的训练。</p><h2 id="Better"><a href="#Better" class="headerlink" title="Better"></a>Better</h2><p>YOLOv2进行了众多实验，添加别的组件，验证新模型在识别率上的表现，如下表</p><p><img src="/2019/09/01/YOLO-v1-v2-v3/YOLOv2-Table2.png" alt="YOLOv2-Table2"></p><ol><li><p>Batch Normalization</p><p> 添加批归一化层后，mAP升高$2\%$以上。并且可减少其他形式的正则化惩罚，如移除了dropout层。</p></li><li><p>High Resolution Classifier</p><p> 在YOLOv1训练时，使用$224 \times 224$尺寸的图片进行模型预训练，之后用$448 \times 448$尺寸的图片进行检测网络的训练，也就是说，网络需要在学习检测任务的同时，适应新的输入分辨率。所以在YOLOv2训练时，先将预训练网络在$448 \times 448$尺寸的数据机上进行微调，共迭代10代。之后训练检测网络，这提升了$4\%$的mAP。</p></li><li><p>Convolutional With Anchor Boxes</p><p> YOLOv2移除了全连接层，并添加了锚框。首先，移除一层最大池化层，使得特征图的分辨率升高，这样输出的特征图尺寸为$13 \times 13$。考虑到特征图的几何意义，最终层输出的特征图每个位置代表一个网格，也就是说，每个网格中心都应对应一个位置，但是$448/13$不为整数，故将图像分辨率调整至$416 \times 416$，网络下采样倍率为$\frac{416}{13}=32$。</p><p> 在不添加锚框时，一个cell仅能输出$7 \times 7 \times 2 = 98$个候选框。而每个cell设置锚框后，对每个锚框均进行预测，而不是仅考虑cell的空间位置，可生成更多的候选框。</p><p> 没有锚框的情况下，模型指标为$69.5$mAP与$81\%$的召回率，增加后，mAP降低为$69.2$，召回率上升到$88\%$，这说明模型还有较大空间可以调整。</p><p> 对于锚框，文中没有提及，以下进行一些说明，现在每个cell的尺寸为$32\times32$，假定对单个cell设置$3$种纵横比的anchor，如$32 \times 32, 24 \times 48, 48 \times 24$，那么对于下图中包含物体的cell，锚框可视化为</p><p> <img src="/2019/09/01/YOLO-v1-v2-v3/anchor.jpg" alt="anchor"></p><p> 对于上述三个锚框，从上至下分别为$32 \times 32, 24 \times 48, 48 \times 24$的锚框对应的特征图显示如下</p><p> <img src="/2019/09/01/YOLO-v1-v2-v3/groudtruth_32x32.jpg" alt="groudtruth_32x32"></p><p> <img src="/2019/09/01/YOLO-v1-v2-v3/groudtruth_24x48.jpg" alt="groudtruth_24x48"></p><p> <img src="/2019/09/01/YOLO-v1-v2-v3/groudtruth_48x24.jpg" alt="groudtruth_48x24"></p><blockquote><p>此外，每个纵横比下可分别设置$3$种尺度。</p></blockquote></li><li><p>Dimension Clusters</p><p> 至此遇到两个问题。第一，锚框的纵横比、尺度等是人为指定的，网络可以适应指定的锚框，但不是最优的，希望能够从数据中得到锚框的参数。所以对标注框的长宽尺寸进行K-Means聚类，注意到，如果使用欧式距离作为聚类指标，框越大它造成的误差也越大，希望的是IOU评分上升，所以定义指标为</p><script type="math/tex; mode=display">d(\rm{box}, \rm{centroid}) = 1 - \rm{IoU}(\rm{box}, \rm{centroid})</script><p> 最终确定为$k=5$，在VOC和MSCOCO数据机上可能有所差异，详情查看下图<br> <img src="/2019/09/01/YOLO-v1-v2-v3/YOLOv2-Figure2.png" alt="YOLOv2-Figure2"></p></li><li><p>Direct location prediction</p><p> 对于偏移量，如果沿用一般的计算方法，则有</p><script type="math/tex; mode=display"> \begin{cases}     t_x = \frac{x - x_a}{w_a}, x_a = (\lfloor\frac{x}{cellsize}\rfloor + \frac{1}{2}) \times w_a \\     t_y = \frac{y - y_a}{h_a}, y_a = (\lfloor\frac{y}{cellsize}\rfloor + \frac{1}{2}) \times h_a \\     t_w = \frac{w}{w_a} \\     t_h = \frac{h}{h_a}  \end{cases}</script><p> 也即</p><script type="math/tex; mode=display"> \begin{cases}     x = t_x \times w_a + x_a \\     y = t_y \times h_a + y_a \\     w = t_w \times w_a \\     h = t_h \times h_a  \end{cases}</script><p> 当$t_x=1$时表示相对于锚框向右平移$w_a$的距离，$t_x=-1$时表示相对于锚框向左平移$w_a$的距离，上式中对$t_x$是没有限制作用的。现添加sigmoid函数处理，将值映射到$[0, 1]$范围内，并且直接预测坐标，而不是偏移量的方法，此外，利用指数函数$e^x$进行映射，平衡回归框尺寸对损失值的影响。如下</p><script type="math/tex; mode=display"> \begin{cases}     b_x = \sigma(t_x) + c_x \\      b_y = \sigma(t_y) + c_y \\      b_w = p_w e^{t_w} \\     b_h = p_h e^{t_h} \end{cases}</script><p> 其中$(c_x, c_y)$为特征图上相对于左上角的坐标，$\sigma(t_x), \sigma(t_y), t_w, t_h$是网络的输出，$p_*$为锚框的尺寸信息(除以图像边长归一化)。这种计算方法下，各锚框的ground truth应为</p><script type="math/tex; mode=display"> \begin{cases}     \sigma(t_x) = \frac{x}{cellsize} - \lfloor\frac{x}{cellsize}\rfloor \\     \sigma(t_y) = \frac{y}{cellsize} - \lfloor\frac{y}{cellsize}\rfloor \\     t_w = \log \frac{b_w}{p_w} \\     t_h = \log \frac{b_h}{p_h}  \end{cases}</script><p> <img src="/2019/09/01/YOLO-v1-v2-v3/groudtruth_32x32_new.jpg" alt="groudtruth_32x32_new"></p><p> <img src="/2019/09/01/YOLO-v1-v2-v3/groudtruth_24x48_new.jpg" alt="groudtruth_24x48_new"></p><p> <img src="/2019/09/01/YOLO-v1-v2-v3/groudtruth_48x24_new.jpg" alt="groudtruth_48x24_new"></p></li><li><p>Fine-Grained Features</p><p> 为获得更细粒度的特征，用于小物体的检测，如Faster-RCNN与SSD是在各层特征图上进行候选框的生成。YOLOv2添加了passthrough层，将浅层特征与深层特征堆叠起来。这提升了$1\%$的表现。</p></li><li><p>Multi-Scale Training</p><p> 由于YOLOv2中仅包含卷积层与池化层，所以可接受任意尺寸的输入，为使得网络对各尺寸均有良好的鲁棒性，在尺寸为${320, 352, \cdots, 608}$时都进行训练。这样做可以使图像尺寸减小以加快计算速度，减少显存消耗，并且不降低准确率，在$288 \times 288$的尺寸时，可达到$90$FPS。</p></li></ol><h2 id="Faster"><a href="#Faster" class="headerlink" title="Faster"></a>Faster</h2><ol><li><p>Darknet-19</p><p> 大多数检测器用VGG-16作为特征提取网络结构，但是它参数量众多，且运算量很大，即使输入为$224 \times 224$也需要千万级别的FLOPS。新设计的Darknet-19架构，仅需要$5.58$百万级别的FLOPS，达到了72.9% top-1和91.2% top-5的准确率。</p></li><li><p>Training for classification</p><p> 首先，在ImageNet上进行1000类的图像分类模型训练，共迭代160代，初始学习率为$0.1$，多项式学习率衰减，权值衰减设置为$4e-5$，动量$0.9$。之后，将图像分辨率提高到$448 \times 448$，学习率0.001，进行10个周期的迭代，来微调网络，使其适应该分辨率。</p></li><li><p>Training for detection</p><p> 将预训练模型的最后一层卷积层删除，添加$3 \times 3 \times 1024$卷积层与$1 \times 1 \times [(C + 4 + 1) \times B]$卷积层。注意到，与YOLOv1不同的是，每个框都会输出类别信息。在VOC数据集上，$C = 20, B = 5$。在$3 \times 3 \times 512$层的输出到最终的输出间设置passthrough，以更好地使用浅层特征。</p><p> 共进行$160$个周期的迭代，初始学习率$0.001$，在第$60, 90$代时衰减$10\%$。权重衰减$5e-4$，动量$0.9$。</p></li></ol><h2 id="Stronger"><a href="#Stronger" class="headerlink" title="Stronger"></a>Stronger</h2><p>在YOLO9000训练过程中，用到了一种联合分类数据的训练机制。将监测数据与分类数据混合，若训练过程中遇到检测数据，则计算全部的损失，而若遇到分类数据，仅计算分类的损失。但是这样做有一些挑战，检测数据集中对物体的标号仅仅包含dog、boat等，而分类数据标签划分更细，如dog可分为Norfolk terrier、Yorkshire terrier等。分类模型使用softmax作为损失函数，只能进行单标签的分类。一种解决方法是，采用多标签的模型来组合不假设互斥的数据集，这种方法忽略了我们对数据所知的所有结构，例如，MSCOCO的类别都是互斥的。</p><ol><li><p>Hierarchical classification</p><p> ImageNet的标签来源于<a href="https://wordnet.princeton.edu/" target="_blank" rel="noopener">WordNet</a>，这是一个语言的数据集合，整理了语义关系。比如说，Norfolk terrier和Yorkshire terrier都是猎犬，都是犬等等。由于语言的复杂性，WordNet的结构是有向图，在训练YOLOv2时，并不需要完整的图结构，因此可通过这种非扁平的数据结构构建分层树形图来简化问题。</p><p> 对于ImageNet中的视觉名词，许多同义词只有一条路径，所以首先将这些路径添加到树中，然后继续迭代剩下的名词。如果某个概念通往根节点有两条路径，那么其中一条会往树中添加3条边，另一条路径添加1条边，选择尽量短的边添加方案。最终形成层级的结构WordTree，这个树可用于计算条件概率，如</p><script type="math/tex; mode=display"> \begin{aligned}     Pr(\rm{Norfolk terrier} | \rm{terrier}) \\     Pr(\rm{Yorkshire terrier} | \rm{terrier}) \\     Pr(\rm{Bedlington terrier} | \rm{terrier}) \\     \cdots \end{aligned}</script><p> 对于某个类别的概率，其通过各条件概率累乘的方法，如</p><script type="math/tex; mode=display"> \begin{aligned}     Pr(\rm{Norfolk terrier}) = \\     Pr(\rm{Norfolk terrier} | \rm{terrier}) \\     * Pr(\rm{terrier} | \rm{hunting dog}) \\     * \cdots \\     * Pr(\rm{mammal} | \rm{animal}) \\     * Pr(\rm{animal} | \rm{physical object}) \\     * Pr(\rm{physical object}) \end{aligned}</script><p> 注意$Pr(\rm{physical object})=1$。</p></li><li><p>Dataset combination with WordTree</p><p> 借助于WordTree的多层级结构，构建多标签分类模型，如下图，进行多次softmax运算</p><p> <img src="/2019/09/01/YOLO-v1-v2-v3/YOLOv2-Figure5.png" alt="YOLOv2-Figure5"></p></li><li><p>Joint classification and detection</p><p> 在MSCOCO与ImageNet数据集上，产生了9000多个类别。此外我们需要对模型进行验证。</p><blockquote><p>We also need to evaluate our method so we add in any classes from the ImageNet detection challenge that were not already included. The corresponding WordTree for this dataset has 9418 classes.</p></blockquote><p> ImageNet是一个更大的数据集，所以通过对MSCOCO进行过采样来平衡数据，使ImageNet以4：1的比例增大。使用此数据集进行训练时，仅选用3个锚框以减少内存消耗，当网络遇到带检测标签的数据，进行全部的损失计算，而对于分类数据，仅对分类损失进行反传。值得注意的是，如果标签为dog，仅对该层次进行反传，因为再向下没有细化信息，如这是德国牧羊犬还是金毛犬。</p></li></ol><h1 id="YOLOv3"><a href="#YOLOv3" class="headerlink" title="YOLOv3"></a>YOLOv3</h1><p>YOLOv3相比较于YOLO9000没有过大的改变：</p><ul><li>边界框回归值同YOLO9000；</li><li>仍进行多标签的分类；</li><li>关于锚框，共3种尺度$(S=3)$，类似特征金字塔的概念，则最终层输出为$N \times N \times [(4 + 1 + C) \times B \times S]$；</li><li>将多个浅层的特征层上采样后进行组合，用于候选框的生成；</li><li>仍使用K-Means确定锚框的纵横比，最终确定9种纵横比$10 \times 13, 16 \times 30, 33 \times 23, 30 \times 61, 62 \times 45, 59 \times 119, 116 \times 90, 156 \times 198, 373 \times 326$，每个纵横比下3种尺度，共27个锚框。</li></ul><p>网络仍使用$3 \times 3$与$1 \times 1$卷积层的堆叠，加入shortcut使深度大大增加，最终形成Darknet-53。</p><p><img src="/2019/09/01/YOLO-v1-v2-v3/YOLOv3-Darknet-53.png" alt="YOLOv3-Darknet-53"></p><p>YOLOv3运算速度相当快，准确率也可以</p><p><img src="/2019/09/01/YOLO-v1-v2-v3/YOLOv3-Figure3.png" alt="YOLOv3-Figure3"></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://pjreddie.com/darknet/yolo/" target="_blank" rel="noopener">YOLO: Real Time Object Detection</a></li><li><a href="https://arxiv.org/abs/1506.02640" target="_blank" rel="noopener">You Only Look Once: Unified, Real-Time Object Detection</a></li><li><a href="https://arxiv.org/abs/1612.08242" target="_blank" rel="noopener">YOLO9000: Better, Faster, Stronger</a></li><li><a href="https://arxiv.org/abs/1804.02767" target="_blank" rel="noopener">YOLOv3: An Incremental Improvement</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Object Detection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[解读] Recent Advances in Deep Learning for Object Detection</title>
      <link href="/2019/08/31/%E8%A7%A3%E8%AF%BB-Recent-Advances-in-Deep-Learning-for-Object-Detection/"/>
      <url>/2019/08/31/%E8%A7%A3%E8%AF%BB-Recent-Advances-in-Deep-Learning-for-Object-Detection/</url>
      
        <content type="html"><![CDATA[<p>论文可从<a href="https://arxiv.org/abs/1908.03673?context=cs.CV" target="_blank" rel="noopener">Recent Advances in Deep Learning for Object Detection - arXiv.org</a>下载。</p><h1 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h1><p><img src="/2019/08/31/%E8%A7%A3%E8%AF%BB-Recent-Advances-in-Deep-Learning-for-Object-Detection/解读-Recent-Advances-in-Deep-Learning-for-Object-Detection/contents.jpg" alt="contents"></p><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><blockquote><p>Object detection is a fundamental visual recognition problem in computer vision and has been widely studied in the past decades. <strong>Visual object detection aims to find objects of certain target classes with precise localization in a given image and assign each object instance a corresponding class label.</strong> Due to the tremendous successes of deep learning based image classification, object detection techniques using deep learning have been actively studied in recent years. In this paper, we give a comprehensive survey of recent advances in visual object detection with deep learning. By reviewing a large body of recent related work in literature, we systematically analyze the existing object detection frameworks and organize the survey into three major parts: <strong>(i) detection components, (ii) learning strategies, and (iii) applications &amp; benchmarks.</strong> In the survey, we cover a variety of factors affecting the detection performance in detail, <strong>such as detector architectures, feature learning, proposal generation, sampling strategies, etc.</strong> Finally, we discuss <strong>several future directions to facilitate and spur future research</strong> for visual object detection with deep learning.<br><strong>Keywords:</strong> Object Detection, Deep Learning, Deep Convolutional Neural Networks</p></blockquote><p>目标检测：在给定图像中找到目标类对象的精确位置，并分配相应的类别标签。</p><p>本文介绍的主要分为以下几个部分</p><ul><li>组件组成部分；</li><li>学习策略；</li><li>应用及数据集、测试。</li></ul><p>影响检测的几个细节：</p><ul><li>检测器结构；</li><li>特征学习；</li><li>预选框生成；</li><li>采样策略等。</li></ul><h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><h2 id="1-1-基本的视觉识别问题"><a href="#1-1-基本的视觉识别问题" class="headerlink" title="1.1 基本的视觉识别问题"></a>1.1 基本的视觉识别问题</h2><p><img src="/2019/08/31/%E8%A7%A3%E8%AF%BB-Recent-Advances-in-Deep-Learning-for-Object-Detection/解读-Recent-Advances-in-Deep-Learning-for-Object-Detection/Fig1.jpg" alt="Fig1"></p><ul><li>图像分类(image classification)：识别给定图像中对象的语义类别；</li><li>物体检测(object detection)：    识别给定图像中对象的语义类别，并用边界框表出物体位置；</li><li>语义分割(semantic segementation)：为每个像素分配特定的类别标签；</li><li>实例分割(instance segementation)：目标检测和语义分割交集，在语义分割基础上，在同类别物体中分辨出不同实例。</li></ul><h2 id="1-2-如何设计好的检测算法"><a href="#1-2-如何设计好的检测算法" class="headerlink" title="1.2 如何设计好的检测算法"></a>1.2 如何设计好的检测算法</h2><p>好的检测算法需要对语义及空间信息有很好的理解。</p><blockquote><p>A good detection algorithm should have a strong understanding of semantic cues as well as the spatial information about the image.</p></blockquote><h2 id="1-3-早期物体检测算法"><a href="#1-3-早期物体检测算法" class="headerlink" title="1.3 早期物体检测算法"></a>1.3 早期物体检测算法</h2><p>可分成三个步骤</p><ul><li>候选框生成(proposal generation)<br>一种直观方法：滑动窗口(sliding window)，将检测图像以不同比例缩放，并使用不同尺寸的滑动窗口选择感兴趣区域(regions of interest)。</li><li>特征提取(feature vector extraction)<br>从ROI区域提取固定长度的向量作为特征，如尺度不变特征变换(SIFT)，Haar，梯度直方图(HOG)，或加速鲁棒特征(SURF)。</li><li>区域分类(region classification)<br>例如支持向量机(SVM)，配合bagging，adaboost，级联学习(cascade learning)等方法。</li></ul><p>传统方法存在的局限性</p><ul><li>在候选框生成时，大量冗余的候选框造成误正(false positive)率高。窗口尺度是人为或启发式指定的，不能很好地匹配物体；</li><li>特征提取时，基于低级视觉特征，难以捕获上下文语义信息；</li><li>以上三个步骤单独设计优化，无法获得全局最优解。</li></ul><h2 id="1-4-深度学习方法"><a href="#1-4-深度学习方法" class="headerlink" title="1.4 深度学习方法"></a>1.4 深度学习方法</h2><p>模拟生物学分层结构，利用反向传播算法更新参数，但存在局限性：</p><ul><li>训练样本过少，造成过拟合；</li><li>计算资源的限制；</li><li>相比较于SVM等传统方法，缺少理论支持。</li></ul><p>其优点是</p><ul><li>深度卷积神经网络生成从原始像素到高级语义信息的分层特征表示，其从训练数据中自动学习，并且在复杂上下文中显示出更具辨别力的表达能力；</li><li>于传统视觉描述符相比，自动学习特征表示，而不是固定的；</li><li>可以以端到端的方式进行优化。</li></ul><h2 id="1-5-基于深度学习的对象检测框架"><a href="#1-5-基于深度学习的对象检测框架" class="headerlink" title="1.5 基于深度学习的对象检测框架"></a>1.5 基于深度学习的对象检测框架</h2><p><img src="/2019/08/31/%E8%A7%A3%E8%AF%BB-Recent-Advances-in-Deep-Learning-for-Object-Detection/解读-Recent-Advances-in-Deep-Learning-for-Object-Detection/Fig2.jpg" alt="Fig2"></p><p>两种系列</p><ul><li>两阶段检测器(two-stage detector)：通过候选框生成器，生成数目较少的候选框，并对每个候选框内内容进行特征提取；应用特征对候选区域进行分类。如 R-CNN(CNN + SVM/FNN)；</li><li>一阶段检测器(one-stage detector)：无虚级联区域分类步骤，对特征图的每个位置上的对象进行分类预测。如 YOLO 及其变体。<br>通常来说，一阶段检测器速度更快，可用于试试物体检测；二阶段检测器精度更高，在公共数据集等测试中效果更好。</li></ul><h1 id="2-Problem-Settings"><a href="#2-Problem-Settings" class="headerlink" title="2. Problem Settings"></a>2. Problem Settings</h1><p>目标检测涉及识别(如物体分类)和定位(如坐标回归)任务。给定数据集包含$N$张带标记的图片</p><script type="math/tex; mode=display">D = \{X^{(1)}, X^{(2)}, \cdots, X^{(N)}\}</script><p>对于第$i$张图片，若其内部包含$M_i$个物体，这些物体属于$C$类，第$j$个物体的标签包含所属类别$c^{(i)}_j$，所在位置$b^{(i)}_j$，则</p><script type="math/tex; mode=display">y^{(i)}_j = (c^{(i)}_j, b^{(i)}_j)</script><p>则该图片对应标签集为</p><script type="math/tex; mode=display">y^{(i)} = \{(c^{(i)}_1, b^{(i)}_1), (c^{(i)}_2, b^{(i)}_2), \cdots, (c^{(i)}_{M_i}, b^{(i)}_{M_i})\}</script><p>对于预测输出，为</p><script type="math/tex; mode=display">\hat{y}^{(i)} = \{(\hat{c}^{(i)}_1, \hat{b}^{(i)}_1), (\hat{c}^{(i)}_2, \hat{b}^{(i)}_2), \cdots, (\hat{c}^{(i)}_{M_i}, \hat{b}^{(i)}_{M_i})\}</script><p>总体损失定义为</p><script type="math/tex; mode=display">L(X, \theta) = \frac{1}{N} \sum_{i=1}^N L(X^{(i)}, y^{(i)}, \hat{y}^{(i)}; \theta) + \frac{\lambda}{2} ||\theta||_2^2</script><p>定义指标交并比IoU(intersection-over-union)</p><script type="math/tex; mode=display">\text{IoU} (b^{(i)}_j, \hat{b}^{(i)}_j) = \frac{\text{Area} (b^{(i)}_j \bigcap \hat{b}^{(i)}_j)}{\text{Area} (b^{(i)}_j \bigcup \hat{b}^{(i)}_j)}</script><p>则预测正确与否的判决为</p><script type="math/tex; mode=display">\text{Prediction} =     \begin{cases}         \text{Positive} & c^{(i)}_j = \hat{c}^{(i)}_j \quad \text{and} \quad \text{IoU} (b^{(i)}_j, \hat{b}^{(i)}_j) > \Omega \\         \text{Negative} & \text{otherwise}     \end{cases}</script><p>另外，在$C$类物体的检测问题中，需要计算mAP(mean average precision)进行评估。通常来说，达到20FPS的检测器可用于实时检测场景。</p><h1 id="3-Detection-Components"><a href="#3-Detection-Components" class="headerlink" title="3. Detection Components"></a>3. Detection Components</h1><h2 id="3-1-Detection-Settings-bbox-level-and-mask-level-algorithms"><a href="#3-1-Detection-Settings-bbox-level-and-mask-level-algorithms" class="headerlink" title="3.1. Detection Settings: bbox-level and mask-level algorithms"></a>3.1. Detection Settings: bbox-level and mask-level algorithms</h2><ul><li>bbox-level<br>只需要边界框注释，在评估时，计算预测与实际边界框的交并比IoU进行性能衡量。</li><li>mask-level<br>即实例分割，需要通过像素级掩码而不是粗略的边界框来分割对象，对空间信息的处理要求更改。</li></ul><h2 id="3-2-Detection-Paradigms-two-stage-detectors-and-one-stage-detectors"><a href="#3-2-Detection-Paradigms-two-stage-detectors-and-one-stage-detectors" class="headerlink" title="3.2. Detection Paradigms: two-stage detectors and one-stage detectors"></a>3.2. Detection Paradigms: two-stage detectors and one-stage detectors</h2><ul><li>两阶段检测器(two-stage detector)：通过候选框生成器，生成数目较少的候选框，并对每个候选框内内容进行特征提取；应用特征对候选区域进行分类。如 R-CNN(CNN + SVM/FNN)；</li><li>一阶段检测器(one-stage detector)：无虚级联区域分类步骤，对特征图的每个位置上的对象进行分类预测。如 YOLO 及其变体。<br>通常来说，一阶段检测器速度更快，可用于试试物体检测；二阶段检测器精度更高，在公共数据集等测试中效果更好。</li></ul><h3 id="3-2-1-Two-stage-Detectors"><a href="#3-2-1-Two-stage-Detectors" class="headerlink" title="3.2.1. Two-stage Detectors"></a>3.2.1. Two-stage Detectors</h3><p>将检测任务分成两部分：</p><ul><li>候选框生成<br>基本上思想是选出高召回率(Recall)的图像区域。</li><li>对候选框内图像进行判别<br>基于深度学习的模型，可将框内图像进行分类，此外，该模型输出也用以矫正第一阶段输出的候选框，使其更契合物体位置。</li></ul><h4 id="3-2-1-1-R-CNN"><a href="#3-2-1-1-R-CNN" class="headerlink" title="3.2.1.1. R-CNN"></a>3.2.1.1. R-CNN</h4><p><img src="/2019/08/31/%E8%A7%A3%E8%AF%BB-Recent-Advances-in-Deep-Learning-for-Object-Detection/解读-Recent-Advances-in-Deep-Learning-for-Object-Detection/Fig3-R-CNN.png" alt="Fig3-R-CNN"></p><ol><li>组成</li></ol><ul><li>候选框生成：通过选择性搜索(Selective Search)生成，可拒绝一些明显是背景的候选框，减少误正率(false positive)；</li><li>特征提取：通过裁剪、缩放获得固定尺寸图像，输入到深度卷积网络，得到4096维的向量；</li><li>区域分类：分类器选用一对多(one-vs-all)SVM，此外边界框回归器将候选框矫正。</li></ul><ol><li>细节</li></ol><ul><li>与传统方法相比，深度卷积网络生成分层特征，捕获不同尺度信息；</li><li>利用迁移学习方法，使用ImageNet与训练的卷积网络权重，全连接层重新初始化权值；</li></ul><ol><li>缺点</li></ol><ul><li>不共享权值，造成大量冗余计算；</li><li>各部分独立，不能进行端到端的方式优化，难以获得全局最优；</li><li>选择性搜索难以适应复杂背景的图片，并且无法使用GPU加速。</li></ul><h4 id="3-2-1-2-SPP-Net"><a href="#3-2-1-2-SPP-Net" class="headerlink" title="3.2.1.2. SPP-Net"></a>3.2.1.2. SPP-Net</h4><p><img src="/2019/08/31/%E8%A7%A3%E8%AF%BB-Recent-Advances-in-Deep-Learning-for-Object-Detection/解读-Recent-Advances-in-Deep-Learning-for-Object-Detection/Fig3-SPP-net.png" alt="Fig3-SPP-net"></p><ol><li><p>细节<br>在处理候选框内的图片时，并不将其进行裁剪缩放，而是定义空间金字塔池化层(Spatial Pyramid Pooling Layer)。<br>例如对于尺寸为$H \times W$的可见光图像，将其划分为$N \times N$个网格，在每个尺寸为$\frac{H}{N} \times \frac{W}{N}$网格内进行池化操作。选取不同的$N$重复采样，将不同划分数目$N$下得到的输出，合并为长度为$N \times N$向量。<br>SPP-layer可以接受不同尺度和纵横比的图像，故避免了信息丢失和几何失真等情况。</p></li><li><p>缺点</p></li></ol><ul><li>仍旧不能进行端到端的方式优化；</li><li>由于该层不能进行反向传播，此层之前的网络参数需要固定。</li></ul><h4 id="3-2-1-3-Fast-R-CNN"><a href="#3-2-1-3-Fast-R-CNN" class="headerlink" title="3.2.1.3. Fast R-CNN"></a>3.2.1.3. Fast R-CNN</h4><p><img src="/2019/08/31/%E8%A7%A3%E8%AF%BB-Recent-Advances-in-Deep-Learning-for-Object-Detection/解读-Recent-Advances-in-Deep-Learning-for-Object-Detection/Fig3-Fast-R-CNN.png" alt="Fig3-Fast-R-CNN"></p><ol><li><p>细节<br>计算了整个图像的特征图(同SPP-Net)，在特征图上提取固定长度的特征，这一步使用ROI Pooling Layer实现，是Spatial Pyramid Pooling Layer的特殊情况，仅在一种网格划分数目下采样，实际操作步骤如下：在<strong>整个图像</strong>计算得到的特征图中，根据实际边界框位置选取尺寸为$h \times w$的感兴趣区域(ROI)，指定网格的大小如$H \times W$，将ROI划分为$\frac{h}{H} \times \frac{w}{W}$个网格，在每个网格内进行池化操作，得到$\frac{h}{H} \times \frac{w}{W}$的向量。<br>分类与边界框回归为两个单独的全连接层网络，而不是采用SVM，分类器输出维数为$C+1$($C$种类别加背景)，回归器输出维数为$4 \times C$(各类别分别对应矫正参数)。<br>值得注意的是，该结构特征提取、区域分类与边界框回归这几个步骤可通过端到端的方式优化，</p></li><li><p>缺点<br>候选框仍使用传统方法生成，如选择性搜索(Selective Search)或边缘框(Edge Boxes)。</p></li></ol><h4 id="3-2-1-4-Faster-R-CNN"><a href="#3-2-1-4-Faster-R-CNN" class="headerlink" title="3.2.1.4. Faster R-CNN"></a>3.2.1.4. Faster R-CNN</h4><p><img src="/2019/08/31/%E8%A7%A3%E8%AF%BB-Recent-Advances-in-Deep-Learning-for-Object-Detection/解读-Recent-Advances-in-Deep-Learning-for-Object-Detection/Fig3-Faster-R-CNN.png" alt="Fig3-Faster-R-CNN"></p><ol><li><p>细节<br>提出新的候选框生成方法：Region Proposal Network(PRN)，为全卷积神经网络，接受任意大小的图像。在检测时，用大小为$n \times n$的滑动窗口在特征图上滑动，每个位置提取特征，送入分类层(cls)与回归层(reg)，最终结果用于确定候选框。<br>可将RPN插入到Fast R-CNN中从而以端到端的方式进行优化。</p></li><li><p>缺点<br>尽管Faster R-CNN在提取特征图时共享权值，但对于后续每个ROI内的特征图对应的向量，仍需要单独通过全连接计算。</p></li></ol><h4 id="3-2-1-5-R-FCN"><a href="#3-2-1-5-R-FCN" class="headerlink" title="3.2.1.5. R-FCN"></a>3.2.1.5. R-FCN</h4><p><img src="/2019/08/31/%E8%A7%A3%E8%AF%BB-Recent-Advances-in-Deep-Learning-for-Object-Detection/解读-Recent-Advances-in-Deep-Learning-for-Object-Detection/Fig3-R-FCN.png" alt="Fig3-R-FCN"></p><ol><li>细节<br>提出Positive-Sensitive ROP Pooling(PSROI Polling)，生成名为Position-Sensitive Score Map的特征图，保持了空间信息(to extract spatial-aware region features by encoding each relative position of the target regions)。如对于Stage 1生成的特征图，设其尺寸为$h \times w \times c$，用$k^2(C+1)$个$1 \times 1$的卷积核，即$k^2(C+1) \times 1 \times 1 \times c$进行运算，得到$h \times w \times k^2(C+1)$的Position-Sensitive Score Map。</li></ol><p><img src="/2019/08/31/%E8%A7%A3%E8%AF%BB-Recent-Advances-in-Deep-Learning-for-Object-Detection/解读-Recent-Advances-in-Deep-Learning-for-Object-Detection/Fig3-R-FCN-psROI.png" alt="Fig3-R-FCN-psROI"></p><p>当取$k=3$时，表示将每个ROI划分为$3 \times 3$，在特征图平面位置为$(x, y)$处，可切片得到向量$f_{3^2 \times (C+1)}$，对于所属类别$C_j$的部分，又有$f^{(j)}_{3^2}$，表示该ROI内，左上、上、右上、左、中、右、左下、下、右下$9$个位置处，所属类别$C_j$的概率。Pooling 操作同Fast R-CNN与Faster R-CNN。</p><h4 id="3-2-1-6-FPN-MNC-Mask-R-CNN-Mask-Scoring-R-CNN-…"><a href="#3-2-1-6-FPN-MNC-Mask-R-CNN-Mask-Scoring-R-CNN-…" class="headerlink" title="3.2.1.6. FPN, MNC, Mask R-CNN, Mask Scoring R-CNN, …"></a>3.2.1.6. FPN, MNC, Mask R-CNN, Mask Scoring R-CNN, …</h4><p>略。</p><h3 id="3-2-2-One-stage-Detectors"><a href="#3-2-2-One-stage-Detectors" class="headerlink" title="3.2.2. One-stage Detectors"></a>3.2.2. One-stage Detectors</h3><p>该类检测方法没有设置单独的生成候选框的阶段，通常将图像上所有位置视为潜在对象，并尝试将每个感兴趣区域分类。</p><h4 id="3-2-2-1-YOLOv1"><a href="#3-2-2-1-YOLOv1" class="headerlink" title="3.2.2.1. YOLOv1"></a>3.2.2.1. YOLOv1</h4><p><img src="/2019/08/31/%E8%A7%A3%E8%AF%BB-Recent-Advances-in-Deep-Learning-for-Object-Detection/解读-Recent-Advances-in-Deep-Learning-for-Object-Detection/Fig4-YOLO.png" alt="Fig4-YOLO"></p><p>YOLOv1接受$448 \times 448$大小的$3$通道图像输入，得到尺寸为$7 \times 7 \times ((4 + 1) \times n_{boxes} + n_{classes})$，$n_{boxes}$表示该网格预测输出几个回归框(YOLOv1中设置为2)，每个回归框对应$5$维特征，即$(t_x, t_y, t_w, t_h, t_c)$。可达到45FPS，或者精简网络下155FPS。但存在一些缺点</p><ul><li>每个网格处，仅能预测两个物体，对于体型较小的或是聚集的物体，难以识别；</li><li>仅通过最后一个特征图来进行预测，没有考虑多尺度和不同横比。</li></ul><h4 id="3-2-2-2-SSD"><a href="#3-2-2-2-SSD" class="headerlink" title="3.2.2.2. SSD"></a>3.2.2.2. SSD</h4><p><img src="/2019/08/31/%E8%A7%A3%E8%AF%BB-Recent-Advances-in-Deep-Learning-for-Object-Detection/解读-Recent-Advances-in-Deep-Learning-for-Object-Detection/Fig4-SSD.png" alt="Fig4-SSD"></p><p>SSD将各层特征图均用于预测，分成固定数目的网格，每个网格设置一定尺度和纵横比的anchor。例如对于某层大小为$H \times W \times C$的特征图，经过卷积核$[n_{anchors} \times (n_{classes} + 4)] \times 3 \times 3 \times C$，得到$H \times W \times [n_{anchors} \times (n_{classes} + 4)]$的特征图，此特征图用于预测。</p><h4 id="3-2-2-3-RetinaNet"><a href="#3-2-2-3-RetinaNet" class="headerlink" title="3.2.2.3. RetinaNet"></a>3.2.2.3. RetinaNet</h4><p><img src="/2019/08/31/%E8%A7%A3%E8%AF%BB-Recent-Advances-in-Deep-Learning-for-Object-Detection/解读-Recent-Advances-in-Deep-Learning-for-Object-Detection/Fig4-RetinaNet.png" alt="Fig4-RetinaNet"></p><p>使用Focal Loss解决了不同类别样本数目不均衡问题，此外使用Feature Pyramid Network来检测多尺度物体。</p><h4 id="3-2-2-4-CornerNet"><a href="#3-2-2-4-CornerNet" class="headerlink" title="3.2.2.4 CornerNet"></a>3.2.2.4 CornerNet</h4><p><img src="/2019/08/31/%E8%A7%A3%E8%AF%BB-Recent-Advances-in-Deep-Learning-for-Object-Detection/解读-Recent-Advances-in-Deep-Learning-for-Object-Detection/Fig4-CornerNet.png" alt="Fig4-CornerNet"></p><p>该网络为anchor-free类，改变以往寻找anchor框内物体的思路，而预测回归框的关键点。它将物体检测为一对角，在特征图的每个位置上，预测了类热图(Classification Heatmaps)。</p><h2 id="3-3-Backbone-Architecture"><a href="#3-3-Backbone-Architecture" class="headerlink" title="3.3. Backbone Architecture"></a>3.3. Backbone Architecture</h2><p>采用大规模图像分类的预训练模型已经成为大多物体检测网络的默认策略。但直接使用分类模型是次优的</p><ul><li>分类需要更大的感受野，并希望保持空间不变性，故应用多个下采样操作以降低特征的映射分辨率，生成的特征图是低分辨率且空间不变的。但是定位任务需要较高的空间信息；</li><li>分类使用单个特征图即可，而检测任务考虑到多尺度问题，需要在多个尺寸的特征图上进行预测。</li></ul><h3 id="3-3-1-Basic-Architecture-of-a-CNN"><a href="#3-3-1-Basic-Architecture-of-a-CNN" class="headerlink" title="3.3.1. Basic Architecture of a CNN"></a>3.3.1. Basic Architecture of a CNN</h3><p>深度卷积神经网络通常由一系列的卷积层、池化层、非线性激活层和全连接层组成。</p><ul><li>卷积层：卷积层输入输出图像可视作通道数为$C_1, C_2$的图像，卷积核参数为$C_2 \times k \times k \times C_1$；每个特征图上像素点对应原图中的大小称为感受野。</li><li>池化岑：用于扩大感受野并降低计算成本，在一定程度上增加了对图像旋转等抗干扰性。</li><li>非线性激活层：用于添加非线性信息，若无非线性层，网络再深也是线性变化。</li><li>全连接层：一般设置一系列卷积操作后，最后输出时，添加全连接层“兜底”。</li></ul><h3 id="3-3-2-CNN-Backbone-for-Object-Detection"><a href="#3-3-2-CNN-Backbone-for-Object-Detection" class="headerlink" title="3.3.2. CNN Backbone for Object Detection"></a>3.3.2. CNN Backbone for Object Detection</h3><ol><li><p>VGG16</p><p> 包括$2 + 2 + 3 + 3 + 3$层卷积层和$3$层全连接层，每组卷积层间为最大池化层。网络层数的增加可增大网络的容量，但是超过20层时，难以使用SGD进行梯度下降反传。</p></li><li><p>ResNet</p><p> 引入shortcut connection，一定程度上解决了梯度消失问题，可使网络堆叠得更深，即</p><script type="math/tex; mode=display">x_{l+1} = x_l + f_{l+1}(x_l, \theta)</script></li><li><p>ResNet-v2</p><p> ResNet-v2增加Batch Normalization层。尽管shortcut解决了训练问题，但它没有充分利用前层特征图。底层特征在逐元素操作中逐渐丢失，因此提出DenseNet，通过通道组合得方法合并特征，并且层间密集连接。</p><script type="math/tex; mode=display">x_{l+1} = x_l \circ f_{l+1}(x_l, \theta)</script></li><li><p>Dual Path Network</p><p> Dual Path Network结合两者的特点，某一层的特征图通道可分为密集连接部分和逐元素相加元素，即$C=C^d + C^r$</p><script type="math/tex; mode=display">x_{l+1} = (x^r_l + f^r_{l+1}(x^r_l, \theta^r)) \circ (x^d_l \circ f^d_{l+1}(x^d_l, \theta^d))</script></li><li><p>ResNeXt</p><p> 采用分组分离卷积的方法，大大减少了参数量与计算量。</p></li><li><p>GoogLeNet</p><p> 除了增加网络深度，还通过增加支路来扩大网络容量。</p></li></ol><h2 id="3-4-Proposal-Generation"><a href="#3-4-Proposal-Generation" class="headerlink" title="3.4. Proposal Generation"></a>3.4. Proposal Generation</h2><p>One-stage Detectors与Two-stage Detectors都产生了候选框，区别是前者在特征图对应的每个位置生成指定大小的特征图，而后者仅产生前景或背景信息的候选框，得到的结果较为稀疏。</p><h3 id="3-4-1-Traditional-Computer-Vision-Methods"><a href="#3-4-1-Traditional-Computer-Vision-Methods" class="headerlink" title="3.4.1. Traditional Computer Vision Methods"></a>3.4.1. Traditional Computer Vision Methods</h3><p>略。</p><h3 id="3-4-2-Anchor-based-Methods"><a href="#3-4-2-Anchor-based-Methods" class="headerlink" title="3.4.2. Anchor-based Methods"></a>3.4.2. Anchor-based Methods</h3><p>anchor通过人为指定的方式</p><ul><li>根据不同特征图的感受野设置锚框(SSD)；</li><li>为检测细小物体，可增大图像尺寸和减少锚框stride的方式；</li><li>基于RPN，分解锚框的维度(DeRPN)；</li><li>用K-Means确定(YOLOv2)；</li><li>先指定锚框，再通过训练结果矫正锚框(RefineNet)；</li></ul><h3 id="3-4-3-Keypoints-based-Methods"><a href="#3-4-3-Keypoints-based-Methods" class="headerlink" title="3.4.3. Keypoints-based Methods"></a>3.4.3. Keypoints-based Methods</h3><p>略。暂时没有接触过，理解不深，后续可能补上(TODO:)。</p><h3 id="3-4-4-Other-Methods"><a href="#3-4-4-Other-Methods" class="headerlink" title="3.4.4. Other Methods"></a>3.4.4. Other Methods</h3><p>略。</p><h2 id="3-5-Feature-Representation-Learning"><a href="#3-5-Feature-Representation-Learning" class="headerlink" title="3.5. Feature Representation Learning"></a>3.5. Feature Representation Learning</h2><h3 id="3-5-1-Multi-scale-Feature-Learning"><a href="#3-5-1-Multi-scale-Feature-Learning" class="headerlink" title="3.5.1. Multi-scale Feature Learning"></a>3.5.1. Multi-scale Feature Learning</h3><p>如Fast R-CNN与Faster R-CNN，仅通过单个特征图预测输出，这对应多尺度和多个纵横比的情况下具有极大难度。</p><p>底层特征图比高层特征图具有更高的分辨率与更小的感受野，因此更适合于检测小物体。而深层的特征图具有更多的语义信息，对光照、偏移等鲁棒性更好，并具有更大的感受野，更适用于检测大体系物体。</p><p><img src="/2019/08/31/%E8%A7%A3%E8%AF%BB-Recent-Advances-in-Deep-Learning-for-Object-Detection/解读-Recent-Advances-in-Deep-Learning-for-Object-Detection/Fig7.png" alt="Fig7"></p><p>有四种解决多尺度特征学习问题的方法</p><ol><li><p>Image Pyramid<br>通过将图像缩放为不同大小的方式，单独训练适应尺寸的网络，测试时将图片缩放为相应尺寸输入到不同的网络中，计算量较大。但是Singh等人提出，学习单个网络以适应不同尺寸比学习多个适应不同尺寸的网络更困难(SNIP)。</p></li><li><p>Integrated Features<br>通过组合多个层的特征图，以新构造的特征图来预测输出，常用的方法如跳跃连接(skip connection)。又如ION，通过ROI Pooling剪裁来自不同层的区域特征，将其组合后作为特征。又如HyperNet，用反卷积的方式，通过集成浅层及中间层的特征图，生成新的高分辨率特征用以输出候选框。又如Multi-scale Location-aware Kernel Representation (MLKP)，捕获高阶统计量，生成更多的判别特征表示，更具描述性，为分类和定位提供语义及空间信息。</p></li><li><p>Prediction Pyramid<br>如SSD，每一层特征图均用于预测输出，每个层设置一定比例的对象。Multi-Scale Deep Convolutional Neural Network(MSCNN)通过反卷积将特征图分辨率增大，用这些特征图预测输出。Reception Field Block Net(RFBNet)设置多分支，每个分支设置不同尺寸的卷积核，从而获得多尺度、不同感受野的特征图，从而用于预测输出。</p></li><li><p>Feature Pyramid<br>结合Integrated Features与Prediction Pyramid的优点。如Feature Pyramid Network(FPN)自上而下将不同尺度的特征通过逐元素相加或者组合的方式，利用深层特征丰富浅层特征的语义信息。</p></li></ol><p><img src="/2019/08/31/%E8%A7%A3%E8%AF%BB-Recent-Advances-in-Deep-Learning-for-Object-Detection/解读-Recent-Advances-in-Deep-Learning-for-Object-Detection/Fig8.png" alt="Fig8"></p><h3 id="3-5-2-Region-Feature-Encoding"><a href="#3-5-2-Region-Feature-Encoding" class="headerlink" title="3.5.2. Region Feature Encoding"></a>3.5.2. Region Feature Encoding</h3><ul><li>R-CNN</li><li>ROI Pooling Layer</li><li>ROI Warping Layer</li><li>ROI Align Layer</li><li>Precise ROI Pooling Layer</li><li>Position Sensitive ROI Pooling Layer</li><li>Feature Selective Network</li><li>CoupleNet</li><li>Deformable ROI Pooling Layer</li></ul><h3 id="3-5-3-Contextual-Reasoning"><a href="#3-5-3-Contextual-Reasoning" class="headerlink" title="3.5.3. Contextual Reasoning"></a>3.5.3. Contextual Reasoning</h3><p>由于物体的出现与环境相关，且需要与其他物体进行交互，故上下文信息十分重要。深度卷积网络隐式地从分层特征表示中捕获上下文信息。</p><ul><li><p>全局上下文<br>从整个图像地上下文中学习，利用图像其余部分信息，来对感兴趣区域进行分类。</p><ul><li>循环神经网络编码整个图像的四个方向信息(ION)；</li><li>学习类别分数，用于作为与检测结果连接的上下文特征(Ouyang et al.);</li><li>从整个图像提取嵌入信息，将其与局部特征组合用以改善检测结果(He et al.)；</li><li>基于语义分割的方法；</li><li>将目标检测和语义分割作为多任务进行优化(He et al. and Dai et al.)；</li><li><u>伪分段</u>语义标注(Zhao et al.)；</li><li>通过学习的方式获得语义特征图(Detection with Enriched Semantics)；</li></ul></li><li><p>局部上下文<br>对周围区域上下文进行编码，并学习对象与周围区域的交互，直接学习不同位置和带有上下文信息的类别是很困难的。</p></li></ul><blockquote><p>Directly modeling different locations and categories objects relations with the contextual is very challenging. Chen et al. proposed <strong>Spatial Memory Network (SMN)</strong> [130] which introduced a spatial memory based module. The spatial memory module captured instance-level contexts by assembling object instances back into a pseudo ”image” representations which were later used for object relations reasoning. Liu et al. proposed <strong>Structure Inference Net (SIN)</strong> [137] which formulated object detection as a graph inference problem by considering scene contextual information and object relationships. In SIN, each object was treated as a graph node and the relationship between different objects were regarded as graph edges. Hu et al. [138] proposed a <strong>lightweight framework relation network</strong> which formulated the interaction between different objects between their appearance and image locations. The new proposed framework did not need additional annotation and showed improvements in object detection performance. Based on Hu et al., Gu et al. [139] proposed a <strong>fully learnable object detector</strong> which proposed a general viewpoint that unified existing region feature extraction methods. Their proposed method removed heuristic choices in ROI pooling methods and automatically select the most significant parts, including contexts beyond proposals. <strong>Another method</strong> to encode contextual information is to implicitly encode region features by adding image features surrounding region proposals and a large number of approaches have been proposed based on this idea [131, 106, 140, 141, 142, 143]. In addition to encode features from region proposals, <strong>Gidaris et al.</strong> [131] extracted features from a number of different sub-regions of the original object proposals(border regions, central regions, contextual regions etc.) and concatenated these features with the original region features. Similar to their method, [106] extracted local contexts by enlarging the proposal window size and concatenating these features with the original ones. Zeng et al. [142] proposed <strong>Gated Bi-Directional CNN (GBDNet)</strong> which extracted features from multi-scale subregions.Notably, GBDNet learned a gated function to control the transmission of different region information because not all contextual information is helpful for detection.</p></blockquote><h3 id="3-5-4-Deformable-Feature-Learning"><a href="#3-5-4-Deformable-Feature-Learning" class="headerlink" title="3.5.4. Deformable Feature Learning"></a>3.5.4. Deformable Feature Learning</h3><p>检测器应对图像中物体的非刚性变形具有鲁棒性。传统方式有Deformable Part based Models(DPMs)，使用可变形编码方法由多个组成表示对象。深度学习方法如DeepIDNet，开发Deformable-aware Pooling Layer;Deformable Convolutional Layers自动学习辅助位置，以增强常规采样的信息。</p><h1 id="4-Learning-Strategy"><a href="#4-Learning-Strategy" class="headerlink" title="4. Learning Strategy"></a>4. Learning Strategy</h1><h2 id="4-1-Training-Stage"><a href="#4-1-Training-Stage" class="headerlink" title="4.1. Training Stage"></a>4.1. Training Stage</h2><h3 id="4-1-1-Data-Augmentation"><a href="#4-1-1-Data-Augmentation" class="headerlink" title="4.1.1. Data Augmentation"></a>4.1.1. Data Augmentation</h3><p>为解决数据量少的问题，需要进行数据扩增。在物体检测中，常用方法有：水平翻转，旋转、随机裁剪、延申、颜色抖动(亮度，对比度，饱和度和色度)。注意图像变换后，需要对标签也作对应变换。</p><h3 id="4-1-2-Imbalance-Sampling"><a href="#4-1-2-Imbalance-Sampling" class="headerlink" title="4.1.2. Imbalance Sampling"></a>4.1.2. Imbalance Sampling</h3><p>候选框内图像大多数都是背景，而不是物体，有以下两个问题：1) 类别不平衡(class imbalance)，由于只有一小部分候选框内内容为物体，故负样本占大多数，导致梯度反传时负样本占主导。2) 困难不平衡(difficulty imbalance)，类似第一点，检测器更易分辨背景，难以分辨物体。</p><p>一些二阶段检测器，如R-CNN与Fast R-CNN会先拒绝大部分负样本，Fast R-CNN从$2000$个候选框中随机采样，直到在某批次的数据中，正负样本比例达到$1:3$。随机采样能解决类别不平衡问题，但是丢失的负样本可能包含丰富的语义信息。为解决这个问题，刘等人提出困难负样本策略(hard negative sampli  Strategy)，主要保留难以判别为负的负样本，具体地说来，就是选取损失值较大的负样本。</p><p>为了解决困难不平衡问题，大部分都是通过合理设置损失函数。对于标检测来说，多类别分类器需要分辨$C+1$个类别，即$C$类物体加背景。假定某区域真实标签为$u$，$p$是网络输出的$C+1$个类别的概率分布($p = {p_0, \cdots, p_C}$)，那么损失定义为</p><script type="math/tex; mode=display">L_{cls}(p, u) = - \log p_u</script><p>现阶段有一种改进的交叉熵损失：<a href="https://arxiv.org/abs/1904.09048" target="_blank" rel="noopener">Focal Loss</a>，即</p><script type="math/tex; mode=display">L_{FL} = - \alpha (1 - p_u)^{\gamma} \log p_u</script><p>其中参数$\alpha$与$\gamma$为超参数，该损失函数可根据网络输出的$p_u$计算权值，错误分类样本$p_u$更低，从而使权重更大，可以更多地关注误分类样本。梯度协调机制(gradient harmonizing mechanism - GHM)采用类似的思路，不仅抑制了易分类负样本，并避免了异常负样本的影响。此外，还有如在线困难样本挖掘策略(online hard example mining strategy)，自动选取困难样本用以训练，仅关注样本的困难度而不关注类别信息，即单批正负样本比例没有被考虑，他们认为，对于检测问题，样本困难度比类别不平衡更加重要。</p><h3 id="4-1-3-Localization-Refinement"><a href="#4-1-3-Localization-Refinement" class="headerlink" title="4.1.3. Localization Refinement"></a>4.1.3. Localization Refinement</h3><p>物体检测算法需要提供一个包含物体的最小矩形框，但精确定位困难，因为预测通常集中在物体更具分辨性特征的部位，而不一定是包含物体的区域。在一定场景下，需要进行高质量预测，可用IoU作为指标。一种解决方法是生成高质量的候选框，以下介绍一些其他方法。在R-CNN中使用L2惩罚作为损失，在Fast R-CNN中使用平滑L1惩罚作为损失，即</p><script type="math/tex; mode=display">L_{reg}(t^c, v) = \sum_{i \in \{x, y, w, h\}} \text{SmoothL1}(t^c_i - v_i)</script><script type="math/tex; mode=display">\text{SmoothL1}(x) = \begin{cases} 0.5x^2 & \text{if} |x| < 1 \\ |x| - 0.5 & \end{cases}</script><p>其中每类均具有回归的偏置，即$t^c = (t^c_x, t^c_y, t^c_w, t^c_h)$，真实边界框位置为$v=(v_x, v_y, v_w, v_h)$。</p><p>基于定位校准，一些方法采用辅助模型用于更好地矫正坐标。如Gidaris等人引入一种迭代地边框回归方法，使用R-CNN反复迭代候选框内容，多次矫正候选框；另外，提出LocNet，将每个边界框的分布进行建模。这些方法都需要单独模块，不能进行联合调优。</p><p>一些其他的，侧重于设计带有修改的目标函数(modified objective function)的统一网络框架。在多路网络(Multi-Path Network)中，采用一系列的分类器，这些分类器是通过不同的指标，以整体损失进行优化的，每个分类器都适应对应的IoU阈值，所有输出组成最终的预测结果。Fitness NMS学习了一种新式的IoU计算方法，他们认为现在的检测器旨在找到合格的预测，而不是最优的预测，因此高质量、低质量的候选有同等的重要性。Fitne-IoU更看重高度重合的候选框。他们也采用了基于一组IoU上限，来到处边界框的回归损失，以最大化具有对象的预测的IoU(They also derived a bounding box regression loss based on a set of IoU upper bounds to maximum the IoU of predictions with objects)。Grid R-CNN参照CornerNet与DeNet，用角点定位的机制取代边界框的线性回归。</p><h3 id="4-1-4-Cascade-Learning"><a href="#4-1-4-Cascade-Learning" class="headerlink" title="4.1.4. Cascade Learning"></a>4.1.4. Cascade Learning</h3><p>级联学习是一种粗到细的学习策略，从给定分类器的输出中收集信息，以级联的方式构建更强的分类器，首次被应用于训练人脸检测器。在深度学习算法方面，Cascade Region-proposal-network And FasT-rcnn(CRAFT)学习PRN以及带级联策略的分类器，首先学习一个标准的RPN网络，之后用二分类的Fast R-CNN拒绝一些容易判别的错误样本，剩余样本用来构建包含两个Fast R-CNN网络的级联区域分类器。Yang等人引入层级级联分类器，用于多尺度的物体检测，不同层的特征图设置分类器，浅层的分类器将拒绝易分辨的错误样本，剩余样本将送入更深的网络层。RefineDet和Cascade R-CNN将级联用于回归框的矫正，构建多阶段的边界框回归器，边界框输出将在各个阶段进行矫正，并且这些回归器是通过不同quality的指标训练得到的。Cheng等人通过观察Faster R-CNN的误检图片，注意到即使回归器定位准确，样本分类却存在错误，他们将此归结于特征共享(sharing of features)和联合的多任务优化(joint multi-task optimization)导致的次优特征表示(sub-optimal feature representation)；此外，他们认为Faster R-CNN的较大感受野引入了较多噪声。他们建立了一个基于Faster R-CNN与R-CNN的级联检测系统以互补，即用训练好的Faster R-CNN得到一些初始的预测，这些结果用以训练R-CNN。</p><h3 id="4-1-5-Others"><a href="#4-1-5-Others" class="headerlink" title="4.1.5. Others"></a>4.1.5. Others</h3><p>有一些其他的学习策略</p><ol><li><p>Adversarial Learning</p><p> 对抗性学习显示了生成模型的重要性，最主要的应用是生成对抗网络(GAN)。生成器对数据分布进行建模，根据给定的噪声输入，得到一副假的图片，送入鉴别器判断该图片是否为真。GAN在许多领域显示其有效性，在目标检测方面也不例外。Li等人提出的Perceptual GAN可用于细小物体检测，通过对抗过程，生成器将学习细小物体的高分辨率特征表征。A-Fast-R-CNN通过生成的对抗样本训练，他们认为困难样本是在分布的长尾上，因此他们映入了两个新式模块，自动生成具有遮挡和变形的特征。</p></li><li><p>Training from Scratch</p><p> 现在的检测器大多依赖于ImageNet与训练的分类模型，但是，由于分类和检测任务损失不同、数据分布不同，这可能会对结果造成负面影响。Finetuning可能解决这个问题，但是不能完全消除偏差。另外，将此分类模型用作新的领域可能不合适，如RGB图像到MRI数据。所以有必要从空白开始训练，这样的困难主要是物体检测训练数据过少，会造成过拟合。与图像分类不同，物体检测需要边界框级别的标注，这是非常耗时耗力的(ImageNet有1000个类别，但只有200类包含检测标注)。</p><p> Deeply Supervised Object Detectors(DSOD)的设计者认为，密集连接的网络结构用于监督学习可大大减少优化难度。基于DSOD，Shen等人提出了一种门控循环特征金字塔结构，动态调整中间层的监督强度以自适应不同尺度的物体，将空间和语义信息压缩到单个预测特征图，进一步减少了参数量从而加快了收敛速度。此外，门控特征金字塔结构可根据物体大小适应不同强度的监督，这种方法比原始DSOD更有效。但是随后He等人用从头开始训练的检测器在MSCOCO数据机上进行验证，发现vanilla detector可以获得等同于$10K$标注数据训练得到的检测能力，这表明从头开始训练的模型并不依赖特定结构，<strong>这与之前的工作相矛盾</strong>。</p></li><li><p>Knowledge Distillation</p><p> 通过师生教学方案(teacher-student training scheme)，将多个模型集成为一个模型。Li等人提出轻量级检测器，它的训练通过重量级有效的检测器指导进行训练，该检测器速度更快，精准度与后者相近。Cheng等人提出了一种基于RCNN的快速探测器，优化时，R-CNN模型作为教师网络来指导培训过程，与传统的单模型优化策略相比，他们的框架检测精度提高。</p></li></ol><h2 id="4-2-Testing-Stage"><a href="#4-2-Testing-Stage" class="headerlink" title="4.2. Testing Stage"></a>4.2. Testing Stage</h2><p>目标检测算法生成了众多预测结果，但是由于大量的冗余性，输出结果不能直接使用。因此有其他策略提升检测准确率，或加速推断过程。</p><h3 id="4-2-1-Duplicate-Removal"><a href="#4-2-1-Duplicate-Removal" class="headerlink" title="4.2.1. Duplicate Removal"></a>4.2.1. Duplicate Removal</h3><p><img src="/2019/08/31/%E8%A7%A3%E8%AF%BB-Recent-Advances-in-Deep-Learning-for-Object-Detection/解读-Recent-Advances-in-Deep-Learning-for-Object-Detection/Fig10-nms.png" alt="Fig10-nms"></p><p>Non-maximum suppression(NMS)是物体检测算法的一个组成部分，用于消除重复的假阳(false positive)预测，如上图。对于一阶段检测器来说，同一物体周围的预测边界框，可能具有相同的置信度，导致较高的假阳率；而二阶段检测算法产生较为稀疏的候选框，并且回归器会将这些候选框拉向相近的位置，同样会导致较高的假阳率。</p><p>具体说来，对于指定的一类物体，其预测框将按照置信度排序，选择当前置信度最高的候选框，记作$M$，然后计算该框与其余框的IoU，如果IoU值大于某阈值$\Omega_{test}$，该框将被从候选框中删除，即</p><script type="math/tex; mode=display">\text{Score}_B =     \begin{cases}        \text{Score}_B  & \text{IoU}(B, M) < \Omega_{test} \\        0               & \text{otherwise}    \end{cases}</script><p>但是对于聚集的物体，NMS算法将会把同类物体，靠近的物体框删除，这导致回归框预测确实，因此Navaneeth等人提出Soft-NMS算法，使用指定函数将靠近的框的置信度降低，而不是直接置为0</p><script type="math/tex; mode=display">\text{Score}_B =     \begin{cases}        \text{Score}_B              & \text{IoU}(B, M) < \Omega_{test} \\        \text{F}(\text{IoU}(B, M))  & \text{otherwise}    \end{cases}</script><blockquote><p>详细的实现代码可查看<a href="https://louishsu.xyz/2019/05/26/NMS-softer-NMS/" target="_blank" rel="noopener">该文</a></p></blockquote><p>此外，Hosong等人设计了一种网络结构，基于置信度和回归框来改进NMS，这是独立于检测器单独进行有监督训练的。他们认为，重复预测的原因是，检测器故意鼓励每个物体进行多次高分检测而不是奖励单个高分。因此他们根据两个动机来进行网络的设计：1)设置损失来惩罚二次检测，使得每个物体准确预测单个精确预测；2)处理附近的检测输出，给检测器提供是否物体已被多次检测的信息。新提出的模型没有舍弃检测结果，而是将NMS用作重估，降低重复检测结果的评分。</p><h3 id="4-2-2-Model-Acceleration"><a href="#4-2-2-Model-Acceleration" class="headerlink" title="4.2.2. Model Acceleration"></a>4.2.2. Model Acceleration</h3><p>目标检测应用需要较高的实时性，因此需要用指标评估检测器的速度。虽然当前state-of-art算法可以在公开数据集上得到一个较高的检测评价，但是他们的速度限制了他应用在实时场景中。通常来说，二阶段检测器比一阶段检测器速度更慢，因为候选框生成器与分类器单独运算，使得运算量较大。尽管R-FCN提出空间敏感的特征图，通过position-sensitive ROI Pooling来共享计算，但是随着物体种类增多，通道数也随之线性增加。</p><p>从检测器的主体结构可以看到，占计算量最多的主要是网络模型部分，因此一个简单的解决方法是用高效率的主体，比如MobileNet，通过分离卷积的方式，大大减少了参数量与计算量。PVANet是一种新的网络结构，他用到了CReLU，较少了非线性计算。</p><script type="math/tex; mode=display">\text{CReLU}(x) = [\text{ReLU}(x), \text{ReLU}(-x)]</script><p>另一种方法是，将模型进行线下优化，比如模型压缩。最后呢，如NVIDIA开发了一个加速工具TensorRT，在模型部署上进行优化，以加运算速度。</p><h3 id="4-2-3-Others"><a href="#4-2-3-Others" class="headerlink" title="4.2.3. Others"></a>4.2.3. Others</h3><p>其他方法，如将输入图像进行变换，以提高检测精度。图像金字塔是将待检测图像，以一定的比例生成一系列尺寸的图像，在每个图像上进行检测，最终结果合并于每张检测结果。Zhang等人，将图像缩放到指定尺寸，在某一特定尺寸下，仅检测某一指定大小的物体。水平翻转也可用于测试阶段。这些方法都可以增加准确率但是计算量也随之增加。</p><h1 id="5-Applications"><a href="#5-Applications" class="headerlink" title="5. Applications"></a>5. Applications</h1><h2 id="5-1-Face-Detection"><a href="#5-1-Face-Detection" class="headerlink" title="5.1. Face Detection"></a>5.1. Face Detection</h2><p>人脸检测是一个经典的计算机视觉问题，通常是人脸验证、对其、识别等算法的第一步。然而，人脸检测问题与通用检测之间存在关键差异：1)人脸检测中，目标的比例范围远大于通用物体；2)脸部对象包括强结构信息，并且仅有一类物体。考虑到这些特效，需要有一些先验来改进检测算法。</p><h2 id="5-2-Pedestrian-Detection"><a href="#5-2-Pedestrian-Detection" class="headerlink" title="5.2. Pedestrian Detection"></a>5.2. Pedestrian Detection</h2><p>行人检测是一个关键的重要任务。和通用检测不同，1)结构良好，具有几乎固定的纵横比，但也存在于较大范围内；2)行人检测是真实应用场景，有许多挑战：人群拥挤、遮挡、图像模糊等。</p><h2 id="5-3-Others"><a href="#5-3-Others" class="headerlink" title="5.3. Others"></a>5.3. Others</h2><p>其他应用如Logo检测和视频目标检测。</p><h1 id="6-Detection-Benchmarks"><a href="#6-Detection-Benchmarks" class="headerlink" title="6. Detection Benchmarks"></a>6. Detection Benchmarks</h1><p><img src="/2019/08/31/%E8%A7%A3%E8%AF%BB-Recent-Advances-in-Deep-Learning-for-Object-Detection/解读-Recent-Advances-in-Deep-Learning-for-Object-Detection/Tab1.png" alt="Tab1"></p><h2 id="6-1-Generic-Detection-Benchmarks"><a href="#6-1-Generic-Detection-Benchmarks" class="headerlink" title="6.1. Generic Detection Benchmarks"></a>6.1. Generic Detection Benchmarks</h2><ul><li>Pascal VOC2007</li><li>Pascal VOC2012</li><li>MSCOCO</li><li>Open Images</li><li>LVIS</li><li>ImageNet</li></ul><h2 id="6-2-Face-Detection-Benchmarks"><a href="#6-2-Face-Detection-Benchmarks" class="headerlink" title="6.2. Face Detection Benchmarks"></a>6.2. Face Detection Benchmarks</h2><ul><li>WIDER FACE</li><li>FDDB</li><li>PASCAL FACE</li></ul><h2 id="6-3-Pedestrian-Detection-Benchmarks"><a href="#6-3-Pedestrian-Detection-Benchmarks" class="headerlink" title="6.3. Pedestrian Detection Benchmarks"></a>6.3. Pedestrian Detection Benchmarks</h2><ul><li>CityPersons</li><li>Caltech</li><li>ETH</li><li>INRIA</li><li>KITTI</li></ul><h1 id="7-State-of-the-art-for-Generic-Object-Detection"><a href="#7-State-of-the-art-for-Generic-Object-Detection" class="headerlink" title="7. State-of-the-art for Generic Object Detection"></a>7. State-of-the-art for Generic Object Detection</h1><p><img src="/2019/08/31/%E8%A7%A3%E8%AF%BB-Recent-Advances-in-Deep-Learning-for-Object-Detection/解读-Recent-Advances-in-Deep-Learning-for-Object-Detection/Tab2.png" alt="Tab2"></p><p><img src="/2019/08/31/%E8%A7%A3%E8%AF%BB-Recent-Advances-in-Deep-Learning-for-Object-Detection/解读-Recent-Advances-in-Deep-Learning-for-Object-Detection/Tab3.png" alt="Tab3"></p><h1 id="8-Concluding-Remarks-and-Future-Directions"><a href="#8-Concluding-Remarks-and-Future-Directions" class="headerlink" title="8. Concluding Remarks and Future Directions"></a>8. Concluding Remarks and Future Directions</h1><p>目标检测还存在许多挑战和未来的发展方向</p><ol><li><p>候选框生成策略</p><p> 如<a href="#34-proposal-generation">3.4.节</a>中所述，当前许多检测器是基于anchor的，这些anchor主要是手动设计的，难以匹配多尺度物体，基于IoU的匹配策略也是启发式的。而对于无anchor算法，具有大的改进空间，如计算成本告等。当前无锚框算法是一个热点。</p></li><li><p>有效的上下文信息编码</p><p> 上下文信息对物体检测十分重要，但是目前所作的工作对上下文信息的使用比较局限。</p></li><li><p>基于AutoML的检测方法</p><p> 给一个特定任务设计合适的网络结构是很重要的，但是也会消耗大量时间和人力。当前一个比较有趣和重要的研究方向是，通过学习的方法，自动设计网络结构。可通过AutoML方法进行网络结构的探索，但是这种算法需要大量的计算资源(more than 100 GPU cards to train a single model)。</p></li><li><p>目标检测新的数据集</p><p> 当前MSCOCO是目标检测最常用的数据库，但是它只包含80类物体，在真实世界中，这是远远不够的。最近有一个数据集LVIS旨在收集更多类别物体的图像数据，它包含超过1000个类别的16400张图片，其中还有许多高质量的语义分割标注。此外，它模拟真实世界的场景，其中存在大量类别但是有些类别数据很少。</p></li><li><p>Low-shot目标检测</p><p> 有限标记数据训练得到的模型，称作Low-shot。对于边界框级别的图像标注非常耗时耗力，现在有一些通过半监督学习的方法，来减少数据的使用。</p></li><li><p>检测任务的骨干架构</p><p> 当前检测器很多都基于分类模型。</p></li><li><p>其余研究问题</p><p> large batch learning和增量学习(incremental learning)等。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Object Detection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Batch Normalization</title>
      <link href="/2019/08/27/Batch-Normalization/"/>
      <url>/2019/08/27/Batch-Normalization/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>深度学习网络可通过mini-batch随机梯度下降的方式进行优化，然而在优化过程中，存在梯度消失、收敛不稳定的问题。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>机器学习中，假定训练数据与测试数据独立同分布(independent and identical independent)，当输入数据进行白化操作后，可使模型收敛速度加快，这被称作<code>Covariate Shift</code>。</p><p>而在神经网络内部，各层的特征图数据分布不均匀，称为<code>Internal Covariate Shift</code>，有以下几点需求需要进行内部白化</p><ol><li>为防止网络发散，网络参数初始化一般服从均值为$0$的正态分布；</li><li>激活函数敏感区域一般定义在零点位置，如<code>logistic</code>函数，在零点出该处梯度最大，而其他位置容易出现梯度消失问题；</li></ol><p><img src="/2019/08/27/Batch-Normalization/emoji.jpg" alt="emoji"></p><p>内部白化后，输出数据近似服从标准正态分布。一般用于卷积层后、激活函数前。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>Batch Normalization层通常包含参数<code>mean</code>, <code>variance</code>, <code>rolling_mean</code>, <code>rolling_variance</code>，其中<code>mean</code>与<code>variance</code>为训练时根据批次数据计算得到，在训练阶段使用以归一化批次数据；<code>rolling_mean</code>与<code>rolling_variance</code>为该层实际学习的参数，在测试阶段使用以归一化批次数据。</p><p>对于某批次输入的数据$X_{\mathcal{B}}$，尺寸为$(N, H, W, C)$，计算该批次数据每个维度上的均值<code>mean</code>与方差<code>variance</code>，尺寸均为$(H, W, C)$，即</p><script type="math/tex; mode=display">\mu = \frac{1}{N} \sum_{i=1}^N X^{(i)}</script><script type="math/tex; mode=display">\sigma^2 = \frac{1}{N} \sum_{i=1}^N (X^{(i)} - \mu)^2</script><p>更新参数<code>rolling_mean</code>与<code>rolling_variance</code>，以动量方式更新，可取$\gamma=0.01$</p><script type="math/tex; mode=display">\tilde{\mu} := \gamma \cdot \mu + (1 - \gamma) \cdot \tilde{\mu}</script><script type="math/tex; mode=display">\tilde{\sigma^2} := \gamma \cdot \sigma^2 + (1 - \gamma) \cdot \tilde{\sigma^2}</script><p>值得注意的是，在训练阶段前向计算时</p><script type="math/tex; mode=display">\hat{X^{(i)}} = \frac{X^{(i)} - \mu}{\sqrt{\sigma^2 + \epsilon}}</script><p>而测试阶段</p><script type="math/tex; mode=display">\hat{X^{(i)}} = \frac{X^{(i)} - \tilde{\mu}}{\sqrt{\tilde{\sigma^2} + \epsilon}}</script><p>以下为<a href="https://github.com/pjreddie/darknet/blob/master/src/batchnorm_layer.c" target="_blank" rel="noopener">darknet/src/batchnorm_layer.c</a>前向与反向传播计算的具体实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forward_batchnorm_layer</span><span class="params">(layer l, network net)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l.type == BATCHNORM) copy_cpu(l.outputs*l.batch, net.input, <span class="number">1</span>, l.output, <span class="number">1</span>);</span><br><span class="line">    copy_cpu(l.outputs*l.batch, l.output, <span class="number">1</span>, l.x, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(net.train)&#123;</span><br><span class="line">        mean_cpu(l.output, l.batch, l.out_c, l.out_h*l.out_w, l.mean);</span><br><span class="line">        variance_cpu(l.output, l.mean, l.batch, l.out_c, l.out_h*l.out_w, l.variance);</span><br><span class="line"></span><br><span class="line">        scal_cpu(l.out_c, <span class="number">.99</span>, l.rolling_mean, <span class="number">1</span>);</span><br><span class="line">        axpy_cpu(l.out_c, <span class="number">.01</span>, l.mean, <span class="number">1</span>, l.rolling_mean, <span class="number">1</span>);</span><br><span class="line">        scal_cpu(l.out_c, <span class="number">.99</span>, l.rolling_variance, <span class="number">1</span>);</span><br><span class="line">        axpy_cpu(l.out_c, <span class="number">.01</span>, l.variance, <span class="number">1</span>, l.rolling_variance, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        normalize_cpu(l.output, l.mean, l.variance, l.batch, l.out_c, l.out_h*l.out_w);   </span><br><span class="line">        copy_cpu(l.outputs*l.batch, l.output, <span class="number">1</span>, l.x_norm, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        normalize_cpu(l.output, l.rolling_mean, l.rolling_variance, l.batch, l.out_c, l.out_h*l.out_w);</span><br><span class="line">    &#125;</span><br><span class="line">    scale_bias(l.output, l.scales, l.batch, l.out_c, l.out_h*l.out_w);</span><br><span class="line">    add_bias(l.output, l.biases, l.batch, l.out_c, l.out_h*l.out_w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backward_batchnorm_layer</span><span class="params">(layer l, network net)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!net.train)&#123;</span><br><span class="line">        l.mean = l.rolling_mean;</span><br><span class="line">        l.variance = l.rolling_variance;</span><br><span class="line">    &#125;</span><br><span class="line">    backward_bias(l.bias_updates, l.delta, l.batch, l.out_c, l.out_w*l.out_h);</span><br><span class="line">    backward_scale_cpu(l.x_norm, l.delta, l.batch, l.out_c, l.out_w*l.out_h, l.scale_updates);</span><br><span class="line"></span><br><span class="line">    scale_bias(l.delta, l.scales, l.batch, l.out_c, l.out_h*l.out_w);</span><br><span class="line"></span><br><span class="line">    mean_delta_cpu(l.delta, l.variance, l.batch, l.out_c, l.out_w*l.out_h, l.mean_delta);</span><br><span class="line">    variance_delta_cpu(l.x, l.delta, l.mean, l.variance, l.batch, l.out_c, l.out_w*l.out_h, l.variance_delta);</span><br><span class="line">    normalize_delta_cpu(l.x, l.mean, l.variance, l.mean_delta, l.variance_delta, l.batch, l.out_c, l.out_w*l.out_h, l.delta);</span><br><span class="line">    <span class="keyword">if</span>(l.type == BATCHNORM) copy_cpu(l.outputs*l.batch, l.delta, <span class="number">1</span>, net.delta, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://arxiv.org/abs/1502.03167" target="_blank" rel="noopener">Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift - arXiv.org</a></li><li><a href="https://arxiv.org/abs/1805.11604" target="_blank" rel="noopener">How Does Batch Normalization Help Optimization? - arXiv.org</a></li><li><a href="https://github.com/pjreddie/darknet/blob/master/src/batchnorm_layer.c" target="_blank" rel="noopener">darknet/src/batchnorm_layer.c - Github</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Module Layer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eigenface and Fisherface</title>
      <link href="/2019/08/20/Eigenface-and-Fisherface/"/>
      <url>/2019/08/20/Eigenface-and-Fisherface/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在众多人脸图像中，能否找到特一组特征脸，用于表征其他人脸呢？在<a href="https://louishsu.xyz/2018/10/22/PCA/" target="_blank" rel="noopener">PCA</a>和<a href="https://louishsu.xyz/2019/04/22/LDA/" target="_blank" rel="noopener">LDA</a>中分别介绍了两种线性降维方法，本文介绍一种使用以上两种算法的特征提取方法。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="Eigenface"><a href="#Eigenface" class="headerlink" title="Eigenface"></a>Eigenface</h2><p><code>Eigenface</code>由Sirovich与Kirby在1987年提出，认为人脸图像可由一系列特征图加权组合重构而成，即</p><script type="math/tex; mode=display">F = F_m + \sum_i w_i F_i \tag{1}</script><p><code>Eigenface</code>可通过<code>PCA</code>生成，在大量的人脸数据图像上进行分析，选取主分量作为特征脸，详细步骤如下</p><ol><li><p>假设有图像尺寸为$(H, W)$的人脸数据，共$N$张。将单张的灰度图片展开成为维数为$H \times W$的向量$x^{(i)}$，构成数据矩阵$X$</p><script type="math/tex; mode=display">X_{(H \times W) \times N} = \begin{bmatrix} x^{(1)} & x^{(2)} & \ldots & x^{(N)} \end{bmatrix} \tag{2.1}</script></li><li><p>计算各样本向量的均值$\mu$，将各样本去均值化，生成数据矩阵$\overline{X}$</p><script type="math/tex; mode=display">\mu = \frac{1}{N} \sum_{i=1}^{N} x^{(i)}; \quad \overline{x}^{(i)} = x^{(i)} - \mu \tag{2.2}</script></li><li><p>计算协方差矩阵$C$</p><script type="math/tex; mode=display">C = \frac{1}{N} \overline{X} \cdot \overline{X}^T \tag{2.3}</script></li><li><p>将协方差矩阵进行特征值分解</p><script type="math/tex; mode=display">C \alpha_i = \lambda_i \alpha_i \tag{2.4}</script><blockquote><p>注意到，在图像尺寸为$(H, W)$的情况下，协方差矩阵的尺寸为$(H \times W, H \times W)$，本文使用数据库内图像为$112 \times 92$，存储为浮点类型<code>(4 byte)</code>，也就是说，该协方差矩阵所占内存</p><script type="math/tex; mode=display">(112 \times 92)^2 \text{pixel} \times 4 \text{byte/pixel} = 441 \rm{kb} \text{(阵亡。。。)}</script><p>因此，需要转换一下求解问题，查看<a href="#eigenface%e6%b1%82%e8%a7%a3">Eigenface求解</a>。</p></blockquote></li><li><p>按特征值降序，重新排列特征对$(\lambda_i, \alpha_i)$，选取前$K$个特征向量作为<code>Eigenface</code></p><script type="math/tex; mode=display">E_{(H \times W) \times K} = \begin{bmatrix} \alpha_1 & \alpha_2 & \ldots & \alpha_K \end{bmatrix} \tag{2.5}</script></li></ol><p>此时将人脸数据$x$投影到各主分量上，可获得相应系数，该系数向量可用于表征该人脸的特征，即</p><script type="math/tex; mode=display">\vec{w} = \begin{bmatrix} w_1 & w_2 & \cdots & w_K \end{bmatrix} \tag{3}</script><p>其中$w_i = x^T \alpha_i$。</p><p>将各主轴恢复原图像尺寸后，其可视化输出如下<br><img src="/2019/08/20/Eigenface-and-Fisherface/output_30_0.png" alt="output_30_0"></p><h2 id="FisherFace"><a href="#FisherFace" class="headerlink" title="FisherFace"></a>FisherFace</h2><p><code>Fisherface</code>基本思路与<code>Eigenface</code>一致，也是寻找一组特征脸，用于表征人脸特征。可通过<code>LDA</code>生成，<code>LDA</code>考虑类内与类间散布，与<code>PCA</code>不同，为有监督学习。详细步骤如下</p><ol><li><p>同样的，获取数据矩阵$X$</p><script type="math/tex; mode=display">X_{(H \times W) \times N} = \begin{bmatrix} x^{(1)} & x^{(2)} & \ldots & x^{(N)} \end{bmatrix} \tag{4.1}</script></li><li><p>计算所有数据的均值向量$\mu$与各类别的均值向量$\mu_j$</p><script type="math/tex; mode=display">\mu = \frac{1}{N} \sum_{i=1}^{N} x^{(i)}; \quad \mu_j = \frac{1}{N_j} \sum_{i=1}^{N_j} x^{(i)}, x^{(i)} \in C_j \tag{4.2}</script></li><li><p>计算类内离散度矩阵$S_W$与类间离散度矩阵$S_B$</p><script type="math/tex; mode=display"> \begin{aligned}  S_W = \sum_{j=1}^{C} \frac{N_j}{N} \left[ \frac{1}{N_j} \sum_{i=1}^{N_j} (x^{(i)} - \mu_j) (x^{(i)} - \mu_j)^T \right] \\ = \frac{1}{N} \sum_{j=1}^{C} \sum_{i=1}^{N_j} (x^{(i)} - \mu_j) (x^{(i)} - \mu_j)^T; \quad x^{(i)} \in C_j \end{aligned} \tag{4.3}</script><script type="math/tex; mode=display">S_B = \sum_{j=1}^{C} \frac{N_j}{N} (\mu_j - \mu) (\mu_j - \mu)^T \tag{4.4}</script></li><li><p>求解广义特征值问题</p><script type="math/tex; mode=display">S_B \alpha_i = \lambda_i S_W \alpha_i \tag{4.5}</script><blockquote><p>通常该问题可通过分解矩阵$S_W^{-1} S_B$进行求解</p><script type="math/tex; mode=display">S_W^{-1} S_B \alpha_i = \lambda_i \alpha_i</script><p>但由于函数<code>numpy.linalg.eig(a)</code>问题，在求解$S_W^{-1} S_B$特征对时出现复数。更加令人疑惑的是，作为实对称矩阵$S_W^{-1}$，其特征对用该函数求解时，也会出现复数。实际上，<code>numpy</code>提供了函数<code>numpy.linalg.eigh(a)</code>专门求解实对称矩阵或<code>Hermite</code>矩阵的特征对，故需要对该特征求解进行一定处理，查看<a href="#%e5%b9%bf%e4%b9%89%e7%89%b9%e5%be%81%e5%80%bc%e9%97%ae%e9%a2%98sb-alphai--lambdai-sw-alphai">广义特征值问题$S_B \alpha_i = \lambda_i S_W \alpha_i$</a>。<br><strong>性质1：</strong> 实对称矩阵(满足$A^T = A$)的特征值都是实数。<br><strong>性质2：</strong> 实对称矩阵(满足$A^T = A$)属于不同特征值的特征向量正交。</p></blockquote></li><li><p>按特征值降序，重新排列特征对$(\lambda_i, \alpha_i)$，选取前$K$个特征向量作为<code>FisherFace</code></p><script type="math/tex; mode=display">F_{(H \times W) \times K} = \begin{bmatrix} \alpha_1 & \alpha_2 & \ldots & \alpha_K \end{bmatrix} \tag{4.6}</script></li></ol><p>类似的，将人脸数据$x$投影到各主分量上，可获得相应系数，该系数向量可用于表征该人脸的特征，即</p><script type="math/tex; mode=display">\vec{w} = \begin{bmatrix} w_1 & w_2 & \cdots & w_K \end{bmatrix} \tag{5}</script><p>其中$w_i = x^T \alpha_i$。</p><p>将各主轴恢复原图像尺寸后，其可视化输出如下<br><img src="/2019/08/20/Eigenface-and-Fisherface/output_33_0.png" alt="output_33_0"></p><p>实际上，若输入的数据矩阵$X$不做降维处理，计算得到矩阵$S_W$与$S_B$尺寸为$(H \times W) \times (H \times W)$，也是一个令人头疼的计算量问题。而与<a href="#eigenface">上面</a>不同，这是无法避免的。所以考虑到这一点，需要对原始数据进行降维，可利用<code>PCA</code></p><script type="math/tex; mode=display">\tilde{X}_{D \times N} = \text{pca}(X_{(H \times W) \times N}) \tag{6.1}</script><p>对矩阵$\tilde{X}$进行<code>LDA</code>计算后，得到<code>Fisherface</code>序列${\alpha_1, \alpha_2, \ldots}$，其中$\alpha_i$维度为$D \times 1$，若需可视化结果，利用计算得到的<code>PCA</code>模型将其重建即可</p><script type="math/tex; mode=display">A_i = \text{pca}^{-1}(\alpha_i) \tag{6.2}</script><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><h2 id="Eigenface求解"><a href="#Eigenface求解" class="headerlink" title="Eigenface求解"></a>Eigenface求解</h2><p>矩阵$\overline{X}$可经$SVD$分解为</p><script type="math/tex; mode=display">\overline{X} = U \Sigma V^T \tag{7}</script><p>对于协方差矩阵$C_{(H \times W) \times (H \times W)} = \frac{1}{N} \overline{X} \cdot \overline{X}^T$，对其进行特征值分解如下</p><script type="math/tex; mode=display">\overline{X} \cdot \overline{X}^T u_i = \lambda_i u_i \tag{8}</script><p>实际上，$(8)$为求解矩阵$\overline{X}$左奇异向量$u_i, i = 1, 2, \ldots, H \times W$的过程，然而其计算量过大，考虑矩阵$\overline{X}$右奇异向量$v_i, i = 1, 2, \ldots, N$。</p><script type="math/tex; mode=display">\overline{X}^T \overline{X} v_i = \lambda_i v_i \tag{9}</script><p>由$(7)$可得</p><script type="math/tex; mode=display">\begin{aligned}    \overline{X} V = U \Sigma & 或 & \overline{X} v_i = \sigma_i u_i \end{aligned}</script><p>所以</p><script type="math/tex; mode=display">\begin{aligned}    u_i = \frac{1}{\sigma_i} \overline{X} v_i & 或 & U = \overline{X} V \Sigma^{-1}\end{aligned} \tag{10}</script><p>其中$V$与$\Lambda$由式$(9)$已知，奇异值$\sigma_i = \sqrt{\lambda_i}$，故</p><script type="math/tex; mode=display">\begin{aligned}    u_i = \frac{1}{\sqrt{\lambda_i}} \overline{X} v_i & 或 & U = \overline{X} V \Lambda^{-\frac{1}{2}}\end{aligned} \tag{11}</script><p>实际上，由于$\text{rank}(\overline{X}) \leq N$，故后$(H \times W) - N$个特征值均为$0$，对应特征向量无意义，不予求解。</p><h2 id="广义特征值问题-S-B-alpha-i-lambda-i-S-W-alpha-i"><a href="#广义特征值问题-S-B-alpha-i-lambda-i-S-W-alpha-i" class="headerlink" title="广义特征值问题$S_B \alpha_i = \lambda_i S_W \alpha_i$"></a>广义特征值问题$S_B \alpha_i = \lambda_i S_W \alpha_i$</h2><p>由于函数<code>numpy.linalg.eig(a)</code>问题，在求解$S_W^{-1} S_B$特征对时出现复数。故作如下处理</p><p>$S_W$为实对称矩阵，故可使用函数<code>numpy.linalg.eigh(a)</code>解得其特征对，即</p><script type="math/tex; mode=display">S_W = P \Lambda P^T \tag{12}</script><p>代入$S_W^{-1} S_B \alpha_i = \lambda_i \alpha_i$并作相应变换</p><script type="math/tex; mode=display">(P \Lambda P^T)^{-1} S_B \alpha_i = \lambda_i \alpha_i</script><script type="math/tex; mode=display">\underbrace{P \Lambda^{-\frac{1}{2}} \Lambda^{-\frac{1}{2}} P^T}_{S_W} \cdot S_B \cdot \underbrace{P \Lambda^{-\frac{1}{2}} \Lambda^{\frac{1}{2}} P^T}_I \cdot \alpha_i = \lambda_i \alpha_i</script><script type="math/tex; mode=display">\underbrace{\Lambda^{-\frac{1}{2}} P^T \cdot S_B \cdot P \Lambda^{-\frac{1}{2}}}_{A} \underbrace{\Lambda^{\frac{1}{2}} P^T \cdot \alpha_i}_{\beta_i} = \lambda_i \underbrace{\Lambda^{\frac{1}{2}} P^T \cdot \alpha_i}_{\beta_i} \tag{13}</script><p>其中$A = \Lambda^{-\frac{1}{2}} P^T \cdot S_B \cdot P \Lambda^{-\frac{1}{2}}$也为对称矩阵，可由用函数<code>numpy.linalg.eigh(a)</code>解得其特征对$(\lambda_i, \beta_i)$，则</p><script type="math/tex; mode=display">\beta_i = \Lambda^{\frac{1}{2}} P^T \cdot \alpha_i</script><script type="math/tex; mode=display">\alpha_i = P \Lambda^{-\frac{1}{2}} \beta_i \tag{14}</script><h1 id="实现及实验"><a href="#实现及实验" class="headerlink" title="实现及实验"></a>实现及实验</h1><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>实验中数据集选用<a href="https://www.cl.cam.ac.uk/research/dtg/attarchive/facedatabase.html" target="_blank" rel="noopener">ORL Face</a>，包含40名人员的10份人脸数据，包括拍摄时间、光照、表情(睁/闭眼、笑/不笑)、面部细节(眼镜)的变化。图片保存为<code>.pgm</code>格式，可用<code>OpenCV</code>进行读取。</p><p>其数据预览如下</p><p><img src="/2019/08/20/Eigenface-and-Fisherface/faces.gif" alt="preview"></p><h2 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PCA</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">""" Principal Components Analysis</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Attributes:</span></span><br><span class="line"><span class="string">        components_: &#123;ndarray(n_components, n_features)&#125;</span></span><br><span class="line"><span class="string">        means_:      &#123;ndarray(n_components)&#125;</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n_components)</span>:</span></span><br><span class="line"></span><br><span class="line">        self.n_components = n_components</span><br><span class="line">        self.components_  = <span class="keyword">None</span></span><br><span class="line">        self.means_       = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        <span class="string">''' train the model</span></span><br><span class="line"><span class="string">        Params:</span></span><br><span class="line"><span class="string">            X: &#123;ndarray(n_samples, n_features)&#125;</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        n_samples, n_features = X.shape</span><br><span class="line"></span><br><span class="line">        self.means_ = np.mean(X, axis=<span class="number">0</span>)</span><br><span class="line">        X_ = X - self.means_</span><br><span class="line">        eigval, eigvec = <span class="keyword">None</span>, <span class="keyword">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> n_samples &lt; n_features:</span><br><span class="line">            eigval, u = np.linalg.eig(X_.dot(X_.T))</span><br><span class="line">            eigvec = X_.T.dot(u).dot(np.diag(<span class="number">1</span> / eigval))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            covar_ = X_.T.dot(X_)</span><br><span class="line">            eigval, eigvec = np.linalg.eig(covar_)</span><br><span class="line"></span><br><span class="line">        order = np.argsort(eigval)[::<span class="number">-1</span>]</span><br><span class="line">        eigval = eigval[order]</span><br><span class="line">        eigvec = eigvec.T[order].T</span><br><span class="line"></span><br><span class="line">        self.components_ = eigvec[:, :self.n_components].T</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transform</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Params:</span></span><br><span class="line"><span class="string">            X: &#123;ndarray(n_samples, n_features)&#125;</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            X_:&#123;ndarray(n_samples, n_components)&#125;</span></span><br><span class="line"><span class="string">        Notes:</span></span><br><span class="line"><span class="string">            X'_&#123;nxk'&#125; · V_&#123;kxk'&#125;^T = X''_&#123;nxk&#125;</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        X_ = X - self.means_</span><br><span class="line">        X_ = X_.dot(self.components_.T)</span><br><span class="line">        <span class="keyword">return</span> X_</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit_transform</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        self.fit(X)</span><br><span class="line">        <span class="keyword">return</span> self.transform(X)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transform_inv</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        <span class="string">""" </span></span><br><span class="line"><span class="string">        Params:</span></span><br><span class="line"><span class="string">            X: &#123;ndarray(n_samples, n_components)&#125;</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            X_:&#123;ndarray(n_samples, n_features)&#125;</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        X_ = X.dot(self.components_) + self.means_</span><br><span class="line">        <span class="keyword">return</span> X_</span><br></pre></td></tr></table></figure><h2 id="LDA"><a href="#LDA" class="headerlink" title="LDA"></a>LDA</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eig</span><span class="params">(A1, A2)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Params:</span></span><br><span class="line"><span class="string">        A1, A2: &#123;ndarray(n, n)&#125;</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        eigval: &#123;ndarray(n)&#125;</span></span><br><span class="line"><span class="string">        eigvec: &#123;ndarray(n, n)&#125;</span></span><br><span class="line"><span class="string">    Notes:</span></span><br><span class="line"><span class="string">        A1 \alpha = \lambda A2 \alpha</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    s, u = np.linalg.eigh(A2)</span><br><span class="line">    s[s &lt;= <span class="number">0</span>] = np.finfo(float).eps</span><br><span class="line">    s_sqrt = np.diag(np.sqrt(s))</span><br><span class="line">    s_sqrt_inv = np.linalg.inv(s_sqrt)</span><br><span class="line"></span><br><span class="line">    A = s_sqrt_inv.dot(u.T).dot(A1).dot(u).dot(s_sqrt_inv)</span><br><span class="line">    eigval, P = np.linalg.eigh(A)</span><br><span class="line">    eigvec = u.dot(s_sqrt_inv).dot(P)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> eigval, eigvec</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LDA</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">""" </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Attributes:</span></span><br><span class="line"><span class="string">        n_components: &#123;int&#125;</span></span><br><span class="line"><span class="string">        components_:  &#123;ndarray(n_components, n_features)&#125;</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n_components=<span class="number">-1</span>)</span>:</span></span><br><span class="line">        self.n_components = n_components</span><br><span class="line">        self.components_ = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X, y)</span>:</span></span><br><span class="line">        <span class="string">""" train the model</span></span><br><span class="line"><span class="string">        Params:</span></span><br><span class="line"><span class="string">            X:      &#123;ndarray(n_samples, n_features)&#125;</span></span><br><span class="line"><span class="string">            y:      &#123;ndarray(n_samples)&#125;</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        labels = list(set(list(y)))</span><br><span class="line">        n_class = len(labels)</span><br><span class="line">        n_samples, n_feats = X.shape</span><br><span class="line"></span><br><span class="line">        S_W = np.zeros(shape=(n_feats, n_feats))</span><br><span class="line">        S_B = np.zeros(shape=(n_feats, n_feats))</span><br><span class="line">        mean_ = np.mean(X, axis=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> i_class <span class="keyword">in</span> range(n_class):</span><br><span class="line">            X_ = X[y==labels[i_class]]</span><br><span class="line">            means_ = np.mean(X_, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            X_ = X_ - means_</span><br><span class="line">            means_ = (means_ - mean_).reshape(<span class="number">1</span>, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">            S_W += (X_.T).dot(X_) * (<span class="number">1</span> / n_samples)</span><br><span class="line">            S_B += (means_.T).dot(means_) * (X_.shape[<span class="number">0</span>] / n_samples)</span><br><span class="line"></span><br><span class="line">        eigval, eigvec = eig(S_B, S_W)</span><br><span class="line"></span><br><span class="line">        order = np.argsort(eigval)[::<span class="number">-1</span>]</span><br><span class="line">        eigval = eigval[order]</span><br><span class="line">        eigvec = eigvec[:, order]</span><br><span class="line"></span><br><span class="line">        self.components_ = eigvec[:, :self.n_components].T</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transform</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Params:</span></span><br><span class="line"><span class="string">            X:  &#123;ndarray(n_samples, n_features)&#125;</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            X:  &#123;ndarray(n_samples, n_components)&#125;</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        X_ = X.dot(self.components_.T)</span><br><span class="line">        <span class="keyword">return</span> X_</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit_transform</span><span class="params">(self, X, y)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Params:</span></span><br><span class="line"><span class="string">            X:  &#123;ndarray(n_samples, n_features)&#125;</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            X:  &#123;ndarray(n_samples, n_components)&#125;</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.fit(X, y)</span><br><span class="line">        X_ = self.transform(X)</span><br><span class="line">        <span class="keyword">return</span> X_</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transform_inv</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Params:</span></span><br><span class="line"><span class="string">            X:  &#123;ndarray(n_samples, n_components)&#125;</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            X:  &#123;ndarray(n_samples, n_features)&#125;</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        X_ = X.dot(self.components_)</span><br><span class="line">        <span class="keyword">return</span> X_</span><br></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_features</span><span class="params">(X, dsize, title=<span class="string">"features"</span>)</span>:</span></span><br><span class="line">    <span class="string">""" Show features</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Params:</span></span><br><span class="line"><span class="string">        X: &#123;ndarray(N, n_features)&#125;</span></span><br><span class="line"><span class="string">        dsize: &#123;tuple(H, W)&#125;</span></span><br><span class="line"><span class="string">        title: &#123;str&#125;</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    SUBPLOT = <span class="string">"19&#123;&#125;"</span></span><br><span class="line"></span><br><span class="line">    plt.figure(figsize=(<span class="number">18</span>, <span class="number">2</span>))</span><br><span class="line">    plt.title(title)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">        plt.subplot(int(SUBPLOT.format(i+<span class="number">1</span>)))</span><br><span class="line">        plt.imshow(X[i].reshape(dsize), cmap=<span class="string">"gray"</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><ol><li><p>Eigenface</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pca = PCA(n_components=n_features); pca.fit(X)</span><br><span class="line">show_features(pca.components_, DSIZE, title=<span class="string">"Eigenface &#123;&#125;"</span>.format(repr(DSIZE)))</span><br></pre></td></tr></table></figure><p> <img src="/2019/08/20/Eigenface-and-Fisherface/output_30_0.png" alt="output_30_0"></p></li><li><p>FisherFace</p><p> 为减少计算量，将原始数据<code>PCA</code>降维后，再用于<code>LDA</code>计算<code>FisherFace</code>，故维度数目选取会影响实验结果，以下分别选择不同维数时产生的<code>FisherFace</code>序列，显示前9个特征脸。可见主分量数目越少，特征脸越清晰，但包含的细节也越少。</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">n_decomposed = n_samples - n_classes - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">pca = PCA(n_components=n_decomposed)</span><br><span class="line">X_decomposed = pca.fit_transform(X)</span><br><span class="line"></span><br><span class="line">lda = LDA(n_components=n_classes - <span class="number">1</span>)</span><br><span class="line">lda.fit(X_decomposed, y)</span><br><span class="line"></span><br><span class="line">components_ = pca.transform_inv(lda.components_)</span><br><span class="line">show_features(components_, DSIZE, title=<span class="string">"Fisherface &#123;&#125; &#123;&#125;"</span>.format(repr(DSIZE), n_decomposed))</span><br></pre></td></tr></table></figure><ul><li>199<br><img src="/2019/08/20/Eigenface-and-Fisherface/output_33_0.png" alt="output_33_0"></li><li>279<br><img src="/2019/08/20/Eigenface-and-Fisherface/output_33_2.png" alt="output_33_2"></li><li>359<br><img src="/2019/08/20/Eigenface-and-Fisherface/output_33_4.png" alt="output_33_4"></li></ul></li></ol><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.cl.cam.ac.uk/research/dtg/attarchive/facedatabase.html" target="_blank" rel="noopener">The Database of Faces</a></li><li><a href="https://www.xuebuyuan.com/3231919.html" target="_blank" rel="noopener">人脸识别之—-FisherFace - 学步园</a></li><li><a href="https://bytefish.de/pdf/facerec_python.pdf" target="_blank" rel="noopener">Face Recognition with Python, by Philipp Wagner</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 特征提取 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Neighborhood Preserving Embedding</title>
      <link href="/2019/08/12/Neighborhood-Preserving-Embedding/"/>
      <url>/2019/08/12/Neighborhood-Preserving-Embedding/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在<a href="https://louishsu.xyz/2019/08/09/Locally-Linear-Embedding/" target="_blank" rel="noopener">Locally Linear Embedding</a>一节中介绍了非线性降维方法<code>LLE</code>，原数据到低维数据没有指定映射方法，故不适用于新数据点。本文介绍的<code>NPE</code>是在其基础上的改进。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>设有$M$个$N$维数据，构成矩阵$X$</p><script type="math/tex; mode=display">X_{N \times M} = \left[ \begin{matrix}    |             & |             &        & |              \\    \vec{x}^{(1)} & \vec{x}^{(2)} & \cdots & \vec{x}^{(M)}  \\    |             & |             &        & |\end{matrix} \right] \tag{1.1}</script><p>其中</p><script type="math/tex; mode=display">\vec{x}^{(i)}_{N \times 1} = \left[ \begin{matrix}    \vec{x}^{(i)}_1 & \vec{x}^{(i)}_2 & \cdots & \vec{x}^{(i)}_N \end{matrix} \right] ^T \tag{1.2}</script><h2 id="高维到低维的映射"><a href="#高维到低维的映射" class="headerlink" title="高维到低维的映射"></a>高维到低维的映射</h2><p>在<code>LLE</code>基础上，将数据的映射方法指定为</p><script type="math/tex; mode=display">\vec{y}^{(i)} = P^T · \vec{x}^{(i)} \tag{*1}</script><blockquote><script type="math/tex; mode=display">\vec{y}^{(i)}_j = \vec{p}_j^T · \vec{x}^{(i)}</script></blockquote><p>其中</p><script type="math/tex; mode=display">P_{N \times D} = \left[ \begin{matrix}    |         & |         &        & |          \\    \vec{p}_1 & \vec{p}_2 & \cdots & \vec{p}_D  \\    |         & |         &        & |\end{matrix} \right] \tag{2.1}</script><script type="math/tex; mode=display">\vec{p}_{i_{N \times 1}} = \left[ \begin{matrix}    \vec{p}_{i1} & \vec{p}_{i2} & \cdots & \vec{p}_{iN}\end{matrix} \right] ^T \tag{2.2}</script><script type="math/tex; mode=display">\vec{y}^{(i)}_{D \times 1} = \left[ \begin{matrix}    \vec{y}^{(i)}_1 & \vec{y}^{(i)}_2 & \cdots & \vec{y}^{(i)}_D \end{matrix} \right] ^T \tag{2.3}</script><h2 id="高维空间的空间结构特征"><a href="#高维空间的空间结构特征" class="headerlink" title="高维空间的空间结构特征"></a>高维空间的空间结构特征</h2><p>与<a href="https://louishsu.xyz/2019/08/09/Locally-Linear-Embedding/" target="_blank" rel="noopener">Locally Linear Embedding</a>一致，通过矩阵$\dot{W}$保存空间结构特征</p><script type="math/tex; mode=display">J(\vec{w}_i) = || \vec{x}^{(i)} - \sum_{\vec{x}^{(j)} \in \mathcal{N}_K(\vec{x}^{(i)})} w_{ij} \vec{x}^{(j)} ||_2^2 \tag{3.1}</script><script type="math/tex; mode=display">\text{s.t.} \quad \sum_{j=1}^K w_{ij} = 1 \quad \text{or} \quad \vec{w}_i^T \vec{1} = 1 \tag{3.2}</script><p>解得</p><script type="math/tex; mode=display">\vec{w}_{i_{K \times 1}} = \frac{Z^{(i)-1} \vec{1}}{\vec{1}^T Z^{(i)-1} \vec{1}} \tag{*2}</script><p>其中</p><script type="math/tex; mode=display">Z^{(i)}_{K \times K} = (X^{(i)} - N^{(i)})^T (X^{(i)} - N^{(i)})</script><script type="math/tex; mode=display">X^{(i)} = \left[ \begin{matrix}    |             & |             &        & |              \\    \vec{x}^{(i)} & \vec{x}^{(i)} & \cdots & \vec{x}^{(i)}  \\    |             & |             &        & |\end{matrix} \right]</script><script type="math/tex; mode=display">N^{(i)} = \left[ \begin{matrix}    |               & |               &        & |               \\    \vec{x}^{(1)}_N & \vec{x}^{(2)}_N & \cdots & \vec{x}^{(K)}_N \\    |               & |               &        & |\end{matrix} \right]</script><p>解得矩阵</p><script type="math/tex; mode=display">W_{K \times M} = \left[ \begin{matrix}    |         & |         &        & |          \\    \vec{w}_1 & \vec{w}_2 & \cdots & \vec{w}_M  \\    |         & |         &        & |\end{matrix} \right]</script><h2 id="低维空间保持同样的空间结构"><a href="#低维空间保持同样的空间结构" class="headerlink" title="低维空间保持同样的空间结构"></a>低维空间保持同样的空间结构</h2><p>在低维空间中，损失定义为</p><script type="math/tex; mode=display">J(Y) = \sum_{i} || \vec{y}^{(i)} - \sum_j w_{ij} \vec{y}^{(j)} ||_2^2 \tag{4}</script><p>由于低维空间中近邻情况未知，故将矩阵$W$扩充为$\dot{W}$</p><script type="math/tex; mode=display">\dot{W}_{M \times M} = \left[ \begin{matrix}    |               & |               &        & |               \\    \dot{\vec{w}}_1 & \dot{\vec{w}}_2 & \cdots & \dot{\vec{w}}_M \\    |               & |               &        & |\end{matrix} \right] \tag{5.1}</script><script type="math/tex; mode=display">\dot{w}_{ij} = \begin{cases}    w_{ik}  & x^{(j)} = N^{(i)}_k \\    0       & \text{otherwise}\end{cases} \tag{5.2}</script><p>相应的，$\vec{y}^{(i)}_{D \times 1}$扩充为$\dot{\vec{y}}^{(i)}_{M \times 1}$。</p><p>则式$(4)$可变换为</p><script type="math/tex; mode=display">J(\dot{Y}) = \sum_{i} || \dot{\vec{y}}^{(i)} - \sum_j \dot{w}_{ij} \dot{\vec{y}}^{(j)} ||_2^2 \tag{6.1}</script><p>增加约束条件，与<code>LLE</code>略有不同</p><script type="math/tex; mode=display">\dot{\vec{y}}^{(i)^T} \dot{\vec{y}}^{(i)} = 1 \tag{6.2}</script><p>写作矩阵形式，即</p><script type="math/tex; mode=display">J(\dot{Y}) = \text{tr} \left[ \dot{Y} (I - \dot{W}) (I - \dot{W})^T \dot{Y}^T \right] \tag{7}</script><script type="math/tex; mode=display">\text{s.t.} \dot{\vec{y}}^{(i)^T} \dot{\vec{y}}^{(i)} = 1</script><p>其中</p><script type="math/tex; mode=display">\dot{Y}_{M \times M} = \dot{P}^T_{(N \times M)^T} X_{N \times M} \tag{8.1}</script><script type="math/tex; mode=display">\dot{\vec{y}^{(i)}}_{M \times 1} = \dot{P}^T_{(N \times M)^T} \dot{\vec{x}^{(i)}}_{N \times 1} \tag{8.2}</script><p>则优化问题转换为</p><script type="math/tex; mode=display">J(\dot{P}) = \text{tr} \left[\dot{P}^T X (I - \dot{W}) (I - \dot{W})^T X^T \dot{P} \right] \tag{9}</script><script type="math/tex; mode=display">\text{s.t.} \quad \dot{\vec{x}^{(i)}}^T \dot{P} \dot{P}^T \dot{\vec{x}^{(i)}} = 1</script><p>记</p><script type="math/tex; mode=display">M = (I - \dot{W}) (I - \dot{W})^T \tag{10}</script><p>列写拉格朗日函数</p><script type="math/tex; mode=display">L(\dot{P}) = \text{tr} \left[\dot{P}^T X (I - \dot{W}) (I - \dot{W})^T X^T \dot{P} \right] + \lambda (\dot{\vec{x}^{(i)}}^T \dot{P} \dot{P}^T \dot{\vec{x}^{(i)}} - 1) \tag{11}</script><script type="math/tex; mode=display">\frac{\nabla L(\dot{P})}{\nabla \dot{P}} = 2 X M X^T \dot{P} + 2 \lambda X X^T \dot{P}</script><script type="math/tex; mode=display">\Rightarrow \quad X M X^T \dot{P} = \lambda X X^T \dot{P} \tag{*3}</script><blockquote><script type="math/tex; mode=display">\frac{\nabla b^T X^T X c}{\nabla X} = X(bc^T + cb^T)</script></blockquote><p>同<code>LLE</code>，当低维数据维度为$D$时，按特征值升序排序约化矩阵，即选择最前的$D$个特征向量组成投影矩阵</p><script type="math/tex; mode=display">P = \left[ \begin{matrix}    |               & |               &        & |               \\    \vec{\alpha}_1  & \vec{\alpha}_2  & \cdots & \vec{\alpha}_D  \\    |               & |               &        & |\end{matrix} \right] \tag{*4}</script><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eig</span><span class="params">(A1, A2)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Params:</span></span><br><span class="line"><span class="string">        A1, A2: &#123;ndarray(n, n)&#125;</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        eigval: &#123;ndarray(n)&#125;</span></span><br><span class="line"><span class="string">        eigvec: &#123;ndarray(n, n)&#125;</span></span><br><span class="line"><span class="string">    Notes:</span></span><br><span class="line"><span class="string">        A1 \alpha = \lambda A2 \alpha</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    s, u = np.linalg.eigh(A2 + np.diag(np.ones(A2.shape[<span class="number">0</span>]))*<span class="number">1e-3</span>)</span><br><span class="line">    s_sqrt_inv = np.linalg.inv(np.diag(np.sqrt(s)))</span><br><span class="line"></span><br><span class="line">    A = s_sqrt_inv.dot(u.T).dot(A1).dot(u).dot(s_sqrt_inv)</span><br><span class="line">    eigval, P = np.linalg.eigh(A)</span><br><span class="line">    eigvec = u.dot(s_sqrt_inv).dot(P)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> eigval, eigvec</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NeighborhoodPreservingEmbedding</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">""" Neighborhood Preserving Embedding</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Attributes:</span></span><br><span class="line"><span class="string">        n_neighbors:  &#123;int&#125;</span></span><br><span class="line"><span class="string">        n_components: &#123;int&#125;</span></span><br><span class="line"><span class="string">        W_: &#123;ndarray&#125; </span></span><br><span class="line"><span class="string">        components_:    &#123;ndarray(n_samples, n_components)&#125;</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n_neighbors, n_components=<span class="number">2</span>, k_skip=<span class="number">1</span>)</span>:</span></span><br><span class="line">        </span><br><span class="line">        self.n_neighbors  = n_neighbors</span><br><span class="line">        self.n_components = n_components</span><br><span class="line">        self.k_skip = k_skip</span><br><span class="line"></span><br><span class="line">        self.W_ = <span class="keyword">None</span></span><br><span class="line">        self.components_ = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        <span class="string">""" </span></span><br><span class="line"><span class="string">        Params:</span></span><br><span class="line"><span class="string">            X: &#123;ndarray(n_samples, n_features)&#125;</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KDTree</span><br><span class="line">        kdtree = KDTree(X, metric=<span class="string">'euclidean'</span>)</span><br><span class="line">        </span><br><span class="line">        n_samples, n_features = X.shape</span><br><span class="line">        self.W_ = np.zeros((n_samples, n_samples))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n_samples):</span><br><span class="line"></span><br><span class="line">            <span class="comment">## 获取近邻样本点</span></span><br><span class="line">            x = X[i]</span><br><span class="line">            idx = kdtree.query(x.reshape(<span class="number">1</span>, <span class="number">-1</span>), self.n_neighbors + <span class="number">1</span>, return_distance=<span class="keyword">False</span>)[<span class="number">0</span>][<span class="number">1</span>: ]</span><br><span class="line">            <span class="comment">## 求取矩阵 Z = (x - N).dot((x - N).T)</span></span><br><span class="line">            N = X[idx]</span><br><span class="line">            Z = (x - N).dot((x - N).T)</span><br><span class="line">            <span class="comment">## 求取权重 w_i</span></span><br><span class="line">            Z_inv = np.linalg.inv(Z + np.finfo(float).eps * np.eye(self.n_neighbors))</span><br><span class="line">            w = np.sum(Z_inv, axis=<span class="number">1</span>) / np.sum(Z_inv)</span><br><span class="line">            <span class="comment">## 保存至 W</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(self.n_neighbors):</span><br><span class="line">                self.W_[idx[j], i] = w[j]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">## 求取矩阵 M = (I - W)(I - W)^T</span></span><br><span class="line">        I = np.eye(n_samples)</span><br><span class="line">        M = (I - self.W_).dot((I - self.W_).T)</span><br><span class="line"></span><br><span class="line">        <span class="comment">## 求解 X M X^T \alpha = \lambda X X^T \alpha</span></span><br><span class="line">        A1 = X.T.dot(M).dot(X)</span><br><span class="line">        A2 = X.T.dot(X)</span><br><span class="line"></span><br><span class="line">        <span class="comment">## 求解拉普拉斯矩阵的特征分解</span></span><br><span class="line">        <span class="comment"># eps = np.finfo(float).eps * np.eye(A2.shape[0])</span></span><br><span class="line">        <span class="comment"># A  = np.linalg.inv(A2 + eps).dot(A1)</span></span><br><span class="line">        <span class="comment"># eigval, eigvec = np.linalg.eig(A)</span></span><br><span class="line">        <span class="comment"># 上三句改为</span></span><br><span class="line">        eigval, eigvec = eig(A1, A2)</span><br><span class="line"></span><br><span class="line">        eigvec = eigvec[:, np.argsort(eigval)]</span><br><span class="line">        eigval = eigval[np.argsort(eigval)]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">## 选取 D 维</span></span><br><span class="line">        self.components_ = eigvec[:, self.k_skip: self.n_components + self.k_skip]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transform</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        <span class="string">""" </span></span><br><span class="line"><span class="string">        Params:</span></span><br><span class="line"><span class="string">            X: &#123;ndarray(n_samples, n_features)&#125;</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            Y: &#123;ndarray(n_samples, n_components)&#125;</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        Y = X.dot(self.components_)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit_transform</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        <span class="string">""" </span></span><br><span class="line"><span class="string">        Params:</span></span><br><span class="line"><span class="string">            X: &#123;ndarray(n_samples, n_features)&#125;</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            Y: &#123;ndarray(n_samples, n_components)&#125;</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        self.fit(X)</span><br><span class="line">        Y = self.transform(X)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Y</span><br></pre></td></tr></table></figure><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"></span><br><span class="line">digits = datasets.load_digits(n_class=<span class="number">6</span>)</span><br><span class="line">X = digits.data</span><br><span class="line">y = digits.target</span><br><span class="line">images = digits.images</span><br><span class="line"></span><br><span class="line">npe = NeighborhoodPreservingEmbedding(<span class="number">30</span>, <span class="number">2</span>, k_skip=<span class="number">3</span>)</span><br><span class="line">X_npe = npe.fit_transform(X)</span><br><span class="line"></span><br><span class="line">plot_embedding(X_npe, y, images, title=<span class="keyword">None</span>, t=<span class="number">2e-3</span>, figsize=(<span class="number">12</span>, <span class="number">9</span>))</span><br></pre></td></tr></table></figure><p><img src="/2019/08/12/Neighborhood-Preserving-Embedding/Figure_1.png" alt="Figure_1"></p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 降维 </tag>
            
            <tag> manifold </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>挪威的森林</title>
      <link href="/2019/08/10/%E6%8C%AA%E5%A8%81%E7%9A%84%E6%A3%AE%E6%9E%97/"/>
      <url>/2019/08/10/%E6%8C%AA%E5%A8%81%E7%9A%84%E6%A3%AE%E6%9E%97/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/08/10/%E6%8C%AA%E5%A8%81%E7%9A%84%E6%A3%AE%E6%9E%97/挪威的森林/image.jpg" alt="挪威的森林"></p><blockquote><p>没有人喜欢孤独，只是不愿失望。</p></blockquote><ol><li>时至今日，我才恍然领悟到直子之所以求我别忘掉她的原因。直子当然知道，知道她在我心目中的记忆迟早要被冲淡。也惟其如此，她才强调说：希望你能记住我，记住我曾这样存在过。 想到这里，我就悲哀得难以自禁。因为，直子连爱都没爱过我的。</li><li>死并非生的对立面，而作为生的一部分永存。</li><li>或许我的心包有一层硬壳，能破壳而入的东西是极其有限的。所以我才不能对人一往情深。</li><li>他也背负着他的十字架匍匐在人生征途中。</li><li>那正是同被直子盯视眼睛时所感到的同一性质的悲哀。这种莫可名状的心绪，我既不能将其排遣于外，又不能将其深藏于内。它像掠身而去的阵风一样没有轮廓，没有重量。</li><li>这种莫可名状的心绪，我既不能将其排遣于外，又不能将其深藏于内。它像掠身而去的阵风一样没有轮廓，没有重量。我甚至连把它裹在身上都不可能。</li><li>“哪里会有人喜欢孤独！不过是不乱交朋友罢了。那样只能落得失望。”我说。</li><li>“绅士就是：所做的，不是自己想做之事，而是自己应做之事。”</li><li>说不定那时我们是为相遇而相遇的。纵令那时未能相遇，也会在别的地方相遇—倒没什么根据，但我总是有这种感觉。</li><li>也许等得过久了。我追求的是十二分完美无缺的东西，所以才这么难。</li><li>孤零零一个人，觉得身体就像一点点腐烂似的。渐渐腐烂、融化，最后变成一洼黏糊糊的绿色液体，再被吸进地底下去，剩下来的只是衣服—就是这种感觉，在干等一天的时间里。</li><li>每个人无不显得很幸福。至于他们是真的幸福还是仅仅表面看上去如此，就无从得知了。</li><li>什么是美好的以及如何获得幸福之类。对我毋宁说是个十分烦琐而错综复杂的命题，从而使我转求其他的标准，诸如公正、正直、普遍性等。”</li><li>倘若我在你心中留下什么创伤，那不仅仅是你一个人的，也是我的创伤。</li><li>所以如此，是因为什么，而它又意味什么，为什么等等。至于这种分析是将世界简单化还是条理化，我却是不明不白。</li><li>普通人啊。生在普通家庭，长在普通家庭，一张普通的脸，普通的成绩，想普通的事情。</li><li>人若要在某件事上扯谎，就势必为此编造出一大堆相关的谎言。</li><li>世界上，有人喜欢查时刻表一查就整整一天；也有的人把火柴棍拼在一起，准备造一艘一米长的船。所以说，这世上有一两个要理解你的人也没什么不自然的吧？</li><li>世上是有这种人的：尽管有卓越的天赋才华，却承受不住使之系统化的训练，而终归将才华支离破碎地挥霍掉。</li><li>现实世界里，很多方面人们都在互相强加，以邻为壑，否则就活不下去。</li><li>“那不是努力，只是劳动。”永泽断然说道，“我所说的努力与这截然不同。所谓努力，指的是主动而有目的的活动。”</li><li>就在这种气势夺人的暮色当中，我猛然想起了初美，并且这时才领悟她给我带来的心灵震颤究竟是什么东西—它类似一种少年时代的憧憬，一种从来不曾实现而且永远不可能实现的憧憬。这种直欲燃烧般的天真烂漫的憧憬，我在很早以前就已遗忘在什么地方了，甚至在很长时间里我连它曾在我心中存在过都未曾记起。而初美所摇撼的恰恰就是我身上长眠未醒的“我自身的一部分”。</li><li>“可爱极了！”<br>“绿子，”她说，“要加上名字。”<br>“可爱极了，绿子。”我补充道。<br>“极了是怎么个程度？”<br>“山崩海枯那样可爱。”<br>绿子扬着脸看着我：“你用词倒还不同凡响。”<br>“给你这么一说，我心里也暖融融的。”我笑道。<br>“来句更棒的。”<br>“最最喜欢你，绿子。”<br>“什么程度？”<br>“像喜欢春天的熊一样。”<br>“春天的熊？”绿子再次扬起脸，“什么春天的熊？”<br>“春天的原野里，你正一个人走着，对面走来一只可爱的小熊，浑身的毛活像天鹅绒，眼睛圆鼓鼓的。它这么对你说道：‘你好，小姐，和我一块打滚玩好么？’接着你就和小熊抱在一起，顺着长满三叶草的山坡咕噜咕噜滚下去，整整玩了一大天。你说棒不棒？”<br>“太棒了。”<br>“我就这么喜欢你。”</li><li>“喜欢我喜欢到什么程度？”绿子问。<br>“整个世界森林里的老虎全都融化成黄油。”</li><li>我则几乎没有抬头，日复一日地打发时光。在我眼里，只有漫无边际的泥沼。往前落下右脚，拔起左脚，再拔起右脚。我判断不出我位于何处，也不具有自己是在朝正确方向前进的信心。我之所以一步步挪动步履，只是因为我必须挪动，而无论去哪里。</li><li>在我眼里，春夜里的樱花，宛如从开裂的皮肤中鼓胀出来的烂肉，整个院子都充满烂肉那甜腻而沉闷的腐臭气味。</li><li>同情自己是卑劣懦夫干的勾当。</li><li>“饼干罐不是装有各种各样的饼干，喜欢的和不大喜欢的不都在里面吗？如果先一个劲儿地挑你喜欢的吃，那么剩下的就全是不大喜欢的。每次遇到麻烦我就总这样想：先把这个应付过去，往下就好过了。人生就是饼干罐。”</li><li>纵令听其自然，世事的长河也还是要流往其应流的方向，而即使再竭尽人力，该受伤害的人也无由幸免。所谓人生便是如此。</li><li>死并非生的对立面，死潜伏在我们的生之中。</li><li>“信终归不过是信。”我说，“即使烧了，该留在心里的自然留下；就算保存在那里，留不下来的照样留不下。”</li><li>我给绿子打电话，告诉她：自己无论如何都想和她说话，有满肚子话要说，有满肚子非说不可得话。整个世界上除了她别无他求。相见她想同她说话，两人一切从头开始。<br>绿子在电话的另一头久久默然不语，如同全世界的细雨落在全世界所有的草坪上一般的沉默在持续。这时间里，我一直合着双眼，把额头顶在电话亭玻璃上。良久，绿子用沉静的声音开口道：“你现在在哪里？”<br>我现在在哪里？<br>我拿着听筒扬起脸，飞快读环视电话亭四周。我现在在哪里？我不知道这里是哪里，全然摸不着头脑。这里究竟是哪里？目力所及，无不是不知走去哪里的无数男男女女。我在哪里也不是的场所的中央，不断地呼唤着绿子。 </li></ol>]]></content>
      
      
      <categories>
          
          <category> Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 村上春树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Locally Linear Embedding</title>
      <link href="/2019/08/09/Locally-Linear-Embedding/"/>
      <url>/2019/08/09/Locally-Linear-Embedding/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>高维数据可视化需要通过降维的方式，而PCA、LDA等线性降维算法，忽视了数据点间的空间结构特征，本文介绍的局部线性嵌入<code>(LLE)</code>算法为非线性降维方法，基于谱的降维方法，所以很靠谱 :-)。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>设有$M$个$N$维数据点，构成矩阵$X$，如下</p><script type="math/tex; mode=display">X = \left[ \begin{matrix} \vec{x}^{(1)} & \vec{x}^{(2)} & \cdots & \vec{x}^{(M)} \end{matrix} \right] \tag{1}</script><p>其中$\vec{x}^{(i)}$表示样本点向量</p><script type="math/tex; mode=display">\vec{x}^{(i)} = \left[ \begin{matrix} x^{(i)}_1 & x^{(i)}_2 & \cdots & x^{(i)}_3 \end{matrix} \right]^T \tag{2}</script><p><strong><code>LLE</code>的基本思路：</strong> 任一数据点$\vec{x}^{(i)}$可由其的$K$个近邻点$\mathcal{N}_K(\vec{x}^{(i)})$线性表出，可作为数据样本的结构特征，即</p><script type="math/tex; mode=display">\hat{\vec{x}}^{(i)} = \sum_{\vec{x}^{(j)} \in \mathcal{N}_K(\vec{x}^{(i)})} w_{ij} \vec{x}^{(j)} \tag{3.1}</script><p>其中</p><script type="math/tex; mode=display">\vec{w}_i = \left[ \begin{matrix} w_{i1} & w_{i2} & \cdots & w_{ik} \end{matrix} \right]^T</script><p>若$\vec{x}^{(i)}$映射到低维空间中对应特征点为$\vec{y}^{(i)}$，对相同参数$w_{ij}$，$\vec{x}^{(i)}$也可由其K个近邻点$\mathcal{N}_K(\vec{y}^{(i)})$表出，即</p><script type="math/tex; mode=display">\hat{\vec{y}}^{(i)} = \sum_{\vec{y}^{(j)} \in \mathcal{N}_K(\vec{y}^{(i)})} w_{ij} \vec{y}^{(j)} \tag{3.2}</script><h2 id="数据结构参数"><a href="#数据结构参数" class="headerlink" title="数据结构参数"></a>数据结构参数</h2><p>求解参数向量$\vec{w}_i$，可利用最小二乘法，即目标函数定义为</p><script type="math/tex; mode=display">J(\vec{w}_i) = || \vec{x}^{(i)} - \sum_{\vec{x}^{(j)} \in \mathcal{N}_K(\vec{x}^{(i)})} w_{ij} \vec{x}^{(j)} ||_2^2 \tag{4.1}</script><p>对参数向量$\vec{w}_i$归一化，即加入约束项</p><script type="math/tex; mode=display">\sum_{j=1}^K w_{ij} = 1 \quad \text{or} \quad \vec{w}_i^T \vec{1} = 1 \tag{4.2}</script><p>式$(4.1)$可作如下变换</p><script type="math/tex; mode=display">J(\vec{w}_i) = || \vec{x}^{(i)} - \sum_{\vec{x}^{(j)} \in \mathcal{N}_K(\vec{x}^{(i)})} w_{ij} \vec{x}^{(j)} ||_2^2</script><script type="math/tex; mode=display">= || \sum_{j=1}^K w_{ij} \vec{x}^{(i)} - \sum_{j=1}^K w_{ij} \vec{x}^{(j)} ||_2^2</script><script type="math/tex; mode=display">= || \sum_{j=1}^K w_{ij} (\vec{x}^{(i)} - \vec{x}^{(j)}) ||_2^2</script><script type="math/tex; mode=display">= || (X^{(i)} - N^{(i)}) \vec{w}_i ||_2^2 \tag{5.1}</script><p>其中</p><script type="math/tex; mode=display">X^{(i)} = \left[ \begin{matrix} \vec{x}^{(i)} & \vec{x}^{(i)} & \cdots & \vec{x}^{(i)} \end{matrix} \right] \tag{5.1.1}</script><script type="math/tex; mode=display">N^{(i)} = \left[ \begin{matrix} \vec{x}_N^{(1)} & \vec{x}_N^{(2)} & \cdots & \vec{x}_N^{(K)} \end{matrix} \right] \tag{5.1.2}</script><p>则</p><script type="math/tex; mode=display">J(\vec{w}_i) = || (X^{(i)} - N^{(i)}) \vec{w}_i ||_2^2 \tag{5.1}</script><script type="math/tex; mode=display">= \left[ (X^{(i)} - N^{(i)}) \vec{w}_i \right]^T \left[ (X^{(i)} - N^{(i)}) \vec{w}_i \right]</script><script type="math/tex; mode=display">= \vec{w}_i^T (X^{(i)} - N^{(i)})^T (X^{(i)} - N^{(i)}) \vec{w}_i \tag{5.2}</script><p>记矩阵</p><script type="math/tex; mode=display">Z^{(i)}_{K \times K} = (X^{(i)} - N^{(i)})^T (X^{(i)} - N^{(i)}) \tag{5.3}</script><p>最终优化目标为</p><script type="math/tex; mode=display">J(\vec{w}_i) = \vec{w}_i^T Z^{(i)} \vec{w}_i \tag{*1}</script><script type="math/tex; mode=display">\text{s.t.} \quad \vec{w}_i^T \vec{1} = 1</script><p>利用拉格朗日乘子法，构造拉格朗日函数，有</p><script type="math/tex; mode=display">L(\vec{w}_i) = \vec{w}_i^T Z^{(i)} \vec{w}_i + \lambda (\vec{w}_i^T \vec{1} - 1) \tag{6.1}</script><p>则</p><script type="math/tex; mode=display">\begin{cases}    \frac{\nabla L(\vec{w}_i)}{\nabla \vec{w}_i} = 2 Z^{(i)} \vec{w}_i  + \lambda \vec{1} = \vec{0} \\    \frac{\nabla L(\vec{w}_i)}{\nabla \lambda} = \vec{w}_i^T \vec{1} - 1 = 0\end{cases} \tag{6.2}</script><p>由式$1$得到</p><script type="math/tex; mode=display">\vec{w}_i = - \frac{\lambda}{2} Z^{(i)-1} \vec{1} \tag{6.3}</script><p>代入式$2$有</p><script type="math/tex; mode=display">\left( - \frac{\lambda}{2} Z^{(i)-1} \vec{1} \right)^T \vec{1} = 1 \tag{6.4}</script><p>解得</p><script type="math/tex; mode=display">\lambda = - \frac{2}{\vec{1}^T Z^{(i)-1} \vec{1}} \tag{6.5}</script><p>代回$(6.3)$得到</p><script type="math/tex; mode=display">\vec{w}_i = \frac{Z^{(i)-1} \vec{1}}{\vec{1}^T Z^{(i)-1} \vec{1}} \tag{*2}</script><h2 id="低维数据的求解"><a href="#低维数据的求解" class="headerlink" title="低维数据的求解"></a>低维数据的求解</h2><p>由式$(3.2)$，即</p><script type="math/tex; mode=display">\hat{\vec{y}}^{(i)} = \sum_{\vec{y}^{(j)} \in \mathcal{N}_K(\vec{y}^{(i)})} \dot{w}_{ij} \vec{y}^{(j)} \tag{3.2}</script><p>同样的，利用最小二乘法，构建目标函数为</p><script type="math/tex; mode=display">J(Y) = \sum_{i=1}^M || \vec{y}^{(i)} - \sum_{\vec{y}^{(j)} \in \mathcal{N}_K(\vec{y}^{(i)})} \dot{w}_{ij} \vec{y}^{(j)} ||_2^2 \tag{7.1}</script><p>对低维数据进行标准化，即加入约束</p><script type="math/tex; mode=display">\begin{cases}    \sum_{i=1}^M \vec{y}^{(i)} = \vec{0} \\    \frac{1}{M} \sum_{i=1}^M \vec{y}^{(i)} \vec{y}^{(i)T} = I\end{cases} \tag{7.2}</script><p>矩阵形式为</p><script type="math/tex; mode=display">Y Y^T = M·I \tag{7.3}</script><p>由于当前数据点具体分布未知，故$\vec{y}^{(i)}$的近邻点$\mathcal{N}_K(\vec{y}^{(i)})$无法得知，故将矩阵$W_{M \times K}$补全为矩阵$\dot{W}_{M \times M}$，即</p><script type="math/tex; mode=display">\dot{w}_{ij} = \begin{cases}    w_{ik}  & x^{(j)} = N^{(i)}_k \\    0       & \text{otherwise}\end{cases} \tag{8}</script><blockquote><p>相当于邻接矩阵。</p></blockquote><p>同样的，$\vec{y}^{(i)}$也需在维度上进行补全为$\dot{\vec{y}}^{(i)}$，记</p><script type="math/tex; mode=display">\dot{Y}_{M \times M} = \left[ \begin{matrix} \dot{\vec{y}}^{(1)} & \dot{\vec{y}}^{(2)} & \cdots & \dot{\vec{y}}^{(M)} \end{matrix} \right] \tag{9}</script><p>则</p><script type="math/tex; mode=display">J(\dot{Y}) = \sum_{i=1}^M || \dot{\vec{y}}^{(i)} - \sum_{\dot{\vec{y}}^{(j)} \in \mathcal{N}_K(\dot{\vec{y}}^{(i)})} \dot{w}_{ij} \dot{\vec{y}}^{(j)} ||_2^2 \tag{7.1}</script><script type="math/tex; mode=display">= \sum_{i=1}^M || \dot{Y} \vec{1}_i - \dot{Y} \dot{\vec{w}_i} ||_2^2 = \sum_{i=1}^M || \dot{Y} (\vec{1}_i - \dot{\vec{w}_i}) ||_2^2 \tag{10.1}</script><script type="math/tex; mode=display">= \text{tr} \left[ \dot{Y} (I - \dot{W}) (I - \dot{W})^T \dot{Y}^T \right] \tag{10.2}</script><blockquote><script type="math/tex; mode=display">(10.1) \rightarrow (10.2): \mathcal{WTF}</script></blockquote><p>实际上</p><blockquote><p>由于</p><script type="math/tex; mode=display">d_i = \sum_{j=1}^M \dot{w}_{ij} = 1</script><p>所以由拉普拉斯矩阵定义</p><script type="math/tex; mode=display">L = D - W</script><p>$I - \dot{W}$即邻接矩阵$\dot{W}$的拉普拉斯矩阵。</p></blockquote><p>其中</p><script type="math/tex; mode=display">\vec{1}_i = \left[ \begin{matrix} 0 & \cdots & 1_i & \cdots & 0 \end{matrix} \right]^T</script><script type="math/tex; mode=display">I = \left[\begin{matrix}    1 &         &   \\      & \cdots  &   \\      &         & 1 \end{matrix}\right]</script><p>记$A = (I - \dot{W}) (I - \dot{W})^T$, 最终优化目标为</p><script type="math/tex; mode=display">J(\dot{Y}) = \text{tr} \left[ \dot{Y} A \dot{Y}^T \right] \tag{*3}</script><script type="math/tex; mode=display">\text{s.t.} \quad \dot{Y} \dot{Y}^T = M·I</script><p>构造拉格朗日函数</p><script type="math/tex; mode=display">L(\dot{Y}) = \text{tr} \left[ \dot{Y} A \dot{Y}^T \right] + \lambda (\dot{Y} \dot{Y}^T - M · I) \tag{11}</script><script type="math/tex; mode=display">\begin{cases}    \frac{\nabla L(\dot{Y})}{\nabla \dot{Y}} = 2 A \dot{Y}^T + 2 \lambda \dot{Y}^T = 0 \\    \frac{\nabla L(\dot{Y})}{\nabla \lambda} = \dot{Y} \dot{Y}^T - M · I = 0\\\end{cases}</script><blockquote><script type="math/tex; mode=display">\frac{\nabla \text{tr}[F(\vec{x})]}{\nabla \vec{x}} = f(\vec{x})^T</script></blockquote><p>注意$1$式，可变换为</p><script type="math/tex; mode=display">A \dot{Y}^T = \hat{\lambda} \dot{Y}^T \tag{12.1}</script><p>其中$\hat{\lambda} = - \lambda$，又$\dot{Y} \dot{Y}^T = M·I$，为<strong>正交相似变换</strong>，所以</p><script type="math/tex; mode=display">\dot{Y}^T = P = \left[ \begin{matrix} \vec{\alpha}_1 & \vec{\alpha}_2 & \cdots & \vec{\alpha}_M \end{matrix} \right] \tag{12.2}</script><p>由于最小化目标为</p><script type="math/tex; mode=display">J(\dot{Y}) = \text{tr} \left[ \dot{Y} A \dot{Y}^T \right] = \text{tr} (\Lambda) = \sum_{i=1}^M \lambda_i</script><p>故选择最小的特征值$\lambda_i$及其对应的特征向量$\alpha_i$，要得到$D$维数据集，将$\dot{Y}^T$进行约化，即</p><script type="math/tex; mode=display">Y^T = \left[ \begin{matrix} \vec{\alpha}_{M + 1 - D} & \cdots & \vec{\alpha}_M \end{matrix} \right] \tag{13}</script><p>由于$\vec{w}_i^T \vec{1} = 1$，即</p><script type="math/tex; mode=display">\dot{W}^T \vec{1} = \vec{1} \tag{14.1}</script><p>移项整理得</p><script type="math/tex; mode=display">(\dot{W} - I)^T \vec{1} = \vec{0}</script><p>$\vec{1} \neq \vec{0}$，所以</p><script type="math/tex; mode=display">(\dot{W} - I)^T = 0 \tag{14.2}</script><p>左边同乘$\dot{W} - I$得到</p><script type="math/tex; mode=display">(\dot{W} - I) (\dot{W} - I)^T \vec{1} = A · \vec{1} = 0 · \vec{1} \tag{14.3}</script><p>所以</p><script type="math/tex; mode=display">\lambda_M = 0, \quad \alpha_M = \vec{1} \tag{14.4}</script><p>特征值为$0$表示不能反映数据特征，故低维数据应为</p><script type="math/tex; mode=display">Y^T = \left[ \begin{matrix} \vec{\alpha}_{M - D} & \cdots & \vec{\alpha}_{M-1} \end{matrix} \right] \tag{*4}</script><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><ol><li><p>计算原始样本空间中，每个样本$x^{(i)}$的近邻点$N^{(i)}$，并求取权值$w_{ij}$作为邻接权重，存储为矩阵$\dot{W}_{M \times M}$；</p><script type="math/tex; mode=display">Z^{(i)}_{K \times K} = (X^{(i)} - N^{(i)})^T (X^{(i)} - N^{(i)}) \tag{5.3}</script><script type="math/tex; mode=display">\vec{w}_i = \frac{Z^{(i)-1} \vec{1}}{\vec{1}^T Z^{(i)-1} \vec{1}} \tag{*2}</script><script type="math/tex; mode=display"> \dot{w}_{ij} =  \begin{cases}     w_{ik}  & x^{(j)} = N^{(i)}_k \\     0       & \text{otherwise} \end{cases} \tag{8}</script></li><li><p>求取矩阵$A$，并将其特征分解</p><script type="math/tex; mode=display">A = (I - \dot{W}) (I - \dot{W})^T</script><script type="math/tex; mode=display">A \dot{Y}^T = \hat{\lambda} \dot{Y}^T \tag{12.1}</script></li><li><p>选择最小的特征值$\lambda_i$及其对应的特征向量$\alpha_i$，约化为$D$维数据，作为低维特征点</p><script type="math/tex; mode=display">Y^T = \left[ \begin{matrix} \vec{\alpha}_{M - D} & \cdots & \vec{\alpha}_{M-1} \end{matrix} \right] \tag{*4}</script></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocallyLinearEmbedding</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">""" Locally Linear Embedding</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Attributes:</span></span><br><span class="line"><span class="string">        n_neighbors:  &#123;int&#125;</span></span><br><span class="line"><span class="string">        n_components: &#123;int&#125;</span></span><br><span class="line"><span class="string">        W: &#123;ndarray&#125; </span></span><br><span class="line"><span class="string">            $$ W = \left[ \begin&#123;matrix&#125; w_1 &amp; w_2 &amp; \cdots &amp; w_&#123;n_samples&#125; \end&#123;matrix&#125; \right] $$</span></span><br><span class="line"><span class="string">            $$ w_i = \left[ \begin&#123;matrix&#125; w_&#123;i1&#125; &amp; w_&#123;i2&#125; &amp; \cdots &amp; w_&#123;i, n_samples&#125; \end&#123;matrix&#125; \right]^T $$</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n_neighbors, n_components=<span class="number">2</span>)</span>:</span></span><br><span class="line">        </span><br><span class="line">        self.n_neighbors  = n_neighbors</span><br><span class="line">        self.n_components = n_components</span><br><span class="line">        self.W = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        <span class="string">""" </span></span><br><span class="line"><span class="string">        Params:</span></span><br><span class="line"><span class="string">            X: &#123;ndarray(n_samples, n_features)&#125;</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            W: &#123;ndarray(n_samples, n_samples)&#125;</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KDTree</span><br><span class="line">        kdtree = KDTree(X, metric=<span class="string">'euclidean'</span>)</span><br><span class="line">        </span><br><span class="line">        n_samples, n_features = X.shape</span><br><span class="line">        self.W = np.zeros((n_samples, n_samples))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n_samples):</span><br><span class="line"></span><br><span class="line">            <span class="comment">## 获取近邻样本点</span></span><br><span class="line">            x = X[i]</span><br><span class="line">            idx = kdtree.query(x.reshape(<span class="number">1</span>, <span class="number">-1</span>), self.n_neighbors + <span class="number">1</span>, return_distance=<span class="keyword">False</span>)[<span class="number">0</span>][<span class="number">1</span>: ]</span><br><span class="line">            <span class="comment">## 求取矩阵 Z = (x - N).dot((x - N).T)</span></span><br><span class="line">            N = X[idx]</span><br><span class="line">            Z = (x - N).dot((x - N).T)</span><br><span class="line">            <span class="comment">## 求取权重 w_i</span></span><br><span class="line">            Z_inv = np.linalg.inv(Z + np.finfo(float).eps * np.eye(self.n_neighbors))</span><br><span class="line">            w = np.sum(Z_inv, axis=<span class="number">1</span>) / np.sum(Z_inv)</span><br><span class="line">            <span class="comment">## 保存至 W</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(self.n_neighbors):</span><br><span class="line">                self.W[idx[j], i] = w[j]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.W</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transform</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        <span class="string">""" </span></span><br><span class="line"><span class="string">        Params:</span></span><br><span class="line"><span class="string">            X: &#123;ndarray(n_samples, n_features)&#125;</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            Y: &#123;ndarray(n_samples, n_components)&#125;</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n_samples, n_features = X.shape</span><br><span class="line"></span><br><span class="line">        <span class="comment">## 求取矩阵 A = (I - W)(I - W)^T</span></span><br><span class="line">        I = np.eye(n_samples)</span><br><span class="line">        A = (I - self.W).dot((I - self.W).T)</span><br><span class="line"></span><br><span class="line">        <span class="comment">## 对 A 进行特征分解，并按特征值升序排序</span></span><br><span class="line">        eigval, eigvec = np.linalg.eig(A)</span><br><span class="line">        eigvec = eigvec[:, np.argsort(eigval)]</span><br><span class="line"></span><br><span class="line">        <span class="comment">## 选取 D 维</span></span><br><span class="line">        k_skip = <span class="number">1</span></span><br><span class="line">        Y = eigvec[:, k_skip: self.n_components + k_skip]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit_transform</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        <span class="string">""" </span></span><br><span class="line"><span class="string">        Params:</span></span><br><span class="line"><span class="string">            X: &#123;ndarray(n_samples, n_features)&#125;</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            Y: &#123;ndarray(n_samples, n_components)&#125;</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        self.fit(X)</span><br><span class="line">        Y = self.transform(X)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Y</span><br></pre></td></tr></table></figure><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>在<code>scikit learn</code>官网有具体实现<a href="https://scikit-learn.org/stable/auto_examples/manifold/plot_lle_digits.html#sphx-glr-auto-examples-manifold-plot-lle-digits-py" target="_blank" rel="noopener">基于手写数据集的几种基于谱的降维方法对比</a>。</p><p><img src="/2019/08/09/Locally-Linear-Embedding/sklearn.png" alt="sphx_glr_plot_lle_digits_008"></p><p>以下为上述代码实现的结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets  <span class="keyword">import</span> load_digits</span><br><span class="line"></span><br><span class="line">digits = load_digits(n_class=<span class="number">6</span>)</span><br><span class="line">X = digits.data</span><br><span class="line">y = digits.target</span><br><span class="line">images = digits.images</span><br><span class="line"></span><br><span class="line">lle = LocallyLinearEmbedding(<span class="number">30</span>, <span class="number">2</span>)</span><br><span class="line">X_lle = lle.fit_transform(X)</span><br><span class="line"></span><br><span class="line">plot_embedding(X_lle, y, images, title=<span class="keyword">None</span>, t=<span class="number">2e-3</span>, figsize=(<span class="number">12</span>, <span class="number">9</span>))</span><br></pre></td></tr></table></figure></p><p><img src="/2019/08/09/Locally-Linear-Embedding/custom.png" alt="custom"></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.jianshu.com/p/25a2a47bb60b" target="_blank" rel="noopener">(十二)LLE局部线性嵌入降维算法 - 简书</a></li><li><a href="https://scikit-learn.org/stable/modules/manifold.html#locally-linear-embedding" target="_blank" rel="noopener">2.2.3. Locally Linear Embedding - scikit learn</a></li><li><a href="https://cs.nyu.edu/~roweis/lle/papers/lleintro.pdf" target="_blank" rel="noopener">An Introduction to Locally Linear Embedding</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 降维 </tag>
            
            <tag> manifold </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git工具-submodules</title>
      <link href="/2019/08/09/Git%E5%B7%A5%E5%85%B7-submodules/"/>
      <url>/2019/08/09/Git%E5%B7%A5%E5%85%B7-submodules/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>当需要在一个项目中使用另一个项目时，可以将后者作为子模块加入前者。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="新建带子模块的仓库"><a href="#新建带子模块的仓库" class="headerlink" title="新建带子模块的仓库"></a>新建带子模块的仓库</h2><p>例如在本地新建仓库<code>Repository</code><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir Repository &amp;&amp; <span class="built_in">cd</span> Repository</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line">Initialized empty Git repository in C:/Users/islou/Desktop/Repository/.git/</span><br></pre></td></tr></table></figure></p><p>若在本仓库中，需要使用该仓库<a href="https://github.com/isLouisHsu/Games" target="_blank" rel="noopener">isLouisHsu/Games</a><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git submodule add https://github.com/isLouisHsu/Games</span></span><br><span class="line">Cloning into 'C:/Users/islou/Desktop/Repository/Games'...</span><br><span class="line">remote: Enumerating objects: 30, done.</span><br><span class="line">remote: Counting objects: 100% (30/30), done.</span><br><span class="line">remote: Compressing objects: 100% (27/27), done.</span><br><span class="line">remote: Total 30 (delta 5), reused 0 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (30/30), done.</span><br></pre></td></tr></table></figure></p><p>在当前仓库<code>Repository</code>中可以看到生成了文件<code>.gitmodules</code>与子仓库<code>Games</code>，<code>.gitmodules</code>内容如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[submodule &quot;Games&quot;]</span><br><span class="line">path &#x3D; Games</span><br><span class="line">url &#x3D; https:&#x2F;&#x2F;github.com&#x2F;isLouisHsu&#x2F;Games</span><br></pre></td></tr></table></figure></p><p>此时，若在当前仓库查询状态，显示更改内容<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use "git rm --cached &lt;file&gt;..." to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   .gitmodules</span><br><span class="line">        new file:   Games</span><br><span class="line"><span class="meta">$</span><span class="bash"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> Games</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with 'origin/master'.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure></p><h2 id="克隆带子仓库的模块"><a href="#克隆带子仓库的模块" class="headerlink" title="克隆带子仓库的模块"></a>克隆带子仓库的模块</h2><ol><li><p>方法1</p><p> 克隆这类仓库时，默认包含该子模块目录，但其中没有文件，需要在仓库目录下运行</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git submodule init</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git submodule update</span></span><br></pre></td></tr></table></figure><p> <code>git submodule init</code> 用来初始化本地配置文件，而 <code>git submodule update</code> 则从该项目中抓取所有数据并检出父项目中列出的合适的提交</p></li><li><p>方法2</p><p> 直接使用<code>--recursive</code>参数，自动初始化并更新仓库中的每一个子模块</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> --recursive https://github.com/louishsu/Repository</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97" target="_blank" rel="noopener">7.11 Git工具-子模块 - git</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python生成Markdown表格</title>
      <link href="/2019/08/09/Python%E7%94%9F%E6%88%90Markdown%E8%A1%A8%E6%A0%BC/"/>
      <url>/2019/08/09/Python%E7%94%9F%E6%88%90Markdown%E8%A1%A8%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><h1 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h1><p>Markdown中编辑表格比较繁琐，如编辑下表时，需要按字符输入</p><div class="table-container"><table><thead><tr><th style="text-align:center">姓名\科目</th><th>A</th><th>B</th><th>C</th><th>D</th></tr></thead><tbody><tr><td style="text-align:center">小妖</td><td>3</td><td>4</td><td>5</td><td>3</td></tr><tr><td style="text-align:center">小怪</td><td>4</td><td>5</td><td>3</td><td>4</td></tr><tr><td style="text-align:center">小兽</td><td>5</td><td>3</td><td>4</td><td>5</td></tr></tbody></table></div><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 姓名\科目 | A | B | C | D |</span><br><span class="line">| :------: | - | - | - | - |</span><br><span class="line">| 小妖     | 3 | 4 | 5 | 3 |</span><br><span class="line">| 小怪     | 4 | 5 | 3 | 4 |</span><br><span class="line">| 小兽     | 5 | 3 | 4 | 5 |</span><br></pre></td></tr></table></figure><p>可借助字符串操作生成表格。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_markdown_table_2d</span><span class="params">(head_name, rows_name, cols_name, data)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Params:</span></span><br><span class="line"><span class="string">        head_name: &#123;str&#125; 表头名， 如"count\比例"</span></span><br><span class="line"><span class="string">        rows_name, cols_name: &#123;list[str]&#125; 项目名， 如 1,2,3</span></span><br><span class="line"><span class="string">        data: &#123;ndarray(H, W)&#125;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        table: &#123;str&#125;</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    ELEMENT = <span class="string">" &#123;&#125; |"</span></span><br><span class="line"></span><br><span class="line">    H, W = data.shape</span><br><span class="line">    LINE = <span class="string">"|"</span> + ELEMENT * W</span><br><span class="line">    </span><br><span class="line">    lines = []</span><br><span class="line"></span><br><span class="line">    <span class="comment">## 表头部分</span></span><br><span class="line">    lines += [<span class="string">"| &#123;&#125; | &#123;&#125; |"</span>.format(head_name, <span class="string">' | '</span>.join(cols_name))]</span><br><span class="line"></span><br><span class="line">    <span class="comment">## 分割线</span></span><br><span class="line">    SPLIT = <span class="string">"&#123;&#125;:"</span></span><br><span class="line">    line = <span class="string">"| &#123;&#125; |"</span>.format(SPLIT.format(<span class="string">'-'</span>*len(head_name)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(W):</span><br><span class="line">        line = <span class="string">"&#123;&#125; &#123;&#125; |"</span>.format(line, SPLIT.format(<span class="string">'-'</span>*len(cols_name[i])))</span><br><span class="line">    lines += [line]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">## 数据部分</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(H):</span><br><span class="line">        d = list(map(str, list(data[i])))</span><br><span class="line">        lines += [<span class="string">"| &#123;&#125; | &#123;&#125; |"</span>.format(rows_name[i], <span class="string">' | '</span>.join(d))]</span><br><span class="line"></span><br><span class="line">    table = <span class="string">'\n'</span>.join(lines)</span><br><span class="line">    <span class="keyword">return</span> table</span><br></pre></td></tr></table></figure><p>终端中运行<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; import numpy as np</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; from temp import gen_markdown_table_2d</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; head_name = <span class="string">"姓名\\科目"</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; rows_name = [<span class="string">"小妖"</span>, <span class="string">"小怪"</span>, <span class="string">"小兽"</span>]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; cols_name = [<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; data = np.arange(4*3).reshape(3, 4)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; table = gen_markdown_table_2d(head_name, rows_name, cols_name, data)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; table</span></span><br><span class="line">'| 姓名\\科目 | A | B | C | D |\n| -----: | -: | -: | -: | -: |\n| 小妖 | 0 | 1 | 2 | 3 |\n| 小怪 | 4 | 5 | 6 | 7 |\n|  小兽 | 8 | 9 | 10 | 11 |'</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(table)</span></span><br><span class="line">| 姓名\科目 | A | B | C | D |</span><br><span class="line">| -----: | -: | -: | -: | -: |</span><br><span class="line">| 小妖 | 0 | 1 | 2 | 3 |</span><br><span class="line">| 小怪 | 4 | 5 | 6 | 7 |</span><br><span class="line">| 小兽 | 8 | 9 | 10 | 11 |</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自动化脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ID3, C4.5, CART, RF</title>
      <link href="/2019/08/02/ID3-C4-5-CART-RF/"/>
      <url>/2019/08/02/ID3-C4-5-CART-RF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>决策树(Decision Tree)是一种基本的分类与回归方法，本文主要讨论分类决策树，它可被认作<code>if-then</code>的集合，也可以认作是定义在特征空间与类空间上的条件概率分布。</p><h1 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h1><p>决策树模型形式如下，由结点<code>(node)</code>，有向边<code>(directed edge)</code>组成，节点包含两种：内部节点<code>(internal node)</code>和叶节点<code>(leaf node)</code>，内部节点表示一个特征或属性，叶节点包含一个类。</p><p><img src="/2019/08/02/ID3-C4-5-CART-RF/model.jfif" alt="model"></p><p>决策树需要满足一个重要性质：互斥且完备。即每个实例<strong>都被且仅被</strong>一条路径或一条<code>if-then</code>规则覆盖。并且生成的决策树深度不能过大。</p><p>决策树学习主要有3个步骤： 特征选择、决策树生成、决策树修剪。</p><h2 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h2><p>现以下某贷款申请样本数据表为例进行解释说明。</p><div class="table-container"><table><thead><tr><th>ID</th><th>年龄</th><th>工作</th><th>有房</th><th>信贷情况</th><th>类别</th></tr></thead><tbody><tr><td>1</td><td>青年</td><td>否</td><td>否</td><td>一般</td><td>否</td></tr><tr><td>2</td><td>青年</td><td>否</td><td>否</td><td>好</td><td>否</td></tr><tr><td>3</td><td>青年</td><td>是</td><td>否</td><td>好</td><td>是</td></tr><tr><td>4</td><td>青年</td><td>是</td><td>是</td><td>一般</td><td>是</td></tr><tr><td>5</td><td>青年</td><td>否</td><td>否</td><td>一般</td><td>否</td></tr><tr><td>6</td><td>中年</td><td>否</td><td>否</td><td>一般</td><td>否</td></tr><tr><td>7</td><td>中年</td><td>否</td><td>否</td><td>好</td><td>否</td></tr><tr><td>8</td><td>中年</td><td>是</td><td>是</td><td>好</td><td>是</td></tr><tr><td>9</td><td>中年</td><td>否</td><td>是</td><td>非常好</td><td>是</td></tr><tr><td>10</td><td>中年</td><td>否</td><td>是</td><td>非常好</td><td>是</td></tr><tr><td>11</td><td>老年</td><td>否</td><td>是</td><td>非常好</td><td>是</td></tr><tr><td>12</td><td>老年</td><td>否</td><td>是</td><td>好</td><td>是</td></tr><tr><td>13</td><td>老年</td><td>是</td><td>否</td><td>好</td><td>是</td></tr><tr><td>14</td><td>老年</td><td>是</td><td>否</td><td>非常好</td><td>是</td></tr><tr><td>15</td><td>老年</td><td>否</td><td>否</td><td>一般</td><td>否</td></tr></tbody></table></div><h2 id="符号说明"><a href="#符号说明" class="headerlink" title="符号说明"></a>符号说明</h2><p>设数据集为$D$，$|D|$表示样本总数。设有$K$个类别$C_k(k=1, \cdots, K)$，$|C_k|$为类别$k$的样本数目，那么</p><script type="math/tex; mode=display">|D| = \sum_{k=1}^K |C_k|</script><p>设特征$A$有$N$个不同的取值${a_1, a_2, \cdots, a_N}$，则根据不同的取值，可将数据集$D$划分为$N$组${D_1, D_2, \cdots, D_N}$，也有</p><script type="math/tex; mode=display">|D| = \sum_{n=1}^N |D_n|</script><p>记子集$D_n$中属于类别$C_k$的样本集合为$D_{nk}$，即</p><script type="math/tex; mode=display">D_{nk} = D_n \bigcap C_k</script><h2 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h2><p>在某个内部节点上，需要选择最具有代表性，或区分度最高的特征。可选用的准则有信息增益（条件熵）、基尼系数等。</p><ol><li><p>ID3：以<strong>信息增益</strong>为准则来选择最优划分属性</p><p> <strong>定义(信息增益)</strong>：特征$A$对训练数据集$D$的信息增益$g(D, A)$，定义为集合$D$的经验熵$H(D)$与特征A给定条件下$D$的经验条件熵$H(D|A)$之差，即</p><script type="math/tex; mode=display">g(D, A) = H(D) - H(D|A) \tag{1.1}</script><p> 等价于训练数据集中类与特征的<strong>互信息</strong><code>(mutual information)</code>，表示<strong>得知特征$A$的信息对数据集$D$分类的不确定性减少的程度。</strong></p><p> 其中</p><script type="math/tex; mode=display">H(D) = - \sum_{k=1}^K \frac{|C_k|}{|D|} \log_2 \frac{|C_k|}{|D|} \tag{1.2}</script><p> 上式即，<strong>类别分布的经验熵</strong></p><script type="math/tex; mode=display"> H(D|A) = \sum_{n=1}^N \frac{|D_n|}{|D|} H(D_n)  = \sum_{n=1}^N \frac{|D_n|}{|D|} \underbrace{     - \sum_{k=1}^K \frac{|D_{nk}|}{|D_n|} \log_2 \frac{|D_{nk}|}{|D_n|} }_{H(D_n)} \tag{1.3}</script><p> 上式即，<strong>以特征$A$不同取值进行子集划分，每个子集的类别分布经验熵，求取加权和</strong></p></li></ol><blockquote><p>注：</p><ol><li><p>熵</p><ul><li><p>连续</p><script type="math/tex; mode=display">H(X) = - \int_x p(x) \log p(x) dx</script></li><li><p>离散</p><script type="math/tex; mode=display">H(X) = - \sum_x p(x) \log p(x)</script></li></ul></li><li><p>条件熵</p><script type="math/tex; mode=display">\begin{aligned}H(X|Y) = H(X, Y) - H(Y) \\= (- \sum_{x, y} p(x, y) \log p(x, y)) - (- \sum_y p(y) \log p(y)) \\= - \sum_{x, y} p(x, y) \log p(x, y) + \sum_x (\sum_y p(x, y)) \log p(y) \\= - \sum_{x, y} p(x, y) (\log p(x, y) - \log p(y)) \\= - \sum_{x, y} p(x, y) \log \frac{p(x, y)}{p(y)} \\= - \sum_{x, y} p(x, y) \log p(x | y)\end{aligned}</script></li><li><p>互信息<br>一般地，熵$H(Y)$与条件熵$H(Y|X)$之差称为互信息<code>(mutual information)</code>。</p><script type="math/tex; mode=display">I(X; Y) = H(X) - H(X | Y)</script><p>也即</p><script type="math/tex; mode=display">\begin{aligned}   I(X; Y) = H(X) + H(Y) - H(X, Y) \\   I(X; Y) = I(Y; X)\end{aligned}</script><p>由定义可得</p><script type="math/tex; mode=display">I(X; Y) = \sum_{x, y} p(x, y) \log \frac{p(x, y)}{p(x) p(y)}</script></li></ol></blockquote><ol><li><p>C4.5：基于<strong>信息增益率准则</strong>选择最优分割属性的算法</p><p> 是对<code>ID3</code>的改进：</p><ul><li>以<strong>信息增益比</strong><code>(information gain ratio)</code>作为特征选择的准则，克服<code>ID3</code>会优先选择有较多属性值的特征的缺点；<blockquote><p>属性值较多的特征，可将$D$划分为更多子集，计算得信息增益更大；信息增益比引入特征数据分布的衡量，对于两个相同信息增益的特征，选择特征数据分布更为集中的，划分更有效。</p></blockquote></li><li><p>弥补不能处理特征属性值连续的问题</p><script type="math/tex; mode=display">g_R(D, A) = \frac{g(D, A)}{H_A(D)} \tag{2.1}</script><p>其中$H_A(D)$为<strong>特征$A$取值的的分布经验熵</strong></p><script type="math/tex; mode=display">H_A(D) = - \sum_{n=1}^N \frac{|D_n|}{|D|} \log_2 \frac{|D_n|}{|D|} \tag{2.2}</script></li></ul></li><li><p>CART：以<strong>基尼系数</strong>为准则选择最优划分属性，可以应用于分类和回归</p><blockquote><p>基尼不纯度可以解释为：一个随机事件变成它的对立事件的概率，可以作为衡量系统混乱程度的标准。</p></blockquote><p> 由L.Breiman,J.Friedman,R.Olshen和C.Stone于1984年提出。ID3中根据属性值分割数据，之后该特征不会再起作用，这种快速切割的方式会影响算法的准确率。<strong>CART是一棵二叉树，采用二元切分法，每次把数据切成两份，分别进入左子树、右子树</strong>。而且每个非叶子节点都有两个孩子，所以CART的叶子节点比非叶子多1。相比ID3和C4.5，CART应用要多一些，既可以用于分类也可以用于回归。</p><p> <strong>定义(基尼系数)</strong>：分类问题中，假设有$K$个类别，样本点属于第$k$类的概率为$p_k$，则基尼系数定义为</p><script type="math/tex; mode=display">\text{Gini}(p) = \sum_{k=1}^K p_k (1 - p_k) = 1 - \sum_{k=1}^K p_k^2 \tag{3.1}</script><ul><li><p>分类树</p><p>  特征选择准则为</p><script type="math/tex; mode=display">g_G(D, A) = \text{Gini}(D) - \text{Gini}(D|A)  \tag{3.2}</script><p>  其中</p><script type="math/tex; mode=display">\text{Gini}(D) = 1 - \sum_{k=1}^K \left( \frac{|C_k|}{|D|} \right)^2 \tag{3.3}</script><script type="math/tex; mode=display">\text{Gini}(D|A) = \sum_{n=1}^N \frac{|D_n|}{|D|} \text{Gini}(D_n) = \sum_{n=1}^N \frac{|D_n|}{|D|} \left[ 1 - \sum_{k=1}^K \left( \frac{|D_{nk}|}{|D_n|} \right)^2 \right] \tag{3.4}</script></li><li><p>回归树</p><p>  寻找最佳切分点，将输入空间划分为多个区域。</p></li></ul></li></ol><h2 id="引例求解"><a href="#引例求解" class="headerlink" title="引例求解"></a>引例求解</h2><p>以求解在<a href="#%e5%bc%95%e4%be%8b">引例</a>的第一个内部节点为例，选用信息增益作为分类特征。</p><p>类别标签有两种</p><script type="math/tex; mode=display">D.y = \{ 是， 否 \}</script><p>则</p><script type="math/tex; mode=display">p(y = 是) = \frac{9}{15},\quad p(y = 否) = \frac{6}{15}</script><script type="math/tex; mode=display">H(D) = - \frac{9}{15} \log_2 \frac{9}{15} - \frac{6}{15} \log_2 \frac{6}{15} = 0.971</script><p>当前特征集为</p><script type="math/tex; mode=display">A = \{ 年龄， 有工作， 有自己的房子， 信贷情况 \}</script><ol><li><p>以年龄为特征<br> 年龄含青年、中年、老年，则</p><script type="math/tex; mode=display">p(青年) = \frac{5}{15}, \quad p(中年) = \frac{5}{15}, \quad p(老年) = \frac{5}{15}</script><script type="math/tex; mode=display">p(y = 是|青年) = \frac{2}{5}, \quad p(y = 否|青年) = \frac{3}{5}</script><script type="math/tex; mode=display">p(y = 是|中年) = \frac{3}{5}, \quad p(y = 否|中年) = \frac{2}{5}</script><script type="math/tex; mode=display">p(y = 是|老年) = \frac{4}{5}, \quad p(y = 否|老年) = \frac{1}{5}</script><p> 则</p><script type="math/tex; mode=display">H(D|青年) = - \frac{2}{5} \log_2 \frac{2}{5} - \frac{3}{5} \log_2 \frac{3}{5} = 0.971</script><script type="math/tex; mode=display">H(D|中年) = - \frac{3}{5} \log_2 \frac{3}{5} - \frac{2}{5} \log_2 \frac{2}{5} = 0.971</script><script type="math/tex; mode=display">H(D|老年) = - \frac{4}{5} \log_2 \frac{4}{5} - \frac{1}{5} \log_2 \frac{1}{5} = 0.722</script><p> 则</p><script type="math/tex; mode=display">H(D|年龄) = \sum_{年龄=青年}^{老年} p(年龄) H(D|年龄) = 0.888</script><p> 所以</p><script type="math/tex; mode=display">g(D, 年龄) = H(D) - H(D|年龄) = 0.083</script></li><li><p>以工作为特征</p><script type="math/tex; mode=display">g(D, 工作) = H(D) - H(D|工作) = 0.324</script></li><li><p>以房子为特征</p><script type="math/tex; mode=display">g(D, 房子) = H(D) - H(D|房子) = 0.420</script></li><li><p>以信贷为特征</p><script type="math/tex; mode=display">g(D, 信贷) = H(D) - H(D|信贷) = 0.363</script></li></ol><p>由于$g(D, 房子)$最大，故当前节点选择房子作为分类特征，然后按此特征可分成2个子集合${D_{有房}，D_{无房}}$，递归即可。</p><h2 id="决策树生成"><a href="#决策树生成" class="headerlink" title="决策树生成"></a>决策树生成</h2><p>决策树生成使用递归方法，将该节点处所属数据子集$D_s$按<a href="#%e7%89%b9%e5%be%81%e9%80%89%e6%8b%a9">特征选择准则</a>，选择当期节点最优划分，然后在划分后的子节点处，继续调用该函数进行递归生成。</p><p>伪代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">输入：数据集D，特征集A &#x3D; &#123;a_1, a_2, ..., a_N&#125;，阈值eps；</span><br><span class="line">输出：节点node</span><br><span class="line"></span><br><span class="line">CREAT-NODE(D, A, eps)</span><br><span class="line">    if D中所有样本属于类别C_k</span><br><span class="line">        return Node(C_k)</span><br><span class="line"></span><br><span class="line">    if A为空集</span><br><span class="line">        C &#x3D; argmax(|D_k|, k &#x3D; 1, ..., K)</span><br><span class="line">        return Node(C)</span><br><span class="line"></span><br><span class="line">    # 计算特征选择准则，这里采用互信息g(D, A)</span><br><span class="line">    for n &#x3D; 1 upto N</span><br><span class="line">        g(D, A_n) &#x3D; H(D) - H(D|A_n)</span><br><span class="line">    </span><br><span class="line">    # 选择最优特征</span><br><span class="line">    a_g &#x3D; argmax(g(D, A_n), n &#x3D; 1, ..., N)</span><br><span class="line"></span><br><span class="line">    # 终止条件</span><br><span class="line">    if g(D, a_g) &lt; eps</span><br><span class="line">        C &#x3D; argmax(|D_k|, k &#x3D; 1, ..., K)</span><br><span class="line">        return Node(C)</span><br><span class="line">    </span><br><span class="line">    node &#x3D; Node(a_g)</span><br><span class="line"></span><br><span class="line">    # 递归</span><br><span class="line">    for i &#x3D; 1 upto a_g.length</span><br><span class="line">        node.sub[i] &#x3D; CREAT-NODE(D_i, A - a_g, eps)</span><br><span class="line"></span><br><span class="line">    return node</span><br></pre></td></tr></table></figure></p><h2 id="决策树剪枝"><a href="#决策树剪枝" class="headerlink" title="决策树剪枝"></a>决策树剪枝</h2><p>如果学习时过多地考虑如何提高对训练数据的正确分类，使决策树<strong>划分层次过多(也即叶节点个数过多)</strong>，构建出过于复杂的决策树，那么会引起过拟合现象。</p><p>设决策树共有$T$个叶节点，且叶节点$t$上有$N_t$个样本点、其中类别$k$的有$N_{tk}$个，$k = 1, \cdots, K$，那么<strong>叶节点$t$的类别经验熵</strong>为</p><script type="math/tex; mode=display">H_t(T) = - \sum_k \frac{N_{tk}}{N_t} \log \frac{N_{tk}}{N_t} \tag{4.1}</script><p>那么<strong>所有叶节点的类别经验熵之和</strong>为</p><script type="math/tex; mode=display">C(T) = \sum_{t=1}^{|T|} N_t H_t(T) \tag{4.2}</script><p>希望$C(T)$极小化，减小类别经验熵，那么会增加划分使叶子节点数目增多，考虑模型复杂度$T$与目标之间的权衡，设置正则化参数$\alpha$，那么决策树的<strong>整体结构损失函数</strong>为</p><script type="math/tex; mode=display">C_{\alpha} (T) = C(T) + \alpha |T| \tag{4.3}</script><p><strong>利用损失函数最小原则仅剪枝就是用正则化的极大似然估计进行模型选择</strong>。可以通过<strong>动态规划</strong>递归地使叶子节点向上回缩，求取损失函数最小地子树$T_{\alpha}$。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>详细查看<a href="https://github.com/isLouisHsu/Basic-Machine-Learning-Algorithm/blob/master/algorithm/p110_decision_tree.py" target="_blank" rel="noopener">Github: isLouisHsu/Basic-Machine-Learning-Algorithm</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Attributes:</span></span><br><span class="line"><span class="string">        index: 子树分类标签, 若为叶节点, 则为None</span></span><br><span class="line"><span class="string">        childNode: 子树，若为叶节点, 则为分类标签; 否则为字典</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        </span><br><span class="line">        self.index = <span class="keyword">None</span></span><br><span class="line">        self.childNode = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecisionTree</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    @note:  </span></span><br><span class="line"><span class="string">        - categorical features;</span></span><br><span class="line"><span class="string">        - ID3</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        </span><br><span class="line">        self.tree = <span class="keyword">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X, y)</span>:</span></span><br><span class="line">     </span><br><span class="line">        self.tree = self._creatNode(X, y)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_creatNode</span><span class="params">(self, X, y)</span>:</span></span><br><span class="line">    </span><br><span class="line">        node = Node()</span><br><span class="line">        <span class="comment"># 若只含一种类别，则返回叶节点</span></span><br><span class="line">        <span class="keyword">if</span> len(set(y)) == <span class="number">1</span>: node.childNode = list(set(y))[<span class="number">0</span>]; <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">        <span class="comment"># entropy: H(D)</span></span><br><span class="line">        y_encoded = OneHotEncoder().fit_transform(y.reshape(<span class="number">-1</span>, <span class="number">1</span>)).toarray()</span><br><span class="line">        p_y = np.mean(y_encoded, axis=<span class="number">0</span>); p_y[p_y==<span class="number">0.0</span>] = <span class="number">1.0</span>       <span class="comment"># 因为 0*np.log(0)结果为nan, 而不是0, 用 1*np.log(1)替代</span></span><br><span class="line">        H_D = - np.sum(p_y * np.log(p_y))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># conditional entropy: H(D|A)</span></span><br><span class="line">        H_D_A = np.zeros(shape=(X.shape[<span class="number">1</span>],))                       <span class="comment"># initialize</span></span><br><span class="line">        <span class="keyword">for</span> i_feature <span class="keyword">in</span> range(X.shape[<span class="number">1</span>]):</span><br><span class="line">            X_feature = X[:, i_feature]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> len(set(X_feature)) == <span class="number">1</span>: </span><br><span class="line">                H_D_A[i_feature] = float(<span class="string">'inf'</span>); <span class="keyword">continue</span>           <span class="comment"># 若该特征只有一种取值，表示已使用该列作为分类特征</span></span><br><span class="line">        </span><br><span class="line">            X_feature_encoded = OneHotEncoder().fit_transform(X_feature.reshape((<span class="number">-1</span>, <span class="number">1</span>))).toarray()</span><br><span class="line">            p_X = np.mean(X_feature_encoded, axis=<span class="number">0</span>)                <span class="comment"># 每个取值的概率</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> j_feature <span class="keyword">in</span> range(X_feature_encoded.shape[<span class="number">1</span>]):     <span class="comment"># 该特征取值有几种，编码后就有几列</span></span><br><span class="line">                y_encoded_feature = y_encoded[X_feature_encoded[:, j_feature]==<span class="number">1</span>]   <span class="comment"># 该特征某种取值下，其对应的标签值</span></span><br><span class="line">                p_y_X = np.mean(y_encoded_feature, axis=<span class="number">0</span>); p_y_X[p_y_X==<span class="number">0.0</span>] = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">                H_D_feature = - np.sum(p_y_X * np.log(p_y_X))</span><br><span class="line">                H_D_A[i_feature] += p_X[j_feature] * H_D_feature    <span class="comment"># 条件熵</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># information gain: g(D, A) = H(D) - H(D|A)</span></span><br><span class="line">        g_D_A = H_D - H_D_A</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 选出最大的作为分类特征</span></span><br><span class="line">        node.index = np.argmax(g_D_A)</span><br><span class="line">        X_selected = X[:, node.index]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 分类后继续建立树</span></span><br><span class="line">        node.childNode = dict()</span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> set(X_selected):</span><br><span class="line">            valIndex = (X_selected==val)</span><br><span class="line">            X_val, y_val = X[valIndex], y[valIndex]</span><br><span class="line">            node.childNode[val] = self._creatNode(X_val, y_val)     <span class="comment"># 存储在字典中，键为分类值，值为子树</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        y_pred = np.zeros(shape=(X.shape[<span class="number">0</span>],))</span><br><span class="line">        <span class="keyword">for</span> i_sample <span class="keyword">in</span> range(X.shape[<span class="number">0</span>]):</span><br><span class="line">            currentNode = self.tree                                 <span class="comment"># 初始化为父节点</span></span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> currentNode.index==<span class="keyword">None</span>:                      <span class="comment"># 若为None, 表示为叶子结点</span></span><br><span class="line">                val = X[i_sample, currentNode.index]                <span class="comment"># 当前样本在分类特征上的值</span></span><br><span class="line">                currentNode = currentNode.childNode[val]            <span class="comment"># 递归</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                y_pred[i_sample] = currentNode.childNode</span><br><span class="line">        <span class="keyword">return</span> y_pred</span><br></pre></td></tr></table></figure><p>最终生成分类树如下<br><img src="/2019/08/02/ID3-C4-5-CART-RF/tree.jpg" alt="tree"></p><h1 id="随机森林-Random-Forest"><a href="#随机森林-Random-Forest" class="headerlink" title="随机森林(Random Forest)"></a>随机森林(Random Forest)</h1><p>随机森林是用Bagging策略，对包含$N$个样本的数据集<strong>进行$M$次的有放回的采样，每次随机取$N_m$个样本</strong>，得到$M$个样本数目为$N_m$的样本子集，对每个子集建立分类器。</p><blockquote><p><strong>Bootstrap采样</strong>：对于一个样本，它在某一次含$m$个样本的训练集的随机采样中，每次被采集到的概率是$1/m$。不被采集到的概率为$1−1/m$。如果$m$次采样都没有被采集中的概率是$(1−1/m)^m$。当$m→\infty$时，$\lim_{m \rightarrow \infty} (1−1/m)^m \approx 0.368$。也就是说，在bagging的每轮随机采样中，训练集中大约有36.8%的数据没有被采样集采集中。对于这部分大约$36.8\%$的没有被采样到的数据，我们常常称之为袋外数据(Out Of Bag, 简称OOB)。这些数据没有参与训练集模型的拟合，因此可以用来检测模型的泛化能力。</p></blockquote><p>随机森林在<strong>Bagging策略</strong>上进行训练：</p><ol><li>用Bootstrap策略随机采样$M$次；</li><li>一棵树的生成时，<strong>仅从所有特征($K$个)中选取$k$个特征</strong>；</li><li>生成$M$棵树进行投票表决，确定预测结果(分类可取众数、回归可取均值)。</li></ol><p>那么随机森林有以下<strong>超参数</strong>：</p><ol><li>选取特征数目$k$，一般取$k = \sqrt{K}$；</li><li>每棵树的最大深度，一般不超过$8$；</li><li>树的数目；</li><li>……</li></ol><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://zhuanlan.zhihu.com/p/34534004" target="_blank" rel="noopener">ID3、C4.5、CART、随机森林、bagging、boosting、Adaboost、GBDT、xgboost算法总结</a></li><li><a href="https://book.douban.com/subject/10590856/" target="_blank" rel="noopener">统计学习方法，李航，第5章</a></li><li><a href="https://www.cnblogs.com/fionacai/p/5894142.html" target="_blank" rel="noopener">决策树与随机森林 - cnblogs</a></li><li><a href="https://baijiahao.baidu.com/s?id=1633580172255481867&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">常用的模型集成方法介绍：bagging、boosting、stacking - 机器之心</a></li><li><a href="https://www.cnblogs.com/xieqing/p/6520432.html" target="_blank" rel="noopener">Bagging与随机森林算法原理小结 - cnblogs</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>人间失格</title>
      <link href="/2019/07/21/%E4%BA%BA%E9%97%B4%E5%A4%B1%E6%A0%BC/"/>
      <url>/2019/07/21/%E4%BA%BA%E9%97%B4%E5%A4%B1%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/07/21/%E4%BA%BA%E9%97%B4%E5%A4%B1%E6%A0%BC/人间失格/image.jpg" alt="image"></p><p>人类是群居的孤独者。</p><h1 id="第一手札"><a href="#第一手札" class="headerlink" title="第一手札"></a>第一手札</h1><ol><li>尽管如此，他们却能够不死自杀，免于疯狂，纵谈政治，竟不绝望，不屈不挠，继续与生活搏斗。他们不是并不痛苦吗？他们使自己成为彻底的利己主义者，并虔信那一些里所担任，曾几何时怀疑过自己呢？这样一来，不是很轻松惬意吗？</li></ol><blockquote><p>太平洋战争爆发后，当时的许多作家纷纷创造起了激发人们战斗欲望的小说作品，唯独太宰治不一样，他从不去碰战争题材，相反的，太宰治为了让那些为了度过困难时期而奋斗着的人们于百忙之中能得到片刻慰藉，于是发明了一种新的写作方式——私小说，并创作了令人轻松愉悦捧腹大笑的作品——《御伽草纸》。<br>一直到日本二战战败以后，许多曾经崇拜战争的作家们纷纷“临阵倒戈”。太宰治发现，人们似乎根本没有意识到自己的罪恶，并创作了以二战为背景的战争题材小说《斜阳》：“被记者追捧者，鼓吹民主主义什么的，我不干，所有日本人都参与了战争。”</p></blockquote><ol><li>这是我向人类最后的求爱。尽管我对人类极度恐惧，但似乎始终割不断对人类的缘情，于是借着装傻这一缕细丝，来维系与人类的贯联。表面上我总是笑脸迎人，暗中则是拼了死命，战战兢兢，如履薄冰般才艰难万分做出这样的奉侍。</li></ol><blockquote><p>戴上人性的面具。</p></blockquote><ol><li>我却从人们动怒的面孔中发现了比狮子、鳄鱼、巨龙更可怕的动物本性。平常他们总是隐藏起这种动物本性，可一旦遇到某个时机，他们就会像那些温文尔雅地躺在草地上歇息的牛，蓦然甩动尾巴抽死肚皮上的牛虻一般，暴露出人的这种本性。</li><li>对讨厌的事不能说讨厌，而对喜欢的事呢，也是一样。</li><li>我对受人尊敬这一状态进行了如下定义：近于完美无缺地蒙骗别人，尔后又被某个全知全能之人识破真相，最终原形毕露，被迫当众出丑，以致于比死亡更难堪更困窘。</li><li>那时，我被男女佣人教唆者做出了可悲的丑事。事到如今我认为，对年幼者干出那种事情，无疑是人类所能犯下的罪孽中最丑恶最卑劣的行径。</li><li>不公平现象是必然存在的。这点是明摆着的事实。向人诉苦不过是徒劳，与其如此，不如默默承受。</li><li>相互欺骗，却又令人惊奇地不受到任何伤害，甚至于就好像没有察觉到彼此在欺骗似的，这种不加掩饰从而显得清冽、豁达的互不信任的例子，在人类生活中比比皆是。</li></ol><h1 id="第二手札"><a href="#第二手札" class="headerlink" title="第二手札"></a>第二手札</h1><ol><li>在迄今为止的生涯中，我曾经无数次祈望过自己被杀死，却从来也没有动过杀死别人的念头。这是因为我觉得，那样做只会给可怕的对手带来幸福的缘故。</li><li>“迷恋”、“被迷恋”这些措辞本身就是粗俗不堪而又戏弄人的说法，给人一种装腔作势的感觉。无论是多么“严肃”的场合，只要让这些词语抛头露面，忧郁的伽蓝就会顷刻间分崩离析，变得索然无味。</li><li>对人感到过分恐惧的人，反倒更加迫切地希望用自己地眼睛去看更可怕的妖怪；越是容易对事物感到胆怯的神经质的人，就越是渴望暴风雨降临得更加猛烈。</li><li>人啊，明明一点儿也不了解对方，错看对方，却视彼此为独一无二的挚友，一生不解对方的真性情，待一方撒手西去，还要为其哭泣，念诵悼词。</li><li>竭力想把觉得美的东西原封不动地描绘为美是幼稚和愚蠢乃至完全谬误的。</li><li>胆小鬼连幸福都会害怕，碰到棉花都会受伤，有时还被幸福所伤。</li></ol><h1 id="第三手札"><a href="#第三手札" class="headerlink" title="第三手札"></a>第三手札</h1><ol><li>人怎么能如此轻易地变得面目全非呢？这令我感到可耻，不，毋宁说是滑稽。</li><li>世上所有人的说法，总是显得拐弯抹角，含糊不清，其中有一种试图逃避责任似的微妙性和复杂性。</li><li>那以后我也尝试过画各种各样的画，但都远远及不上那记忆中的杰作，以致于我总是被一种失落感所折磨着，恍若整个胸膛都变成了一个空洞。</li><li>“可事实上，我是多么畏惧他们啊！我越是畏惧他们，就越是博得他们的喜欢，而越是博得他们的喜欢，我就越是畏惧他们，并不得不里他们远去。”</li><li>莫非在别人眼里，我那种畏惧他人、躲避他人、搪塞他人的性格，竟然与遵从俗话所说的那种“明哲保身、得过且过”的处世训条的做法，在表现形式上是相同的吗？</li><li>所谓世间，又是什么呢？是人的复数吗？可哪儿存在着“世间”这个东西的实体呢？迄今为止，我一直以为它是一种苛烈、严酷、而且可怕的东西，并且一直生活在这种想法之中，如今被崛木一说，有一句话差点就脱口而出：“所谓的世人，不就是你吗？”……打那时候起，我开始萌发了一种可以称之为“思想”的念头：所谓世间，不就是个人吗？</li><li>第二天也重复着同一件事情/只需遵从与昨天相同的习性/倘若愿意避免狂喜狂乐/大惊大悲就不会降临/躲开前方的挡路巨石/像蟾蜍一般迂回前进。</li><li>我知道有人是爱我的，但我好像缺乏爱人的能力。</li><li>所谓世间的真相，就是个人与个人之间的争斗，而且是即时即地的斗争。人需要在那种争斗中当场取胜，人是绝不可能服从他人的。即使是当努力，也会以努力的方式进行卑屈的反击。所以，人除了当场一决胜负外，不可能有别的生存方式。虽然人们提倡大义名分，但努力的目标毕竟是属于个人的，超越了个人之后依旧还是个人，世间的不可思议其实也就是个人的不可思议。</li><li>难道纯真无瑕的信赖之心真的是罪恶之源吗？难道纯真无瑕的信赖之心也算是罪过吗？</li><li>我的不幸，恰恰在于我缺乏拒绝的能力。我害怕一旦拒绝别人，便会在彼此心里留下永远无法愈合的裂痕。</li><li>但是，被关进这所医院的人全是狂人，而逍遥在外的全都是正常人。我问神灵：难道不反抗也是一种罪过吗？</li><li>我已丧失做人的资格。我已经彻底变成一个废人了。</li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>大庭叶藏是善良的人，心思细腻敏感却怯懦敏感，性格孤独，渴望被爱，在世间选择了极端的生活方式，根源最主要还是软弱的灵魂，没有自我</p><ul><li>自小充满幻想，对幻想破灭而大觉扫兴；</li><li>见到静子母女的背影，黯然离去，不忍打扰；</li><li>良子过于信任他人，与书商发生关系，而叶藏反复认定这是因为自己欣赏良子的纯真无暇，这不是她的错；</li><li>堀木作为叶藏的“朋友”，对叶藏一直抱有轻蔑的态度，叶藏看破不说破，并从堀木家中看到东京人真实的生活状态；</li><li>在药店老板的诱导下，吸毒上瘾；</li><li>不忍拒绝他人的请求；</li><li>“我们所认识的阿叶，又诚实又乖巧，要是不喝酒的话，不，即使是喝酒……也是一个神一样的好孩子呐。”</li></ul><p>想要成为一个人，就必须接受自己会犯错，会让人讨厌的事实，不要在乎他人的眼光。</p>]]></content>
      
      
      <categories>
          
          <category> Reading </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SphereFace, CosFace, ArcFace</title>
      <link href="/2019/07/13/SphereFace-CosFace-ArcFace/"/>
      <url>/2019/07/13/SphereFace-CosFace-ArcFace/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/07/13/SphereFace-CosFace-ArcFace/feature.gif" alt="feature"></p><blockquote><p>文中合成<code>gif</code>图不清晰，原图可在<a href="https://github.com/isLouisHsu/isLouisHsu.github.io/tree/master/2019/07/13/SphereFace-CosFace-ArcFace/gif" target="_blank" rel="noopener">该页面</a>下载获取</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>深度神经网络可将样本映射到超空间中的嵌入向量，然而若不在损失中增加几何约束，该超空间中的嵌入向量不具有几何意义。现对空间中嵌入向量间的余弦距离研究甚是火热，可用于<code>open-set</code>数据集的识别问题，特别是人脸验证问题。</p><blockquote><p>所谓<code>open-set</code>与<code>close-set</code>，是指训练集中是否包含测试集中的类别，如人脸问题中，训练集不可能包含所有人的人脸数据，则如何识别未出现在训练集中的样本成为一个问题。<br><img src="/2019/07/13/SphereFace-CosFace-ArcFace/open-close-set.jpg" alt="open-close-set"></p></blockquote><p>目前对嵌入向量的约束方案有如下几种</p><p><img src="/2019/07/13/SphereFace-CosFace-ArcFace/intra-interstrategy.jpg" alt="intra-interstrategy"></p><ul><li>Centre Loss，惩罚样本对应特征与其对应类别中心之间的欧氏距离，以获得类内紧致性，本文不做介绍；</li><li>Triplet Loss，在训练样本中寻找三元组，组合数量爆炸，且计算量较大，本文不做介绍；</li><li>CosFace: Additive Cosine Margin；</li><li>SphereFace: Multiplicative Angular Margin；</li><li>ArcFace: Additive Angular Margin。</li></ul><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="Maltilabel-Softmax-CrossEnt"><a href="#Maltilabel-Softmax-CrossEnt" class="headerlink" title="Maltilabel: Softmax + CrossEnt"></a>Maltilabel: Softmax + CrossEnt</h2><p>在多分类问题中，网络输出层一般设置为<code>Softmax</code>层</p><script type="math/tex; mode=display">\tilde{y}^{(i)}_j = \frac{e^{f^{(i)}_j}}{\sum_k e^{f^{(i)}_k}} \tag{1}</script><p>其中$f^{(i)}_j$表示<code>Softmax</code>层输入，一般为前一层网络的线性输出。损失函数一般采用交叉熵<code>Cross Entropy</code></p><script type="math/tex; mode=display">L = \frac{1}{N} \sum_i - \log \tilde{y}^{(i)}_{y^{(i)}} \tag{2}</script><p>其中，$N$为<code>batchsize</code>大小，$\tilde{y}^{(i)}_j$表示样本$X^{(i)}$预测为第$j$类的概率输出，$y^{(i)}$为其对应真实标签。</p><p>也即</p><script type="math/tex; mode=display">L = \frac{1}{N} \sum_i - \log \frac{e^{f^{(i)}_{y^{(i)}}}}{\sum_k e^{f^{(i)}_k}} \tag{*}</script><blockquote><script type="math/tex; mode=display">H(p, q) = \sum_x p(x) \log \frac{1}{q(x)}</script><p>其中$p(x), q(x)$为概率分布。</p></blockquote><h2 id="Geometric-Modified-Softmax-Loss"><a href="#Geometric-Modified-Softmax-Loss" class="headerlink" title="Geometric: Modified Softmax Loss"></a>Geometric: Modified Softmax Loss</h2><p>由于<code>Softmax</code>不具有几何意义，对其进行修改，在前一层与<code>Softmax</code>层之间添加线性层，即</p><script type="math/tex; mode=display">g^{(i)}_j = W_j^T f^{(i)} + b_j \tag{3}</script><p>其中</p><script type="math/tex; mode=display">W_j^T f^{(i)} = ||W_j|| ||f^{(i)}|| \cos \theta^{(i)}_j \tag{4}</script><p>$\theta^{(i)}_j$表示$W_j$与$f^{(i)}$夹角，$f^{(i)}$为上一层输出，其维数为$D$，则参数$W, b$维数应为$C \times D, C \times 1$。</p><p>此时类别$c_1$与$c_2$间决策平面为</p><script type="math/tex; mode=display">W_{c_1}^T f^{(i)} + b_{c_1} = W_{c_2}^T f^{(i)} + b_{c_2}</script><p>令$||W_j|| = 1, b_j = 0$，有</p><script type="math/tex; mode=display">g^{(i)}_j = W_j^T f^{(i)} + b_j = ||f^{(i)}|| \cos \theta^{(i)}_j \tag{5}</script><p>则判决平面为</p><script type="math/tex; mode=display">||f^{(i)}|| \cos \theta^{(i)}_{c_1} = ||f^{(i)}|| \cos \theta^{(i)}_{c_2}</script><p>也即</p><script type="math/tex; mode=display">\cos \theta^{(i)}_{c_1} = \cos \theta^{(i)}_{c_2}\tag{6}</script><p>则此时向量夹角大小可作为判决平面，赋予角度上的几何意义，将$g^{(i)}$输入<code>Softmax</code>层与<code>CrossEnt</code>损失</p><script type="math/tex; mode=display">\tilde{y}^{(i)}_j = \frac{e^{g^{(i)}_j}}{\sum_k e^{g^{(i)}_k}} = \frac{e^{||f^{(i)}|| \cos \theta^{(i)}_j}}{\sum_k e^{||f^{(i)}|| \cos \theta^{(i)}_k}}</script><script type="math/tex; mode=display">L = \frac{1}{N} \sum_i - \log \tilde{y}^{(i)}_{y^{(i)}}</script><p>写成一个等式，在<code>SphereFace</code>一文中，称下式为<code>Modified Softmax Loss</code></p><script type="math/tex; mode=display">L = \frac{1}{N} \sum_i - \log \frac{e^{||f^{(i)}|| \cos \theta^{(i)}_{y^{(i)}}}}{\sum_k e^{||f^{(i)}|| \cos \theta^{(i)}_k}} \tag{*1}</script><p>其与<code>Softmax</code>对比如下<br><img src="/2019/07/13/SphereFace-CosFace-ArcFace/softmax-a-softmax.jpg" alt="softmax-a-softmax"></p><h2 id="CosFace-Additive-Cosine-Margin"><a href="#CosFace-Additive-Cosine-Margin" class="headerlink" title="CosFace: Additive Cosine Margin"></a>CosFace: Additive Cosine Margin</h2><p>在<a href="#Geometric-Modified-Softmax-Loss">Modified Softmax Loss</a>基础上添加Margin。</p><p>希望对于样本$X^{(i)}$，其对应的嵌入向量$f^{(i)}$与其所属类中心向量$W_{y^{(i)}}$间夹角$\theta^{(i)}_{y^{(i)}}$愈小愈好，由余弦函数单调性，可得</p><script type="math/tex; mode=display">\min \theta^{(i)}_{y^{(i)}} \Rightarrow \max \cos \theta^{(i)}_{y^{(i)}}</script><p>引入Margin参数$m$，使$\theta^{(i)}_{y^{(i)}}$更大，更新为$\phi^{(i)}_{c_{y^{(i)}}}$，其余$\theta^{(i)}_j$不变，从而使得对类别$c_{y^{(i)}}$<strong>惩罚更大</strong>，也即</p><script type="math/tex; mode=display">\phi^{(i)}_{c_{y^{(i)}}} = \arccos (\cos \theta^{(i)}_{c_{y^{(i)}}} - m) > \theta^{(i)}_{c_{y^{(i)}}}</script><p>从而</p><script type="math/tex; mode=display">\cos \phi^{(i)}_{c_{y^{(i)}}} = \cos \theta^{(i)}_{c_{y^{(i)}}} - m < \cos \theta^{(i)}_{c_{y^{(i)}}} \tag{7}</script><p>所以</p><script type="math/tex; mode=display">m > 0</script><p>此时类别$c_{y^{(i)}}$与其他类$c_j$间的判别平面为</p><script type="math/tex; mode=display">\cos \theta^{(i)}_{c_{y^{(i)}}} - m = \cos \theta^{(i)}_{c_j}</script><p>那么$(*1)$更新为</p><script type="math/tex; mode=display">L = \frac{1}{N} \sum_i - \log \frac{e^{||f^{(i)}|| (\cos \theta^{(i)}_{y^{(i)}} - m)}}{e^{||f^{(i)}|| (\cos \theta^{(i)}_{y^{(i)}} - m)} + \sum_{k \neq y^{(i)}} e^{||f^{(i)}|| \cos \theta^{(i)}_k}}, 其中m > 0 \tag{8}</script><p>由于决策平面取决于角度，与$||f^{(i)}||$分布无关，故设置为常数$s$，有<code>Additive Cosine Margin Loss</code></p><script type="math/tex; mode=display">L = \frac{1}{N} \sum_i - \log \frac{e^{s (\cos \theta^{(i)}_{y^{(i)}} - m)}}{e^{s (\cos \theta^{(i)}_{y^{(i)}} - m)} + \sum_{k \neq y^{(i)}} e^{s \cos \theta^{(i)}_k}}, 其中m > 0 \tag{*2}</script><script type="math/tex; mode=display">s.t. \qquad \cos \theta^{(i)}_j = \frac{W_j^T f^{(i)}}{||W_j||||f^{(i)}||}</script><p>$m$典型值为</p><script type="math/tex; mode=display">m = 0.35</script><p><img src="/2019/07/13/SphereFace-CosFace-ArcFace/cosface.jpg" alt="cosface"></p><blockquote><p>实际上，$s$可控制决策平面的陡峭程度，如在二分类问题中，采用<code>Softmax</code>进行决策时</p><script type="math/tex; mode=display">\tilde{y}^{(i)}_1 = \frac{e^{s f^{(i)}_1}}{e^{s f^{(i)}_1} + e^{s f^{(i)}_2}} = \frac{1}{1 + e^{-s (f^{(i)}_1 - f^{(i)}_2)}}</script><p>记$z^{(i)}_1 = f^{(i)}_1 - f^{(i)}_2$，有<code>Sigmoid</code>函数</p><script type="math/tex; mode=display">\tilde{y}^{(i)}_1 = \frac{1}{1 + e^{-s z^{(i)}_1}}</script><p>设置不同的$s$参数，得到图像如下<br><img src="/2019/07/13/SphereFace-CosFace-ArcFace/parameter_s.png" alt="parameter_s"></p><p>从另一角度理解，可设$s = \frac{1}{\sigma^2}$，则$s$也可用于描述分布的方差，本文中，这里指角度的分布方差。</p></blockquote><h2 id="SphereFace-Multiplicative-Angular-Margin"><a href="#SphereFace-Multiplicative-Angular-Margin" class="headerlink" title="SphereFace: Multiplicative Angular Margin"></a>SphereFace: Multiplicative Angular Margin</h2><p>与<a href="#CosFace-Additive-Cosine-Margin">CosFace: Additive Cosine Margin</a>思路一致，在<a href="#Geometric-Modified-Softmax-Loss">Modified Softmax Loss</a>基础上添加Margin，不同的是对角度增加乘法裕度。</p><p>引入乘子$m$，使$\theta^{(i)}_{y^{(i)}}$更大，更新为$\phi^{(i)}_{c_{y^{(i)}}}$，其余$\theta^{(i)}_j$不变，从而使得对类别$c_{y^{(i)}}$<strong>惩罚更大</strong></p><script type="math/tex; mode=display">\phi^{(i)}_{c_{y^{(i)}}} = m \theta^{(i)}_{y^{(i)}}</script><script type="math/tex; mode=display">\cos \phi^{(i)}_{c_{y^{(i)}}} = \cos m \theta^{(i)}_{y^{(i)}} < \cos \theta^{(i)}_{c_{y^{(i)}}} \tag{9}</script><p>所以$m &gt; 1$，原文中去整数，即$m \geq 2$，同时，沿用<code>CosFace</code>中对$||f^{(i)}||$处理，$(*1)$更新为</p><script type="math/tex; mode=display">L = \frac{1}{N} \sum_i - \log \frac{e^{s \cos m \theta^{(i)}_{y^{(i)}}}}{e^{s \cos m \theta^{(i)}_{y^{(i)}}} + \sum_{k \neq y^{(i)}} e^{s \cos \theta^{(i)}_k}}, 其中m(\text{integer}) \geq 2 \tag{*3}</script><script type="math/tex; mode=display">s.t. \qquad \cos \theta^{(i)}_j = \frac{W_j^T f^{(i)}}{||W_j||||f^{(i)}||}</script><p>此时类别$c_{y^{(i)}}$与其他类$c_j$间的判别平面为</p><script type="math/tex; mode=display">m \theta^{(i)}_{c_{y^{(i)}}} = \theta^{(i)}_{c_j}</script><p>$m$典型值为</p><script type="math/tex; mode=display">m = 2</script><p><img src="/2019/07/13/SphereFace-CosFace-ArcFace/sphereface.jpg" alt="sphereface"></p><h2 id="ArcFace-Additive-Angular-Margin"><a href="#ArcFace-Additive-Angular-Margin" class="headerlink" title="ArcFace: Additive Angular Margin"></a>ArcFace: Additive Angular Margin</h2><p>与<a href="#CosFace-Additive-Cosine-Margin">CosFace: Additive Cosine Margin</a>思路一致，在<a href="#Geometric-Modified-Softmax-Loss">Modified Softmax Loss</a>基础上添加Margin，对角度增加加法裕度。</p><p>引入$m$，使$\theta^{(i)}_{y^{(i)}}$更大，更新为$\phi^{(i)}_{c_{y^{(i)}}}$，其余$\theta^{(i)}_j$不变，从而使得对类别$c_{y^{(i)}}$<strong>惩罚更大</strong></p><script type="math/tex; mode=display">\phi^{(i)}_{c_{y^{(i)}}} = \theta^{(i)}_{y^{(i)}} + m</script><script type="math/tex; mode=display">\cos \phi^{(i)}_{c_{y^{(i)}}} = \cos (\theta^{(i)}_{y^{(i)}} + m) < \cos \theta^{(i)}_{c_{y^{(i)}}} \tag{9}</script><p>所以$m &gt; 0$，同时，沿用<code>CosFace</code>中对$||f^{(i)}||$处理，$(*1)$更新为</p><script type="math/tex; mode=display">L = \frac{1}{N} \sum_i - \log \frac{e^{s \cos (\theta^{(i)}_{y^{(i)}} + m)}}{e^{s \cos (\theta^{(i)}_{y^{(i)}} + m)} + \sum_{k \neq y^{(i)}} e^{s \cos \theta^{(i)}_k}}, 其中m > 0 \tag{*4}</script><script type="math/tex; mode=display">s.t. \qquad \cos \theta^{(i)}_j = \frac{W_j^T f^{(i)}}{||W_j||||f^{(i)}||}</script><p>$m$典型值为</p><script type="math/tex; mode=display">m = 0.5</script><p>此时类别$c_{y^{(i)}}$与其他类$c_j$间的判别平面为</p><script type="math/tex; mode=display">\theta^{(i)}_{c_{y^{(i)}}} + m = \theta^{(i)}_{c_j}</script><p><img src="/2019/07/13/SphereFace-CosFace-ArcFace/arcface.jpg" alt="arcface"></p><h1 id="可改进之处"><a href="#可改进之处" class="headerlink" title="可改进之处"></a>可改进之处</h1><h2 id="CosMulFace"><a href="#CosMulFace" class="headerlink" title="CosMulFace?"></a>CosMulFace?</h2><p>好像还有一个空余的位置可以添加参数，笑:-)。</p><p>与<a href="#CosFace-Additive-Cosine-Margin">CosFace: Additive Cosine Margin</a>思路一致，在<a href="#Geometric-Modified-Softmax-Loss">Modified Softmax Loss</a>基础上添加Margin，不同的是对余弦值增加乘法裕度。</p><p>引入乘子$m$，使$\theta^{(i)}_{y^{(i)}}$更大，更新为$\phi^{(i)}_{c_{y^{(i)}}}$，其余$\theta^{(i)}_j$不变，从而使得对类别$c_{y^{(i)}}$<strong>惩罚更大</strong></p><script type="math/tex; mode=display">\phi^{(i)}_{c_{y^{(i)}}} = \arccos (m \cos \theta^{(i)}_{c_{y^{(i)}}}) > \theta^{(i)}_{c_{y^{(i)}}}</script><script type="math/tex; mode=display">\cos \phi^{(i)}_{c_{y^{(i)}}} = m \cos \theta^{(i)}_{c_{y^{(i)}}} < \cos \theta^{(i)}_{c_{y^{(i)}}} \tag{10}</script><p>由于函数<code>cos(x)</code>有</p><script type="math/tex; mode=display">\begin{cases}    \cos x \geq 0 & x \in [-\frac{\pi}{2} + 2k\pi, \frac{\pi}{2} + 2k\pi] \\    \cos x \leq 0 & x \in [\frac{\pi}{2} + 2k\pi, \frac{3\pi}{2} + 2k\pi]\end{cases}, 且 -1 \leq \cos x \leq 1</script><p>所以为使得对于乘子$m$，均有式$(9)$成立，令</p><script type="math/tex; mode=display">\cos \theta^{(i)}_j := \cos \theta^{(i)}_j - 1 \tag{11}</script><p>所以$m &gt; 1$，同时，沿用<code>CosFace</code>中对$||f^{(i)}||$处理，$(*1)$更新为</p><script type="math/tex; mode=display">L = \frac{1}{N} \sum_i - \log \frac{e^{s m (\cos \theta^{(i)}_{y^{(i)}} - 1)}}{e^{s m (\cos \theta^{(i)}_{y^{(i)}} - 1)} + \sum_{k \neq y^{(i)}} e^{s (\cos \theta^{(i)}_k - 1)}}, 其中 m > 1 \tag{*5}</script><script type="math/tex; mode=display">s.t. \qquad \cos \theta^{(i)}_j = \frac{W_j^T f^{(i)}}{||W_j||||f^{(i)}||}</script><p>此时类别$c_{y^{(i)}}$与其他类$c_j$间的判别平面为</p><script type="math/tex; mode=display">m (\cos \theta^{(i)}_{c_{y^{(i)}}} - 1) = \cos \theta^{(i)}_{c_j} - 1 \tag{12}</script><p><img src="/2019/07/13/SphereFace-CosFace-ArcFace/cosmulface.jpg" alt="cosmulface"></p><h2 id="AdaptiveFace-Adaptive-Margin"><a href="#AdaptiveFace-Adaptive-Margin" class="headerlink" title="AdaptiveFace: Adaptive Margin?"></a>AdaptiveFace: Adaptive Margin?</h2><p>Margin必须为固定常数？</p><p>设置可变参数$m_i, i = 1, \cdots, 4$</p><p>可令</p><script type="math/tex; mode=display">L = \frac{1}{N} \sum_i - \log \frac{e^{s \cdot m^4 \left[\cos (m^1 \theta^{(i)} + m^2) - m^3 - 1\right] }}{e^{s \cdot m^4 \left[\cos (m^1 \theta^{(i)} + m^2) - m^3 - 1\right] } + \sum_{k \neq y^{(i)}} e^{s (\cos \theta^{(i)}_k - 1)}} \tag{*6}</script><script type="math/tex; mode=display">\begin{cases}    \cos \theta^{(i)}_j = \frac{W_j^T f^{(i)}}{||W_j||||f^{(i)}||} \\    m_1 > 1 \\    m_2 > 0 \\    m_3 > 0 \\    m_4 > 1\end{cases}</script><p>反向传播时，同时更新$m_i, i = 1, \cdots, 4$。</p><p>注意点：参数下限，每次参数更新后，需对其限制，即剪裁。</p><script type="math/tex; mode=display">f(x) = \begin{cases}    \text{min} & x < \text{min} \\    x          & otherwise \\    \text{max} & x > \text{max}\end{cases}</script><h2 id="船新版本"><a href="#船新版本" class="headerlink" title="船新版本"></a>船新版本</h2><!-- 先保密hhh，见[实验3](#3-%E4%BC%A0%E6%96%B0%E7%89%88%E6%9C%AC)。 --><p>在<a href="#Geometric-Modified-Softmax-Loss">Modified Softmax Loss</a>基础上，增加损失项</p><script type="math/tex; mode=display">L = \frac{1}{N} \sum_i - \log \frac{e^{s \cos \theta^{(i)}_{y^{(i)}} }}{e^{s \cos \theta^{(i)}_{y^{(i)}} } + \sum_{k \neq y^{(i)}} e^{s \cos \theta^{(i)}_k}} + \lambda || \sum_j W_j ||_2 \tag{*7}</script><script type="math/tex; mode=display">s.t.\begin{cases}    \cos \theta^{(i)}_j = \frac{W_j^T f^{(i)}}{||W_j||||f^{(i)}||} \\    || W_j ||_2 = 1 \\\end{cases}</script><p>即使得各类别所属向量的<strong>矢量和</strong>长度趋向$0$，由于最小化损失项$|| \sum_j W_j ||_2$，其最优解为</p><script type="math/tex; mode=display">W_j = \vec{0}</script><p>或者说$W_j$长度衰减至$0$，所以需要加上限制，<strong>在每次参数迭代后，重新归一化该向量，使其为单位向量</strong>，即</p><script type="math/tex; mode=display">W_j := \frac{W_j}{||W_j||}</script><h1 id="CosFace-SphereFace-ArcFace-CosMulFace"><a href="#CosFace-SphereFace-ArcFace-CosMulFace" class="headerlink" title="CosFace + SphereFace + ArcFace + CosMulFace"></a>CosFace + SphereFace + ArcFace + CosMulFace</h1><p>综合<a href="#CosFace-Additive-Cosine-Margin">CosFace</a>, <a href="#SphereFace-Multiplicative-Angular-Margin">SphereFace</a>, <a href="#ArcFace-Additive-Angular-Margin">ArcFace</a>, <a href="#CosMulFace">CosMulFace</a>, 得到</p><script type="math/tex; mode=display">L = \frac{1}{N} \sum_i - \log \frac{e^{s \cdot m_4 \left[\cos (m_1 \theta^{(i)}_{y^{(i)}} + m_2) - m_3 - 1 \right] }}{e^{s \cdot m_4 \left[\cos (m_1 \theta^{(i)}_{y^{(i)}} + m_2) - m_3 - 1 \right] } + \sum_{k \neq y^{(i)}} e^{s (\cos \theta^{(i)}_k - 1)}} \tag{**}</script><script type="math/tex; mode=display">s.t. \qquad\begin{cases}    \cos \theta^{(i)}_j = \frac{W_j^T f^{(i)}}{||W_j||||f^{(i)}||} \\    m_1 \geq 2 \\    m_2 > 0 \\    m_3 > 0 \\    m_4 > 1\end{cases}</script><p>通过组合可能获得更好的实验结果。</p><h1 id="方法对比"><a href="#方法对比" class="headerlink" title="方法对比"></a>方法对比</h1><p><code>ArcFace</code>与<code>CosFace</code>, <code>SphereFace</code>对比有如下特点</p><ol><li><p>数值计算稳定<br><img src="/2019/07/13/SphereFace-CosFace-ArcFace/arcface1.jpg" alt="arcface1"></p></li><li><p>几何意义不同，决策平面区分度更好<br><img src="/2019/07/13/SphereFace-CosFace-ArcFace/arcface2.jpg" alt="arcface2"></p></li></ol><h1 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h1><p><img src="/2019/07/13/SphereFace-CosFace-ArcFace/process.jpg" alt="process"></p><ol><li>初始化各类中心，记作矩阵$W_{C \times D}$，其中$C$表示类别数目， $D$表示特征维数；</li><li>迭代过程中，某批输入的样本记作$X_N$，其中$N$表示批次数据数；</li><li>计算该批中各样本$X^{(i)}$提取的特征$f^{(i)}$到各类别中心$W_j$的余弦值$\cos \theta^{(i)}_j$，保存为矩阵$Cos_{N \times C}$；</li><li><p>各样本真实标签对应的余弦值加上相应Margin，即</p><script type="math/tex; mode=display"> \cos \phi^{(i)}_j = \begin{cases}     m_4 (\text{monocos} (m_1 \theta^{(i)}_j + m_2) - m_3 - 1) & j = y^{(i)} \\     \cos \theta^{(i)}_j - 1 & \text{otherwise} \end{cases} \tag{14}</script><blockquote><p><code>monocos</code>在<a href="#cos%E5%87%BD%E6%95%B0%E7%9A%84%E5%8D%95%E8%B0%83%E6%80%A7%E9%97%AE%E9%A2%98">cos函数的单调性问题</a>中说明</p></blockquote></li><li><p>将计算得到的矩阵代入<code>Softmax</code>层，计算该样本属于各类别的概率</p><script type="math/tex; mode=display">\tilde{y}^{(i)}_j = \frac{e^{\cos \phi^{(i)}_j}}{\sum_k e^{\cos \phi^{(i)}_k}} \tag{15}</script></li><li><p>代入<code>Cross Entropy</code>计算损失值</p><script type="math/tex; mode=display">L^{(i)} = - \log \tilde{y}^{(i)}_{y^{(i)}} \tag{16}</script></li><li><p>则该批次的损失值为</p><script type="math/tex; mode=display">L = \frac{1}{N} \sum_i L^{(i)} \tag{17}</script></li></ol><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>详情查看<a href="https://github.com/isLouisHsu/Toy-Problem-based-on-MNIST" target="_blank" rel="noopener">isLouisHsu/Toy-Problem-based-on-MNIST - Github</a>。</p><p>在实现过程中，有两个注意点：</p><ul><li>反余弦函数<code>arccos(x)</code>在$x = \pm 1$处不可导问题；</li><li>余弦函数<code>cos(x)</code>的单调性问题；</li></ul><p>对于上述两个问题，进行以下处理</p><h2 id="arccos函数不可导点问题"><a href="#arccos函数不可导点问题" class="headerlink" title="arccos函数不可导点问题"></a>arccos函数不可导点问题</h2><p><img src="/2019/07/13/SphereFace-CosFace-ArcFace/arccos.png" alt="arccos"></p><p>由于函数$\arccos(x)$的导函数为</p><script type="math/tex; mode=display">\frac{d}{dx} \arccos(x) = - \frac{1}{\sqrt{1 - x^2}} \tag{18}</script><p>特征$f^{(i)}$与各类中心$W_j$余弦值范围为</p><script type="math/tex; mode=display">\cos \theta^{(i)}_j \in [-1, 1]</script><p>则当$\cos \theta^{(i)}_j = \pm 1$时</p><script type="math/tex; mode=display">\lim_{\theta \rightarrow \pm 1} \frac{d}{dx} \arccos(x) = \infty</script><p>则无法使用BP算法进行参数更新，因此，使用泰勒展开式近似计算$\theta^_j$</p><script type="math/tex; mode=display">\arccos x = \frac{\pi}{2} - x - \frac{1}{2} \cdot \frac{x^3}{3} - \cdots - \frac{(2n-1)!}{(2n)!} \cdot \frac{x^{2n+1}}{2n+1}- \cdots \tag{19}</script><p><img src="/2019/07/13/SphereFace-CosFace-ArcFace/taylor_arccos,_n_=_5.png" alt="taylor_arccos,_n_=_5"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">taylorArccos</span><span class="params">(x, n)</span>:</span></span><br><span class="line"></span><br><span class="line">    general_term = <span class="keyword">lambda</span> x, n: (math.factorial(<span class="number">2</span> * n - <span class="number">1</span>) /\</span><br><span class="line">                                math.factorial(<span class="number">2</span> * n)) *\</span><br><span class="line">                                (x**(<span class="number">2</span> * n + <span class="number">1</span>) / (<span class="number">2</span> * n + <span class="number">1</span>))</span><br><span class="line">    y = np.pi / <span class="number">2</span> - x</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        y -= general_term(x, i)</span><br><span class="line">    <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><h2 id="cos函数的单调性问题"><a href="#cos函数的单调性问题" class="headerlink" title="cos函数的单调性问题"></a>cos函数的单调性问题</h2><p><img src="/2019/07/13/SphereFace-CosFace-ArcFace/cos.png" alt="cos"></p><p>由于特征$f^{(i)}$与各类中心$W_j$余弦值范围为</p><script type="math/tex; mode=display">\cos \theta^{(i)}_j \in [-1, 1]</script><p>利用反三角函数<code>arccos(x)</code>计算其角度后，有</p><script type="math/tex; mode=display">\theta^{(i)}_j \in [0, \pi]</script><p>仅考虑余弦函数内部部分，添加Margin后，应有</p><script type="math/tex; mode=display">\phi^{(i)}_j = m_1 \theta^{(i)}_j + m_2 \in [m_2, m_2 + m_1 \pi]</script><p>此时仍然满足</p><script type="math/tex; mode=display">\phi^{(i)}_j > \theta^{(i)}_j</script><p>然而经过余弦函数后，可能由于其单调性问题，<strong>不一定满足下式</strong></p><script type="math/tex; mode=display">\cos \phi^{(i)}_j < \cos \theta^{(i)}_j</script><p>所以定义如下函数，使其在$[0, \infty]$单调递减</p><script type="math/tex; mode=display">\text{monocos}(\theta) = \cos (\theta - n \pi) - 2n 其中 n = \lfloor{} \frac{\theta}{\pi} \rfloor{} \tag{19}</script><p>此时必满足</p><script type="math/tex; mode=display">\text{monocos} \phi^{(i)}_j < \text{monocos} \theta^{(i)}_j</script><blockquote><p>由于$\phi^{(i)}_j &gt; \theta^{(i)}_j$，所以满足$[0, \infty]$即可，实际上，该函数在$[-\infty, \infty]$均单调递减。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">monocos</span><span class="params">(x)</span>:</span></span><br><span class="line">    n = x // np.pi</span><br><span class="line">    y = np.cos(x - np.pi*n) - <span class="number">2</span>*n</span><br><span class="line">    <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><p>其函数图像如下<br><img src="/2019/07/13/SphereFace-CosFace-ArcFace/cos_&amp;_monocos.png" alt="cos_&amp;_monocos"></p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CosineLayer</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Attributes:</span></span><br><span class="line"><span class="string">        weight: &#123;Parameter(num_classes, feature_size)&#125;</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num_classes, feature_size)</span>:</span></span><br><span class="line">        super(CosineLayer, self).__init__()</span><br><span class="line">        </span><br><span class="line">        self.weights = Parameter(torch.Tensor(num_classes, feature_size))</span><br><span class="line">        nn.init.xavier_uniform_(self.weights)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Params:</span></span><br><span class="line"><span class="string">            x: &#123;tensor(N, feature_size)&#125;</span></span><br><span class="line"><span class="string">        Notes:</span></span><br><span class="line"><span class="string">            \cos \theta^&#123;(i)&#125;_j = \frac&#123;W_j^T f^&#123;(i)&#125;&#125;&#123;||W_j|| ||f^&#123;(i)&#125;||&#125;</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        x = F.linear(F.normalize(x), F.normalize(self.weights))</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkMargin</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num_classes, feature_size)</span>:</span></span><br><span class="line">        super(NetworkMargin, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.pre_layers = nn.Sequential(</span><br><span class="line">            nn.Conv2d(   <span class="number">1</span>,  <span class="number">64</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>),</span><br><span class="line"></span><br><span class="line">            nn.Conv2d(  <span class="number">64</span>,  <span class="number">64</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>),</span><br><span class="line"></span><br><span class="line">            nn.Conv2d( <span class="number">64</span>,  feature_size, <span class="number">7</span>),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        self.cosine_layer = CosineLayer(num_classes, feature_size)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_feature</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        </span><br><span class="line">        x = self.pre_layers(x)</span><br><span class="line">        x = x.view(x.shape[<span class="number">0</span>], <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line"></span><br><span class="line">        x = self.get_feature(x)</span><br><span class="line">        x = self.cosine_layer(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  x</span><br></pre></td></tr></table></figure><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MarginProduct</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Notes:</span></span><br><span class="line"><span class="string">        $$</span></span><br><span class="line"><span class="string">        \text&#123;softmax&#125; = \frac&#123;1&#125;&#123;N&#125; \sum_i -\log \frac&#123;e^&#123;\tilde&#123;y&#125;_&#123;y_i&#125;&#125;&#125;&#123;\sum_i e^&#123;\tilde&#123;y&#125;_i&#125;&#125;</span></span><br><span class="line"><span class="string">        $$</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        $\text&#123;where&#125;$</span></span><br><span class="line"><span class="string">        $$</span></span><br><span class="line"><span class="string">        \tilde&#123;y&#125; = \begin&#123;cases&#125;</span></span><br><span class="line"><span class="string">            s(m4 \cos(m_1 \theta_&#123;j, i&#125; + m_2) + m_3) &amp; j = y_i \\</span></span><br><span class="line"><span class="string">            s(m4 \cos(    \theta_&#123;j, i&#125;))             &amp; j \neq y_i</span></span><br><span class="line"><span class="string">        \end&#123;cases&#125;</span></span><br><span class="line"><span class="string">        $$</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, s=<span class="number">32.0</span>, m1=<span class="number">2.00</span>, m2=<span class="number">0.50</span>, m3=<span class="number">0.35</span>, m4=<span class="number">2.00</span>)</span>:</span></span><br><span class="line"></span><br><span class="line">        super(MarginProduct, self).__init__()</span><br><span class="line">        self.s = s</span><br><span class="line">        self.m1 = m1</span><br><span class="line">        self.m2 = m2</span><br><span class="line">        self.m3 = m3</span><br><span class="line">        self.m4 = m4</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, cosTheta, label)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Params:</span></span><br><span class="line"><span class="string">            cosTheta: &#123;tensor(N, n_classes)&#125; 每个样本(N)，到各类别(n_classes)矢量的余弦值</span></span><br><span class="line"><span class="string">            label:  &#123;tensor(N)&#125;</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            output: &#123;tensor(N, n_classes)&#125;</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        one_hot = torch.zeros(cosTheta.size(), device=<span class="string">'cuda'</span> <span class="keyword">if</span> \</span><br><span class="line">                        torch.cuda.is_available() <span class="keyword">else</span> <span class="string">'cpu'</span>)</span><br><span class="line">        one_hot.scatter_(<span class="number">1</span>, label.view(<span class="number">-1</span>, <span class="number">1</span>).long(), <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># theta  = torch.acos(cosTheta)</span></span><br><span class="line">        theta  = arccos(cosTheta)</span><br><span class="line">        cosPhi = self.m4 * (monocos(self.m1*theta + self.m2) - self.m3 - <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        output = torch.where(one_hot &gt; <span class="number">0</span>, cosPhi, cosTheta - <span class="number">1</span>)</span><br><span class="line">        output = self.s * output</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MarginLoss</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, s=<span class="number">32.0</span>, m1=<span class="number">2.00</span>, m2=<span class="number">0.50</span>, m3=<span class="number">0.35</span>, m4=<span class="number">2.00</span>)</span>:</span></span><br><span class="line">        super(MarginLoss, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.margin = MarginProduct(s, m1, m2, m3, m4)</span><br><span class="line">        self.crossent = nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, pred, gt)</span>:</span></span><br><span class="line"></span><br><span class="line">        output = self.margin(pred, gt)</span><br><span class="line">        loss   = self.crossent(output, gt)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> loss</span><br></pre></td></tr></table></figure><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p><strong>注意，以下实验网络的参数初始均相同。</strong></p><h2 id="1-设置不同参数，对比实验结果"><a href="#1-设置不同参数，对比实验结果" class="headerlink" title="1.设置不同参数，对比实验结果"></a>1.设置不同参数，对比实验结果</h2><script type="math/tex; mode=display">L = \frac{1}{N} \sum_i - \log \frac{e^{s \cdot \left[\cos (m_1 \theta^{(i)}_{y^{(i)}} + m_2) - m_3 \right] }}{e^{s \cdot \left[\cos (m_1 \theta^{(i)}_{y^{(i)}} + m_2) - m_3 \right] } + \sum_{k \neq y^{(i)}} e^{s \cos \theta^{(i)}_k}} \tag{**}</script><script type="math/tex; mode=display">s.t. \qquad \cos \theta^{(i)}_j = \frac{W_j^T f^{(i)}}{||W_j||||f^{(i)}||}</script><div class="table-container"><table><thead><tr><th>Margin type</th><th>Modified</th><th>CosFace</th><th>SphereFace</th><th>ArcFace</th><th>ArcFace</th><th>ArcFace</th><th>ArcFace</th></tr></thead><tbody><tr><td>$s$</td><td>8</td><td>8</td><td>8</td><td><strong>16</strong></td><td><strong>8</strong></td><td><strong>4</strong></td><td><strong>1</strong></td></tr><tr><td>$m_1(m_1&gt;=2)$</td><td>1</td><td>1</td><td><strong>2</strong></td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>$m_2(m_2&gt;0)$</td><td>0</td><td>0</td><td>0</td><td><strong>0.5</strong></td><td><strong>0.5</strong></td><td><strong>0.5</strong></td><td><strong>0.5</strong></td></tr><tr><td>$m_3(m_3&gt;0)$</td><td>0</td><td><strong>0.35</strong></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table></div><ol><li>参数$s$对实验结果影响不大；</li><li><code>CosFace</code>, <code>SphereFace</code>, <code>ArcFace</code>三种损失作用下，角度的区分度均比<code>Modified Softmax</code>效果好。</li></ol><h3 id="嵌入向量维度为2"><a href="#嵌入向量维度为2" class="headerlink" title="嵌入向量维度为2"></a>嵌入向量维度为2</h3><p><img src="/2019/07/13/SphereFace-CosFace-ArcFace/exp1_dim2.png" alt="exp1_dim2"></p><h3 id="嵌入向量维度为3"><a href="#嵌入向量维度为3" class="headerlink" title="嵌入向量维度为3"></a>嵌入向量维度为3</h3><blockquote><p>使用<code>imageio.mimread()</code>函数，读取出<code>.gif</code>会改变原图颜色，很迷。</p></blockquote><p><img src="/2019/07/13/SphereFace-CosFace-ArcFace/exp1_dim3.gif" alt="exp1_dim3"></p><h2 id="2-改进的方法实验"><a href="#2-改进的方法实验" class="headerlink" title="2. 改进的方法实验"></a>2. 改进的方法实验</h2><div class="table-container"><table><thead><tr><th>Margin type</th><th>CosMulFace</th><th>CosMulFace</th><th>CosMulFace</th><th>AdaptiveFace</th></tr></thead><tbody><tr><td>$s$</td><td>8</td><td>8</td><td>8</td><td>8</td></tr><tr><td>$m_1(m_1&gt;=2)$</td><td>1</td><td>1</td><td>1</td><td>/</td></tr><tr><td>$m_2(m_2&gt;0)$</td><td>0</td><td>0</td><td>0</td><td>/</td></tr><tr><td>$m_3(m_3&gt;0)$</td><td>0</td><td>0</td><td>0</td><td>/</td></tr><tr><td>$m_4(m_4 &gt; 1)$</td><td><strong>2.00</strong></td><td><strong>3.00</strong></td><td><strong>4.00</strong></td><td>/</td></tr></tbody></table></div><ul><li><code>CosMulFace</code>在$m=2, 4$时效果良好。</li><li><code>AdaptiveFace</code>得到自适应参数如下(?)<script type="math/tex; mode=display">  \begin{cases}      m_1 = 1 \\      m_2 = 0 \\      m_3 = 0 \\      m_4 = 6.8345 \\  \end{cases}</script></li></ul><h3 id="嵌入向量维度为2-1"><a href="#嵌入向量维度为2-1" class="headerlink" title="嵌入向量维度为2"></a>嵌入向量维度为2</h3><p><img src="/2019/07/13/SphereFace-CosFace-ArcFace/exp2_dim2.png" alt="exp2_dim2"></p><h3 id="嵌入向量维度为3-1"><a href="#嵌入向量维度为3-1" class="headerlink" title="嵌入向量维度为3"></a>嵌入向量维度为3</h3><p><img src="/2019/07/13/SphereFace-CosFace-ArcFace/exp2_dim3.gif" alt="exp2_dim3"></p><h2 id="3-传新版本"><a href="#3-传新版本" class="headerlink" title="3. 传新版本"></a>3. 传新版本</h2><p>可见其角度分布更加均匀，从而区分度更大。</p><h3 id="嵌入向量维度为2-2"><a href="#嵌入向量维度为2-2" class="headerlink" title="嵌入向量维度为2"></a>嵌入向量维度为2</h3><p><img src="/2019/07/13/SphereFace-CosFace-ArcFace/exp3_dim2.png" alt="exp3_dim2"></p><h3 id="嵌入向量维度为3-2"><a href="#嵌入向量维度为3-2" class="headerlink" title="嵌入向量维度为3"></a>嵌入向量维度为3</h3><p><img src="/2019/07/13/SphereFace-CosFace-ArcFace/exp3_dim3.gif" alt="exp3_dim3"></p><p>上图和#$%@%一样，如下为<code>scatter_lda8</code>原图</p><p><img src="/2019/07/13/SphereFace-CosFace-ArcFace/gif/scatter_lda8.gif" alt="scatter_lda8"></p><p><img src="/2019/07/13/SphereFace-CosFace-ArcFace/gif/scatter_lda8_spherized.gif" alt="scatter_lda8_spherized"></p><p>数据类别过多可能不够明显，现选择4类，在设置$\lambda=0$与$\lambda=16$时，各类别的三维分布如下两图，区别很明显</p><p><img src="/2019/07/13/SphereFace-CosFace-ArcFace/gif/scatter_lda0_c4_.gif" alt="scatter_lda0_c4_"></p><p><img src="/2019/07/13/SphereFace-CosFace-ArcFace/gif/scatter_lda16_c4_.gif" alt="scatter_lda16_c4_"></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://arxiv.org/abs/1801.07698v1" target="_blank" rel="noopener">ArcFace: Additive Angular Margin Loss for Deep Face Recognition - arxiv.org</a></li><li><a href="https://arxiv.org/abs/1801.09414" target="_blank" rel="noopener">CosFace: Large Margin Cosine Loss for Deep Face Recognition - arxiv.org</a></li><li><a href="https://arxiv.org/abs/1704.08063" target="_blank" rel="noopener">SphereFace: Deep Hypersphere Embedding for Face Recognition - arxiv.org</a></li><li><a href="https://github.com/deepinsight/insightface" target="_blank" rel="noopener">deepinsight/insightface - Github</a></li><li><a href="https://github.com/wy1iu/sphereface" target="_blank" rel="noopener">wy1iu/sphereface - Github</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python迭代器与生成器</title>
      <link href="/2019/07/11/Python%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/"/>
      <url>/2019/07/11/Python%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在读取大数据量的文件时，使用迭代器和生成器可减少内存开销。</p><h1 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器(Iterator)"></a>迭代器(Iterator)</h1><p>迭代是Python访问集合元素的一种方式。迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p><h2 id="内建函数iter-与next"><a href="#内建函数iter-与next" class="headerlink" title="内建函数iter()与next()"></a>内建函数iter()与next()</h2><p>该函数将可迭代对象转换为迭代器，支持的数据容器对象如<code>string</code>、<code>list</code>、<code>dict</code>、<code>tuple</code>等，使用方法如下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="comment"># 创建可迭代对象</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a = <span class="string">"iterator"</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; b = [_ <span class="keyword">for</span> _ <span class="keyword">in</span> a]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; c = dict(zip(a, range(len(a))))</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; d = tuple(a)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a</span></span><br><span class="line">'iterator'</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; b</span></span><br><span class="line">['i', 't', 'e', 'r', 'a', 't', 'o', 'r']</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; c</span></span><br><span class="line">&#123;'i': 0, 't': 5, 'e': 2, 'r': 7, 'a': 4, 'o': 6&#125;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; d</span></span><br><span class="line">('i', 't', 'e', 'r', 'a', 't', 'o', 'r')</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="comment"># 调用`iter()`函数将可迭代对象转换为迭代器</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; all = [a, b, c, d]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; iterAll = list(map(iter, all))</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; all</span></span><br><span class="line">['iterator', ['i', 't', 'e', 'r', 'a', 't', 'o', 'r'], &#123;'i': 0, 't': 5, 'e': 2, 'r': 7, 'a': 4, 'o': 6&#125;, ('i', 't', 'e', 'r', 'a', 't', 'o', 'r')]</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; iterAll</span></span><br><span class="line">[&lt;str_iterator object at 0x00000216C399D6A0&gt;, &lt;list_iterator object at 0x00000216C399D6D8&gt;, &lt;dict_keyiterator object at 0x00000216C37672C8&gt;, &lt;tuple_iterator object at 0x00000216C399D710&gt;]</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="comment"># 反复调用`next()`函数取出迭代器值</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; next(iterAll[0])</span></span><br><span class="line">'i'</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; next(iterAll[0])</span></span><br><span class="line">'t'</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; next(iterAll[0])</span></span><br><span class="line">'e'</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; next(iterAll[0])</span></span><br><span class="line">'r'</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; next(iterAll[0])</span></span><br><span class="line">'a'</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; next(iterAll[0])</span></span><br><span class="line">'t'</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; next(iterAll[0])</span></span><br><span class="line">'o'</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; next(iterAll[0])</span></span><br><span class="line">'r'</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="comment"># 迭代结束</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; next(iterAll[0])</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure></p><h2 id="for语法糖"><a href="#for语法糖" class="headerlink" title="for语法糖"></a>for语法糖</h2><p>实际中对可迭代对象进行迭代时，上述这般麻烦。在Python的循环语句<code>for</code>已对其进行包装，内部调用函数<code>iter()</code>和<code>next()</code>，返回可迭代对象元素<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a</span></span><br><span class="line">'iterator'</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="keyword">for</span> i <span class="keyword">in</span> a:</span></span><br><span class="line">...     print(i)</span><br><span class="line">...</span><br><span class="line">i</span><br><span class="line">t</span><br><span class="line">e</span><br><span class="line">r</span><br><span class="line">a</span><br><span class="line">t</span><br><span class="line">o</span><br><span class="line">r</span><br></pre></td></tr></table></figure></p><h2 id="自定义迭代器-敲黑板划重点！"><a href="#自定义迭代器-敲黑板划重点！" class="headerlink" title="自定义迭代器(敲黑板划重点！)"></a>自定义迭代器(敲黑板划重点！)</h2><p>将自定义类定义为可迭代对象的实现方法是，实现魔术方法<code>__iter__()</code>与<code>__next__()</code>。</p><p>例如，要求返回斐波那契数列前20个值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, m)</span>:</span></span><br><span class="line">        </span><br><span class="line">        self.m = m</span><br><span class="line">        self.n, self.a, self.b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.n &lt; self.m:</span><br><span class="line">            t = self.b</span><br><span class="line">            self.a, self.b = self.b, self.a + self.b</span><br><span class="line">            self.n += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> t</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br></pre></td></tr></table></figure></p><p>在命令行中执行<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; from iter import Fibonacci</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; g = Fibonacci(20)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; g</span></span><br><span class="line">&lt;iter.Fibonacci object at 0x000001F359927E10&gt;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="keyword">while</span> True:</span></span><br><span class="line">...     try:</span><br><span class="line">...             next(g)</span><br><span class="line">...     except StopIteration:</span><br><span class="line">...             break</span><br><span class="line">...</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">8</span><br><span class="line">13</span><br><span class="line">21</span><br><span class="line">34</span><br><span class="line">55</span><br><span class="line">89</span><br><span class="line">144</span><br><span class="line">233</span><br><span class="line">377</span><br><span class="line">610</span><br><span class="line">987</span><br><span class="line">1597</span><br><span class="line">2584</span><br><span class="line">4181</span><br><span class="line">6765</span><br></pre></td></tr></table></figure></p><blockquote><p>在<code>Pytorch</code>中，数据集<code>Dataset</code>定义时，重写函数<code>__getitem__()</code>与<code>__len__()</code>，并不是可迭代对象，而<code>Dataloader</code>为可迭代对象，详细源码可查看<a href="https://github.com/pytorch/pytorch/blob/master/torch/utils/data/dataloader.py/" target="_blank" rel="noopener">Github: Pytorch</a></p></blockquote><h1 id="生成器-Generator"><a href="#生成器-Generator" class="headerlink" title="生成器(Generator)"></a>生成器(Generator)</h1><p>调用一个生成器函数，返回的是一个迭代器对象。在调用生成器运行的过程中，每次遇到<code>yield</code>时函数会暂停并保存当前所有的运行信息，返回<code>yield</code>的值, 并在下一次执行<code>next()</code>方法时从当前位置继续运行。</p><h2 id="推导式定义生成器"><a href="#推导式定义生成器" class="headerlink" title="推导式定义生成器"></a>推导式定义生成器</h2><p>语法类似列表推导式，不同的是将<code>[]</code>改为<code>()</code><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; g = (i <span class="keyword">for</span> i <span class="keyword">in</span> range(20))</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; g</span></span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x00000161D16F44F8&gt;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; next(g)</span></span><br><span class="line">0</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; next(g)</span></span><br><span class="line">1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; next(g)</span></span><br><span class="line">2</span><br></pre></td></tr></table></figure></p><h2 id="将函数定义为生成器"><a href="#将函数定义为生成器" class="headerlink" title="将函数定义为生成器"></a>将函数定义为生成器</h2><p>利用函数打印斐波那契数列<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(m)</span>:</span></span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; m:</span><br><span class="line">        print(b)</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>若需得到生成器，将<code>print()</code>改为<code>yield()</code>即可<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci_gen</span><span class="params">(m)</span>:</span></span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; m:</span><br><span class="line">        <span class="keyword">yield</span>(b)</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>在命令行中执行<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; from iter import fibonacci_gen</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; g = fibonacci_gen(20)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; g</span></span><br><span class="line">&lt;generator object fibonacci_gen at 0x000001F036DA44F8&gt;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; next(g)</span></span><br><span class="line">1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; next(g)</span></span><br><span class="line">1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; next(g)</span></span><br><span class="line">2</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; next(g)</span></span><br><span class="line">3</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; next(g)</span></span><br><span class="line">5</span><br></pre></td></tr></table></figure></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.runoob.com/python3/python3-iterator-generator.html" target="_blank" rel="noopener">Python3 迭代器与生成器 - 菜鸟教程</a></li><li><a href="https://www.cnblogs.com/tkqasn/p/5984090.html" target="_blank" rel="noopener">python 迭代器和生成器详解 - 博客园</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WSL - Windows Subsystem for Linux</title>
      <link href="/2019/07/11/WSL-Windows-Subsystem-for-Linux/"/>
      <url>/2019/07/11/WSL-Windows-Subsystem-for-Linux/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Windows远程登陆服务器，需要借助<a href="https://xshell.en.softonic.com/" target="_blank" rel="noopener">xshell</a>等软件。其实安装完子系统后，即可使用<code>ssh</code>登录，并且子系统与原系统隔离较好，不会产生影响。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol><li><p>呼叫小娜，打开“启用或关闭Windows功能”，勾选“适用于Linux的Windows子系统”，并重启；<br> <img src="/2019/07/11/WSL-Windows-Subsystem-for-Linux/wsl1.jpg" alt="wsl1"><br> <img src="/2019/07/11/WSL-Windows-Subsystem-for-Linux/wsl2.jpg" alt="wsl2"></p></li><li><p>在巨硬软件商城(Microsoft Store)中下载合适的WSL，选择喜好的WSL进行安装</p></li></ol><ul><li><a href="https://www.microsoft.com/zh-cn/p/ubuntu-1604-lts/9pjn388hp8c9?rtc=1&amp;activetab=pivot:overviewtab" target="_blank" rel="noopener">Ubuntu 16.04 LTS</a></li><li><a href="https://www.microsoft.com/zh-cn/p/ubuntu-1804-lts/9n9tngvndl3q?rtc=1&amp;activetab=pivot:overviewtab" target="_blank" rel="noopener">Ubuntu 18.04 LTS</a></li><li><a href="https://www.microsoft.com/zh-cn/p/opensuse-leap-15/9n1tb6fpvj8c?rtc=1&amp;activetab=pivot:overviewtab" target="_blank" rel="noopener">OpenSUSE Leap 15</a></li><li><a href="https://www.microsoft.com/zh-cn/p/opensuse-leap-42/9njvjts82tjx?rtc=1&amp;activetab=pivot:overviewtab" target="_blank" rel="noopener">OpenSUSE Leap 42</a></li><li><a href="https://www.microsoft.com/zh-cn/p/suse-linux-enterprise-server-12/9p32mwbh6cns?rtc=1&amp;activetab=pivot:overviewtab" target="_blank" rel="noopener">SUSE Linux Enterprise Server 12</a></li><li><a href="https://www.microsoft.com/zh-cn/p/suse-linux-enterprise-server-15/9pmw35d7fnlx?rtc=1&amp;activetab=pivot:overviewtab" target="_blank" rel="noopener">SUSE Linux Enterprise Server 15</a></li><li><a href="https://www.microsoft.com/zh-cn/p/kali-linux/9pkr34tncv07?rtc=1&amp;activetab=pivot:overviewtab" target="_blank" rel="noopener">Kali Linux</a></li><li><a href="https://www.microsoft.com/zh-cn/p/debian/9msvkqc78pk6?rtc=1&amp;activetab=pivot:overviewtab" target="_blank" rel="noopener">Debian GNU/Linux</a></li><li><a href="https://www.microsoft.com/zh-cn/p/fedora-remix-for-wsl/9n6gdm4k2hnc?rtc=1&amp;activetab=pivot:overviewtab" target="_blank" rel="noopener">Fedora Remix for WSL</a></li><li><a href="https://www.microsoft.com/zh-cn/p/pengwin/9nv1gv1pxz6p?rtc=1&amp;activetab=pivot:overviewtab" target="_blank" rel="noopener">Pengwin</a></li><li><a href="https://www.microsoft.com/zh-cn/p/pengwin-enterprise/9n8lp0x93vcp?rtc=1&amp;activetab=pivot:overviewtab" target="_blank" rel="noopener">Pengwin Enterprise</a></li><li><a href="https://www.microsoft.com/zh-cn/p/alpine-wsl/9p804crf0395?rtc=1&amp;activetab=pivot:overviewtab" target="_blank" rel="noopener">Alpine WSL</a></li></ul><ol><li>启动WSL，并添加用户和密码，即可使用<br><img src="/2019/07/11/WSL-Windows-Subsystem-for-Linux/wsl3.jpg" alt="wsl3"><br><img src="/2019/07/11/WSL-Windows-Subsystem-for-Linux/wsl4.jpg" alt="wsl4"></li></ol><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10" target="_blank" rel="noopener">Windows Subsystem for Linux Installation Guide for Windows 10 - Microsoft</a></li><li><a href="https://linux.cn/article-9545-1.html" target="_blank" rel="noopener">如何在Windows 10上开启WSL之旅</a></li><li><a href="https://www.cnblogs.com/skyshalo/p/7724072.html" target="_blank" rel="noopener">关于WSL(Windows上的Linux子系统)的简单介绍及安装 - CNBLOG</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python语法糖</title>
      <link href="/2019/06/17/Python%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
      <url>/2019/06/17/Python%E8%AF%AD%E6%B3%95%E7%B3%96/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>盘点一些有趣的、pythonic的骚操作。</p><ul><li><a href="#目录">目录</a></li><li><a href="#切片操作">切片操作</a></li><li><a href="#ellipsis">Ellipsis(…)</a></li><li><a href="#动态参数-args-kwargs">动态参数: *args, **kwargs</a></li><li><a href="#魔法方法">魔法方法</a></li><li><a href="#上下文管理器-with">上下文管理器: with</a></li><li><a href="#匿名函数-lambda">匿名函数: lambda</a></li><li><a href="#推导表达式">推导表达式</a></li><li><a href="#生成器和迭代器">生成器和迭代器</a><ul><li><a href="#for">for</a></li><li><a href="#迭代器">迭代器</a></li><li><a href="#生成器">生成器</a></li></ul></li><li><a href="#装饰器">装饰器</a></li><li><a href="#else的妙用">else的妙用</a><ul><li><a href="#if-else">if-else</a></li><li><a href="#for-else">for-else</a></li><li><a href="#while-else">while-else</a></li><li><a href="#try-except-else">try-except-else</a></li></ul></li><li><a href="#reference">Reference</a></li></ul><h1 id="切片操作"><a href="#切片操作" class="headerlink" title="切片操作"></a>切片操作</h1><p>切片操作用于<strong>从数组中获取部分值</strong>，完整的切片语句如下，即从<code>start</code>索引开始，以<code>step</code>为间隔获取元素，直至索引<code>end</code>(不包括)<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object[start: end: step]</span><br></pre></td></tr></table></figure></p><p>切片操作主要有以下几种<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = list(range(<span class="number">20</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 获取索引为`0`的元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>]</span><br><span class="line"><span class="number">0</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 获取索引为`18`的元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">18</span>]</span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 支持负索引，即等价于</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">-2</span>]</span><br><span class="line"><span class="number">18</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 获取从数组开始，前10个元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[:<span class="number">10</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 获取从第10个元素开始的所有元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">10</span>:]</span><br><span class="line">[<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 获取索引为奇数的元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>::<span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">17</span>, <span class="number">19</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 获取从数组开始，前10个元素中索引为奇数的元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>:<span class="number">10</span>:<span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 将列表逆序，不会修改a</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 在功能上等价于列表方法`reverse()`，但这是in-place操作，会修改a内容</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[::<span class="number">-1</span>]</span><br><span class="line">[<span class="number">19</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">16</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 逆序后前10个元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[:<span class="number">10</span>:<span class="number">-1</span>]</span><br><span class="line">[<span class="number">19</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">16</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">11</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 等价于</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[::<span class="number">-1</span>][:<span class="number">10</span>]</span><br><span class="line">[<span class="number">19</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">16</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 不同于</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[:<span class="number">10</span>][::<span class="number">-1</span>]</span><br><span class="line">[<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="Ellipsis-…"><a href="#Ellipsis-…" class="headerlink" title="Ellipsis(…)"></a>Ellipsis(…)</h1><p>非常pythonic的一个思想是，<strong>一切皆对象</strong>，在python中<code>...</code>也是有含义的<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># CLI中直接打印输出</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>...</span><br><span class="line"><span class="built_in">Ellipsis</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 类型是`ellipsis`类</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(...)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">ellipsis</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; # 转换为布尔类型是真</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">bool</span><span class="params">(...)</span></span></span><br><span class="line"><span class="class"><span class="title">True</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; # 是一个实例，具有自己的<span class="title">id</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">id</span><span class="params">(...)</span></span></span><br><span class="line"><span class="class">140718179951088</span></span><br></pre></td></tr></table></figure></p><p>许多函数，如<code>builtins.pyi</code>中就有如下形式的函数定义<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">abs</span><span class="params">(__n: SupportsAbs[_T])</span> -&gt; _T:</span> ...</span><br></pre></td></tr></table></figure></p><p>在<a href="https://www.quora.com/What-do-the-dots-mean-in-Python" target="_blank" rel="noopener">Quora</a>中有一条这样的回答</p><p>The other answers are correct to point out that … is <strong>the default secondary prompt in the Python interpreter</strong>, generated when you type multi-line constructs. (See 2. Using the Python Interpreter for more details.)<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>the_world_is_flat = <span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> the_world_is_flat:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"Be careful not to fall off!"</span>)</span><br><span class="line">...</span><br><span class="line">Be careful <span class="keyword">not</span> to fall off!</span><br></pre></td></tr></table></figure><br>However, … is actually also a valid Python expression which represents the singleton Ellipsis object. This object has no methods and was originally intended only for use in <strong>advanced slicing notation in the numpy package</strong>: for example a[…, 0] selects the first elements in the last dimension of a multidimensional array. However, it is sometimes also used:</p><ul><li><strong>as a placeholder for not-yet-written code</strong> (e.g. if error: …). Code that is intentionally empty is better represented with pass.</li><li><strong>when specifying type hints using the typing module</strong> (e.g. Callable[…, str] signifies a function that returns a string without specifying the call signature).</li><li><strong>as a default argument value</strong> (e.g. def fn(x=…)), especially when you want to distinguish between not passing in a value and passing in None.</li></ul><p>Since … is a singleton, you should check for it with is rather than ==.</p><h1 id="动态参数-args-kwargs"><a href="#动态参数-args-kwargs" class="headerlink" title="动态参数: *args, **kwargs"></a>动态参数: *args, **kwargs</h1><p>定义python函数时，常常看到以下的形式<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p><p>其中<code>*args</code>是位置参数，以元组形式保存；<code>**kwargs</code>是关键字参数，以字典形式保存。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    print(type(args))</span><br><span class="line">    print(args)</span><br><span class="line">    print(type(kwargs))</span><br><span class="line">    print(kwargs)</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, a=<span class="number">4</span>, b=<span class="number">5</span>, c=<span class="number">6</span>)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">tuple</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">dict</span>'&gt;</span></span><br><span class="line">&#123;'a': 4, 'b': 5, 'c': 6&#125;</span><br></pre></td></tr></table></figure><p>也可以将位置参数和关键字参数用<code>*</code>解析后，直接传入函数<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, b, c, d, e, f)</span>:</span></span><br><span class="line">    print(a, b, c, d, e, f)</span><br></pre></td></tr></table></figure></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>args = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kwargs = &#123;<span class="string">'d'</span>: <span class="number">4</span>, <span class="string">'e'</span>: <span class="number">5</span>, <span class="string">'f'</span>: <span class="number">6</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(*args, **kwargs)</span><br><span class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span></span><br></pre></td></tr></table></figure><div style="page-break-after: always;"></div><h1 id="魔法方法"><a href="#魔法方法" class="headerlink" title="魔法方法"></a>魔法方法</h1><p>Python中以<code>__[function]__</code>形式定义的函数就是<strong>魔术方法</strong>(Magic Function)，可以实现运算符重载等操作。常用的魔术方法有很多，如构造函数<code>__init__</code>和析构函数<code>__del__</code>、对象元素相关的如<code>__len__, __getitem__, __setitem__, __delitem__</code>、迭代器相关的如<code>__iter__</code>和<code>__next__</code>、运算类<code>__add__, __sub__</code>等等。</p><p>这类方法会在不同的时机被调用，如构造函数<code>__init__</code>在类的实例化时被调用，<code>__getitem__</code>在形如<code>obj[key]</code>取元素时被调用，<code>__len__</code>又在函数<code>len(obj)</code>时被调用，<code>__call__</code>可将实例化的对象作为可调用对象，即<code>obj(*args)</code>，例如<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'call __init__'</span>)</span><br><span class="line">        self.nums = list(range(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        print(<span class="string">'call __getitem__'</span>)</span><br><span class="line">        <span class="keyword">return</span> self.nums[index]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'call __len__'</span>)</span><br><span class="line">        <span class="keyword">return</span> len(self.nums)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'call __call__'</span>)</span><br></pre></td></tr></table></figure></p><p>分别触发函数调用<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = A()</span><br><span class="line">call __init__</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>]</span><br><span class="line">call __getitem__</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(a)</span><br><span class="line">call __len__</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a()</span><br><span class="line">call __call__</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="上下文管理器-with"><a href="#上下文管理器-with" class="headerlink" title="上下文管理器: with"></a>上下文管理器: with</h1><p>上下文指的是，在执行某些操作时，需要先进行一些初始化工作，结束后还需执行一些清理工作。例如在读写文件时，需要先打开文件，然后读写，结束后关闭文件，完整的代码如下<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 只写形式打开文件</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'test.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 写入一些内容</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">"test line"</span>)</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 关闭文件</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br></pre></td></tr></table></figure></p><p>在python中可以用<code>with</code>关键字自动完成上下文管理，即<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'test.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">... </span>    f.write(<span class="string">"test line"</span>)</span><br><span class="line">...</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure></p><p>上下文管理器的原理是实现了类的<code>__enter__</code>和<code>__exit__</code>魔法方法，例如<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextIllustration</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        print(val)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'entering...'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'exiting...'</span>)</span><br></pre></td></tr></table></figure></p><p>在调用时，如下<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> ContextIllustration(<span class="string">'hello'</span>):</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'world'</span>)</span><br><span class="line">...</span><br><span class="line">hello</span><br><span class="line">entering...</span><br><span class="line">world</span><br><span class="line">exiting...</span><br></pre></td></tr></table></figure></p><h1 id="匿名函数-lambda"><a href="#匿名函数-lambda" class="headerlink" title="匿名函数: lambda"></a>匿名函数: lambda</h1><p>匿名函数的定义格式为<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> args: expression</span><br></pre></td></tr></table></figure><br>其中<code>args</code>是参数列表，<code>expression</code>是关于参数的表达式。它具有以下特性</p><ul><li>是匿名的，定义时没有指定函数名，将其赋值给变量后，通过变量进行调用；</li><li>有输入和输出，输入是参数列表指定的值，输出是<code>expression</code>的运算结果；</li><li>功能简单，能完成一些简单的功能，提高代码可重用性，但不能实现复杂的功能，如异常捕获等。</li></ul><p>常用于<code>map</code>、<code>filter</code>、<code>sort</code>、<code>reduce</code>等内建函数，例如<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = list(range(<span class="number">20</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 求各个数字的平方</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, a))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>, <span class="number">121</span>, <span class="number">144</span>, <span class="number">169</span>, <span class="number">196</span>, <span class="number">225</span>, <span class="number">256</span>, <span class="number">289</span>, <span class="number">324</span>, <span class="number">361</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 过滤出3的倍数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(filter(<span class="keyword">lambda</span> x: x % <span class="number">3</span> == <span class="number">0</span>, a))</span><br><span class="line">[<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">18</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 以 x % 3 排序</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(a, key=<span class="keyword">lambda</span> x: x % <span class="number">3</span>)</span><br><span class="line">[<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">18</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">19</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">14</span>, <span class="number">17</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 求数组的元素之和</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(reduce(<span class="keyword">lambda</span> x , y: x + y, a))</span><br><span class="line"><span class="number">190</span></span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="推导表达式"><a href="#推导表达式" class="headerlink" title="推导表达式"></a>推导表达式</h1><ul><li><p><strong>列表推导表达式</strong>：</p><p>  得到$0 \sim 20$范围内奇数列表</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[_ <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">20</span>, <span class="number">2</span>)]</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">17</span>, <span class="number">19</span>]</span><br></pre></td></tr></table></figure><p>  还可以带判断条件进行生成，如得到$0 \sim 20$范围内$3$的倍数的列表</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>) <span class="keyword">if</span> i % <span class="number">3</span> == <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">18</span>]</span><br></pre></td></tr></table></figure></li><li><p><strong>生成器推导表达式</strong></p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = (i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>) <span class="keyword">if</span> i % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x000001FC712E0DE0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> num <span class="keyword">in</span> g:</span><br><span class="line"><span class="meta">... </span>    print(num)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>集合推导表达式</strong><br>  集合的特点是不存在重复的元素，如</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[i // <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>)]</span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;i // <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>)&#125;</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>字典推导表达式</strong></p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;str(i): i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>) <span class="keyword">if</span> i % <span class="number">3</span> == <span class="number">0</span>&#125;</span><br><span class="line">&#123;<span class="string">'0'</span>: <span class="number">0</span>, <span class="string">'3'</span>: <span class="number">3</span>, <span class="string">'6'</span>: <span class="number">6</span>, <span class="string">'9'</span>: <span class="number">9</span>, <span class="string">'12'</span>: <span class="number">12</span>, <span class="string">'15'</span>: <span class="number">15</span>, <span class="string">'18'</span>: <span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="生成器和迭代器"><a href="#生成器和迭代器" class="headerlink" title="生成器和迭代器"></a>生成器和迭代器</h1><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p><code>for</code>是Python中重要的关键字，下面会介绍，在使用迭代器时，可通过显式调用<code>iter</code>和<code>next</code>函数来取得各项，实际上<code>for</code>已经将这两个函数包装<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it_a = iter(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)): <span class="comment"># range()返回了一个迭代器</span></span><br><span class="line"><span class="meta">... </span>    print(next(it_a))</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure></p><p>可以直接通过<code>for</code>迭代<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> num <span class="keyword">in</span> a:</span><br><span class="line"><span class="meta">... </span>    print(num)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure></p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代是Python访问数组元素的一种方式。迭代器是一个可以记住遍历位置的对象，从数组的一个元素开始访问，遍历到数组尾部。注意迭代器只能向前不能后退。</p><p>Python中有一个很重要的概念是<strong>可迭代对象</strong>，一般来说定义了<code>__iter__</code>函数的对象都具有可迭代属性，如<code>list</code>, <code>set</code>, <code>dict</code>, <code>str</code>等等，可以用内置函数<code>isinstance</code>进行判别</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(a, Iterable)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p><strong>实现迭代功能需要借助以下两个函数</strong></p><ul><li><code>iter(object[, sentinel])</code>：用于生成迭代器<ul><li><code>object</code>：支持迭代的集合对象；</li><li><code>sentinel</code>：如果传递了该参数，那么<code>object</code>必须是可调用对象(如函数)，当迭代器返回值与<code>sentinel</code>一致时停止迭代，并抛出<code>StopIteration</code>异常。</li></ul></li><li><code>next(iterator[, default])</code>：返回迭代器的下一个项目<ul><li><code>iterator</code>：可迭代对象；</li><li><code>default</code>：用于设置在没有下一个元素时返回该默认值。</li></ul></li></ul><p>比如迭代字符串<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"test"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s_it = iter(s)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(s_it)</span><br><span class="line"><span class="string">'t'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(s_it)</span><br><span class="line"><span class="string">'e'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(s_it)</span><br><span class="line"><span class="string">'s'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(s_it)</span><br><span class="line"><span class="string">'t'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(s_it)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure></p><p>还可以<strong>自定义迭代器</strong>，例如定义一个可返回$n$个元素的斐波那契数列的可迭代对象<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span>:</span></span><br><span class="line">    <span class="string">""" 1, 1, 2, 3, 5, 8, 13, ... """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.a, self.b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        self.n = n</span><br><span class="line">        self.i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.i == self.n:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line">        a = self.a</span><br><span class="line">        self.i += <span class="number">1</span></span><br><span class="line">        self.a, self.b = self.b, self.a + self.b</span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure></p><p>调用时<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = Fibonacci(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> num <span class="keyword">in</span> iter(f):</span><br><span class="line"><span class="meta">... </span>    print(num)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">34</span></span><br><span class="line"><span class="number">55</span></span><br></pre></td></tr></table></figure></p><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>生成器是一种特殊的迭代器，通过生成器表达式<code>()</code>或在函数中用<code>yield</code>关键字创建<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = (i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x0000014C2B5544F8</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>又如用生成器重写上面的斐波那契数列生成函数<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(m)</span>:</span></span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    a, b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; m:</span><br><span class="line">        <span class="keyword">yield</span>(a)</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br></pre></td></tr></table></figure></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = fibonacci(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f</span><br><span class="line">&lt;generator object fibonacci at <span class="number">0x00000275142345E8</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> num <span class="keyword">in</span> iter(f):</span><br><span class="line"><span class="meta">... </span>    print(num)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">34</span></span><br><span class="line"><span class="number">55</span></span><br></pre></td></tr></table></figure><div style="page-break-after: always;"></div><h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><p>装饰器是基于<strong>闭包</strong>(Closure)编程，简单来说就是<strong>一个函数定义中引用了函数外定义的变量，并且该函数可以在其定义环境外被执行</strong>，这样的一个函数我们称之为闭包。实际上闭包可以看做一种更加广义的函数概念。因为其已经不再是传统意义上定义的函数。</p><p>例如下面函数<code>print_hello_world</code>中嵌入了局部函数<code>print_world</code>，并将其作为返回值，<code>print_world</code>中引用了函数之外定义的变量<code>hello</code>。按照C/C++的方式理解，在退出<code>print_hello_world</code>函数后，<code>hello</code>变量将被释放，但是实际上这个局部变量被封闭在了局部函数中<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_hello_world</span><span class="params">()</span>:</span></span><br><span class="line">    hello = <span class="string">'hello'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_world</span><span class="params">()</span>:</span></span><br><span class="line">        print(hello, <span class="string">'world'</span>)</span><br><span class="line">    <span class="keyword">return</span> print_world</span><br></pre></td></tr></table></figure></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = print_hello_world()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f</span><br><span class="line">&lt;function print_hello_world.&lt;locals&gt;.print_world at <span class="number">0x00000199391312F0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(f)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">function</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; </span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="class"><span class="title">hello</span> <span class="title">world</span></span></span><br></pre></td></tr></table></figure><p>装饰器的本质是一个函数，接受另一个函数作为参数，对其进行处理后返回，例如<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">warper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">'call'</span>, func.__name__)    <span class="comment"># 添加log信息</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> func(*args, *kwargs)     <span class="comment"># 执行func函数</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> warper</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(x)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f_with_log = log(f)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f_with_log(<span class="string">"this is a decorated function"</span>)</span><br><span class="line">call f</span><br><span class="line">this <span class="keyword">is</span> a decorated function</span><br></pre></td></tr></table></figure></p><p>用修饰符<code>@</code>改写上述代码<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">warper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">'call'</span>, func.__name__)    <span class="comment"># 添加log信息</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> func(*args, *kwargs)     <span class="comment"># 执行func函数</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> warper</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@log</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(x)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="string">"this is a decorated function"</span>)</span><br><span class="line">call f</span><br><span class="line">this <span class="keyword">is</span> a decorated function</span><br></pre></td></tr></table></figure></p><p>但是这样会有问题，函数<code>f</code>的名字被改写成了<code>warper</code><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__name__</span><br><span class="line"><span class="string">'warper'</span></span><br></pre></td></tr></table></figure></p><p>在装饰器内用<code>functools.wraps</code>进行包装<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">""" 返回闭包函数 """</span></span><br><span class="line"><span class="meta">... </span>    @wraps(func)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">warper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="string">""" 嵌入 """</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">'call'</span>, func.__name__)    <span class="comment"># 添加log信息</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> func(*args, **kwargs)    <span class="comment"># 执行func函数</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> warper</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@log</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(x)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="string">"this is a decorated function"</span>)</span><br><span class="line">call f</span><br><span class="line">this <span class="keyword">is</span> a decorated function</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__name__</span><br><span class="line"><span class="string">'f'</span></span><br></pre></td></tr></table></figure></p><p>装饰器本质是个函数，是可以接受参数的，例如<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">log_with_text</span><span class="params">(text)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">""" 返回接受参数的装饰器 """</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="string">""" 返回闭包函数 """</span></span><br><span class="line"><span class="meta">... </span>        @wraps(func)</span><br><span class="line"><span class="meta">... </span>        <span class="function"><span class="keyword">def</span> <span class="title">warper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>            <span class="string">""" 嵌入 """</span></span><br><span class="line"><span class="meta">... </span>            print(<span class="string">'text'</span>, text)             <span class="comment"># 输出装饰器参数</span></span><br><span class="line"><span class="meta">... </span>            print(<span class="string">'call'</span>, func.__name__)    <span class="comment"># 添加log信息</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> func(*args, **kwargs)    <span class="comment"># 执行func函数</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> warper</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> decorator</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@log_with_text(<span class="string">'some parameters'</span>)</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(x)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="string">"this is a decorated function"</span>)</span><br><span class="line">text some parameters</span><br><span class="line">call f</span><br><span class="line">this <span class="keyword">is</span> a decorated function</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__name__</span><br><span class="line"><span class="string">'f'</span></span><br></pre></td></tr></table></figure></p><p>装饰器的一个用法是给函数绑定静态变量。python中没有声明静态变量的方法，只能通过全局变量来实现静态变量的功能。但是实际上，python的一切都是对象，函数也不例外，因此函数是可以设置属性的，即<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 当前函数`f`无属性`a`</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(f.a)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">'function'</span> object has no attribute <span class="string">'a'</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 设置属性`a`</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.a = <span class="string">"this is an attribute of function `f`"</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 当前函数`f`包含属性`a`</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(f.a)</span><br><span class="line">this <span class="keyword">is</span> an attribute of function `f`</span><br></pre></td></tr></table></figure></p><p>那么可以通过装饰器，给函数绑定函数变量作为静态变量</p><blockquote><p>注意下面的带参装饰器写法与上面说的有所不同，因为只需给函数<code>f</code>绑定变量，而无需通过调用<code>warper</code>来调用<code>f</code>。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">static_vars</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">set_static_vars</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">for</span> k <span class="keyword">in</span> kwargs:</span><br><span class="line"><span class="meta">... </span>            setattr(func, k, kwargs[k])</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> func</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> set_static_vars</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@static_vars(a=<span class="string">'this is an attribute of function `f`'</span>)</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(x)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.a</span><br><span class="line"><span class="string">'this is an attribute of function `f`'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__name__</span><br><span class="line"><span class="string">'f'</span></span><br></pre></td></tr></table></figure></p></blockquote><p>实际上可以写作<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>set_static_vars = static_vars(a=<span class="string">'this is an attribute of function `f`'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = set_static_vars(f)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.a</span><br><span class="line"><span class="string">'this is an attribute of function `f`'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__name__</span><br><span class="line"><span class="string">'f'</span></span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="else的妙用"><a href="#else的妙用" class="headerlink" title="else的妙用"></a>else的妙用</h1><p><code>else</code>在python中不仅仅只用于分支语句<code>if-elif-else</code>中，还可用于循环控制语句<code>for</code>、<code>while</code>的终止，以及异常捕获<code>try</code>中。</p><h2 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h2><p>很常用的用法，完整结构如下，所有测试条件都失败时会执行<code>else</code>块的语句<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition1:</span><br><span class="line">    ...     <span class="comment"># do something</span></span><br><span class="line"><span class="keyword">elif</span> condition2:</span><br><span class="line">    ...     <span class="comment"># do something</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">elif</span> conditionN:</span><br><span class="line">    ...     <span class="comment"># do something</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    ...     <span class="comment"># do something</span></span><br></pre></td></tr></table></figure></p><h2 id="for-else"><a href="#for-else" class="headerlink" title="for-else"></a>for-else</h2><p>在<code>for</code>循环语句中，<code>else</code>块的语句将在循环结束时执行，完整结构是<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> variables:</span><br><span class="line">    ...     <span class="comment"># do something</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    ...     <span class="comment"># do something</span></span><br></pre></td></tr></table></figure></p><p>例如<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line"><span class="meta">... </span>    print(i)</span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'done'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><h2 id="while-else"><a href="#while-else" class="headerlink" title="while-else"></a>while-else</h2><p><code>while</code>语句中<code>else</code>的用法同<code>for</code>，即<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> condition:</span><br><span class="line">    ...     <span class="comment"># do something</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    ...     <span class="comment"># do something</span></span><br></pre></td></tr></table></figure></p><p>例如<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>i = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> i &lt; <span class="number">5</span>:</span><br><span class="line"><span class="meta">... </span>    print(i)</span><br><span class="line"><span class="meta">... </span>    i += <span class="number">1</span></span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'done'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h2 id="try-except-else"><a href="#try-except-else" class="headerlink" title="try-except-else"></a>try-except-else</h2><p>异常捕获的完整语句是<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    ...     <span class="comment"># do something</span></span><br><span class="line"><span class="keyword">except</span> [XXXError]:</span><br><span class="line">    ...     <span class="comment"># do something</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    ...     <span class="comment"># do something</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    ...     <span class="comment"># do something</span></span><br></pre></td></tr></table></figure></p><p>其执行的顺序是</p><ul><li>先执行<code>try</code>语句块，分为以下两种情况</li><li>捕获到异常：发生的异常是指定的类型，执行<code>except</code>语句块；</li><li>未捕获异常：执行<code>else</code>语句块。</li><li>最后不论有无发生异常，都会执行<code>finally</code>语句块。</li></ul><p>例如，以<code>r+</code>方式打开未存在文件时，会发生<code>IOError</code>异常<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="keyword">None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    f = open(<span class="string">'test.txt'</span>, <span class="string">'r+'</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> IOError <span class="keyword">as</span> e:</span><br><span class="line"><span class="meta">... </span>    print(e)</span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>    print(f.read())</span><br><span class="line"><span class="meta">... </span>    f.close()</span><br><span class="line"><span class="meta">... </span><span class="keyword">finally</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'exiting...'</span>)</span><br><span class="line">...</span><br><span class="line">[Errno <span class="number">2</span>] No such file <span class="keyword">or</span> directory: <span class="string">'test.txt'</span></span><br><span class="line">exiting...</span><br></pre></td></tr></table></figure></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://www.cnblogs.com/zhouyixian/p/11129347.html#_label4" target="_blank" rel="noopener">Python的常用魔法方法详细总结</a></li><li><a href="https://blog.csdn.net/weixin_43790276/article/details/90216525" target="_blank" rel="noopener">Python with上下文管理及自定义上下文管理</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Useful Terminal Control Sequences</title>
      <link href="/2019/05/28/Useful-Terminal-Control-Sequences/"/>
      <url>/2019/05/28/Useful-Terminal-Control-Sequences/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>ANSI</code>定义了用于屏幕显示的<code>Escape</code>屏幕控制码，打印输出到终端时，可指定输出颜色、格式等。</p><h1 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\033[&lt;background color&gt;;&lt;front color&gt;m string to print \033[0m</span><br></pre></td></tr></table></figure><ul><li><code>\033[ xxxx m</code>为一个句段；</li><li><code>\033[0m</code>关闭所有属性；</li></ul><h1 id="光标控制"><a href="#光标控制" class="headerlink" title="光标控制"></a>光标控制</h1><div class="table-container"><table><thead><tr><th>ANSI控制码</th><th>含义</th></tr></thead><tbody><tr><td>\033[nA</td><td>光标上移n行</td></tr><tr><td>\033[nB</td><td>光标下移n行</td></tr><tr><td>\033[nC</td><td>光标右移n行</td></tr><tr><td>\033[nD</td><td>光标左移n行</td></tr><tr><td>\033[y;xH</td><td>设置光标位置</td></tr><tr><td>\033[2J</td><td>清屏</td></tr><tr><td>\033[K</td><td>清除从光标到行尾的内容</td></tr><tr><td>\033[s</td><td>保存光标位置</td></tr><tr><td>\033[u</td><td>恢复光标位置</td></tr><tr><td>\033[?25l</td><td>隐藏光标</td></tr><tr><td>\033[?25h</td><td>显示光标</td></tr></tbody></table></div><h1 id="颜色控制"><a href="#颜色控制" class="headerlink" title="颜色控制"></a>颜色控制</h1><div class="table-container"><table><thead><tr><th>ANSI控制码</th><th>含义</th></tr></thead><tbody><tr><td>\033[m</td><td>NONE</td></tr><tr><td>\033[0;32;31m</td><td>RED</td></tr><tr><td>\033[1;31m</td><td>LIGHT RED</td></tr><tr><td>\033[0;32;32m</td><td>GREEN</td></tr><tr><td>\033[1;32m</td><td>LIGHT GREEN</td></tr><tr><td>\033[0;32;34m</td><td>BULE</td></tr><tr><td>\033[1;34m</td><td>LIGHT BLUE</td></tr><tr><td>\033[1;30m</td><td>GRAY</td></tr><tr><td>\033[0;36m</td><td>CYAN</td></tr><tr><td>\033[1;36m</td><td>LIGHT CYAN</td></tr><tr><td>\033[0;35m</td><td>PURPLE</td></tr><tr><td>\033[1;35m</td><td>LIAGHT PURPLE</td></tr><tr><td>\033[0;33m</td><td>BROWN</td></tr><tr><td>\033[1;33m</td><td>YELLO</td></tr><tr><td>\033[0;37m</td><td>LIGHT GRAY</td></tr><tr><td>\033[1;37m</td><td>WHITE</td></tr></tbody></table></div><p>背景色与字体颜色符号不同</p><div class="table-container"><table><thead><tr><th>背景色</th><th>字体色</th></tr></thead><tbody><tr><td>40: 黑</td><td>30: 黑</td></tr><tr><td>41: 红</td><td>31: 红</td></tr><tr><td>42: 绿</td><td>32: 绿</td></tr><tr><td>43: 黄</td><td>33: 黄</td></tr><tr><td>44: 蓝</td><td>34: 蓝</td></tr><tr><td>45: 紫</td><td>35: 紫</td></tr><tr><td>46: 深绿</td><td>36: 深绿</td></tr><tr><td>47: 白色</td><td>37: 白色</td></tr></tbody></table></div><h1 id="格式控制"><a href="#格式控制" class="headerlink" title="格式控制"></a>格式控制</h1><div class="table-container"><table><thead><tr><th>ANSI控制码</th><th>含义</th></tr></thead><tbody><tr><td>\033[0m</td><td>关闭所有属性</td></tr><tr><td>\033[1m</td><td>设置高亮度</td></tr><tr><td>\033[4m</td><td>下划线</td></tr><tr><td>\033[5m</td><td>闪烁</td></tr><tr><td>\033[7m</td><td>反显</td></tr><tr><td>\033[8m</td><td>消隐</td></tr></tbody></table></div><h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><p>例如用python打印输出<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"\007"</span>)                       <span class="comment"># 发出提示音</span></span><br><span class="line">print(<span class="string">"\033[42:31m hello! \033[0m"</span>) <span class="comment"># 绿底红字` hello! ` </span></span><br><span class="line">print(<span class="string">"\033[4m"</span>)                    <span class="comment"># 开启下划线</span></span><br><span class="line">print(<span class="string">"\033[42:31m hello! \033[0m"</span>) <span class="comment"># 下划线绿底红字` hello! ` </span></span><br><span class="line">print(<span class="string">"\033[0m"</span>)                    <span class="comment"># 关闭所有格式</span></span><br><span class="line">print(<span class="string">"\033[2J"</span>)                    <span class="comment"># 清屏</span></span><br></pre></td></tr></table></figure></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://blog.csdn.net/lzuacm/article/details/8993785" target="_blank" rel="noopener">“\033”(ESC)的用法-ANSI的Esc屏幕控制 - CSDN</a></li><li><a href="https://www.student.cs.uwaterloo.ca/~cs452/terminal.html" target="_blank" rel="noopener">Useful Terminal Control Sequences - student.cs.uwaterloo.ca</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Support Vector Machine</title>
      <link href="/2019/05/27/Support-Vector-Machine/"/>
      <url>/2019/05/27/Support-Vector-Machine/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://github.com/isLouisHsu/Basic-Machine-Learning-Algorithm/blob/master/algorithm/p97_svm.py" target="_blank" rel="noopener">Github: isLouisHsu/Basic-Machine-Learning-Algorithm/algorithm/p97_svm.py</a></p><p>补一补支持向量机的笔记。</p><p>支持向量机<code>(SVM)</code>为有监督学习算法，可用于回归、分类甚至聚类(支持向量聚类)，其主要特点为</p><ul><li>将样本表示为超空间中的点；</li><li>求取支持向量，其余样本点对超平面无影响；</li><li>对于线性不可分问题，利用核函数映射到高维空间，使其线性可分；</li></ul><h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>以下介绍支持向量机的基本原理，首先对一些概念作补充</p><h2 id="概念补充"><a href="#概念补充" class="headerlink" title="概念补充"></a>概念补充</h2><ol><li><p>$n$维空间与超平面<br> 如对于$n$维数据集，其所在空间即为$n$维欧式空间，则在该空间中，余维度为$1$的线性子空间，或称$n-1$维仿射子空间，称为超平面，为$n-1$维，可由下式确定</p><script type="math/tex; mode=display">w^T x + b = 0 \tag{1}</script><p> 其中$w,x$为$n$维列向量，$x$表示超平面上的点($n$维)，$w$表示超平面的法向量，决定超平面的方向，$b$为实数。</p><script type="math/tex; mode=display">x = (x_1, x_2, \cdots, x_n)^T</script><script type="math/tex; mode=display">w = (w_1, w_2, \cdots, w_n)^T</script><p> 例如$3$维空间中的$2$维平面方程为</p><script type="math/tex; mode=display">Ax + By + Cz + D = 0</script></li><li><p>点到超平面的距离<br> <img src="/2019/05/27/Support-Vector-Machine/distance.jpg" alt="distance"></p><p> 对于样本空间中任一点$x$，到超平面$\mathcal{P}_{w,b}$的距离，可表示为</p><script type="math/tex; mode=display">\mathcal{D} = \frac{|w^T x + b|}{||w||} \tag{2}</script><p> 其中$||w||$为向量$w$的$2$范数，即</p><script type="math/tex; mode=display">||w|| = \sqrt{w_1^2 + w_2^2 + \cdots + w_n^2} \tag{3}</script><blockquote><p>证明：假设超平面上一向量点为$x_0$，则向量$x-x_0$在单位法向量$\frac{w}{||w||}$上的投影$d$，即为向量点到超平面的距离</p><script type="math/tex; mode=display">d =  |\frac{w^T}{||w||} (x-x_0)|</script><p>而</p><script type="math/tex; mode=display">w^T x + b = 0 \Rightarrow w^T = -b</script><p>所以</p><script type="math/tex; mode=display">d =  | \frac{- w^T x_0 - b}{||w||} | = \frac{|w^T x_0 + b|}{||w||}</script></blockquote></li></ol><h2 id="核技巧"><a href="#核技巧" class="headerlink" title="核技巧"></a>核技巧</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在前言中说到支持向量机使用核函数映射低维空间到高维空间，这是如何做到的？<br>假设有两个$n$维向量$x_i, x_j$，设有映射$\mathit{\Phi}$使其维度扩张到$n’$维，即</p><script type="math/tex; mode=display">x' = \mathit{\Phi}(x)</script><p>则定义核函数为</p><script type="math/tex; mode=display">\kappa(x_i, x_j) = \mathit{\Phi}(x_i)^T \mathit{\Phi}(x_j) \tag{4}</script><h3 id="常用核函数"><a href="#常用核函数" class="headerlink" title="常用核函数"></a>常用核函数</h3><ol><li>线性<code>(linear)</code>核函数<script type="math/tex; mode=display">\kappa(x_i, x_j) = x_i^T x_j</script></li><li>多项式<code>(Polynomial)</code>核函数<script type="math/tex; mode=display">\kappa(x_i, x_j) = (\gamma x_i^T x_j + c)^n</script></li><li>高斯<code>(Gaussian)</code>核函数<script type="math/tex; mode=display">\kappa(x_i, x_j) = e^{-\gamma \frac{||x_i - x_j||^2}{2\sigma^2}}</script></li><li>拉普拉斯<code>(Laplace)</code>核函数<script type="math/tex; mode=display">\kappa(x_i, x_j) = e^{-\gamma \frac{||x_i - x_j||}{\sigma}}</script></li><li>Sigmoid核函数<script type="math/tex; mode=display">\kappa(x_i, x_j) = \tanh (\gamma x_i^T x_j + c)</script></li></ol><p>等等。</p><p>至于如何选取核函数，需要技术人员一定的先验知识，或者使用超参数搜索确定。</p><h3 id="实例分析核函数的作用"><a href="#实例分析核函数的作用" class="headerlink" title="实例分析核函数的作用"></a>实例分析核函数的作用</h3><ol><li><p>多项式核函数<br> 指定多项式核函数参数$ \gamma = 1, c = 0, n = 2 $，即</p><script type="math/tex; mode=display">\kappa(x_i, x_j) = (x_i^T x_j)^2 \tag{4.a}</script><p> 设原始空间为$2$维，即</p><script type="math/tex; mode=display">x_i = (x_{i1}, x_{i2})^T</script><p> 代入核函数$(4.a)$，有</p><script type="math/tex; mode=display">\kappa(x_i, x_j) = \left[(x_{i1}, x_{i2}) (x_{j1}, x_{j2})^T \right]^2 = (x_{i1}x_{j1} + x_{i2}x_{j2})^2</script><script type="math/tex; mode=display">= x_{i1}^2 x_{j1}^2 + 2x_{i1}x_{j1}x_{i2}x_{j2} + x_{i2}^2 x_{j2}^2</script><p> 把以上$3$项多项式表示成$3$维向量内积，即</p><script type="math/tex; mode=display">\kappa(x_i, x_j) = \left[ \begin{matrix} x_{i1}^2 & \sqrt{2}x_{i1}x_{i2} & x_{i2}^2 \end{matrix} \right]                          \left[ \begin{matrix} x_{j1}^2 & \sqrt{2}x_{j1}x_{j2} & x_{j2}^2 \end{matrix} \right]^T</script><p> 由上式与式$(4)$可得，该核函数对应的映射函数为</p><script type="math/tex; mode=display">\mathit{\Phi}(x) = \left[ \begin{matrix} x_1^2 & \sqrt{2}x_1x_2 & x_2^2 \end{matrix} \right]^T \tag{4.b}</script><p> 这样就把$2$维空间中的点映射到了$3$维空间，作图如下。<br> <img src="/2019/05/27/Support-Vector-Machine/kernel_poly.jpg" alt="kernel_poly"></p></li></ol><pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">X = np.array([</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">2</span>],</span><br><span class="line">[<span class="number">6</span>,<span class="number">1</span>],[<span class="number">6</span>,<span class="number">2</span>],[<span class="number">6</span>,<span class="number">3</span>],[<span class="number">6</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">])</span><br><span class="line">Y=np.array([<span class="number">-1</span>] * <span class="number">14</span> + [<span class="number">1</span>] * <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">plt.figure(<span class="number">0</span>)</span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=Y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据映射到高维后显示</span></span><br><span class="line"><span class="comment"># 映射函数为Φ(x)=[x1^2 √2*x1*x2 x2^2]</span></span><br><span class="line">FX = np.zeros((<span class="number">0</span>, <span class="number">3</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(X.shape[<span class="number">0</span>]):</span><br><span class="line">    tmp = np.array([X[i, <span class="number">0</span>]**<span class="number">2</span>, np.sqrt(<span class="number">2</span>)*X[i, <span class="number">0</span>]*X[i, <span class="number">1</span>], X[i, <span class="number">1</span>]**<span class="number">2</span>]).reshape(<span class="number">1</span>, <span class="number">-1</span>)</span><br><span class="line">    FX = np.r_[FX, tmp]</span><br><span class="line"></span><br><span class="line">fig = plt.figure(<span class="number">1</span>)</span><br><span class="line">figAx = Axes3D(fig)</span><br><span class="line">figAx.scatter(FX[:, <span class="number">0</span>], FX[:, <span class="number">1</span>], FX[:, <span class="number">2</span>], c=Y)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></code></pre><ol><li><p>高斯核函数</p><script type="math/tex; mode=display">\kappa(x_i, x_j) = e^{-\gamma \frac{||x_i - x_j||^2}{2\sigma^2}} = e^{c||x_i - x_j||^2} \tag{4.c}</script><p> 其中包含指数函数，其级数展开式为</p><script type="math/tex; mode=display">e^x = \sum_{i=0}^{\infty} \frac{x^i}{i!} = \sum_{i=0}^{n} \frac{x^i}{i!} + R(n)</script><p> 因此可将样本点映射到无穷维度。</p><ul><li><p>输入维度为$1$</p><script type="math/tex; mode=display">||x_i - x_j||^2 = (x_i - x_j)^2 =x_i^2 - 2x_ix_j + x_j^2</script><p>  则代入核函数$(4.c)$得到</p><script type="math/tex; mode=display">e^{c||x_i - x_j||^2}   = e^{c(x_i^2 - 2x_ix_j + x_j^2)}  = e^{c(x_i^2 + x_j^2)} e^{-2c x_i x_j}</script><p>  其中</p><script type="math/tex; mode=display">  e^{-2c x_i x_j} = \sum_{n=0}^{\infty} \frac{(-2c)^n x_i^n x_j^n}{n!} = 1 - 2cx_ix_j + \frac{4 c^2 x_i^2 x_j^2}{2} - \frac{8 c^3 x_i^3 x_j^3}{6} + \cdots</script><script type="math/tex; mode=display">  = \left[\begin{matrix} \cdots, \sqrt{\frac{(-2c)^n}{n!}x_i^n}, \cdots \end{matrix} \right]  \left[\begin{matrix} \cdots, \sqrt{\frac{(-2c)^n}{n!}x_j^n}, \cdots \end{matrix} \right]^T</script><p>  所以</p><script type="math/tex; mode=display">  e^{c||x_i - x_j||^2}  = e^{c(x_i^2 + x_j^2)} \sum_{n=0}^{\infty} \frac{(-2c)^n x_i^n x_j^n}{n!}</script><script type="math/tex; mode=display">  = \left\{ e^{cx_i^2} \left[\begin{matrix} \cdots, \sqrt{\frac{(-2c)^n}{n!}x_i^n}, \cdots \end{matrix} \right] \right\}  \left\{ e^{cx_j^2} \left[\begin{matrix} \cdots, \sqrt{\frac{(-2c)^n}{n!}x_j^n}, \cdots \end{matrix} \right] \right\}^T</script><p>  则可得映射函数为</p><script type="math/tex; mode=display">\mathit{\Phi}(x) = e^{cx^2} \left[\begin{matrix} \cdots, \sqrt{\frac{(-2c)^n}{n!}x^n}, \cdots \end{matrix} \right] \tag{4.d}</script></li><li><p>输入维度为$d$</p><script type="math/tex; mode=display">||x_i - x_j||^2 = (x_i - x_j)^T (x_i - x_j) = x_i^T x_i - 2 x_i^T x_j + x_j^T x_j</script><p>  代入核函数$(4.c)$得到</p><script type="math/tex; mode=display">e^{c||x_i - x_j||^2} = e^{c(x_i^T x_i + x_j^T x_j)} e^{-2c x_i^T x_j}</script><p>  其中</p><script type="math/tex; mode=display">e^{-2c x_i^T x_j} = \sum_{n=0}^{\infty} \frac{(-2c)^n (x_i^T x_j)^n}{n!}</script><p>  故</p><script type="math/tex; mode=display">e^{c||x_i - x_j||^2} = e^{c(x_i^T x_i + x_j^T x_j)} \sum_{n=0}^{\infty} \frac{(-2c)^n (x_i^T x_j)^n}{n!}</script><p>  特殊化，对于$d=2$，展开至$3$阶，得到</p><script type="math/tex; mode=display">  e^{c||x_i - x_j||^2} = e^{c(x_{i1}^2 + x_{i2}^2 + x_{j1}^2 + x_{j2}^2)} \left[ 1 - 2c (x_{i1}x_{j1} + x_{i2}x_{j2}) + 4c^2 (x_{i1}x_{j1} + x_{i2}x_{j2})^2 -8c^3 (x_{i1}x_{j1} + x_{i2}x_{j2})^3 \right]</script><p>  其中</p><script type="math/tex; mode=display">  \begin{cases}      x_{i1}x_{j1} + x_{i2}x_{j2} \\      (x_{i1}x_{j1} + x_{i2}x_{j2})^2 = x_{i1}^2 x_{j1}^2 + 2x_{i1}x_{j1}x_{i2}x_{j2} + x_{i2}^2 x_{j2}^2 \\      (x_{i1}x_{j1} + x_{i2}x_{j2})^3 = x_{i1}^3 x_{j1}^3 + 3x_{i1}x_{j1}x_{i2}^2x_{j2}^2 + 3x_{i1}^2x_{j1}^2x_{i2}x_{j2} + x_{i2}^3 x_{j2}^3 \\  \end{cases}</script><p>  带入后得</p><script type="math/tex; mode=display">  e^{c||x_i - x_j||^2} = e^{c(x_{i1}^2 + x_{i2}^2 + x_{j1}^2 + x_{j2}^2)} [ 1 - 2c (x_{i1}x_{j1} + x_{i2}x_{j2}) + 4c^2 (x_{i1}^2 x_{j1}^2 + 2x_{i1}x_{j1}x_{i2}x_{j2} + x_{i2}^2 x_{j2}^2) -</script><script type="math/tex; mode=display">  8c^3 (x_{i1}^3 x_{j1}^3 + 3x_{i1}x_{j1}x_{i2}^2x_{j2}^2 + 3x_{i1}^2x_{j1}^2x_{i2}x_{j2} + x_{i2}^3 x_{j2}^3) ]</script><p>  所以映射函数为</p><script type="math/tex; mode=display">  \mathit{\Phi}(x) = e^{c(x_1^2 + x_2^2)} \left[       \begin{matrix}          1, \sqrt{-2c} x_1, \sqrt{-2c} x_2, \sqrt{4c^2} x_1^2, \sqrt{8c^2} x_1x_2, \sqrt{4c^2} x_2^2, \sqrt{-8c^3}x_1^3, \sqrt{-24c^3} x_1 x_2^2, \sqrt{-24c^3} x_1^2 x_2, \sqrt{-8c^3} x_1^3      \end{matrix} \right]^T \tag{4.e}</script><p>  即升维后维数为$10$。</p></li></ul></li></ol><h2 id="线性支持向量机"><a href="#线性支持向量机" class="headerlink" title="线性支持向量机"></a>线性支持向量机</h2><p>对于线性可分得情况，目标为求解一个超平面$w^T \mathit{\Phi}(x) + b = 0$使两类点落在超平面两侧。</p><p><img src="/2019/05/27/Support-Vector-Machine/svm-3-conditions.jpg" alt="svm-3-conditions"></p><p>观察以上两图，图$(c)$分割最佳，应有</p><ul><li>超平面在两类点间隔内，可平移距离最大；<script type="math/tex; mode=display">r = \max (r_+ - r_-)</script></li><li>分割平面$\mathcal{P}$到$\mathcal{P}_+, \mathcal{P}_-$的距离相等，即；<script type="math/tex; mode=display">r_- = r_+ = \frac{r}{2}</script></li><li>落在支撑超平面$\mathcal{P}_+, \mathcal{P}_-$上的点称为<strong>支持向量<code>Support Vector</code></strong>，可记作$x_{+/-}^{sup}$；</li></ul><p>设分割超平面$\mathcal{P}$为</p><script type="math/tex; mode=display">g(x) = w^T \mathit{\Phi}(x) + b = 0 \tag{5}</script><p>判别方程可定义为</p><script type="math/tex; mode=display">\hat{y} = \text{sign} \left[  w^T \mathit{\Phi}(x) + b \right] \tag{6}</script><p>则平面$\mathcal{P}$上下平移后得到平面$\mathcal{P}_+, \mathcal{P}_-$，即</p><script type="math/tex; mode=display">g_+(x) = w^T \mathit{\Phi}(x) + b - C(常数) = 0</script><script type="math/tex; mode=display">g_-(x) = w^T \mathit{\Phi}(x) + b + C(常数) = 0</script><p>作归一化处理，两边同除以$C(常数)$，则支撑超平面方程为</p><script type="math/tex; mode=display">g_+(x) = w^T \mathit{\Phi}(x) + b - 1 = 0</script><script type="math/tex; mode=display">g_-(x) = w^T \mathit{\Phi}(x) + b + 1 = 0</script><p>对于正负样本$x_{+/-}$，分别满足</p><script type="math/tex; mode=display">\begin{cases}    w^T \mathit{\Phi}(x_+) + b > 1 \\    y = 1\end{cases}\begin{cases}    w^T \mathit{\Phi}(x_-) + b < - 1 \\    y = -1\end{cases}</script><p>即</p><script type="math/tex; mode=display">y \left[ w^T \mathit{\Phi}(x) + b \right] > 1</script><p>现希望优化两个平面间的距离，使其达到最大，即优化目标为</p><script type="math/tex; mode=display">w, b = \arg \max r</script><script type="math/tex; mode=display">s.t.\qquad y \left[ w^T \mathit{\Phi}(x) + b \right] > 1 \tag{7}</script><p><strong>那么如何求解支撑超平面间距离$r$呢？</strong>，有两种思路</p><ol><li><p>思路一<br> <img src="/2019/05/27/Support-Vector-Machine/r.jpg" alt="r"></p><p> 过超平面$\mathcal{P}$任一点$\mathit{\Phi}(x)$作垂线，分别交$\mathcal{P}_{+/-}$于向量$\mathit{\Phi}(x_{+/-})$，则</p><script type="math/tex; mode=display"> \begin{cases}     w^T \mathit{\Phi}(x_+) + b = + 1 \\     w^T \mathit{\Phi}(x_-) + b = - 1  \end{cases}</script><p> 利用距离公式求解点$\mathit{\Phi}(x)$到超平面$\mathcal{P}$的距离</p><script type="math/tex; mode=display">r_+ = r_- = \frac{r}{2} = \frac{| w^T \mathit{\Phi}(x_{+/-}) + b |}{||w||} = \frac{1}{||w||}</script><p> 所以</p><script type="math/tex; mode=display">r = \frac{2}{||w||} \tag{8.a}</script></li><li><p>思路二</p><script type="math/tex; mode=display">r_+ = r_- = \frac{r}{2} = \min_i \frac{| w^T \mathit{\Phi}(x^{(i)}) + b |}{||w||}, \quad i = 1, ..., N</script><p> 由支持向量定义</p><script type="math/tex; mode=display">| w^T \mathit{\Phi}(x_{+/-}^{sup}) + b | = \min | w^T \mathit{\Phi}(x^{(i)}) + b |</script><p> 且</p><script type="math/tex; mode=display">| w^T \mathit{\Phi}(x_{+/-}^{sup}) + b | = 1</script><p> 所以</p><script type="math/tex; mode=display">r = \frac{2}{||w||} \tag{8.b}</script></li></ol><p>所以优化目标为</p><script type="math/tex; mode=display">w, b = \arg \max \frac{2}{||w||}</script><script type="math/tex; mode=display">s.t.\qquad y \left[ w^T \mathit{\Phi}(x) + b \right] \geq 1 \tag{9.a}</script><p>为方便求解，相当于</p><script type="math/tex; mode=display">w, b = \arg \min \frac{1}{2} ||w||^2</script><script type="math/tex; mode=display">s.t.\qquad y \left[ w^T \mathit{\Phi}(x) + b \right] \geq 1 \tag{10.b}</script><h1 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a>回归问题</h1><p>回归模型的目标是让训练集中每个样本点$(x^{(i)}, y^{(i)})$尽量拟合到一个线性模型上</p><script type="math/tex; mode=display">y^{(i)} = w^T \mathit{\Phi}(x^{(i)}) + b</script><p>对于一般的回归模型，一般使用$MSE$作为损失函数，但是在$y^{(i)} \neq w^T \mathit{\Phi}(x^{(i)}) + b$时就会有损失，所以$SVM$不采用。</p><p>定义一个常量$\epsilon &gt; 0$，对于某个样本点$(x^{(i)}, y^{(i)})$，其损失定义如下，即在支撑超平面间隔内的样本点是没有损失的</p><script type="math/tex; mode=display">L^{(i)} = \begin{cases}    0 & | y^{(i)} - w^T \mathit{\Phi}(x^{(i)}) - b | \leq \epsilon \\    | y^{(i)} - w^T \mathit{\Phi}(x^{(i)}) - b | - \epsilon & \text{otherwise}\end{cases}</script><p><img src="/2019/05/27/Support-Vector-Machine/regression.jpg" alt="regression"></p><h1 id="优化问题的求解与SMO算法"><a href="#优化问题的求解与SMO算法" class="headerlink" title="优化问题的求解与SMO算法"></a>优化问题的求解与SMO算法</h1><h2 id="带约束的优化问题求解"><a href="#带约束的优化问题求解" class="headerlink" title="带约束的优化问题求解"></a>带约束的优化问题求解</h2><ol><li><p>纯等式约束<br> 一般形式为</p><script type="math/tex; mode=display">\vec{w} = \arg \min f(\vec{w})</script><script type="math/tex; mode=display">s.t. \qquad h_j(\vec{w}) = 0, \quad j = 1, 2, \cdots, m \tag{11}</script><p> 其中$f(\vec{w}), h_j(\vec{w})$均可导</p><p> 列写拉格朗日函数</p><script type="math/tex; mode=display">L(\vec{w}, \vec{\lambda}) = f(\vec{w}) + \sum_{j=0}^m \lambda_j h_j(\vec{w}) \tag{11.a}</script><p> 求取极点</p><script type="math/tex; mode=display"> \begin{cases} \frac{\partial L}{\partial w_i} = \frac{\partial f(\vec{w})}{\partial w_i} + \sum_{j=0}^m \lambda_j \frac{\partial h_j(\vec{w})}{\partial w_i} = 0 \\ \frac{\partial L}{\partial \lambda_j} = h_j(\vec{w}) = 0 \end{cases} \tag{11.b}</script><blockquote><p>如 $f(x, y) = x^2 + 3xy + y^2, \quad s.t. \quad x + y = 100 $</p></blockquote></li><li><p>纯不等式约束<br> 一般形式为</p><script type="math/tex; mode=display">\vec{w} = \arg \min f(\vec{w})</script><script type="math/tex; mode=display">s.t. \qquad g_j(\vec{w}) \leq 0, \quad j = 1, 2, \cdots, p \tag{12}</script><p> 对于上不等式约束，引入松弛变量$\epsilon_j^2$，使其转换为等式约束</p><script type="math/tex; mode=display">s.t. \qquad g_j(\vec{w}) + \epsilon_j^2 = 0, \quad j = 1, 2, \cdots, p</script><blockquote><p>注意，这里引入的松弛变量为平方项，如此可避免增加约束$\epsilon_j \geq 0$</p></blockquote><p> 列写拉格朗日函数</p><script type="math/tex; mode=display">L(\vec{w}, \vec{\mu}, \vec{\epsilon^2}) = f(\vec{w}) + \sum_{j=0}^p \mu_j (g_j(\vec{w}) + \epsilon_j^2) \tag{12.a}</script><p> 求取极值点</p><script type="math/tex; mode=display"> \begin{cases} \frac{\partial L}{\partial w_i} = \frac{\partial f(\vec{w})}{\partial w_i} + \sum_{j=0}^p \mu_j \frac{\partial g_j(\vec{w})}{\partial w_i} = 0 \\ \frac{\partial L}{\partial \mu_j} = g_j(\vec{w}) + \epsilon_j^2 = 0 \\ \frac{\partial L}{\partial \epsilon_j} = 2 \mu_j \epsilon_j = 0 \\ \mu_j \geq 0 \end{cases} \tag{12.b}</script><p> 注意等式三</p><ol><li>若$\mu_j = 0$，即对应不等式$g_j(\vec{w}) \leq 0$未起到约束作用；</li><li><p>若$\mu_j \neq 0$，则$\epsilon_j = 0$，那么$ g_j(\vec{w}) = 0$；<br>则总结可得</p><script type="math/tex; mode=display">\mu_j g_j(\vec{w}) = 0</script><p>故$(12.b)$转化为</p><script type="math/tex; mode=display">\begin{cases}\frac{\partial f(\vec{w})}{\partial w_i} + \sum_{j=0}^p \mu_j \frac{\partial g_j(\vec{w})}{\partial w_i} = 0 \\\mu_j g_j(\vec{w}) = 0 \\\mu_j \geq 0\end{cases} \tag{12.c}</script></li></ol></li></ol><ol><li><p>混合条件约束<br> 一般形式为</p><script type="math/tex; mode=display">\vec{w} = \arg \min f(\vec{w})</script><script type="math/tex; mode=display">s.t. \qquad h_j(\vec{w}) = 0, \quad j = 1, 2, \cdots, m</script><script type="math/tex; mode=display">\quad \qquad g_k(\vec{w}) \leq 0, \quad k = 1, 2, \cdots, p \tag{13}</script><p> 经上述内容，可得</p><script type="math/tex; mode=display">L(\vec{w}, \vec{\mu}, \vec{\epsilon^2}) = f(\vec{w}) + \sum_{j=0}^m \lambda_j h_j(\vec{w}) + \sum_{j=0}^p \mu_j (g_j(\vec{w}) + \epsilon_j^2) \tag{13.a}</script><p> 求取极值点</p><script type="math/tex; mode=display"> \begin{cases} \frac{\partial f(\vec{w})}{\partial w_i} + \sum_{j=0}^m \lambda_j \frac{\partial h_j(\vec{w})}{\partial w_i} + \sum_{j=0}^p \mu_j \frac{\partial g_j(\vec{w})}{\partial w_i} = 0 \\ h_j(\vec{w}) = 0 \\ \mu_j g_j(\vec{w}) = 0 \\ \mu_j \geq 0 \end{cases} \tag{13.b}</script><p> 上式即$K.K.T.$条件。</p></li></ol><h2 id="线性可分情况下求解"><a href="#线性可分情况下求解" class="headerlink" title="线性可分情况下求解"></a>线性可分情况下求解</h2><p><img src="/2019/05/27/Support-Vector-Machine/linear.jpg" alt="linear"></p><p>对于优化问题$(10.b)$</p><script type="math/tex; mode=display">w, b = \arg \max \frac{2}{||w||}</script><script type="math/tex; mode=display">s.t.\qquad y \left[ w^T \mathit{\Phi}(x) + b \right] \geq 1 \tag{10.b}</script><p>利用拉格朗日乘子法</p><script type="math/tex; mode=display">L(w, b, \mu) = \frac{1}{2} ||w||^2 + \sum_i \mu^{(i)} \left\{ 1 - y^{(i)} \left[ w^T \mathit{\Phi}(x^{(i)}) + b \right] \right\} \tag{14}</script><p>则带求解问题为</p><script type="math/tex; mode=display">w, b, \mu = \arg \min_{w, b} \max_{\mu} L(w, b, \mu) \tag{15.a}</script><p>转化为上式的<strong>对偶问题</strong></p><script type="math/tex; mode=display">w, b, \mu = \arg \max_{\mu} \min_{w,b} L(w, b, \mu) \tag{15.b}</script><blockquote><p>凸优化</p></blockquote><p>分别对参数求偏导</p><script type="math/tex; mode=display">\frac{\partial}{\partial w_j} L(w, b, \mu) = w_j - \sum_i \mu^{(i)} y^{(i)} \mathit{\Phi}(x^{(i)}_j)</script><script type="math/tex; mode=display">\frac{\partial}{\partial b} L(w, b, \mu) = - \sum_i \mu^{(i)} y^{(i)}</script><blockquote><p>$ \frac{\partial}{\partial w_j} \frac{1}{2} ||w||^2 = w_j; \quad \frac{\partial}{\partial w_j} \left[ w^T \mathit{\Phi}(x^{(i)}) + b \right] = \mathit{\Phi}(x^{(i)}_j) $，注意这里还没有用到映射函数$\mathit{\Phi}(x)$计算。</p></blockquote><p>该式为不等式约束，由$K.K.T.$条件，联立得到</p><script type="math/tex; mode=display">\begin{cases}    \sum_i \mu^{(i)} y^{(i)} \mathit{\Phi}(x^{(i)}_j) = w_j \\    \sum_i \mu^{(i)} y^{(i)} = 0 \\    \\    1 - y^{(i)} \left[ w^T \mathit{\Phi}(x^{(i)}) + b \right] \leq 0 \\    \mu^{(i)} \left\{ 1 - y^{(i)} \left[ w^T \mathit{\Phi}(x^{(i)}) + b \right] \right\} = 0 \\    \mu^{(i)} \geq 0\end{cases} \tag{16}</script><p>有</p><script type="math/tex; mode=display">\tilde{L}(\mu) = \frac{1}{2} w^T w + \sum_i \mu^{(i)} \left\{ 1 - y^{(i)} \left[ w^T \mathit{\Phi}(x^{(i)}) + b \right] \right\}</script><script type="math/tex; mode=display">\qquad \qquad \qquad \qquad = \frac{1}{2} w^T w + \sum_i \mu^{(i)} - w^T \sum_i \mu^{(i)} y^{(i)} \mathit{\Phi}(x^{(i)}) + b \sum_i \mu^{(i)} y^{(i)} \tag{17.a}</script><p>将$w = \sum_i \mu^{(i)} y^{(i)} \mathit{\Phi}(x^{(i)}), \sum_i \mu^{(i)} y^{(i)} = 0$代入，消去变量$w, b$，有</p><script type="math/tex; mode=display">\tilde{L}(\mu) = \sum_i \mu^{(i)} - \frac{1}{2} w^T w \tag{17.b}</script><p>其中</p><script type="math/tex; mode=display">w^T w = \left[ \sum_i \mu^{(i)} y^{(i)} \mathit{\Phi}(x^{(i)}) \right]^T \left[ \sum_i \mu^{(i)} y^{(i)} \mathit{\Phi}(x^{(i)}) \right]</script><script type="math/tex; mode=display">\qquad = \sum_i \left[ \mu^{(i)} y^{(i)} \mathit{\Phi}(x^{(i)})^T \sum_j \mu^{(j)} y^{(j)} \mathit{\Phi}(x^{(j)}) \right]</script><script type="math/tex; mode=display">\quad = \sum_i \sum_j \mu^{(i)} \mu^{(j)} y^{(i)} y^{(j)} \mathit{\Phi}(x^{(i)})^T \mathit{\Phi}(x^{(j)}) \tag{17.c}</script><p>代回$(17.b)$得到</p><script type="math/tex; mode=display">\tilde{L}(\mu) = \sum_i \mu^{(i)} - \frac{1}{2} \sum_i \sum_j \mu^{(i)} \mu^{(j)} y^{(i)} y^{(j)} \mathit{\Phi}(x^{(i)})^T \mathit{\Phi}(x^{(j)}) \tag{17}</script><blockquote><p>这里出现了<strong>核函数</strong>：$\kappa(x^{(i)}, x^{(j)}) = \mathit{\Phi}(x^{(i)})^T \mathit{\Phi}(x^{(j)})$</p></blockquote><p>那么优化问题现在转化为</p><script type="math/tex; mode=display">\mu = \arg \max_{\mu} \tilde{L}(\mu) = \arg \max_{\mu} \sum_i \mu^{(i)} - \frac{1}{2} \sum_i \sum_j \mu^{(i)} \mu^{(j)} y^{(i)} y^{(j)} \mathit{\Phi}(x^{(i)})^T \mathit{\Phi}(x^{(j)})</script><script type="math/tex; mode=display">s.t.\qquad \mu^{(i)} \geq 0, \quad \sum_i \mu^{(i)} y^{(i)} = 0 \tag{18}</script><p>其中$i = 1, \cdots, N$，现在只需优化$\mu$即可，该式使用$SMO$或梯度下降法算法求解，再用下式求解参数$w, b$</p><script type="math/tex; mode=display">\begin{cases}    w = \sum_i \mu^{(i)} y^{(i)} \mathit{\Phi}(x^{(i)}) \\    y^{sup} \left[ w^T \mathit{\Phi}(x^{sup}) + b \right] = 1\end{cases} \tag{19}</script><p>可能存在多个支持向量，均满足等式$(19.2)$。</p><h2 id="线性不可分情况下求解"><a href="#线性不可分情况下求解" class="headerlink" title="线性不可分情况下求解"></a>线性不可分情况下求解</h2><p><img src="/2019/05/27/Support-Vector-Machine/non-linear.jpg" alt="non-linear"></p><p>如上图，存在部分样本点线性不可分，有两种方法可解决</p><ol><li>核函数</li><li>软间隔支持向量机</li></ol><h3 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h3><p>上面介绍了核函数，其作用是将样本特征升维，添加的维度与已存在的特征是线性不相关的，例如我们有样本点</p><script type="math/tex; mode=display">x^{(i)} = \left[\begin{matrix}    x^{(i)}_1, \cdots, x^{(i)}_n\end{matrix}\right]^T</script><p>可以增加多项式维，例如$(x^{(i)}_j)^n, \prod_{k \leq n}^{k \leq K \leq N} x^{(i)}_k$等，或者添加其他形式的非线性函数，但我们知道，所有函数均可在某点$x = x_0$处展开为幂级数，本质上一致</p><script type="math/tex; mode=display">f(x) = \sum_n \frac{f^{(n)}(x - x_0)}{n!} (x - x_0)^{(n)}</script><p>核函数就是利用级数展开的概念，构造多项式维度，将样本点升维，例如高斯核函数$\kappa(x_i, x_j) = e^{-\gamma \frac{||x_i - x_j||^2}{2\sigma^2}}$将其升高到无穷维。机器学习算法求解各维度的权值系数，特征越重要，系数值占比越大。</p><h3 id="软间隔支持向量机"><a href="#软间隔支持向量机" class="headerlink" title="软间隔支持向量机"></a>软间隔支持向量机</h3><p><strong>本质上仍为线性支持向量机</strong>，对于线性不可分的情况，应允许部分样本点不满足条件</p><script type="math/tex; mode=display">y^{(i)} \left[ w^T \mathit{\Phi}(x^{(i)}) + b \right] \geq 1</script><p>可对每个样本引入松弛变量$\epsilon^{(i)}$，即</p><script type="math/tex; mode=display">y^{(i)} \left[ w^T \mathit{\Phi}(x^{(i)}) + b \right] \geq 1 - \epsilon^{(i)} \tag{20}</script><blockquote><p>仅仅对于落在支撑超平面间的样本点满足$\epsilon^{(i)} &gt; 0$</p></blockquote><p>形象解释，即对于<strong>落在支撑超平面间的样本点$x^{(i)}$</strong>，视其为<strong>软间隔支持向量(自创)</strong>，调整$\epsilon^{(i)}$将支撑超平面进行微量的位移$d_{\epsilon^{(i)}}$，如下图<br><img src="/2019/05/27/Support-Vector-Machine/epsilon.jpg" alt="epsilon"></p><p>但是呢，也要对不满足该条件的样本个数进行限制，希望越少越好。那么加入<strong>惩罚系数$C$(超参数)</strong>，对不满足条件的样本进行惩罚，使$\sum_i \epsilon^{(i)}$越小越好，则优化目标变更为</p><script type="math/tex; mode=display">w, b = \arg \min_{w,b} \left( \frac{1}{2} ||w||^2 + C \sum_i \epsilon^{(i)} \right)</script><script type="math/tex; mode=display">s.t. \qquad y^{(i)} \left[ w^T \mathit{\Phi}(x^{(i)}) + b \right] \geq 1 - \epsilon^{(i)}</script><script type="math/tex; mode=display">\qquad \epsilon^{(i)} \geq 0 \tag{21}</script><p>同样的，构造拉格朗日函数</p><script type="math/tex; mode=display">L(w, b, \epsilon, \mu_1, \mu_2) = \left( \frac{1}{2} ||w||^2 + C \sum_i \epsilon^{(i)} \right) + \sum_i \mu_1^{(i)} \left\{ 1 - \epsilon^{(i)} - y^{(i)} \left[ w^T \mathit{\Phi}(x^{(i)}) + b \right] \right\} + \sum_i \mu_2^{(i)} \left( - \epsilon^{(i)} \right) \tag{22}</script><p>根据$K.K.T.$条件</p><script type="math/tex; mode=display">\begin{cases}    \sum_i \mu_1^{(i)} y^{(i)} \mathit{\Phi}(x^{(i)}_j) = w_j \\    \sum_i \mu_1^{(i)} y^{(i)} = 0 \\    C - \mu_1^{(i)} - \mu_2^{(i)} = 0 \\    \\    1 - \epsilon^{(i)} - y^{(i)} \left[ w^T \mathit{\Phi}(x^{(i)}) + b \right] \leq 0 \\    \mu_1^{(i)} \left\{ 1 - \epsilon^{(i)} - y^{(i)} \left[ w^T \mathit{\Phi}(x^{(i)}) + b \right] \right\} = 0 \\    \mu_1^{(i)} \geq 0 \\    \\    - \epsilon^{(i)} \leq 0 \\    \mu_2^{(i)} \left( - \epsilon^{(i)} \right) = 0 \\    \mu_2^{(i)} \geq 0\end{cases} \tag{23}</script><p>消除$w, b, \epsilon$</p><script type="math/tex; mode=display">\tilde{L}(\mu_1, \mu_2) = \frac{1}{2} w^T w + C \sum_i \epsilon^{(i)} + \sum_i \mu_1^{(i)} \left( 1 - \epsilon^{(i)} \right) - w^T \sum_i \mu_1^{(i)} y^{(i)} \mathit{\Phi}(x^{(i)}) - b \sum_i \mu_1^{(i)} y^{(i)} - \sum_i \mu_2^{(i)} \epsilon^{(i)}</script><p>其中$w = \sum_i \mu_1^{(i)} y^{(i)} \mathit{\Phi}(x^{(i)}); \quad \sum_i \mu_1^{(i)} y^{(i)} = 0$</p><script type="math/tex; mode=display">\tilde{L}(\mu_1, \mu_2) = - \frac{1}{2} w^T w  + C \sum_i \epsilon^{(i)} + \sum_i \mu_1^{(i)} - \sum_i \left( \mu_1^{(i)} + \mu_2^{(i)} \right) \epsilon^{(i)}</script><p>其中$\mu_1^{(i)} + \mu_2^{(i)} = C$，所以同$(17)$</p><script type="math/tex; mode=display">\tilde{L}(\mu_1) = \sum_i \mu_1^{(i)} - \frac{1}{2} w^T w = \sum_i \mu_1^{(i)} - \frac{1}{2} \sum_i \sum_j \mu_1^{(i)} \mu_1^{(j)} y^{(i)} y^{(j)} \mathit{\Phi}(x^{(i)})^T \mathit{\Phi}(x^{(j)}) \tag{24}</script><p>那么优化问题现在转化为</p><script type="math/tex; mode=display">\mu_1 = \arg \max_{\mu_1} \tilde{L}(\mu_1) = \arg \max_{\mu_1} \sum_i \mu_1^{(i)} - \frac{1}{2} \sum_i \sum_j \mu_1^{(i)} \mu_1^{(j)} y^{(i)} y^{(j)} \mathit{\Phi}(x^{(i)})^T \mathit{\Phi}(x^{(j)})</script><script type="math/tex; mode=display">s.t.\qquad \mu_1^{(i)} \geq 0, \quad \mu_2^{(i)} \geq 0</script><script type="math/tex; mode=display">\sum_i \mu_1^{(i)} y^{(i)} = 0</script><script type="math/tex; mode=display">C - \mu_1^{(i)} - \mu_2^{(i)} = 0 \tag{25}</script><p>对于上式，有如下分析</p><script type="math/tex; mode=display">\begin{cases} \mu_1^{(i)} \geq 0 \\ \mu_2^{(i)} \geq 0 \\ \mu_2^{(i)} = C - \mu_1^{(i)} \end{cases} \Rightarrow C \geq \mu_1^{(i)} \geq 0 \tag{26.a}</script><ol><li>$C = \mu_1^{(i)}$时，$\mu_2^{(i)} = 0$，由$\mu_2^{(i)} \left( - \epsilon^{(i)} \right) = 0$，可得$\epsilon^{(i)} \geq 0$<ol><li>$\epsilon^{(i)} = 0$时，$y^{(i)} \left[ w^T \mathit{\Phi}(x^{(i)}) + b \right] = 1$，该点为支撑向量；</li><li>$\epsilon^{(i)} &gt; 0$时，$y^{(i)} \left[ w^T \mathit{\Phi}(x^{(i)}) + b \right] &lt; 1$，该点在支撑超平面间；</li></ol></li><li>$C \neq \mu_1^{(i)}$即$C &gt; \mu_1^{(i)} \geq 0$时，$\mu_2^{(i)} \neq 0$，则由$\mu_2^{(i)} \left( - \epsilon^{(i)} \right) = 0$，可得$\epsilon^{(i)} = 0$，那么$\mu_1^{(i)} \left{ 1 - y^{(i)} \left[ w^T \mathit{\Phi}(x^{(i)}) + b \right] \right} = 0$<ol><li>$\mu_1^{(i)} &gt; 0$时，$y^{(i)} \left[ w^T \mathit{\Phi}(x^{(i)}) + b \right] = 1$，该点为支撑向量；</li><li>$\mu_1^{(i)} = 0$时，$y^{(i)} \left[ w^T \mathit{\Phi}(x^{(i)}) + b \right] \geq 1$，该点分类正确，在支持超平面上或者两边</li></ol></li></ol><p>总结一下，即</p><script type="math/tex; mode=display">\begin{cases}    \mu_1^{(i)} = 0 \iff y^{(i)} \left[ w^T \mathit{\Phi}(x^{(i)}) + b \right] \geq 1 \\    0 < \mu_1^{(i)} < C \iff y^{(i)} \left[ w^T \mathit{\Phi}(x^{(i)}) + b \right] = 1 \\    \mu_1^{(i)} = C \iff y^{(i)} \left[ w^T \mathit{\Phi}(x^{(i)}) + b \right] \leq 1\end{cases} \tag{27}</script><p>同样利用$SMO$或梯度下降法求解$\mu_1$，然后以下式求解$w, b, \epsilon, \mu_2$</p><script type="math/tex; mode=display">\begin{cases}    \mu_2 = C - \mu_1 \\    w_j = \sum_i \mu_1^{(i)} y^{(i)} \mathit{\Phi}(x^{(i)}_j) \\    y^{sup} \left[ w^T \mathit{\Phi}(x^{sup}) + b \right] = 1 \\    y^{sup'} \left[ w^T \mathit{\Phi}(x^{sup'}) + b \right] = 1 - \epsilon^{sup'}\end{cases} \tag{28}</script><blockquote><p>注：$(x^{sup’}, y^{sup’})$表示“软间隔支持向量”。<br>注：(1) 并非所有的样本点都有一个松弛变量与其对应。实际上只有“离群点”才有，所有没离群的点松弛变量都等于0<br>(2) 松弛变量的值实际上标示出了对应的点到底离群有多远，值越大，点就越远<br>(3) 惩罚因子C决定了你有多重视离群点带来的损失，显然当所有离群点的松弛变量的和一定时，你定的C越大，对目标函数的损失也越大，此时就暗示着你非常不愿意放弃这些离群点，最极端的情况C定为无限大，这样只要稍有一个点离群，目标函数的值马上变成无限大，马上让问题变成无解，这就退化成了硬间隔问题<br>(4) 惩罚因子C不是一个变量，整个优化问题在解的时候，C是一个你必须事先指定的值，指定这个值以后，解一下，得到一个分类器，然后用测试数据看看结果怎么样，如果不够好，换一个C的值，再解一次优化问题，得到另一个分类器，再看看效果，如此就是一个参数寻优的过程，但这和优化问题本身决不是一回事，优化问题在解的过程中，C一直是定值<br>(5) 尽管加了松弛变量这么一说，但这个优化问题仍然是一个优化问题（汗，这不废话么），解它的过程比起原始的硬间隔问题来说，没有任何更加特殊的地方(C≥$\mu^{(i)}$≥0)<br>(6) 完全可以给每一个离群点都使用不同的C，这时就意味着你对每个样本的重视程度都不一样，有些样本丢了也就丢了，错了也就错了，这些就给一个比较小的C；而有些样本很重要，决不能分类错误（比如中央下达的文件啥的，笑），就给一个很大的C。<br><strong>以上忘记从哪里摘抄的了:-(</strong> </p></blockquote><h2 id="Sequential-Minimal-Optimization-SMO"><a href="#Sequential-Minimal-Optimization-SMO" class="headerlink" title="Sequential Minimal Optimization(SMO)"></a>Sequential Minimal Optimization(SMO)</h2><p>以上我们得到优化目标</p><script type="math/tex; mode=display">\mu = \arg \max_{\mu} \tilde{L}(\mu) = \arg \max_{\mu} \sum_i \mu^{(i)} - \frac{1}{2} \sum_i \sum_j \mu^{(i)} \mu^{(j)} y^{(i)} y^{(j)} \mathit{\Phi}(x^{(i)})^T \mathit{\Phi}(x^{(j)})</script><script type="math/tex; mode=display">s.t.\qquad \mu^{(i)} \geq 0</script><script type="math/tex; mode=display">\quad \sum_i \mu^{(i)} y^{(i)} = 0</script><script type="math/tex; mode=display">\quad C \geq \mu^{(i)} \geq 0 \tag{29}</script><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>把对整个λ向量的优化转化为对每一对$\mu^{(i)},\mu^{(j)}$的优化，如果我们把其他λ先固定，仅仅优化某一对$\mu^{(i)},\mu^{(j)}$，那么我们可以通过解析式（即通过确定的公式来计算）来优化$\mu^{(i)},\mu^{(j)}$ 。而且此时$K.K.T.$条件很重要，之前说过最优解是一定会满足$K.K.T.$条件的，所以如果我们优化使所有$\mu$都满足了$K.K.T.$条件，那么这样最优解就会找到。</p><h3 id="选择优化对的方法"><a href="#选择优化对的方法" class="headerlink" title="选择优化对的方法"></a>选择优化对的方法</h3><p>寻找两个参数时，应找那些违反$K.K.T.$条件的，具体过程可分为外层循环和内层循环，利用启发式规则寻找待优化参数对。</p><ol><li>启发式规则1<ol><li>在<strong>所有样本</strong>中选择违反$K.K.T.$条件的一个乘子$\mu^{(i)}$，用启发式规则2选择另一个乘子$\mu^{(j)}$，对这两个乘子进行优化；</li><li>接着，从<strong>所有非边界样本</strong>中，选择违反$K.K.T.$条件的一个乘子作为最外层循环，用启发式规则2选择另一个乘子进行这两个乘子的优化；</li><li>最后，若上述非边界样本中没有违反$K.K.T.$条件的样本，则<strong>再从整个样本中</strong>去找，直到所有样本中没有需要改变的乘子，或满足其他停止条件为止。</li></ol></li><li>启发式规则2<ol><li>首先在<strong>非边界乘子</strong>中获得$|E_1−E_2|$最大的样本$\mu^{(j)}$；</li><li>如果1中没有找到，则从<strong>所有样本中</strong>随机确定$\mu^{(j)}$</li></ol></li></ol><p>满足式$(27)$即满足$K.K.T.$条件</p><script type="math/tex; mode=display">\begin{cases}    \mu_1^{(i)} = 0 \iff y^{(i)} \left[ w^T \mathit{\Phi}(x^{(i)}) + b \right] \geq 1 \\    0 < \mu_1^{(i)} < C \iff y^{(i)} \left[ w^T \mathit{\Phi}(x^{(i)}) + b \right] = 1 \\    \mu_1^{(i)} = C \iff y^{(i)} \left[ w^T \mathit{\Phi}(x^{(i)}) + b \right] \leq 1\end{cases} \tag{27}</script><p>那么以下情况不满足$K.K.T.$条件</p><script type="math/tex; mode=display">\begin{cases}    y^{(i)} \left[ w^T \mathit{\Phi}(x^{(i)}) + b \right] \geq 1 时，\mu_1^{(i)} > 0\\    y^{(i)} \left[ w^T \mathit{\Phi}(x^{(i)}) + b \right] = 1 时，\mu_1^{(i)} = 0 或 \mu_1^{(i)} = 1 \\    y^{(i)} \left[ w^T \mathit{\Phi}(x^{(i)}) + b \right] \leq 1 时，\mu_1^{(i)} < C\end{cases} \tag{30}</script><blockquote><p><a href="https://www.cnblogs.com/xxrxxr/p/7538430.html" target="_blank" rel="noopener">第三部分：SMO算法的个人理解 - cnblogs</a><br>找第一个参数的具体过程是这样的：</p><ol><li>遍历一遍整个数据集，对每个不满足$K.K.T.$条件的参数，选作第一个待修改参数</li><li>在上面对整个数据集遍历一遍后，选择那些参数满足$0 &lt; \mu &lt; C$的子集，开始遍历，如果发现一个不满足$K.K.T.$条件的，作为第一个待修改参数，然后找到第二个待修改的参数并修改，修改完后，重新开始遍历这个子集</li><li>遍历完子集后，重新开始①②，直到在执行①和②时没有任何修改就结束<br>（为什么要这样遍历，我现在还是不太明白）</li></ol><p>找第二个参数的过程是这样的：</p><ol><li>启发式找，找能让下式最大的</li><li>寻找一个随机位置的满足下式的可以优化的参数进行修改</li><li>在整个数据集上寻找一个随机位置的可以优化的参数进行修改</li><li>都不行那就找下一个第一个参数</li></ol></blockquote><h3 id="两个变量的优化问题"><a href="#两个变量的优化问题" class="headerlink" title="两个变量的优化问题"></a>两个变量的优化问题</h3><p>以$\mu^{(1)}, \mu^{(2)}$为例</p><script type="math/tex; mode=display">\min_{\mu^{(1)}, \mu^{(2)}} \left[ \frac{1}{2} \sum_i \sum_j \mu^{(i)} \mu^{(j)} y^{(i)} y^{(j)} \mathit{\Phi}(x^{(i)})^T \mathit{\Phi}(x^{(j)}) - \sum_i \mu^{(i)} \right]</script><script type="math/tex; mode=display">= \min_{\mu^{(1)}, \mu^{(2)}} \left[ \frac{1}{2} \sum_i \mu^{(i)} y^{(i)} \mathit{\Phi}(x^{(i)})^T \sum_j \mu^{(j)} y^{(j)} \mathit{\Phi}(x^{(j)}) - \sum_i \mu^{(i)} \right] \tag{31.a}</script><p>其中</p><script type="math/tex; mode=display">\sum_i \mu^{(i)} y^{(i)} \mathit{\Phi}(x^{(i)})^T = \mu^{(1)} y^{(1)} \mathit{\Phi}(x^{(1)})^T + \mu^{(2)} y^{(2)} \mathit{\Phi}(x^{(2)})^T + \sum_{i=3} \mu^{(i)} y^{(i)} \mathit{\Phi}(x^{(i)})^T</script><script type="math/tex; mode=display">\sum_j \mu^{(j)} y^{(j)} \mathit{\Phi}(x^{(j)})^T = \mu^{(1)} y^{(1)} \mathit{\Phi}(x^{(1)})^T + \mu^{(2)} y^{(2)} \mathit{\Phi}(x^{(2)})^T + \sum_{j=3} \mu^{(j)} y^{(j)} \mathit{\Phi}(x^{(j)})^T</script><script type="math/tex; mode=display">\sum_i \mu^{(i)} = \mu^{(1)} + \mu^{(2)} + \sum_{i=3} \mu^{(i)}</script><p>代回$(31.a)$，多项式展开整理得到</p><script type="math/tex; mode=display">(31.b) = \min_{\mu^{(1)}, \mu^{(2)}} [\frac{1}{2} \mu^{(1)2} \mathit{\Phi}(x^{(1)})^T \mathit{\Phi}(x^{(1)}) + \frac{1}{2} \mu^{(2)2} \mathit{\Phi}(x^{(2)})^T \mathit{\Phi}(x^{(2)}) + \mu^{(1)} \mu^{(2)} y^{(1)} y^{(2)} \mathit{\Phi}(x^{(1)})^T \mathit{\Phi}(x^{(2)}) +</script><script type="math/tex; mode=display">\mu^{(1)} y^{(1)} \sum_{i=3} \mu^{(i)} y^{(i)} \mathit{\Phi}(x^{(1)})^T \mathit{\Phi}(x^{(i)}) + \mu^{(2)} y^{(2)} \sum_{j=3} \mu^{(j)} y^{(j)} \mathit{\Phi}(x^{(2)})^T \mathit{\Phi}(x^{(j)}) +</script><script type="math/tex; mode=display">\frac{1}{2} \sum_{i=3} \sum_{j=3} \mu^{(i)} \mu^{(j)} y^{(i)} y^{(j)} \mathit{\Phi}(x^{(i)})^T \mathit{\Phi}(x^{(j)}) - (\mu^{(1)} + \mu^{(2)}) - \sum_{i=3} \mu^{(i)}] \tag{31.b}</script><p>令核函数</p><script type="math/tex; mode=display">K_{ij} = \mathit{\Phi}(x^{(i)})^T \mathit{\Phi}(x^{(j)}) \tag{32.a}</script><script type="math/tex; mode=display">const = \frac{1}{2} \sum_{i=3} \sum_{j=3} \mu^{(i)} \mu^{(j)} y^{(i)} y^{(j)} \mathit{\Phi}(x^{(i)})^T \mathit{\Phi}(x^{(j)}) - \sum_{i=3} \mu^{(i)} \tag{32.b}</script><p>定义</p><script type="math/tex; mode=display">f(x^{(i)}) = \sum_m \mu^{(m)} y^{(m)} K_{im} + b \tag{32.c}</script><script type="math/tex; mode=display">E^{(i)} = f(x^{(i)}) - y^{(i)}</script><script type="math/tex; mode=display">v^{(i)} = \sum_{m=3} \mu^{(m)} y^{(m)} K_{im} = f(x^{(i)}) - \sum_{m=1}^2 \mu^{(m)} y^{(m)} K_{im} - b \tag{32.e}</script><p>以上，代回$(31.b)$，优化问题转化为</p><script type="math/tex; mode=display">\min_{\mu^{(1)}, \mu^{(2)}} [\frac{1}{2} \mu^{(1)2} K_{11} + \frac{1}{2} \mu^{(2)2} K_{22} + \mu^{(1)} \mu^{(2)} y^{(1)} y^{(2)} K_{12} +</script><script type="math/tex; mode=display">\mu^{(1)} y^{(1)} v^{(1)} + \mu^{(2)} y^{(2)} v^{(2)} -(\mu^{(1)} + \mu^{(2)}) + const]</script><script type="math/tex; mode=display">s.t.\qquad \mu^{(i)} \geq 0</script><script type="math/tex; mode=display">\mu^{(1)} y^{(1)} + \mu^{(2)} y^{(2)} = - \sum_{i=3} \mu^{(i)} y^{(i)}</script><script type="math/tex; mode=display">C \geq \mu^{(i)} \geq 0 \tag{33}</script><p>记</p><script type="math/tex; mode=display">g(\mu^{(1)}, \mu^{(2)}) = \frac{1}{2} \mu^{(1)2} K_{11} + \frac{1}{2} \mu^{(2)2} K_{22} + \mu^{(1)} \mu^{(2)} y^{(1)} y^{(2)} K_{12} +</script><script type="math/tex; mode=display">\mu^{(1)} y^{(1)} v^{(1)} + \mu^{(2)} y^{(2)} v^{(2)} -(\mu^{(1)} + \mu^{(2)}) + const \tag{34}</script><p>记$\epsilon = - \sum_{i=3} \mu^{(i)} y^{(i)}$，则</p><script type="math/tex; mode=display">\mu^{(1)} y^{(1)} + \mu^{(2)} y^{(2)} = \epsilon</script><p>消去$\mu^{(1)}$</p><script type="math/tex; mode=display">\mu^{(1)} = \frac{\epsilon - \mu^{(2)} y^{(2)}}{y^{(1)}} \quad 同 \quad \mu^{(1)} = y^{(1)}\epsilon - y^{(1)} y^{(2)} \mu^{(2)}</script><p>记$\gamma = y^{(1)}\epsilon, \quad s = y^{(1)} y^{(2)} $，则</p><script type="math/tex; mode=display">\mu^{(1)} = \gamma - s \mu^{(2)} \tag{35}</script><blockquote><script type="math/tex; mode=display">s^2 = 1, \quad \gamma s = y^{(2)}\epsilon</script></blockquote><p>代入函数$(34)$，有</p><script type="math/tex; mode=display">\tilde{g}(\mu^{(2)}) = \frac{1}{2} (K_{11} + K_{22} - 2 K_{12}) \mu^{(2)2} +</script><script type="math/tex; mode=display">\left[ - \gamma s (K_{11} - K_{12}) - y^{(2)} (v^{(1)} - v^{(2)}) + s - 1 \right] \mu^{(2)} +</script><script type="math/tex; mode=display">(\frac{1}{2} K_{11} \gamma^2 + \epsilon v^{(1)} - \gamma) + const \tag{36}</script><p>转化为单变量$\mu^{(2)}$的二次优化问题。</p><h3 id="剪裁边界"><a href="#剪裁边界" class="headerlink" title="剪裁边界"></a>剪裁边界</h3><p>需考虑$\mu^{(2)}$的取值范围，即编程时$\mu^{(2)}$的<strong>剪裁边界</strong>，设</p><script type="math/tex; mode=display">L \leq \mu^{(2)}_{new} \leq H \tag{37}</script><p>综合条件</p><script type="math/tex; mode=display">\mu^{(1)}_{new} y^{(1)} + \mu^{(2)}_{new} y^{(2)} = \epsilon</script><script type="math/tex; mode=display">0 \leq \mu^{(i)} \leq C</script><blockquote><p>$\mu^{(1)}_{new} y^{(1)} + \mu^{(2)}_{new} y^{(2)} = \epsilon \Rightarrow \mu^{(1)}_{new} + \mu^{(2)}_{new} y^{(1)} y^{(2)} = \epsilon  y^{(1)}$ </p></blockquote><ol><li><p>$y^{(1)} \neq y^{(2)}$时，$y^{(1)} y^{(2)} = -1$</p><script type="math/tex; mode=display">\mu^{(1)}_{old} - \mu^{(2)}_{old} = \epsilon_{\neq} (常数) \quad 则 \quad \mu^{(2)}_{old} = \mu^{(1)}_{old} - \epsilon_{\neq} \tag{38.a}</script><p> 考虑</p><script type="math/tex; mode=display">0 \leq \mu^{(i)} \leq C</script><p> 则</p><script type="math/tex; mode=display"> \begin{cases}     0 \leq \mu^{(1)}_{old} \leq C \\     0 \leq \mu^{(2)}_{old} \leq C \\ \end{cases} \Rightarrow 0 - \epsilon_{\neq} \leq \mu^{(2)}_{old} = \mu^{(1)}_{old} - \epsilon_{\neq} \leq C - \epsilon_{\neq}</script><p> <img src="/2019/05/27/Support-Vector-Machine/y1neqy2.jpg" alt="y1neqy2"></p><p> 此时上下界为</p><script type="math/tex; mode=display"> \begin{cases}     L = \max \{ 0, - \epsilon_{\neq} \} \\     H = \min \{ C, C - \epsilon_{\neq} \} \\ \end{cases} \tag{38.b}</script><p> $(38.a)$代入$(38.b)$，得到迭代式</p><script type="math/tex; mode=display"> \begin{cases}     L = \max \{ 0, - \mu^{(1)}_{old} + \mu^{(2)}_{old} \} \\     H = \min \{ C, C - \mu^{(1)}_{old} + \mu^{(2)}_{old} \} \\ \end{cases} \tag{38}</script></li><li><p>$y^{(1)} = y^{(2)}$时，$y^{(1)} y^{(2)} = 1$</p><script type="math/tex; mode=display">\mu^{(1)}_{old} + \mu^{(2)}_{old} = \epsilon_{=} (常数) \quad 则 \quad \mu^{(2)}_{old} = - \mu^{(1)}_{old} + \epsilon_{=} \tag{39.a}</script><p> 考虑</p><script type="math/tex; mode=display">0 \leq \mu^{(i)} \leq C</script><p> 则</p><script type="math/tex; mode=display"> \begin{cases}     0 \leq \mu^{(1)}_{old} \leq C \\     0 \leq \mu^{(2)}_{old} \leq C \\ \end{cases} \Rightarrow - C + \epsilon_{=} \leq - \mu^{(1)}_{old} + \epsilon_{=} \leq 0 + \epsilon_{=}</script><p> <img src="/2019/05/27/Support-Vector-Machine/y1eqy2.jpg" alt="y1eqy2"></p><p> 此时上下界为</p><script type="math/tex; mode=display"> \begin{cases}     L = \max \{ 0, - C + \epsilon_{=} \} \\     H = \min \{ C, 0 + \epsilon_{=} \} \\ \end{cases} \tag{39.b}</script><p> $(39.a)$代入$(39.b)$，得到迭代式</p><script type="math/tex; mode=display"> \begin{cases}     L = \max \{ 0, \mu^{(1)}_{old} + \mu^{(2)}_{old} - C \} \\     H = \min \{ C, \mu^{(1)}_{old} + \mu^{(2)}_{old} \} \\ \end{cases} \tag{39}</script></li></ol><h3 id="单变量的二次优化"><a href="#单变量的二次优化" class="headerlink" title="单变量的二次优化"></a>单变量的二次优化</h3><script type="math/tex; mode=display">\tilde{g}(\mu^{(2)}) = \frac{1}{2} (K_{11} + K_{22} - 2 K_{12}) \mu^{(2)2} +</script><script type="math/tex; mode=display">\left[ - \gamma s (K_{11} - K_{12}) - y^{(2)} (v^{(1)} - v^{(2)}) + s - 1 \right] \mu^{(2)} +</script><script type="math/tex; mode=display">(\frac{1}{2} K_{11} \gamma^2 + \epsilon v^{(1)} - \gamma) + const \tag{36}</script><ol><li><p>二次项系数$K_{11} + K_{22} - 2 K_{12} &gt; 0$时<br> 求极值点</p><script type="math/tex; mode=display">\frac{\partial \tilde{g}(\mu^{(2)})}{\partial \mu^{(2)}} = 0 \Rightarrow \tilde{\mu}^{(2)} \tag{40.a}</script><ol><li>若$L \leq \tilde{\mu}^{(2)} \leq H$，则最小值点即为$\mu^{(2)} = \tilde{\mu}^{(2)}$；</li><li>否则在边界处取得最小值。</li></ol></li><li><p>二次项系数$K_{11} + K_{22} - 2 K_{12} = 0$时</p><script type="math/tex; mode=display"> \tilde{g}(\mu^{(2)}) =  \left[ - \gamma s (K_{11} - K_{12}) - y^{(2)} (v^{(1)} - v^{(2)}) + s - 1 \right] \mu^{(2)} +  (\frac{1}{2} K_{11} \gamma^2 + \epsilon v^{(1)} - \gamma) + const \tag{40.b}</script><p> $\tilde{g}(\mu^{(2)})$为一次函数，在边界处取得最小值。</p></li><li><p>二次项系数$K_{11} + K_{22} - 2 K_{12} &lt; 0$时<br> $\tilde{g}(\mu^{(2)})$为开口向下的二次函数，在边界处取得最小值。</p></li></ol><p>综上所述，$\mu^{(2)}$更新的解析解为</p><script type="math/tex; mode=display">\mu^{(2)}_{new, clip} = \begin{cases}    H & \mu^{(2)}_{new} > H \\    \mu^{(2)}_{new} & L \leq \mu^{(2)}_{new} \leq H \\    L & \mu^{(2)}_{new} < L \\\end{cases} \tag{40}</script><p>又因为</p><script type="math/tex; mode=display">\mu^{(1)}_{old} = \gamma - s \mu^{(2)}_{old} \tag{41.a}</script><script type="math/tex; mode=display">\mu^{(1)}_{new} = \gamma - s \mu^{(2)}_{new, clip} \tag{41.b}</script><p>两式相减，得到$\mu^{(1)}$更新的增量形式</p><script type="math/tex; mode=display">\mu^{(1)}_{new} = \mu^{(1)}_{old} + y^{(1)} y^{(2)} \left( \mu^{(2)}_{old} - \mu^{(2)}_{new, clip} \right) \tag{41}</script><p>更新$\mu^{(1)}, \mu^{(2)}$后，重新计算$b$，因为$b$影响到$E^{(i)}$的计算，由$(27)$</p><script type="math/tex; mode=display">0 < \mu_1^{(i)} < C \iff y^{(i)} \left[ w^T \mathit{\Phi}(x^{(i)}) + b \right] = 1</script><p>此时对应支撑向量$x^{sup}$，上右式两边同乘$y^{(i)}$，得到</p><script type="math/tex; mode=display">w^T \mathit{\Phi}(x^{(i)}) + b = y^{(i)}</script><script type="math/tex; mode=display">\Rightarrow b = y^{(i)} - w^T \mathit{\Phi}(x^{(i)}) = y^{(i)} - \sum_m \mu^{(m)} y^{(m)} K_{im}</script><blockquote><p>疑问：$w^T \mathit{\Phi}(x^{(i)}) = \sum_m \mu^{(m)} y^{(m)} K_{im}?$</p></blockquote><p>所以</p><script type="math/tex; mode=display">b^{(1)}_{new} = y^{(1)} - \sum_{m=3} \mu^{(m)} y^{(m)} K_{1m} - \mu^{(1)}_{new} y^{(1)} K_{11} - \mu^{(2)}_{new} y^{(2)} K_{12} \tag{42.a}</script><p>其中</p><script type="math/tex; mode=display">\sum_{m=3} \mu^{(m)} y^{(m)} K_{1m} = f(x^{(1)}) - \sum_{m=1}^2 \mu^{(m)}_{old} y^{(m)} K_{1m} - b_{old} \tag{42.b}</script><blockquote><script type="math/tex; mode=display">v^{(i)} = \sum_{m=3} \mu^{(m)} y^{(m)} K_{im} = f(x^{(i)}) - \sum_{m=1}^2 \mu^{(m)} y^{(m)} K_{im} - b \tag{32.e}</script></blockquote><p>所以</p><script type="math/tex; mode=display">b^{(1)}_{new} = y^{(1)} - f(x^{(1)}) - \mu^{(1)}_{old} y^{(1)} K_{11} + \mu^{(2)}_{old} y^{(2)} K_{12} + b_{old} - \mu^{(1)}_{new} y^{(1)} K_{11} - \mu^{(2)}_{new} y^{(2)} K_{12}</script><script type="math/tex; mode=display">= - E^{(1)} + (\mu^{(1)}_{old} - \mu^{(1)}_{new}) y^{(1)} K_{11} + (\mu^{(2)}_{old} - \mu^{(2)}_{new}) y^{(2)} K_{12} + b_{old} \tag{42}</script><p>同理</p><script type="math/tex; mode=display">b^{(2)}_{new} = - E^{(2)} + (\mu^{(1)}_{old} - \mu^{(1)}_{new}) y^{(1)} K_{21} + (\mu^{(2)}_{old} - \mu^{(2)}_{new}) y^{(2)} K_{22} + b_{old} \tag{43}</script><p>当$b^{(1)}$和$b^{(2)}$均有效时</p><script type="math/tex; mode=display">b_{new} = b^{(1)}_{new} = b^{(2)}_{new} \tag{44.a}</script><p>当两个乘子都在边界上时，则$b$阈值与$K.K.T.$条件一致时，不满足时取中点</p><script type="math/tex; mode=display">b = \begin{cases}    b^{(1)} & 0 < \mu^{(1)}_{new} < C \\    b^{(2)} & 0 < \mu^{(2)}_{new} < C \\    \frac{1}{2} (b^{(1)} + b^{(2)}) & \text{otherwise}\end{cases} \tag{44.b}</script><h3 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h3><ol><li><p>计算误差</p><script type="math/tex; mode=display">E^{(i)} = f(x^{(i)}) - y^{(i)} = \sum_i \mu^{(m)} y^{(m)} K_{im} + b -y^{(i)}</script></li><li><p>计算上下界</p><script type="math/tex; mode=display"> \begin{cases}     L = \max \{ 0, - \mu^{(i)}_{old} + \mu^{(j)}_{old} \};\quad H = \min \{ C, C - \mu^{(i)}_{old} + \mu^{(j)}_{old} \} & y^{(i)} \neq y^{(j)} \\     L = \max \{ 0, \mu^{(i)}_{old} + \mu^{(j)}_{old} - C \};\quad H = \min \{ C, \mu^{(i)}_{old} + \mu^{(j)}_{old} \} & y^{(i)} = y^{(j)}  \end{cases}</script></li><li><p>计算$\eta$</p><script type="math/tex; mode=display">\eta = K_{ii} + K_{jj} - 2K_{ij}</script></li><li><p>更新$\mu^{(j)}$</p><script type="math/tex; mode=display">\mu^{(j)}_{new} = \mu^{(j)}_{old} + \frac{y^{(j)}(E^{(i)} - E^{(j)})}{\eta}</script></li><li><p>修剪$\mu^{(j)}$</p><script type="math/tex; mode=display"> \mu^{(j)}_{new, clip} = \begin{cases}     H & \mu^{(j)}_{new} > H \\     \mu^{(j)}_{new} & L \leq \mu^{(j)}_{new} \leq H \\     L & \mu^{(j)}_{new} < L \\ \end{cases}</script></li><li><p>更新$\mu^{(i)}$</p><script type="math/tex; mode=display">\mu^{(i)}_{new} = \mu^{(i)}_{old} + y^{(i)} y^{(j)} \left( \mu^{(j)}_{old} - \mu^{(j)}_{new, clip} \right)</script></li><li><p>更新$b^{(i)}, b^{(j)}$</p></li></ol><script type="math/tex; mode=display">b^{(i)}_{new} = - E^{(i)} + (\mu^{(i)}_{old} - \mu^{(i)}_{new}) y^{(i)} K_{ii} + (\mu^{(j)}_{old} - \mu^{(j)}_{new}) y^{(j)} K_{ij} + b_{old}</script><script type="math/tex; mode=display">b^{(j)}_{new} = - E^{(j)} + (\mu^{(i)}_{old} - \mu^{(i)}_{new}) y^{(i)} K_{ji} + (\mu^{(j)}_{old} - \mu^{(j)}_{new}) y^{(j)} K_{jj} + b_{old}</script><ol><li>修剪$b$<script type="math/tex; mode=display">b = \begin{cases}    b^{(i)} & 0 < \mu^{(i)}_{new} < C \\    b^{(j)} & 0 < \mu^{(j)}_{new} < C \\    \frac{b^{(i)} + b^{(j)}}{2} & \text{otherwise}\end{cases}</script></li></ol><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://zh.wikipedia.org/wiki/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA" target="_blank" rel="noopener">支持向量机 - 维基百科，自由的百科全书</a></li><li><a href="https://scikit-learn.org/stable/modules/svm.html" target="_blank" rel="noopener">1.4. Support Vector Machine - scikit learn</a></li><li><a href="https://www.jiqizhixin.com/articles/2017-02-06-3" target="_blank" rel="noopener">详解支持向量机 - 机器之心</a></li><li><a href="https://blog.csdn.net/lijil168/article/details/69395023" target="_blank" rel="noopener">深入理解拉格朗日乘子法（Lagrange Multiplier) 和KKT条件 - CSDN</a></li><li><a href="https://zhuanlan.zhihu.com/p/26514613" target="_blank" rel="noopener">浅谈最优化问题的KKT条件 - 知乎</a></li><li><a href="https://www.cnblogs.com/xxrxxr/p/7538430.html" target="_blank" rel="noopener">第三部分：SMO算法的个人理解</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 监督学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mAP</title>
      <link href="/2019/05/26/mAP/"/>
      <url>/2019/05/26/mAP/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文介绍一种目标检测任务的评价指标<code>mean Average Precison(mAP)</code>，有以下几个重点</p><ul><li>如何绘制<code>Precision-Recall</code>曲线；</li><li>如何用插值方法计算<code>Average Precison</code>；</li><li>理解目标检测中<code>mAP</code>的计算；</li></ul><h1 id="Precision-Recall-Average-Precision"><a href="#Precision-Recall-Average-Precision" class="headerlink" title="Precision, Recall, Average Precision"></a>Precision, Recall, Average Precision</h1><h2 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h2><p>以上定义查看<a href="https://louishsu.xyz/2018/11/21/Metrics/" target="_blank" rel="noopener">Metrics/分类(classification)评估指标</a>，计算方式如下</p><h3 id="精确率-Precision"><a href="#精确率-Precision" class="headerlink" title="精确率(Precision)"></a>精确率<code>(Precision)</code></h3><p>即所有真实正样本中，被预测为正样本的比例</p><script type="math/tex; mode=display">P = \frac{TP}{TP + FN}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">precision_score</span><span class="params">(gt, pred)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Params:</span></span><br><span class="line"><span class="string">        gt:     &#123;ndarray(N)&#125; `0` or `1`</span></span><br><span class="line"><span class="string">        pred:   &#123;ndarray(N)&#125; `0` or `1`</span></span><br><span class="line"><span class="string">    Returns：</span></span><br><span class="line"><span class="string">        p:      &#123;float&#125;</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    index = pred == <span class="number">1</span></span><br><span class="line">    _gt = gt[index]</span><br><span class="line">    tp = _gt[_gt == <span class="number">1</span>].shape[<span class="number">0</span>]</span><br><span class="line">    pp = _gt.shape[<span class="number">0</span>]</span><br><span class="line">    p = tp / pp <span class="keyword">if</span> pp != <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure><h3 id="召回率-Recall"><a href="#召回率-Recall" class="headerlink" title="召回率(Recall)"></a>召回率<code>(Recall)</code></h3><p>即所有预测的正样本中，真正为正样本的比例</p><script type="math/tex; mode=display">R = \frac{TP}{TP + NP}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recall_score</span><span class="params">(gt, pred)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Params:</span></span><br><span class="line"><span class="string">        gt:     &#123;ndarray(N)&#125; `0` or `1`</span></span><br><span class="line"><span class="string">        pred:   &#123;ndarray(N)&#125; `0` or `1`</span></span><br><span class="line"><span class="string">    Returns：</span></span><br><span class="line"><span class="string">        r:      &#123;float&#125;</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    index = gt == <span class="number">1</span></span><br><span class="line">    _pred = pred[index]</span><br><span class="line">    tp = _pred[_pred == <span class="number">1</span>].shape[<span class="number">0</span>]</span><br><span class="line">    gp = _pred.shape[<span class="number">0</span>]</span><br><span class="line">    r = tp / gp <span class="keyword">if</span> gp != <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure><h3 id="平均精确度-Average-Precision"><a href="#平均精确度-Average-Precision" class="headerlink" title="平均精确度(Average Precision)"></a>平均精确度<code>(Average Precision)</code></h3><p>依次设定不同的阈值，根据预测评分，得到不同的预测标签结果，那么就可以计算得到不同的$P$和$R$，做出$P-R$曲线，其与坐标轴面积即平均精确度。</p><h4 id="Average-Precision"><a href="#Average-Precision" class="headerlink" title="Average Precision"></a>Average Precision</h4><p><img src="/2019/05/26/mAP/2-class-precision-recall.png" alt="2-class-precision-recall"></p><blockquote><p>该图来自<a href="https://arleyzhang.github.io/articles/c521a01c/" target="_blank" rel="noopener">目标检测评价标准-AP mAP</a>，侵删。</p></blockquote><p>那么AP计算公式为</p><script type="math/tex; mode=display">AP = \int_0^1 P(r) dr \tag{1}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">average_precision</span><span class="params">(p, r)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Params:</span></span><br><span class="line"><span class="string">        p: &#123;ndarray(n)&#125; Precision</span></span><br><span class="line"><span class="string">        r: &#123;ndarray(n)&#125; Recall</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        AP:&#123;float&#125;</span></span><br><span class="line"><span class="string">    Notes:</span></span><br><span class="line"><span class="string">        AP = \int_0^1 P(r) dr</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    n = len(p)</span><br><span class="line">    AP = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        deltaR = r[i] - r[i<span class="number">-1</span>]</span><br><span class="line">        P_inter = (p[i] + p[i<span class="number">-1</span>]) / <span class="number">2</span></span><br><span class="line">        AP += P_inter * deltaR  <span class="comment"># 梯形面积</span></span><br><span class="line">    <span class="keyword">return</span> AP</span><br></pre></td></tr></table></figure><h4 id="Approximated-Average-Precision"><a href="#Approximated-Average-Precision" class="headerlink" title="Approximated Average Precision"></a>Approximated Average Precision</h4><p><img src="/2019/05/26/mAP/2-class-precision-recall-approximated.png" alt="2-class-precision-recall-approximated"></p><p>注意图中折线上每个点代表一个样本，则将$(1)$离散化，累积<strong>每个样本点</strong>带来的面积变化</p><script type="math/tex; mode=display">AP_{approx} = \sum_{k=1}^N P(k) \Delta r(k) \tag{2}</script><p>其中$N$为样本总数，$k$为样本数，且</p><script type="math/tex; mode=display">\Delta r(k) = r(k) - r(k-1)</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">average_precision_approximated</span><span class="params">(p, r)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Params:</span></span><br><span class="line"><span class="string">        p: &#123;ndarray(n)&#125; Precision</span></span><br><span class="line"><span class="string">        r: &#123;ndarray(n)&#125; Recall</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        AP:&#123;float&#125;</span></span><br><span class="line"><span class="string">    Notes:</span></span><br><span class="line"><span class="string">        AP_&#123;approx&#125; = \sum_&#123;k=1&#125;^N P(k) \Delta r(k)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    n = len(p)</span><br><span class="line">    AP = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        deltaR = r[i] - r[i<span class="number">-1</span>]</span><br><span class="line">        P_inter = p[i]          <span class="comment"># 每个点处的Precision</span></span><br><span class="line">        AP += P_inter * deltaR  <span class="comment"># 矩形面积</span></span><br><span class="line">    <span class="keyword">return</span> AP</span><br></pre></td></tr></table></figure><h4 id="Interpolated-average-precision"><a href="#Interpolated-average-precision" class="headerlink" title="Interpolated average precision"></a>Interpolated average precision</h4><p><img src="/2019/05/26/mAP/2-class-precision-recall-interpolated.png" alt="2-class-precision-recall-interpolated"></p><p>换一种插值方法计算$P(k)$</p><script type="math/tex; mode=display">P_{inter}(k) = \max_{\hat{k} \geq k} P(\hat{k})</script><script type="math/tex; mode=display">AP_{inter} = \sum_{k=1}^{N} P_{inter}(k) \Delta r(k) \tag{3}</script><p>其中$\hat{k}$为第$k$个样本点后的样本索引，也即，<strong>$P_{inter}(k)$为第$k$个样本点后，最大的<code>Precision</code>值</strong>。</p><p>因为正样本影响<code>Recall</code>阈值，故式$(3)$也可写作</p><script type="math/tex; mode=display">P_{inter}(k) = \max_{\hat{k} \geq k} P(\hat{k})</script><script type="math/tex; mode=display">AP_{inter} = \sum_{k=1}^{K} P_{inter}(k) \Delta r(k) \tag{4}</script><p>其中$K$表示正样本的个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">average_precision_interpolated</span><span class="params">(p, r)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Params:</span></span><br><span class="line"><span class="string">        p: &#123;ndarray(n)&#125; Precision</span></span><br><span class="line"><span class="string">        r: &#123;ndarray(n)&#125; Recall</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        AP:&#123;float&#125;</span></span><br><span class="line"><span class="string">    Notes:</span></span><br><span class="line"><span class="string">        P_&#123;inter&#125;(k) = \max_&#123;\hat&#123;k&#125; \geq k&#125; P(\hat&#123;k&#125;)</span></span><br><span class="line"><span class="string">        AP_&#123;inter&#125; = \sum_&#123;k=1&#125;^&#123;N&#125; P_&#123;inter&#125;(k) \Delta r(k)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    n = len(p)</span><br><span class="line">    AP = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        deltaR = r[i] - r[i<span class="number">-1</span>]</span><br><span class="line">        P_inter = max(p[i:])    <span class="comment"># 每个点后最大的Precision</span></span><br><span class="line">        AP += P_inter * deltaR  <span class="comment"># 矩形面积</span></span><br><span class="line">    <span class="keyword">return</span> AP</span><br></pre></td></tr></table></figure><h4 id="11-points-Interpolated-Average-Precision"><a href="#11-points-Interpolated-Average-Precision" class="headerlink" title="11 points Interpolated Average Precision"></a>11 points Interpolated Average Precision</h4><p><img src="/2019/05/26/mAP/2-class-precision-recall-11points.png" alt="2-class-precision-recall-11points"></p><p>固定选取${0, 0.1, \cdots, 1.0}$ 11个<code>Recall</code>阈值，<strong>选取$P_{inter}(k)$为每个阈值点后最大<code>Precision</code>值</strong>，进行计算</p><script type="math/tex; mode=display">P_{inter}(k) = \max_{r(\hat{k}) \geq R(k)} P(\hat{k}), R \in \{0.0, 0.1, \cdots, 1.0\}</script><script type="math/tex; mode=display">AP_{inter} = \sum_{k=1}^{K} P_{inter}(k) \Delta r(k) \tag{4}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">average_precision_11_points</span><span class="params">(p, r)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Params:</span></span><br><span class="line"><span class="string">        p: &#123;ndarray(n)&#125; Precision</span></span><br><span class="line"><span class="string">        r: &#123;ndarray(n)&#125; Recall</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        AP:&#123;float&#125;</span></span><br><span class="line"><span class="string">    Notes:</span></span><br><span class="line"><span class="string">        P_&#123;inter&#125;(k) = \max_&#123;r(\hat&#123;k&#125;) \geq R(k)&#125; P(\hat&#123;k&#125;), R \in \&#123;0.0, 0.1, \cdots, 1.0\&#125;</span></span><br><span class="line"><span class="string">        AP_&#123;inter&#125; = \sum_&#123;k=1&#125;^&#123;K&#125; P_&#123;inter&#125;(k) \Delta r(k)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    AP = <span class="number">0</span></span><br><span class="line">    deltaR = <span class="number">0.1</span></span><br><span class="line">    p = np.array(p); r = np.array(r)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">11</span>):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">10</span>: </span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        R = i*deltaR</span><br><span class="line">        P_inter = np.max(p[r&gt;R])<span class="comment"># 每个阈值点后最大的Precision</span></span><br><span class="line">        AP += P_inter * deltaR  <span class="comment"># 矩形面积</span></span><br><span class="line">    <span class="keyword">return</span> AP</span><br></pre></td></tr></table></figure><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>以一个二分类任务为例，假设我们得到样本真实标签与预测评分如下</p><div class="table-container"><table><thead><tr><th style="text-align:center">Index</th><th style="text-align:center">Ground Truth</th><th style="text-align:center">Score</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0.4</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0.7</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center">0.6</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">0</td><td style="text-align:center">0.45</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">0</td><td style="text-align:center">0.2</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">1</td><td style="text-align:center">0.2</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">1</td><td style="text-align:center">0.3</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">1</td><td style="text-align:center">0.6</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">1</td><td style="text-align:center">0.9</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">1</td><td style="text-align:center">0.8</td></tr></tbody></table></div><p>可依次设定阈值</p><script type="math/tex; mode=display">thresh = 0.2, 0.2, 0.3, 0.4, 0.45, 0.6, 0.6, 0.7, 0.8, 0.9</script><p>特别注意以下几个正样本Score对应阈值点，得表格如下</p><div class="table-container"><table><thead><tr><th style="text-align:center">Index</th><th style="text-align:center">Ground Truth</th><th style="text-align:center">Score</th><th style="text-align:center">thresh=0.2</th><th style="text-align:center">thresh=0.3</th><th style="text-align:center">thresh=0.6</th><th style="text-align:center">thresh=0.8</th><th style="text-align:center">thresh=0.9</th><th style="text-align:center">thresh=1.0</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0.4</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0.7</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center">0.6</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">0</td><td style="text-align:center">0.45</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">0</td><td style="text-align:center">0.2</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">1</td><td style="text-align:center">0.2</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">1</td><td style="text-align:center">0.3</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">1</td><td style="text-align:center">0.6</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">1</td><td style="text-align:center">0.9</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">1</td><td style="text-align:center">0.8</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><strong>recall</strong></td><td style="text-align:center">/</td><td style="text-align:center">/</td><td style="text-align:center">1</td><td style="text-align:center">0.8</td><td style="text-align:center">0.6</td><td style="text-align:center">0.4</td><td style="text-align:center">0.2</td><td style="text-align:center">0.0</td></tr><tr><td style="text-align:center"><strong>precision</strong></td><td style="text-align:center">/</td><td style="text-align:center">/</td><td style="text-align:center">5/10</td><td style="text-align:center">4/8</td><td style="text-align:center">3/5</td><td style="text-align:center">2/2</td><td style="text-align:center">1/1</td><td style="text-align:center">1.0</td></tr></tbody></table></div><p>$P-R$曲线如下<br><img src="/2019/05/26/mAP/P-R.png" alt="P-R"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 准备数据</span></span><br><span class="line">gt = np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], dtype=<span class="string">'int'</span>)</span><br><span class="line">pred = np.array([<span class="number">0.4</span>, <span class="number">0.7</span>, <span class="number">0.6</span>, <span class="number">0.45</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.6</span>, <span class="number">0.9</span>, <span class="number">0.8</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">## 作P-R曲线，每个点均需计算</span></span><br><span class="line">thresh = list(np.sort(pred))[::<span class="number">-1</span>]</span><br><span class="line">p = []; r = []</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> thresh:</span><br><span class="line">    label = score2label(pred, t)</span><br><span class="line">    n = pred[pred==t].shape[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        p += [precision_score(gt, label)]</span><br><span class="line">        r += [recall_score(gt, label)]</span><br><span class="line"></span><br><span class="line">plt.figure(<span class="string">"P-R"</span>)</span><br><span class="line">plt.xlabel(<span class="string">"recall"</span>); plt.ylabel(<span class="string">"precision"</span>)</span><br><span class="line">plt.ylim([<span class="number">0</span>, <span class="number">1.2</span>])</span><br><span class="line">plt.grid()</span><br><span class="line">plt.plot(r, p)</span><br><span class="line">plt.scatter(r, p)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h1 id="mAP"><a href="#mAP" class="headerlink" title="mAP"></a>mAP</h1><p>对每一类计算<code>AP</code>，求其均值</p><script type="math/tex; mode=display">mAP = \frac{1}{C} \sum_{i=0}^{C} AP_i</script><h1 id="PASCAL-VOC"><a href="#PASCAL-VOC" class="headerlink" title="PASCAL VOC"></a>PASCAL VOC</h1><p>原文<a href="http://host.robots.ox.ac.uk/pascal/VOC/voc2012/devkit_doc.pdf" target="_blank" rel="noopener">devkit_doc/3.4.1</a>如下</p><blockquote><p>3.4.1 Average Precision (AP) The computation of the average precision (AP) measure was changed in 2010 to improve precision and ability to measure differences between methods with low AP. It is computed as follows: </p><ol><li>Compute a version of the measured precision/recall curve with precision monotonically decreasing, by setting the precision for recall r to the maximum precision obtained for any recall $r′ \geq r$.</li><li>Compute the AP as the area under this curve by numerical integration. No approximation is involved since the curve is piecewise constant.</li></ol><p>Note that prior to 2010 the AP is computed by sampling the monotonically decreasing curve at a fixed set of uniformly-spaced recall values $0, 0.1, 0.2, \cdots, 1.0$. By contrast, VOC2010–2012 effectively samples the curve at all unique recall values.</p></blockquote><p>记真实回归框为$B_{gt}$，预测回归框为$B_p$，则当预测框与真实框<code>IoU</code>大于阈值$0.5$时，认定物体被检测到，即</p><script type="math/tex; mode=display">IoU_{gt, p} = \frac{area(B_p \bigcap B_{gt})}{area(B_p \bigcup B_{gt})} \geq 0.5</script><p>其计算方法更加粗暴，计算每个<code>Recall</code>阈值点处最大<code>Precision</code>的均值</p><script type="math/tex; mode=display">P_{inter}(r) = \max_{\hat{r}: \hat{r} \geq r} P(\hat{r})</script><script type="math/tex; mode=display">AP_{voc} = \frac{1}{11} \sum_{r \in \{0.0, 0.1, \cdots, 1.0\}} P_{inter}(r) \tag{5}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">average_precision_voc</span><span class="params">(p, r)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Params:</span></span><br><span class="line"><span class="string">        p: &#123;ndarray(n)&#125; Precision</span></span><br><span class="line"><span class="string">        r: &#123;ndarray(n)&#125; Recall</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        AP:&#123;float&#125;</span></span><br><span class="line"><span class="string">    Notes:</span></span><br><span class="line"><span class="string">        P_&#123;inter&#125;(r) = \max_&#123;\hat&#123;r&#125;: \hat&#123;r&#125; \geq r&#125; P(\hat&#123;r&#125;)</span></span><br><span class="line"><span class="string">        AP_&#123;voc&#125; = \frac&#123;1&#125;&#123;11&#125; \sum_&#123;r \in \&#123;0.0, 0.1, \cdots, 1.0\&#125;&#125; P_&#123;inter&#125;(r)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    AP = <span class="number">0</span></span><br><span class="line">    deltaR = <span class="number">0.1</span></span><br><span class="line">    p = np.array(p); r = np.array(r)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">11</span>):</span><br><span class="line">        R = i*deltaR</span><br><span class="line">        <span class="keyword">if</span> i != <span class="number">10</span>: </span><br><span class="line">            P_inter = np.max(p[r&gt;R])<span class="comment"># 每个阈值点后最大的Precision</span></span><br><span class="line">        AP += P_inter           <span class="comment"># 矩形面积</span></span><br><span class="line">    AP = AP / <span class="number">11</span></span><br><span class="line">    <span class="keyword">return</span> AP</span><br></pre></td></tr></table></figure><h1 id="COCO"><a href="#COCO" class="headerlink" title="COCO"></a>COCO</h1><p>COCO评估指标较多，共有12项，详细查看<a href="http://cocodataset.org/#detection-eval" target="_blank" rel="noopener">Detection Evaluation</a>，以下仅介绍其<code>AP</code>计算方法，原文如下。</p><blockquote><p>Average Precision (AP):</p><ol><li><p>primary challenge metric($AP$)</p><script type="math/tex; mode=display">IoU=.50:.05:.95</script></li><li><p>PASCAL VOC metric($AP^{IoU}=.50$)</p><script type="math/tex; mode=display">IoU=.50</script></li><li><p>strict metric($AP^{IoU}=.75$) </p><script type="math/tex; mode=display">IoU=.75</script></li></ol></blockquote><p>与<code>VOC</code>类似，但选取更多阈值的<code>IoU</code>，从中标记预测正确的样本进行计算。当$IoU = 0.5$时，即<code>VOC</code>计算方法。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="http://host.robots.ox.ac.uk/pascal/VOC/voc2012/devkit_doc.pdf" target="_blank" rel="noopener">The PASCAL Visual Object Classes Challenge 2012 (VOC2012) Development Kit</a></li><li><a href="https://arleyzhang.github.io/articles/c521a01c/" target="_blank" rel="noopener">目标检测评价标准-AP mAP</a></li><li><a href="https://www.zhihu.com/question/41540197" target="_blank" rel="noopener">mean average precision（MAP）在计算机视觉中是如何计算和应用的？</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Object Detection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NMS &amp; soft-NMS</title>
      <link href="/2019/05/26/NMS-softer-NMS/"/>
      <url>/2019/05/26/NMS-softer-NMS/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在目标检测中，若多个回归框<code>(Bounding Box)</code>重叠内容较多，则可以保留其中几个，删除其余冗余的框，非极大值抑制<code>(Non-Maximum Suppression, NMS)</code>算法可实现该功能。</p><p>那么用什么指标评价两个回归框重叠过多呢，以下介绍图像的交并比<code>IoU(Intersection over Union)</code>。</p><h1 id="IoU"><a href="#IoU" class="headerlink" title="IoU"></a>IoU</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><code>IoU</code>的思路非常简单，即计算两个回归框交集部分面积与并集面积的比值，如下图，其计算公式为</p><script type="math/tex; mode=display">IoU_{a, b} = \frac{Area_{inter}}{Area_{union}}</script><p>其中</p><script type="math/tex; mode=display">Area_{union} = Area_{a} + Area_{b} - Area_{inter}</script><script type="math/tex; mode=display">Area_{inter} = w_{inter}*h_{inter}</script><script type="math/tex; mode=display">w_{inter} = x^a_2 - x^b_1</script><script type="math/tex; mode=display">h_{inter} = y^a_2 - y^b_1</script><p><img src="/2019/05/26/NMS-softer-NMS/IoU1.jpg" alt="iou1"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>算法实现中，比较关键的一点是计算交集部分的坐标点，记两个回归框$a, b$左上角坐标为$(x^<em>_1, y^</em>_1)$，右下角为$(x^<em>_2, y^</em>_2)$</p><p>则应有</p><script type="math/tex; mode=display">x^{inter}_1 = \max \{x^a_1, x^b_1\}, y^{inter}_1 = \max \{y^a_1, y^b_1\}</script><script type="math/tex; mode=display">x^{inter}_2 = \min \{x^a_2, x^b_2\}, y^{inter}_2 = \min \{y^a_2, y^b_2\}</script><p><img src="/2019/05/26/NMS-softer-NMS/IoU2.jpg" alt="IoU2"></p><p>使用C/C++实现如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">float</span> x1, y1, x2, y2;</span><br><span class="line">&#125;bbox;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">bbox_overlap</span><span class="params">(<span class="keyword">float</span> ax1, <span class="keyword">float</span> ax2, <span class="keyword">float</span> bx1, <span class="keyword">float</span> bx2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> left  = _max(ax1, bx1);</span><br><span class="line">    <span class="keyword">float</span> right = _min(ax2, bx2);</span><br><span class="line">    <span class="keyword">float</span> gap = right - left;</span><br><span class="line">    <span class="keyword">return</span> gap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">bbox_intersection</span><span class="params">(bbox a, bbox b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> w = bbox_overlap(a.x1, a.x2, b.x1, b.x2);</span><br><span class="line">    <span class="keyword">float</span> h = bbox_overlap(a.y1, a.y2, b.y1, b.y2);</span><br><span class="line">    <span class="keyword">if</span>(w &lt; <span class="number">0</span> || h &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">float</span> area = w*h;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">bbox_area</span><span class="params">(bbox a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> w = a.x2 - a.x1;</span><br><span class="line">    <span class="keyword">float</span> h = a.y2 - a.y1;</span><br><span class="line">    <span class="keyword">return</span> w*h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">bbox_union</span><span class="params">(bbox a, bbox b, <span class="keyword">int</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> u = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">float</span> area_a = bbox_area(a);</span><br><span class="line">    <span class="keyword">float</span> area_b = bbox_area(b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mode == <span class="number">0</span>)&#123;</span><br><span class="line">        u = area_a + area_b - bbox_intersection(a, b);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mode == <span class="number">1</span>)&#123;</span><br><span class="line">        u = _min(area_a, area_b);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">bbox_iou</span><span class="params">(bbox a, bbox b, <span class="keyword">int</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> i = bbox_intersection(a, b);</span><br><span class="line">    <span class="keyword">float</span> u = bbox_union(a, b, mode);</span><br><span class="line">    <span class="keyword">return</span> i/u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="NMS"><a href="#NMS" class="headerlink" title="NMS"></a>NMS</h1><p>以下图为例，其中三个候选框$a,b,c$，其评分依次为0.8, 0.7, 0.9，设定<code>IoU</code>阈值</p><script type="math/tex; mode=display">thresh=0.4</script><p>计算步骤如下<br><img src="/2019/05/26/NMS-softer-NMS/NMS1.jpg" alt="NMS1"></p><ol><li>将其排序，如降序排序， 得到结果$c,a,b$；</li><li>保存当前评分最高的回归框，即$c$；</li><li>计算$c$与剩余框，即$a,b$的<code>IoU</code>，即<script type="math/tex; mode=display">IoU_{c,a} = \frac{1×8}{10×9 + 9×11 - 1×8} = 0.044</script><script type="math/tex; mode=display">IoU_{c,b} = \frac{4×6}{10×9 + 10×11 - 4×6} = 0.136</script></li><li>无大于阈值的框，故无框被删除；</li><li>保存当前评分最高的回归框，即$a$；</li><li>计算$a$与剩余框即$b$的<code>IoU</code>，即<script type="math/tex; mode=display">IoU_{a,b} = \frac{7×9}{9×11 + 10×11 - 7×9} = 0.432</script></li><li>大于阈值，故删除$b$；</li><li>最终保留框$a,c$；</li></ol><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><ol><li><p>Python</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_nms</span><span class="params">(dets, thresh, mode=<span class="string">"Union"</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Params:</span></span><br><span class="line"><span class="string">        dets:   &#123;ndarray(n_boxes, 5)&#125; x1, y1, x2, y2 score</span></span><br><span class="line"><span class="string">        thresh: &#123;float&#125; retain overlap &lt;= thresh</span></span><br><span class="line"><span class="string">        mode:   &#123;str&#125; 'Union' or 'Minimum'</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        idx:   &#123;list[int]&#125; indexes to keep</span></span><br><span class="line"><span class="string">    Notes:</span></span><br><span class="line"><span class="string">        greedily select boxes with high confidence</span></span><br><span class="line"><span class="string">        idx boxes overlap &lt;= thresh</span></span><br><span class="line"><span class="string">        rule out overlap &gt; thresh</span></span><br><span class="line"><span class="string">        if thresh==1.0, keep all</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    x1 = dets[:, <span class="number">0</span>]</span><br><span class="line">    y1 = dets[:, <span class="number">1</span>]</span><br><span class="line">    x2 = dets[:, <span class="number">2</span>]</span><br><span class="line">    y2 = dets[:, <span class="number">3</span>]</span><br><span class="line">    scores = dets[:, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">    areas = (x2 - x1 + <span class="number">1</span>) * (y2 - y1 + <span class="number">1</span>)</span><br><span class="line">    order = scores.argsort()[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    idx = []</span><br><span class="line">    <span class="keyword">while</span> order.size &gt; <span class="number">0</span>:</span><br><span class="line">        i = order[<span class="number">0</span>]</span><br><span class="line">        idx.append(i)</span><br><span class="line"></span><br><span class="line">        xx1 = np.maximum(x1[i], x1[order[<span class="number">1</span>:]])</span><br><span class="line">        yy1 = np.maximum(y1[i], y1[order[<span class="number">1</span>:]])</span><br><span class="line">        xx2 = np.minimum(x2[i], x2[order[<span class="number">1</span>:]])</span><br><span class="line">        yy2 = np.minimum(y2[i], y2[order[<span class="number">1</span>:]])</span><br><span class="line">        w = np.maximum(<span class="number">0.0</span>, xx2 - xx1 + <span class="number">1</span>)</span><br><span class="line">        h = np.maximum(<span class="number">0.0</span>, yy2 - yy1 + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        inter = w * h</span><br><span class="line">        <span class="keyword">if</span> mode == <span class="string">"Union"</span>:</span><br><span class="line">            ovr = inter / (areas[i] + areas[order[<span class="number">1</span>:]] - inter)</span><br><span class="line">        <span class="keyword">elif</span> mode == <span class="string">"Minimum"</span>:</span><br><span class="line">            ovr = inter / np.minimum(areas[i], areas[order[<span class="number">1</span>:]])</span><br><span class="line"></span><br><span class="line">        inds = np.where(ovr &lt;= thresh)[<span class="number">0</span>]</span><br><span class="line">        order = order[inds + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> idx</span><br></pre></td></tr></table></figure></li><li><p>C/C++</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">detect</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> score;    <span class="comment">/* 该框评分 */</span></span><br><span class="line">    bbox bx;        <span class="comment">/* 回归方框 */</span></span><br><span class="line">    bbox offset;    <span class="comment">/* 偏置 */</span></span><br><span class="line">    landmark mk;    <span class="comment">/* 位置 */</span></span><br><span class="line">&#125; detect;</span><br><span class="line"></span><br><span class="line"><span class="comment">// decending order, bubble</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bsort</span><span class="params">(detect** dets, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++ )&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j++ )&#123;</span><br><span class="line">            <span class="keyword">float</span> a = (*dets)[j].score;</span><br><span class="line">            <span class="keyword">float</span> b = (*dets)[j+<span class="number">1</span>].score;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (a &lt; b)&#123;</span><br><span class="line">                detect tmp = (*dets)[j];</span><br><span class="line">                (*dets)[j] = (*dets)[j+<span class="number">1</span>];</span><br><span class="line">                (*dets)[j+<span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _nms(detect* dets, <span class="keyword">int</span> n, <span class="keyword">float</span> thresh, <span class="keyword">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">    bsort(&amp;dets, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dets[i].score == <span class="number">0</span>) <span class="keyword">continue</span>;   <span class="comment">// 表示该框已被删除</span></span><br><span class="line">        bbox a = dets[i].bx;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            bbox b = dets[j].bx;</span><br><span class="line">            <span class="keyword">if</span> (bbox_iou(a, b, mode) &gt; thresh)</span><br><span class="line">                dets[j].score = <span class="number">0</span>;          <span class="comment">// 删除该框</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="Soft-NMS"><a href="#Soft-NMS" class="headerlink" title="Soft-NMS"></a>Soft-NMS</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>对于两个相邻较近的同类物体，如下图，<code>NMS</code>可能将左框删除，这是由于在删除同类别框时，只考虑了<code>IoU</code>重叠大小，并没有将两个框的评分引入计算，当两个框相邻很近但评分都较高时，不能简单地删除。</p><p><img src="/2019/05/26/NMS-softer-NMS/soft-NMS1.jpg" alt="soft-NMS1"></p><p>改进后的<code>soft-NMS</code>伪代码如下<br><img src="/2019/05/26/NMS-softer-NMS/NMS2.jpg" alt="NMS2"></p><p>也可统一写作</p><script type="math/tex; mode=display">s_i \leftarrow s_i f(iou(\mathcal{M}, b_i))</script><p>其中<code>NMS</code>算法引入<code>hard threshold</code>，即</p><script type="math/tex; mode=display">f(iou(\mathcal{M}, b_i)) = \begin{cases}    1 & iou(\mathcal{M}, b_i) < N_t \\    0 & iou(\mathcal{M}, b_i) \geq N_t\end{cases}</script><p><img src="/2019/05/26/NMS-softer-NMS/f1.png" alt="f1"></p><p>应考虑以下因素</p><ul><li>相邻检测的分数应该降低到它们具有增加假阳性率<code>(false positive rate)</code>的可能性较小的程度，同时在排序的检测列表中高于明显的假阳性。</li><li>完全去除具有低NMS阈值的相邻检测将是次优的并且当在高重叠阈值处执行评估时将增加未命中率。</li><li>当使用高NMS阈值时，在一系列重叠阈值上测量的平均精度将下降。</li></ul><p>基于以上分析，改进$f(iou(\mathcal{M}, b_i))$为</p><script type="math/tex; mode=display">f(iou(\mathcal{M}, b_i)) = \begin{cases}    1 & iou(\mathcal{M}, b_i) < N_t \\    1 - iou(\mathcal{M}, b_i) & iou(\mathcal{M}, b_i) \geq N_t\end{cases}</script><p>其函数图像如下，在超过阈值时，为线性函数，且重叠越多，其抑制效果越大或称惩罚越多<br><img src="/2019/05/26/NMS-softer-NMS/f2.png" alt="f2"></p><p>但该函数不连续，可能导致NMS结果的突然改变，故修改为非线性连续函数如下</p><script type="math/tex; mode=display">f(iou(\mathcal{M}, b_i)) = \exp (-\frac{iou(\mathcal{M}, b_i)^2}{\sigma}), \forall b_i \notin \mathcal{D}</script><blockquote><p>注意到$x = \sqrt{\frac{\sigma}{2}}$为函数$f(x)$的拐点</p></blockquote><p><img src="/2019/05/26/NMS-softer-NMS/f3.png" alt="f3"></p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p>对上面代码作如下修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> _f(<span class="keyword">float</span> x, <span class="keyword">float</span> sigma, <span class="keyword">int</span> soft)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">float</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (soft == <span class="number">0</span>)&#123;</span><br><span class="line">        y = x &lt; sigma? <span class="number">1</span>: <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y = <span class="built_in">exp</span>(- <span class="built_in">pow</span>(x, <span class="number">2</span>) / sigma);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _nms(detect* dets, <span class="keyword">int</span> n, <span class="keyword">float</span> sigma, <span class="keyword">int</span> mode, <span class="keyword">int</span> soft)</span><br><span class="line">&#123;</span><br><span class="line">    bsort(&amp;dets, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do nms</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dets[i].score == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        bbox a = dets[i].bx;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            bbox b = dets[j].bx;</span><br><span class="line">            <span class="comment">// if (bbox_iou(a, b, mode) &gt; thresh)</span></span><br><span class="line">            <span class="comment">//     dets[j].score = 0;          // 删除该框</span></span><br><span class="line">            dets[j].score *= _f(bbox_iou(a, b, mode), sigma, soft);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://ieeexplore.ieee.org/abstract/document/1699659" target="_blank" rel="noopener">Efficient Non-Maximum Suppression</a></li><li><a href="https://zhuanlan.zhihu.com/p/37489043" target="_blank" rel="noopener">非极大值抑制(Non-Maximum Suppression)</a></li><li><a href="https://www.pyimagesearch.com/2014/11/17/non-maximum-suppression-object-detection-python/" target="_blank" rel="noopener">Non-Maximum Suppression for Object Detection in Python</a></li><li><a href="https://arxiv.org/abs/1704.04503" target="_blank" rel="noopener">Improving Object Detection With One Line of Code</a></li><li><a href="https://blog.csdn.net/u014380165/article/details/79502197" target="_blank" rel="noopener">Soft NMS算法笔记</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Object Detection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github清除commit记录</title>
      <link href="/2019/05/22/Github%E6%B8%85%E9%99%A4commit%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/05/22/Github%E6%B8%85%E9%99%A4commit%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>当commit记录过多时，仓库会过大难以下载，本文介绍删除commit记录的方法。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li>新建无任何文件的分支 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout --orphan new</span><br></pre></td></tr></table></figure></li><li>添加文件并提交 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add -A</span><br><span class="line">git commit -am "recommit"</span><br></pre></td></tr></table></figure></li><li>删除主分支 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D master</span><br></pre></td></tr></table></figure></li><li>重命名当前分支 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m master</span><br></pre></td></tr></table></figure></li><li>强制更新远程仓库 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f origin master</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Install nVidia drivers on Ubuntu</title>
      <link href="/2019/05/08/Install-nVidia-drivers-on-Ubuntu/"/>
      <url>/2019/05/08/Install-nVidia-drivers-on-Ubuntu/</url>
      
        <content type="html"><![CDATA[<h1 id="PPA安装"><a href="#PPA安装" class="headerlink" title="PPA安装"></a>PPA安装</h1><ol><li>禁用<code>nouveau</code>驱动<br>先将<code>Ubuntu</code>系统集成的显卡驱动程序<code>nouveau</code>从<code>linux</code>内核卸载</li></ol><p>查看当前驱动状态<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lsmod | grep nouveau</span></span><br><span class="line">nouveau              1851392  1</span><br><span class="line">mxm_wmi                16384  1 nouveau</span><br><span class="line">i2c_algo_bit           16384  2 i915,nouveau</span><br><span class="line">ttm                   110592  1 nouveau</span><br><span class="line">drm_kms_helper        172032  2 i915,nouveau</span><br><span class="line">drm                   458752  8 drm_kms_helper,i915,ttm,nouveau</span><br><span class="line">wmi                    24576  3 wmi_bmof,mxm_wmi,nouveau</span><br><span class="line">video                  45056  3 thinkpad_acpi,i915,nouveau</span><br></pre></td></tr></table></figure></p><p>添加黑名单<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ll /etc/modprobe.d/blacklist.conf</span></span><br><span class="line">-rw-r--r-- 1 root root 1667 11月 13 05:54 /etc/modprobe.d/blacklist.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo chmod 666 /etc/modprobe.d/blacklist.conf</span></span><br><span class="line">[sudo] password for louishsu: </span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo vim /etc/modprobe.d/blacklist.conf </span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo chmod 644 /etc/modprobe.d/blacklist.conf</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo update-initramfs -u</span></span><br><span class="line">update-initramfs: Generating /boot/initrd.img-4.18.0-17-generic</span><br><span class="line">...</span><br><span class="line">I: Set the RESUME variable to override this.</span><br></pre></td></tr></table></figure></p><p>重启后查看驱动状态，无输出表示禁用成功<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lsmod | grep nouveau</span></span><br></pre></td></tr></table></figure></p><ol><li>安装驱动</li></ol><p>这里使用<code>PPA</code>方式安装，首先添加源<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo add-apt-repository ppa:graphics-drivers/ppa</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get update</span></span><br></pre></td></tr></table></figure></p><p>查看合适的驱动版本，如下<code>recommended</code><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ubuntu-drivers devices</span></span><br></pre></td></tr></table></figure></p><p>按<code>ctrl+alt+F1</code>进入<code>tty</code>模式，关闭图形桌面显示管理器<code>LightDM</code><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> service lightdm stop</span></span><br></pre></td></tr></table></figure></p><p>安装驱动<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install nvidia-418</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo reboot</span></span><br></pre></td></tr></table></figure></p><ol><li>查看安装情况<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo nvidia-smi</span></span><br><span class="line">Wed May  8 20:22:55 2019       </span><br><span class="line">+------------------------------------------------------+                       </span><br><span class="line">| NVIDIA-SMI 340.107    Driver Version: 340.107        |                       </span><br><span class="line">|-------------------------------+----------------------+----------------------+</span><br><span class="line">| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|===============================+======================+======================|</span><br><span class="line">|   0  GeForce GT 730M     Off  | 0000:04:00.0     N/A |                  N/A |</span><br><span class="line">| N/A   46C    P0    N/A /  N/A |    185MiB /  1023MiB |     N/A      Default |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line">                                                                               </span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| Compute processes:                                               GPU Memory |</span><br><span class="line">|  GPU       PID  Process name                                     Usage      |</span><br><span class="line">|=============================================================================|</span><br><span class="line">|    0            Not Supported                                               |</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo nvidia-settings</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="CUDA"><a href="#CUDA" class="headerlink" title="CUDA"></a>CUDA</h1><p>查看<a href="https://louishsu.xyz/2019/01/04/Ubuntu%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85Tensorflow/" target="_blank" rel="noopener">Ubuntu编译安装Tensorflow</a></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://blog.csdn.net/10km/article/details/61191230" target="_blank" rel="noopener">ubuntu16.04下NVIDIA GTX965M显卡驱动PPA安装</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详细！MTCNN训练全过程！</title>
      <link href="/2019/05/06/%E8%AF%A6%E7%BB%86%EF%BC%81MTCNN%E8%AE%AD%E7%BB%83%E5%85%A8%E8%BF%87%E7%A8%8B%EF%BC%81/"/>
      <url>/2019/05/06/%E8%AF%A6%E7%BB%86%EF%BC%81MTCNN%E8%AE%AD%E7%BB%83%E5%85%A8%E8%BF%87%E7%A8%8B%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记录一下详细的MTCNN训练过程，之前损失函数的问题，训练得到网络效果一般，就拖到了最近。原理在之前写的博客<a href="https://louishsu.xyz/2019/05/05/Face-Detection-MTCNN/" target="_blank" rel="noopener">Face Detection: MTCNN</a>中已说明，本文不做详细介绍。详细代码可见本人代码仓库<a href="https://github.com/isLouisHsu/MTCNN_Darknet" target="_blank" rel="noopener">MTCNN_Darknet - Github</a>。</p><h1 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h1><p><img src="/2019/05/06/%E8%AF%A6%E7%BB%86%EF%BC%81MTCNN%E8%AE%AD%E7%BB%83%E5%85%A8%E8%BF%87%E7%A8%8B%EF%BC%81/详细！MTCNN训练全过程！/dataset1.jpg" alt="dataset1"></p><p><img src="/2019/05/06/%E8%AF%A6%E7%BB%86%EF%BC%81MTCNN%E8%AE%AD%E7%BB%83%E5%85%A8%E8%BF%87%E7%A8%8B%EF%BC%81/详细！MTCNN训练全过程！/dataset2.jpg" alt="dataset2"></p><p>数据集使用的是<a href="http://shuoyang1213.me/WIDERFACE/index.html" target="_blank" rel="noopener">WIDER FACE: A Face Detection Benchmark</a>与<a href="http://mmlab.ie.cuhk.edu.hk/archive/CNN_FacePoint.htm" target="_blank" rel="noopener">Deep Convolutional Network Cascade for Facial Point Detection</a>，前者用于生成识别分类任务、定位回归任务的数据，后者用于生成关键点回归任务的数据。</p><p>我们所需的文件有<code>WIDER_train.zip</code>，<code>WIDER_valid.zip</code>，<code>wider_face_split.zip</code>，<code>train.zip</code>，解压整理后得到文件目录如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data&#x2F;</span><br><span class="line">├─WIDER&#x2F;</span><br><span class="line">│   ├── wider_face_train_bbx_gt.txt</span><br><span class="line">│   ├── wider_face_val_bbx_gt.txt</span><br><span class="line">│   ├── WIDER_train&#x2F;</span><br><span class="line">│   └── WIDER_val&#x2F;</span><br><span class="line">└─Align&#x2F;</span><br><span class="line">    ├── lfw_5590&#x2F;</span><br><span class="line">    ├── net_7876&#x2F;</span><br><span class="line">    ├── testImageList.txt</span><br><span class="line">    └── trainImageList.txt</span><br></pre></td></tr></table></figure></p><p>运行<a href="https://github.com/isLouisHsu/MTCNN_Darknet/blob/master/prepare_data/merge_annotations.py" target="_blank" rel="noopener">prepare_data/merge_annotations.py</a>后，合并标注文件得到<code>data/annotations.txt</code>。</p><h1 id="PNet"><a href="#PNet" class="headerlink" title="PNet"></a>PNet</h1><h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">layer     filters    size           input                output</span><br><span class="line">0 conv      10      3 x 3 &#x2F; 1    12 x  12 x   3   -&gt;    10 x  10 x  10  0.000 BFLOPs</span><br><span class="line">1 max               2 x 2 &#x2F; 2    10 x  10 x  10   -&gt;     5 x   5 x  10</span><br><span class="line">2 conv      16      3 x 3 &#x2F; 1     5 x   5 x  10   -&gt;     3 x   3 x  16  0.000 BFLOPs</span><br><span class="line">3 conv      32      3 x 3 &#x2F; 1     3 x   3 x  16   -&gt;     1 x   1 x  32  0.000 BFLOPs</span><br><span class="line">4 conv      15      1 x 1 &#x2F; 1     1 x   1 x  32   -&gt;     1 x   1 x  15  0.000 BFLOPs</span><br></pre></td></tr></table></figure><h2 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h2><p>运行<a href="https://github.com/isLouisHsu/MTCNN_Darknet/blob/master/prepare_data/pnet_12x12.py" target="_blank" rel="noopener">prepare_data/pnet_12x12.py</a>，对原始图像进行随机采样，注意以下几点：</p><ol><li>WIDER用作分类、定位任务，Align用作关键点定位任务；</li><li>滤除尺寸小于40(pixel)的人脸图像；</li><li>采样数目设置<ul><li>对每张图中任意采样$5 \times n_{faces}$份，再在每个人脸附近采样5份$iou &lt; 0.3$的人脸图像作为负样本(0)；</li><li>每个人脸附近采样10份$iou &gt; 0.65$的人脸图像作为正样本(1)；</li><li>每个人脸附近采样10份$0.4 &lt; iou &lt; 0.65$的人脸图像作为部分样本(-1)；</li><li>每个Align样本附近采样50份关键点样本(-2)。</li></ul></li><li>数据集扩增<ul><li>WIDER：随机左右镜像翻转；</li><li>Align：随机左右镜像翻转，$\pm 15$度随机旋转；</li></ul></li></ol><p>生成以下文件及文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data&#x2F;</span><br><span class="line">├── 12x12&#x2F;</span><br><span class="line">├── 12x12.txt</span><br><span class="line">├── 12x12_train.txt</span><br><span class="line">├── 12x12_valid.txt</span><br><span class="line">└── 12x12_test.txt</span><br></pre></td></tr></table></figure><p>其中<code>12x12/</code>包含随机采样得到的尺寸为$12 \times 12$图像，用于输入网络进行训练；<code>12x12.txt</code>包含所有图像的标注，其格式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[image path] [sample label] [annotations]</span><br></pre></td></tr></table></figure><p>其中负样本(0)无annotations，正样本(1)与部分样本(-1)包含定位框左上右下角的相对偏移量(4个)，关键点样本(-2)包含5个关键点相对于图片左上角的相对偏移量(10个)，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">..&#x2F;data&#x2F;12x12&#x2F;25219.jpg 0</span><br><span class="line">..&#x2F;data&#x2F;12x12&#x2F;25269.jpg 1 0.07142857142857142 0.03571428571428571 -0.21428571428571427 0.10714285714285714</span><br><span class="line">..&#x2F;data&#x2F;12x12&#x2F;25231.jpg -1 -0.030303030303030304 -0.12121212121212122 0.18181818181818182 0.696969696969697</span><br><span class="line">..&#x2F;data&#x2F;12x12&#x2F;3926594.jpg -2 0.29134029571831355 0.08374723013072503 0.7777450550823473 0.20460741825864107 0.2530593377292015 0.5109005869899402 0.30317271612810937 0.767843704149384 0.6327263098562724 0.8486940727227192</span><br></pre></td></tr></table></figure><p><code>12x12_*.txt</code>三个文件为对<code>12x12.txt</code>进行一定比例划分得到的标注文件，这里采用的比例为<code>0.6: 0.15: 0.25</code>。</p><p>经统计，其样本数量与比例详细信息如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Totally 3397282 images</span><br><span class="line">Pos(1): Neg(0): Part(-1): Landmark(-2) &#x3D; 0.3107857987650127: 0.3618628067967275: 0.12916354897827145: 0.1981878454599883</span><br><span class="line">--------------------------------------------------</span><br><span class="line">Cls      | Pos(1)              : Neg(0)   &#x3D; 0.858849798674096</span><br><span class="line">Offset   | [Pos(1) + Part(-1)] : n_samples &#x3D; 0.4399493477432842</span><br><span class="line">Landmark | Landmark(-2)         : n_samples &#x3D; 0.1981878454599883</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure></p><h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><p>数据准备就绪后，可进行网络训练，运行<a href="https://github.com/isLouisHsu/MTCNN_Darknet/blob/master/mtcnn_py/main_pnet.py" target="_blank" rel="noopener">mtcnn_py/main_pnet.py</a>。批次大小设置为512，初始学习率0.01，权重衰减设置为4e-5，采用Adam优化器，学习率调整使用指数衰减策略，每代衰减95%，对于PNet，进行20代训练即可，得到权重文件<code>mtcnn_py/ckptdir/PNet.pkl</code>。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><img src="/2019/05/06/%E8%AF%A6%E7%BB%86%EF%BC%81MTCNN%E8%AE%AD%E7%BB%83%E5%85%A8%E8%BF%87%E7%A8%8B%EF%BC%81/详细！MTCNN训练全过程！/1.jpg" alt="1"></p><h1 id="RNet"><a href="#RNet" class="headerlink" title="RNet"></a>RNet</h1><h2 id="网络结构-1"><a href="#网络结构-1" class="headerlink" title="网络结构"></a>网络结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">layer     filters    size           input                output</span><br><span class="line">0 conv     28       3 x 3 &#x2F; 1    24 x  24 x   3   -&gt;    22 x  22 x  28  0.001 BFLOPs</span><br><span class="line">1 max               3 x 3 &#x2F; 2    22 x  22 x  28   -&gt;    11 x  11 x  28</span><br><span class="line">2 conv     48       3 x 3 &#x2F; 1    11 x  11 x  28   -&gt;     9 x   9 x  48  0.002 BFLOPs</span><br><span class="line">3 max               3 x 3 &#x2F; 2     9 x   9 x  48   -&gt;     4 x   4 x  48</span><br><span class="line">4 conv     64       2 x 2 &#x2F; 1     4 x   4 x  48   -&gt;     3 x   3 x  64  0.000 BFLOPs</span><br><span class="line">5 connected                                 576   -&gt;               128</span><br><span class="line">6 connected                                 128   -&gt;                15</span><br></pre></td></tr></table></figure><h2 id="数据准备-1"><a href="#数据准备-1" class="headerlink" title="数据准备"></a>数据准备</h2><p>运行<a href="https://github.com/isLouisHsu/MTCNN_Darknet/blob/master/prepare_data/rnet_24x24.py" target="_blank" rel="noopener">prepare_data/rnet_24x24.py</a>，生成以下文件及文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data&#x2F;</span><br><span class="line">├── 24x24&#x2F;</span><br><span class="line">├── 24x24.txt</span><br><span class="line">├── 24x24_train.txt</span><br><span class="line">├── 24x24_valid.txt</span><br><span class="line">├── 24x24_test.txt</span><br><span class="line">└── rDets.npy</span><br></pre></td></tr></table></figure><p>RNet训练数据需要用到训练好的PNet生成候选框。首先利用PNet对每张原始图片进行检测，保存检测得到的候选框，文件为<code>data/rDets.npy</code>。</p><p>再依据真实标注框对每个候选框进行判别，由于负样本众多，每张图片保留15份负样本，保留全部正样本与部分样本。关键点样本与PNet一致，每张原始图片生成80份关键点样本。</p><p>经统计，样本数目如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Totally 1954946 images</span><br><span class="line">Pos(1): Neg(0): Part(-1): Landmark(-2) &#x3D; 0.05522607785585893: 0.10885466913152589: 0.2848656689238475: 0.5510535840887677</span><br><span class="line">--------------------------------------------------</span><br><span class="line">Cls      | Pos(1)              : Neg(0)   &#x3D; 0.507337703531402</span><br><span class="line">Offset   | [Pos(1) + Part(-1)] : n_samples &#x3D; 0.34009174677970644</span><br><span class="line">Landmark | Landmark(-2)         : n_samples &#x3D; 0.5510535840887677</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><h2 id="训练-1"><a href="#训练-1" class="headerlink" title="训练"></a>训练</h2><p>运行<a href="https://github.com/isLouisHsu/MTCNN_Darknet/blob/master/mtcnn_py/main_rnet.py" target="_blank" rel="noopener">mtcnn_py/main_rnet.py</a>。批次大小设置为512，初始学习率0.01，权重衰减设置为4e-5，采用Adam优化器，学习率调整使用指数衰减策略，每代衰减95%，进行50代训练，得到权重文件<code>mtcnn_py/ckptdir/RNet.pkl</code>。。</p><h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><p><img src="/2019/05/06/%E8%AF%A6%E7%BB%86%EF%BC%81MTCNN%E8%AE%AD%E7%BB%83%E5%85%A8%E8%BF%87%E7%A8%8B%EF%BC%81/详细！MTCNN训练全过程！/2.jpg" alt="2"></p><h1 id="ONet"><a href="#ONet" class="headerlink" title="ONet"></a>ONet</h1><h2 id="网络结构-2"><a href="#网络结构-2" class="headerlink" title="网络结构"></a>网络结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">layer     filters    size              input                output</span><br><span class="line">0 conv     32       3 x 3 &#x2F; 1    48 x  48 x   3   -&gt;    46 x  46 x  32  0.004 BFLOPs</span><br><span class="line">1 max               3 x 3 &#x2F; 2    46 x  46 x  32   -&gt;    23 x  23 x  32</span><br><span class="line">2 conv     64       3 x 3 &#x2F; 1    23 x  23 x  32   -&gt;    21 x  21 x  64  0.016 BFLOPs</span><br><span class="line">3 max               3 x 3 &#x2F; 2    21 x  21 x  64   -&gt;    10 x  10 x  64</span><br><span class="line">4 conv     64       3 x 3 &#x2F; 1    10 x  10 x  64   -&gt;     8 x   8 x  64  0.005 BFLOPs</span><br><span class="line">5 max               2 x 2 &#x2F; 2     8 x   8 x  64   -&gt;     4 x   4 x  64</span><br><span class="line">6 conv    128       2 x 2 &#x2F; 1     4 x   4 x  64   -&gt;     3 x   3 x 128  0.001 BFLOPs</span><br><span class="line">7 connected                                1152   -&gt;               256</span><br><span class="line">8 connected                                 256   -&gt;                15</span><br></pre></td></tr></table></figure><h2 id="数据准备-2"><a href="#数据准备-2" class="headerlink" title="数据准备"></a>数据准备</h2><p>运行<a href="https://github.com/isLouisHsu/MTCNN_Darknet/blob/master/prepare_data/onet_48x48.py" target="_blank" rel="noopener">prepare_data/onet_48x48.py</a>，生成以下文件及文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data&#x2F;</span><br><span class="line">├── 48x48&#x2F;</span><br><span class="line">├── 48x48.txt</span><br><span class="line">├── 48x48_train.txt</span><br><span class="line">├── 48x48_valid.txt</span><br><span class="line">├── 48x48_test.txt</span><br><span class="line">└── oDets.npy</span><br></pre></td></tr></table></figure><p>数据生成方法与RNet一致，不同之处是用到PNet与RNet生成的候选框，保存检测得到的候选框，文件为<code>data/oDets.npy</code>。</p><p>由于负样本众多，每张图片保留10份负样本，保留全部正样本与部分样本。关键点样本与PNet一致，每张原始图片生成80份关键点样本。</p><p>经统计，样本数目如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Totally 1106392 images</span><br><span class="line">Pos(1): Neg(0): Part(-1): Landmark(-2) &#x3D; 0.04348278006348564: 0.12449656179726534: 0.10240583807547415: 0.7296148200637749</span><br><span class="line">--------------------------------------------------</span><br><span class="line">Cls      | Pos(1)              : Neg(0)   &#x3D; 0.34926892305905244</span><br><span class="line">Offset   | [Pos(1) + Part(-1)] : n_samples &#x3D; 0.14588861813895979</span><br><span class="line">Landmark | Landmark(-2)         : n_samples &#x3D; 0.7296148200637749</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><h2 id="训练-2"><a href="#训练-2" class="headerlink" title="训练"></a>训练</h2><p>运行<a href="https://github.com/isLouisHsu/MTCNN_Darknet/blob/master/mtcnn_py/main_onet.py" target="_blank" rel="noopener">mtcnn_py/main_onet.py</a>，批次大小设置为512，初始学习率0.01，权重衰减设置为4e-5，采用Adam优化器，学习率调整使用指数衰减策略，每代衰减95%，进行30代训练，得到权重文件<code>mtcnn_py/ckptdir/RNet.pkl</code>。</p><h2 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h2><p><img src="/2019/05/06/%E8%AF%A6%E7%BB%86%EF%BC%81MTCNN%E8%AE%AD%E7%BB%83%E5%85%A8%E8%BF%87%E7%A8%8B%EF%BC%81/详细！MTCNN训练全过程！/3.jpg" alt="3"></p><h1 id="转C语言"><a href="#转C语言" class="headerlink" title="转C语言"></a>转C语言</h1><p>C语言框架使用的是<a href="https://github.com/pjreddie/darknet" target="_blank" rel="noopener">darknet</a>，我对它进行了一些修改，在<a href="https://github.com/isLouisHsu/DarkerNet" target="_blank" rel="noopener">isLouisHsu/DarkerNet</a>，安装使用说明在仓库文档说明。</p><p>运行<a href="https://github.com/isLouisHsu/MTCNN_Darknet/blob/master/mtcnn_py/extract_weights.py" target="_blank" rel="noopener">mtcnn_py/extract_weights.py</a>生成权重<code>mtcnn_c/weights/*.weights</code>，运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd mtcnn_c/</span><br><span class="line">mkdir build &amp;&amp; cd build</span><br><span class="line">cmake .. &amp;&amp; make</span><br><span class="line">cd ..</span><br><span class="line">./mtcnn -h</span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://arxiv.org/abs/1604.02878" target="_blank" rel="noopener">Joint Face Detection and Alignment using Multi-task Cascaded Convolutional Networks - arXiv</a></li><li><a href="https://github.com/kpzhang93/MTCNN_face_detection_alignment" target="_blank" rel="noopener">kpzhang93/MTCNN_face_detection_alignment - Github</a></li><li><a href="https://github.com/AITTSMD/MTCNN-Tensorflow" target="_blank" rel="noopener">AITTSMD/MTCNN-Tensorflow - Github</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Face Detection: MTCNN</title>
      <link href="/2019/05/05/Face-Detection-MTCNN/"/>
      <url>/2019/05/05/Face-Detection-MTCNN/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>MTCNN即Multi-task Cascaded Convolutional Networks，利用深度学习方法进行人脸识别、检测与关键点定位，可谓结合机器视觉领域三大任务为一体。</p><p>该算法中，人脸检测与识别视作分类任务，即判别框内图像是否包含人脸；定位视作回归任务，共需确定7个坐标点，依次为：回归框左上、右下坐标，左眼、右眼、鼻尖、左嘴角、右嘴角坐标。</p><p>在设计损失函数时，分类任务采用交叉熵<code>(Cross Entropy)</code>，回归任务采用均方误差<code>(MSE)</code>，并且三个任务的损失，可给定不同的系数进行网络训练，使各网络侧重点不同，即<code>PNet</code>与<code>RNet</code>侧重于人脸识别与回归框定位，<code>ONet</code>侧重于关键点定位。</p><h1 id="算法对比"><a href="#算法对比" class="headerlink" title="算法对比"></a>算法对比</h1><p><img src="/2019/05/05/Face-Detection-MTCNN/detect_algorithm.jpg" alt="detect_algorithm"></p><h1 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h1><p>共设计3个卷积网络，每个网络均可输出识别概率(1)、回归框坐标(2×2)、关键点坐标(5×2)，三个网络级联以获得良好的预测结果。各网络结构图如下</p><p><img src="/2019/05/05/Face-Detection-MTCNN/mtcnn.png" alt="mtcnn"></p><p>分类任务输出层可采用<code>softmax</code>，即视作多分类任务；或者采用<code>sigmoid</code>，视作二分类任务。</p><h2 id="1-P-Net：-Proposal-Network"><a href="#1-P-Net：-Proposal-Network" class="headerlink" title="1. P-Net： Proposal Network"></a>1. P-Net： Proposal Network</h2><p>检测任务比较重要的一步是产生数目足够多的候选框，<code>PNet</code>设计全卷积网络，可接受任意大小的图片输入，利用输出的特征图生成候选框，具体生成算法在检测算法中说明。该网络在训练时接受$12×12×3$的图像输入，各层参数如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">layer     filters    size           input                output</span><br><span class="line">0 conv      10      3 x 3 &#x2F; 1    12 x  12 x   3   -&gt;    10 x  10 x  10  0.000 BFLOPs</span><br><span class="line">1 max               2 x 2 &#x2F; 2    10 x  10 x  10   -&gt;     5 x   5 x  10</span><br><span class="line">2 conv      16      3 x 3 &#x2F; 1     5 x   5 x  10   -&gt;     3 x   3 x  16  0.000 BFLOPs</span><br><span class="line">3 conv      32      3 x 3 &#x2F; 1     3 x   3 x  16   -&gt;     1 x   1 x  32  0.000 BFLOPs</span><br><span class="line">4 conv      15      1 x 1 &#x2F; 1     1 x   1 x  32   -&gt;     1 x   1 x  15  0.000 BFLOPs</span><br></pre></td></tr></table></figure><h2 id="2-R-Net：-Refine-Network"><a href="#2-R-Net：-Refine-Network" class="headerlink" title="2. R-Net： Refine Network"></a>2. R-Net： Refine Network</h2><p><code>PNet</code>产生候选框后，将这些候选框内的图像数据分割并缩放到统一大小，输入到<code>RNet</code>改善识别结果。该网络最后增加全连接层，仅接受$24×24×3$的图像输入，各层参数如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">layer     filters    size           input                output</span><br><span class="line">0 conv     28       3 x 3 &#x2F; 1    24 x  24 x   3   -&gt;    22 x  22 x  28  0.001 BFLOPs</span><br><span class="line">1 max               3 x 3 &#x2F; 2    22 x  22 x  28   -&gt;    11 x  11 x  28</span><br><span class="line">2 conv     48       3 x 3 &#x2F; 1    11 x  11 x  28   -&gt;     9 x   9 x  48  0.002 BFLOPs</span><br><span class="line">3 max               3 x 3 &#x2F; 2     9 x   9 x  48   -&gt;     4 x   4 x  48</span><br><span class="line">4 conv     64       2 x 2 &#x2F; 1     4 x   4 x  48   -&gt;     3 x   3 x  64  0.000 BFLOPs</span><br><span class="line">5 connected                                 576   -&gt;               128</span><br><span class="line">6 connected                                 128   -&gt;                15</span><br></pre></td></tr></table></figure><h2 id="3-O-Net：-Output-Network"><a href="#3-O-Net：-Output-Network" class="headerlink" title="3. O-Net： Output Network"></a>3. O-Net： Output Network</h2><p>该网络功能与<code>RNet</code>相同，不同的是分辨率更高，网络层次更深，且训练过程中，损失的设置更偏重于关键点的回归。接受$48×48×3$的图像输入，各层参数如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">layer     filters    size              input                output</span><br><span class="line">0 conv     32       3 x 3 &#x2F; 1    48 x  48 x   3   -&gt;    46 x  46 x  32  0.004 BFLOPs</span><br><span class="line">1 max               3 x 3 &#x2F; 2    46 x  46 x  32   -&gt;    23 x  23 x  32</span><br><span class="line">2 conv     64       3 x 3 &#x2F; 1    23 x  23 x  32   -&gt;    21 x  21 x  64  0.016 BFLOPs</span><br><span class="line">3 max               3 x 3 &#x2F; 2    21 x  21 x  64   -&gt;    10 x  10 x  64</span><br><span class="line">4 conv     64       3 x 3 &#x2F; 1    10 x  10 x  64   -&gt;     8 x   8 x  64  0.005 BFLOPs</span><br><span class="line">5 max               2 x 2 &#x2F; 2     8 x   8 x  64   -&gt;     4 x   4 x  64</span><br><span class="line">6 conv    128       2 x 2 &#x2F; 1     4 x   4 x  64   -&gt;     3 x   3 x 128  0.001 BFLOPs</span><br><span class="line">7 connected                                1152   -&gt;               256</span><br><span class="line">8 connected                                 256   -&gt;                15</span><br></pre></td></tr></table></figure><h1 id="训练数据"><a href="#训练数据" class="headerlink" title="训练数据"></a>训练数据</h1><h2 id="1-数据集"><a href="#1-数据集" class="headerlink" title="1. 数据集"></a>1. 数据集</h2><ul><li><p>人脸检测<br>  <a href="http://mmlab.ie.cuhk.edu.hk/projects/WIDERFace/" target="_blank" rel="noopener">WIDER FACE</a>是目前最常用的训练集，也是目前最大的公开训练集，人工标注的风格比较友好，适合训练。总共32203图像，393703标注人脸，目前难度最大，各种难点比较全面：尺度，姿态，遮挡，表情，化妆，光照等。</p><p>  <a href="http://mmlab.ie.cuhk.edu.hk/projects/WIDERFace/" target="_blank" rel="noopener">WIDER FACE</a>有以下特点：</p><ul><li>图像分辨率普遍偏高，所有图像的宽都缩放到1024，最小标注人脸10*10，都是彩色图像；</li><li>每张图像的人脸数据偏多，平均12.2人脸/图，密集小人脸非常多；</li><li>分训练集train/验证集val/测试集test，分别占40%/10%/50%，而且测试集的标注结果(ground truth)没有公开，需要提交结果给官方比较，更加公平公正，而且测试集非常大，结果可靠性极高；</li><li>根据EdgeBox的检测率情况划分为三个难度等级：Easy, Medium, Hard。</li></ul></li></ul><p><img src="/2019/05/05/Face-Detection-MTCNN/detect_demo.png" alt="detect_demo"></p><ul><li><p>关键点定位<br>  <a href="http://mmlab.ie.cuhk.edu.hk/archive/CNN_FacePoint.htm" target="_blank" rel="noopener">CNN FACE POINT</a>，包含5个关键点位置。</p><blockquote><p>Training set: <a href="http://mmlab.ie.cuhk.edu.hk/archive/CNN/data/train.zip" target="_blank" rel="noopener">Download</a><br>  It contains 5,590 LFW images and 7,876 other images downloaded from the web. The training set and validation set are defined in trainImageList.txt and testImageList.txt, respectively. Each line of these text files starts with the image name, followed by the boundary positions of the face bounding box retured by our face detector, then followed by the positions of the five facial points.<br>Testing set: <a href="http://mmlab.ie.cuhk.edu.hk/archive/CNN/data/test.zip" target="_blank" rel="noopener">Download</a><br>  It contains the 1,521 BioID images, 781 LFPW training images, and 249 LFPW test images used in our testing, together with the text files recording the boundary positions of the face bounding box retured by our face detector for each dataset. A few images that our face detector failed are not listed in the text files. LFPW images are renamed for the convenience of processing.</p></blockquote><p>  <img src="/2019/05/05/Face-Detection-MTCNN/landmark_demo.png" alt="landmark_demo"></p></li></ul><h2 id="2-训练数据生成"><a href="#2-训练数据生成" class="headerlink" title="2. 训练数据生成"></a>2. 训练数据生成</h2><p>采用了<code>Hard Example Mining</code>，后一网络的训练数据由前一网络结果生成，即先用训练好的前一网络进行数据评估，在评分较低、难以检测的数据中继续采样。在生成数据时，使用数据增广。</p><p>七个关键点坐标转换为偏移量<code>(offset)</code>，使其不受图像缩放影响，且数值较小便于网络收敛，计算方法如下</p><p><img src="/2019/05/05/Face-Detection-MTCNN/offsets.jpg" alt="offsets"></p><ul><li><p>Bounding Box</p><script type="math/tex; mode=display">  offset_{x_1'} = \frac{x_1' - x_1}{size}</script><script type="math/tex; mode=display">  offset_{x_2'} = \frac{x_2' - x_2}{size}</script><ul><li>$y_n$同$x_n$;</li><li>$(x_1, y_1)$表示左上角点位置，$(x_2, y_2)$表示右下角点位置;</li><li>$(x_1’, y_1’)$表示<code>ground true</code>矩形方框位置;</li><li>$size$表示方形回归框边长，即$size = x_2 - x_1 = y_2 - y_1$;</li></ul></li><li><p>Landmark<br>  均以<strong>正方形回归框左上方点</strong>坐标作为基准</p><script type="math/tex; mode=display">  offset_{x_n''} = \frac{x_n'' - x_1}{size}</script><script type="math/tex; mode=display">  offset_{y_n''} = \frac{y_n'' - y_1}{size}</script><ul><li>$(x_n’’, y_n’’)$表示五个关键点坐标;</li><li>$(x_1’, y_1’)$表示回归框左上角点位置;</li><li>$size$表示方形回归框边长，即$size = x_2 - x_1 = y_2 - y_1$;</li></ul></li></ul><p>根据<code>groudtruth</code>随机偏移和旋转，切割人脸数据，根据<code>iou</code>评分，共记作3种标签的样本，其标签分别为</p><ul><li><p><code>Positive(1)</code>:<br>  $iou &gt; 0.65$，其数据格式样例如下</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx&#x2F;positive&#x2F;404031.jpg 1.0 0.18 -0.09 0.15 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0</span><br></pre></td></tr></table></figure></li><li><p><code>Negative(0)</code>:<br>  $iou &lt; 0.3$，其数据格式样例如下</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx&#x2F;negative&#x2F;92073.jpg 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0</span><br></pre></td></tr></table></figure></li><li><p><code>Part(-1)</code>:<br>  $0.4 \leq iou \leq 0.65$，其数据格式样例如下</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx&#x2F;part&#x2F;749569.jpg -1.0 -0.04 0.07 -0.15 0.36 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0</span><br></pre></td></tr></table></figure></li><li><p>此外，关键点数据标签记作<code>Landmark(-2)</code>，其数据格式样例如下</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx&#x2F;train_PNet_landmark_aug&#x2F;4.jpg -2.0 0.0 0.0 0.0 0.0 0.24367088607594936 0.17405063291139242 0.7563291139240507 0.2310126582278481 0.48417721518987344 0.6170886075949367 0.2310126582278481 0.8069620253164557 0.6677215189873418 0.8575949367088608</span><br></pre></td></tr></table></figure></li></ul><h1 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h1><h2 id="1-Classification-loss"><a href="#1-Classification-loss" class="headerlink" title="1. Classification loss"></a>1. Classification loss</h2><p>人脸识别为分类任务，采用二分类交叉熵损失函数，即</p><script type="math/tex; mode=display">L^{(i)}_{cls} = - y^{(i)} \log (p^{(i)}) - (1 - y^{(i)}) \log (1 - p^{(i)})</script><p>注意，在计算分类损失时，将<code>Negative(0)</code>, <code>Part(-1)</code>, <code>Landmark(-2)</code>标签均视作<code>0</code>。</p><h2 id="2-Regression-loss"><a href="#2-Regression-loss" class="headerlink" title="2. Regression loss"></a>2. Regression loss</h2><p>回归任务，采用最小方差准则，即</p><script type="math/tex; mode=display">L^{(i)}_{bbox} = \frac{1}{4} \sum_{j=1}^4 (pred^{(i)}_j - gt^{(i)}_j)^2</script><script type="math/tex; mode=display">L^{(i)}_{landmark} = \frac{1}{10} \sum_{j=1}^{10} (pred^{(i)}_j - gt^{(i)}_j)^2</script><p>注意，在计算回归框损失时，仅对<code>Positive(1)</code>, <code>Part(-1)</code>样本进行，计算关键点损失时，仅对<code>Landmark(-2)</code>样本进行。</p><h2 id="3-OHEM"><a href="#3-OHEM" class="headerlink" title="3. OHEM"></a>3. OHEM</h2><p><code>OHEM</code>即<code>Online Hard Example Mining</code>，在线硬样本数据挖掘，即对于当前批次数据，计算损失时，选取总损失值最大的<code>k</code>个样本，计算其均值作为该批次的损失值。</p><h2 id="4-Total-Loss"><a href="#4-Total-Loss" class="headerlink" title="4. Total Loss"></a>4. Total Loss</h2><p>三个网络赋予各损失的系数不同， 使其偏重于其中某个任务</p><script type="math/tex; mode=display">L_{total} = \frac{1}{topk} \sum_{i=0}^{topk} coef_{cls} L^{(i)}_{cls} + coef_{bbox} L^{(i)}_{bbox} + coef_{landmark} L^{(i)}_{landmark}</script><p>其中$topk$即<code>OHEM</code>计算得到的样本数。</p><details><summary>PyTorch实现</summary><pre><code>class MtcnnLoss(nn.Module):    def __init__(self, cls, bbox, landmark, ohem=0.7):        super(MtcnnLoss, self).__init__()        self.cls = cls        self.bbox = bbox        self.landmark = landmark        self.ohem = ohem        self.bce = nn.BCEWithLogitsLoss(reduction='none')        self.mse = nn.MSELoss(reduction='none')    def forward(self, pred, gt):        """        Params:            pred:   {tensor(N, n) or tensor(N, n, 1, 1)}            gt:     {tensor(N, n)}        Notes:            y_true        """        N = pred.shape[0]        pred = pred.view(N, -1)        ## origin label        gt_labels = gt[:, 0]        ## pos -> 1, neg -> 0, others -> 0        pred_cls = pred[:, 0]        gt_cls = gt_labels.clone(); gt_cls[gt_labels!=1.0] = 0.0        loss_cls = self.bce(pred_cls, gt_cls)        # ohem        n_keep = int(self.ohem * loss_cls.shape[0])        loss_cls = torch.mean(torch.topk(loss_cls, n_keep)[0])        ## label=1 or label=-1 then do regression        idx = (gt_labels==1)^(gt_labels==-1)        pred_bbox = pred[idx, 1: 5]        gt_bbox = gt[idx, 1: 5]        loss_bbox = self.mse(pred_bbox, gt_bbox)        loss_bbox = torch.mean(loss_bbox, dim=1)        # ohem        n_keep = int(self.ohem * loss_bbox.shape[0])        loss_bbox = torch.mean(torch.topk(loss_bbox, n_keep)[0])            ## keep label =-2  then do landmark detection        idx = gt_labels==-2        pred_landmark = pred[idx, 5:]        gt_landmark = gt[idx, 5:]        loss_landmark = self.mse(pred_landmark, gt_landmark)        loss_landmark = torch.mean(loss_landmark, dim=1)        # ohem        n_keep = int(self.ohem * loss_landmark.shape[0])        loss_landmark = torch.mean(torch.topk(loss_landmark, n_keep)[0])        ## total loss        loss_total = self.cls*loss_cls + self.bbox*loss_bbox + self.landmark*loss_landmark        return loss_total, loss_cls, loss_bbox, loss_landmarkloss_coef = {    'PNet': [1.0, 0.5, 0.5],    'RNet': [1.0, 0.5, 0.5],    'ONet': [1.0, 0.5, 1.0],}</code></pre></details><h1 id="检测算法"><a href="#检测算法" class="headerlink" title="检测算法"></a>检测算法</h1><p>检测算法以功能区分，主要分成两个部分：候选框生成与候选框筛除。</p><h2 id="1-候选框生成"><a href="#1-候选框生成" class="headerlink" title="1. 候选框生成"></a>1. 候选框生成</h2><p><img src="/2019/05/05/Face-Detection-MTCNN/pnet1.jpg" alt="pnet1"></p><p><img src="/2019/05/05/Face-Detection-MTCNN/pnet2.jpg" alt="pnet2"></p><p><img src="/2019/05/05/Face-Detection-MTCNN/pnet_gen_box.jpg" alt="pnet_gen_box"></p><p>该步骤使用的网络为<code>PNet</code>。指定超参数<code>minface</code>，对于任意尺寸输入的图像<code>H × W</code>，先将其缩放</p><script type="math/tex; mode=display">H_c = H × \frac{12}{minface}</script><script type="math/tex; mode=display">W_c = W × \frac{12}{minface}</script><p>指定超参数<code>factor</code>，更新缩小尺度，将图片缩小，在每个尺度上进行计算，即</p><script type="math/tex; mode=display">H_c := H_c × factor</script><script type="math/tex; mode=display">W_c := W_c × factor</script><p>对于某一尺度下的图片得到的运算特征图，</p><script type="math/tex; mode=display">Feat_{h×w×15} = PNet(input)</script><p>提取其分类层输出特征图$Feat_{cls}$，设定阈值<code>thresh</code>，对于大于阈值的点，按下式生成候选框</p><script type="math/tex; mode=display">x_1 = stride × i × \frac{1}{scale}</script><script type="math/tex; mode=display">y_1 = stride × j × \frac{1}{scale}</script><script type="math/tex; mode=display">x_2 = x_1 + \frac{cellsize}{scale}</script><script type="math/tex; mode=display">y_2 = y_1 + \frac{cellsize}{scale}</script><p>其中<code>cellsize</code>为超参数，一般指定为<code>cellsize=12</code></p><h2 id="2-候选框筛除"><a href="#2-候选框筛除" class="headerlink" title="2. 候选框筛除"></a>2. 候选框筛除</h2><p><img src="/2019/05/05/Face-Detection-MTCNN/rnet.jpg" alt="rnet"></p><p>改步使用网络<code>PNet</code>与<code>ONet</code>，依次对上一层网络进行<code>refine</code>，计算方法一致。</p><ul><li>获取上一层网络输出回归框，截取图片中相应位置的图像数据，并缩放到对应尺寸；</li><li>前向计算，得到特征输出；</li><li>设定阈值，只保留分类评估大于阈值的结果；</li><li>对剩余结果进行<code>NMS</code>，输出结果；</li></ul><h2 id="3-NMS"><a href="#3-NMS" class="headerlink" title="3. NMS"></a>3. NMS</h2><p><img src="/2019/05/05/Face-Detection-MTCNN/nms.jpg" alt="nms"></p><p>例如，有中三个候选框a, b, c，其评分依次为0.8, 0.7, 0.9，设定NMS阈值</p><script type="math/tex; mode=display">thresh=0.4</script><ol><li>先将其排序，以降序排序为c, a, b；</li><li>保存当前评分最高的回归框，即c；</li><li><p>计算c与a, b的IoU，计算方法如下</p><p> <img src="/2019/05/05/Face-Detection-MTCNN/iou.jpg" alt="iou"></p><script type="math/tex; mode=display"> IoU = \frac{Intersection}{Union}</script><p> 其中</p><script type="math/tex; mode=display"> Intersection = w_{inter} × h_{inter}</script><script type="math/tex; mode=display"> w_{inter} = \min (x^a_2, x^b_2) - \max (x^a_1, x^b_1)</script><script type="math/tex; mode=display"> h_{inter} = \min (y^a_2, y^b_2) - \max (y^a_1, y^b_1)</script><p> 而</p><script type="math/tex; mode=display"> Union = Area_a + Area_b - Intersection</script></li><li><p>则c与a, b的IoU为</p><script type="math/tex; mode=display"> IoU_{a,c} = \frac{1×8}{10×9+9×11-1×8}=0.044</script><script type="math/tex; mode=display"> IoU_{a,b} = \frac{4×6}{10×9+10×11-4×6}=0.136</script><p> 均小于阈值，故无框被删除。</p></li><li><p>保存当前评分最高的回归框，即a；</p></li><li><p>计算a与b的IoU</p><script type="math/tex; mode=display"> IoU_{a,b} = \frac{7×9}{9×11+10×11-7×9} = 0.432</script><p> 大于阈值，删除候选框b</p></li><li>最终保留a，c。</li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>详情查看<a href="https://github.com/isLouisHsu/MTCNN_Darknet/tree/master/torch_mtcnn/detector.py" target="_blank" rel="noopener">isLouisHsu/MTCNN_Darknet/torch_mtcnn/detector.py - Github</a>。</p><h1 id="附：利用关键点进行图像对齐"><a href="#附：利用关键点进行图像对齐" class="headerlink" title="附：利用关键点进行图像对齐"></a>附：利用关键点进行图像对齐</h1><ol><li><p>变换矩阵$M$的求解<br> 例如现有$n$个关键点</p><script type="math/tex; mode=display"> xy = \left[\begin{matrix}     x_1 & y_1 \\     x_2 & y_2 \\     ... & ... \\     x_n & y_n \\ \end{matrix}\right]</script><p> 希望对齐后的坐标点为</p><script type="math/tex; mode=display"> \hat{xy} = \left[\begin{matrix}     \hat{x_1} & \hat{y_1} \\     \hat{x_2} & \hat{y_2} \\     ...  & ...  \\     \hat{x_n} & \hat{y_n} \\ \end{matrix}\right]</script><p> 构造矩阵</p><script type="math/tex; mode=display"> X_{2n\times4} = \left[\begin{matrix}     \vec{x} &  \vec{y} & \vec{1} & \vec{0} \\     \vec{y} & -\vec{x} & \vec{0} & \vec{1} \end{matrix}\right]</script><script type="math/tex; mode=display"> b_{2n} = \left[\begin{matrix}     \hat{x_1} & \hat{x_2} & \cdots & \hat{x_n} &     \hat{y_1} & \hat{y_2} & \cdots & \hat{y_n} \end{matrix}\right]^T</script><p> 其中</p><script type="math/tex; mode=display"> \vec{x} = \left[\begin{matrix}     x_1 & x_2 & \cdots & x_n \end{matrix}\right]^T</script><script type="math/tex; mode=display"> \vec{y} = \left[\begin{matrix}     y_1 & y_2 & \cdots & y_n \end{matrix}\right]^T</script><script type="math/tex; mode=display"> \vec{1} = \left[\begin{matrix}     1 & 1 & \cdots & 1 \end{matrix}\right]^T</script><script type="math/tex; mode=display"> \vec{0} = \left[\begin{matrix}     0 & 0 & \cdots & 0 \end{matrix}\right]^T</script><p> 求解下式解向量$r_{4\times1}$</p><script type="math/tex; mode=display"> X \cdot r = b</script><p> 注意增广矩阵的秩</p><script type="math/tex; mode=display">\text{rank}(X) < rank([X | b])</script><p> 上式无解，可使用伪逆求解</p><script type="math/tex; mode=display"> r = (X^T X + \lambda I)^{-1} X^T b</script><p> 构造矩阵</p><script type="math/tex; mode=display"> R = \left[\begin{matrix}     r_1 & -r_2 & 0 \\     r_2 &  r_1 & 0 \\     r_3 & -r_4 & 1 \\ \end{matrix}\right]</script><p> 则变换矩阵$M$可由下式求解</p><script type="math/tex; mode=display"> \left[\begin{matrix}     M^T & \begin{matrix}         0 \\ 0 \\ 1     \end{matrix} \end{matrix}\right] = R^{-1}</script><p> 即$M$为$R^{-1}$的前两列。</p></li><li><p>坐标变换</p><script type="math/tex; mode=display"> M = \left[\begin{matrix}     m_{11} & m_{12} & m_{13} \\ m_{21} & m_{22} & m_{23} \end{matrix}\right]</script><p> 对于坐标$(x, y)$，其变换后的坐标$(\hat{x}, \hat{y})$为</p><script type="math/tex; mode=display"> \left[\begin{matrix}     \hat{x} \\ \hat{y} \\ \end{matrix}\right] = M \left[\begin{matrix}     x \\ y \\ 1 \end{matrix}\right]</script></li></ol><p>几个关键的函数，C/C++实现如下，详情可查看<a href="https://github.com/isLouisHsu/MobileFaceNet_Darknet/blob/master/src/cp2form.c" target="_blank" rel="noopener">isLouisHsu/MobileFaceNet_Darknet/src/cp2form.c</a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * @param</span></span><br><span class="line"><span class="comment"> *      uv: [u, v]， Nx2</span></span><br><span class="line"><span class="comment"> *      xy: [x, y]， Nx2</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> * @notes</span></span><br><span class="line"><span class="comment"> * -    Xr = Y   ===&gt;  r = (X^T X + \lambda I)^&#123;-1&#125; X^T Y</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CvMat* _findNonreflectiveSimilarity(<span class="keyword">const</span> CvMat* uv, <span class="keyword">const</span> CvMat* xy)</span><br><span class="line">&#123;</span><br><span class="line">    CvMat* X = _stitch(xy);                         <span class="comment">// 2N x  4</span></span><br><span class="line"></span><br><span class="line">    CvMat* XT = cvCreateMat(X-&gt;cols, X-&gt;rows, CV_32F);  </span><br><span class="line">    cvTranspose(X, XT);                             <span class="comment">//  4 x 2N</span></span><br><span class="line"></span><br><span class="line">    CvMat* XTX = cvCreateMat(XT-&gt;rows, X-&gt;cols, CV_32F);</span><br><span class="line">    cvMatMul(XT, X, XTX);                           <span class="comment">//  4 x  4</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; XTX-&gt;rows; i++) XTX-&gt;data.fl[i*XTX-&gt;rows + i] += <span class="number">1e-15</span>;</span><br><span class="line"></span><br><span class="line">    CvMat* XTXi = cvCreateMat(XTX-&gt;rows, XTX-&gt;cols, CV_32F); </span><br><span class="line">    cvInvert(XTX, XTXi, CV_LU);                     <span class="comment">//  4 x  4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -----------------------------------------------------------------------</span></span><br><span class="line">    </span><br><span class="line">    CvMat* uvT = cvCreateMat(uv-&gt;cols, uv-&gt;rows, CV_32F); </span><br><span class="line">    cvTranspose(uv, uvT);                           <span class="comment">//  2 x  N</span></span><br><span class="line">    CvMat header; </span><br><span class="line">    CvMat* YT = cvReshape(uvT, &amp;header, <span class="number">0</span>, <span class="number">1</span>);      <span class="comment">//  1 x 2N    TODO</span></span><br><span class="line">    CvMat* Y = cvCreateMat(YT-&gt;cols, YT-&gt;rows, CV_32F);  </span><br><span class="line">    cvTranspose(YT, Y);                             <span class="comment">// 2N x  1</span></span><br><span class="line">    </span><br><span class="line">    CvMat* XTXiXT = cvCreateMat(XTXi-&gt;rows, XT-&gt;cols, CV_32F);</span><br><span class="line">    CvMat* r = cvCreateMat(XTXiXT-&gt;rows, Y-&gt;cols, CV_32F);</span><br><span class="line">    cvMatMul(XTXi, XT, XTXiXT); cvMatMul(XTXiXT, Y, r);       <span class="comment">//  4 x  1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -----------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    cvReleaseMat(&amp;X); cvReleaseMat(&amp;XT); </span><br><span class="line">    cvReleaseMat(&amp;XTX); cvReleaseMat(&amp;XTXi); cvReleaseMat(&amp;XTXiXT);</span><br><span class="line">    cvReleaseMat(&amp;uvT); cvReleaseMat(&amp;Y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =======================================================================</span></span><br><span class="line"></span><br><span class="line">    CvMat* R = cvCreateMat(<span class="number">3</span>, <span class="number">3</span>, CV_32F);</span><br><span class="line">    R-&gt;data.fl[<span class="number">0</span> * <span class="number">3</span> + <span class="number">0</span>] = r-&gt;data.fl[<span class="number">0</span>]; R-&gt;data.fl[<span class="number">0</span> * <span class="number">3</span> + <span class="number">1</span>] = -r-&gt;data.fl[<span class="number">1</span>]; R-&gt;data.fl[<span class="number">0</span> * <span class="number">3</span> + <span class="number">2</span>] = <span class="number">0.</span>;</span><br><span class="line">    R-&gt;data.fl[<span class="number">1</span> * <span class="number">3</span> + <span class="number">0</span>] = r-&gt;data.fl[<span class="number">1</span>]; R-&gt;data.fl[<span class="number">1</span> * <span class="number">3</span> + <span class="number">1</span>] =  r-&gt;data.fl[<span class="number">0</span>]; R-&gt;data.fl[<span class="number">1</span> * <span class="number">3</span> + <span class="number">2</span>] = <span class="number">0.</span>;</span><br><span class="line">    R-&gt;data.fl[<span class="number">2</span> * <span class="number">3</span> + <span class="number">0</span>] = r-&gt;data.fl[<span class="number">2</span>]; R-&gt;data.fl[<span class="number">2</span> * <span class="number">3</span> + <span class="number">1</span>] =  r-&gt;data.fl[<span class="number">3</span>]; R-&gt;data.fl[<span class="number">2</span> * <span class="number">3</span> + <span class="number">2</span>] = <span class="number">1.</span>;</span><br><span class="line">    </span><br><span class="line">    CvMat* Ri = cvCreateMat(R-&gt;cols, R-&gt;rows, CV_32F);</span><br><span class="line">    cvInvert(R, Ri, CV_LU);</span><br><span class="line"></span><br><span class="line">    CvMat* MT = cvCreateMat(<span class="number">3</span>, <span class="number">2</span>, CV_32F);</span><br><span class="line">    cvGetSubRect(Ri, MT, cvRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    </span><br><span class="line">    CvMat* M = cvCreateMat(MT-&gt;cols, MT-&gt;rows, CV_32F);</span><br><span class="line">    cvTranspose(MT, M);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -----------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    cvReleaseMat(&amp;r); cvReleaseMat(&amp;R); cvReleaseMat(&amp;Ri); cvReleaseMat(&amp;MT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * @param</span></span><br><span class="line"><span class="comment"> *      uv: [u, v]， Nx2</span></span><br><span class="line"><span class="comment"> *      xy: [x, y]， Nx2</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> * @notes</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CvMat* _findReflectiveSimilarity(<span class="keyword">const</span> CvMat* uv, <span class="keyword">const</span> CvMat* xy)</span><br><span class="line">&#123;</span><br><span class="line">    CvMat* xyR = cvCloneMat(xy);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; xyR-&gt;rows; r++) xyR-&gt;data.fl[r*xyR-&gt;cols] *= <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    CvMat* M1 = _findNonreflectiveSimilarity(uv, xy);</span><br><span class="line">    CvMat* M2 = _findNonreflectiveSimilarity(uv, xyR);</span><br><span class="line"></span><br><span class="line">    cvReleaseMat(&amp;xyR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; M2-&gt;rows; r++) M2-&gt;data.fl[r*M2-&gt;cols] *= <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    CvMat* xy1 = _tformfwd(M1, uv);</span><br><span class="line">    CvMat* xy2 = _tformfwd(M2, uv);</span><br><span class="line">    cvSub(xy1, xy, xy1, <span class="literal">NULL</span>); cvSub(xy2, xy, xy2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> norm1 = _matrixNorm2(xy1);</span><br><span class="line">    <span class="keyword">float</span> norm2 = _matrixNorm2(xy2);</span><br><span class="line"></span><br><span class="line">    cvReleaseMat(&amp;xy1); cvReleaseMat(&amp;xy2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (norm1 &lt; norm2)&#123;</span><br><span class="line">        cvReleaseMat(&amp;M2);</span><br><span class="line">        <span class="keyword">return</span> M1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cvReleaseMat(&amp;M1);</span><br><span class="line">        <span class="keyword">return</span> M2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://arxiv.org/abs/1604.02878" target="_blank" rel="noopener">Joint Face Detection and Alignment using Multi-task Cascaded Convolutional Networks</a></li><li><a href="https://github.com/kpzhang93/MTCNN_face_detection_alignment" target="_blank" rel="noopener">kpzhang93/MTCNN_face_detection_alignment</a></li><li><a href="https://github.com/AITTSMD/MTCNN-Tensorflow" target="_blank" rel="noopener">AITTSMD/MTCNN-Tensorflow</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>无所畏</title>
      <link href="/2019/04/30/%E6%97%A0%E6%89%80%E7%95%8F/"/>
      <url>/2019/04/30/%E6%97%A0%E6%89%80%E7%95%8F/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/04/30/%E6%97%A0%E6%89%80%E7%95%8F/无所畏/1.jpg" alt="1"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>世间没有佛，但是有带着佛性的人。</p><h1 id="精选"><a href="#精选" class="headerlink" title="精选"></a>精选</h1><h2 id="壹-成功十要素"><a href="#壹-成功十要素" class="headerlink" title="壹 成功十要素"></a>壹 成功十要素</h2><center>一命二运三风水<br>四积阴德五读书<br>六名七相八敬神<br>九交贵人十养生<br></center><ol><li>曾几何时，我们除了未来一无所有，我们充满好奇，我们有使不完的力气，我们不怕失去，我们眼里有光，我们为建设祖国而读书，我们下身肿胀，我们激素吱吱作响，我们热爱姑娘，我们万物生长。</li><li><p>如何避免成为油腻中年男</p><ul><li>不要成为胖子，曾经玉树临风，现在风狂树残；</li><li>不要停止学习，吹牛能让我们有瞬间快感，但不能改变我们对一些事物所知甚少的事实；</li><li>不要待着不动，说走就走，去散步，去旅行，也好；</li><li>不要当众谈性，关于眼神(盯着女生看)的告诫，也适用于权、钱等其他领域；</li><li>不要追忆从前，积攒唠叨从前的力气，再创业，再创造，再恋爱，我们还能攻城略地，杀伐战取；</li><li>不要教育晚辈，不愤不启；</li><li>不要给别人添麻烦；</li><li>不要停止购物，完全没了欲望，失去对美好事物的贪心，生命也就没有乐趣；</li><li>不要脏兮兮，少年时代的脏是不羁，中年时代的脏是真脏；</li><li><p>不要鄙视和年龄无关的人类习惯，所有的世道变坏，都是从鄙视文艺开始的；</p><p>因为苦逼而牛逼，因为逗逼而二逼，因为装逼而傻逼。愿我们原理油腻和猥琐，敬爱女生，过好余生，让世界更美好。</p></li></ul></li><li><p>更可怕的是成为了油腻青年</p><ul><li>装懂，多学习，多研究，对真正热爱之事，真正投入精力，向那些可以就防晒美白详细说出八种不同方法的女性好好学习；</li><li>着急，“夫水之己也不厚，其负大舟也无力”；</li><li>逐利，只有对钱的热忱却没有理想，即使站在了风口，也不会成为那只“会飞的猪”；</li><li>不要迷恋肉身；</li><li>迷恋手机，比起摸不到心爱的姑娘的手，摸不到自己的手机似乎要严重百倍；</li><li>不靠谱，将来总有一天，你会明白，困境、死境都是自己曾经立起又自己放倒的目标；</li><li>不敢真，对爱的人不敢说“爱”，对不爽的事不敢说“不”，不敢承认自己的处境，不敢承认失败然后从头再来。时过境迁，回过头来，要拿真心对世界的时候，大抵已经找不到心在哪儿了；</li><li>假佛系，假装自己无欲无求，其实只是懒得追求，你就不厌倦自己吗？</li><li>审美差，如今担心会跟审美不好的人撞了女朋友的脸(整容)，哈哈哈哈；</li><li>不要“脸”，所谓“相由心生”，脸上的油光，就是心里的油渣；</li></ul></li><li><p>“极品”男人如何极致装逼</p><ul><li>写信，比如冯唐、比如曾巩；</li><li>跑步；</li><li>喝茶；</li><li>古物，从骨子里明白拥有只是暂时，“欣于所遇，暂得于己，快然自足”；</li><li>言语，极致地吹牛逼也是极致装逼的一种，立言也是立德、立功、立言三不朽的一种；</li><li>读书；</li><li>情怀，极致装逼如下，“为天地立心，为生民立命，为往圣继绝学，为万世开太平”；</li><li>喝酒，和好玩儿的人喝，喝完能背出很多唐诗和楚辞；</li><li>养生，高逼格的养生是乐生，是在乐生的基础上长生。我老爸抽烟，从十二岁开始抽，现在八十三岁了，他的口头禅是：“天亮了，又赚了。”</li><li><p>修佛，高逼格的修佛是在日常的劳作里、阳光里、花花草草里、众生皆苦里、生命终极无意义里，试图体会到蹦蹦跳跳的快活；</p><p>其实，如果志存高远，“三观”正，逼格正，装逼装久了，就是身、心、灵的一部分了。装逼装极致了，就得大成就了。装逼的过程就是学习的过程，就是感受活着的过程，就是实现理想的过程。</p></li></ul></li><li><p>那些爱我们或者爱过我们的女生，在她们的一生中要花很多时间陪护我们这些装腔犯，安静地、积极地、有创造力地陪我们装逼好多年。……。如果爱不在了，那就不用管上面说的一切了，让他找别的姑娘配他装逼陪他飞吧。</p></li><li><p>天天临深履薄，这辈子好惨，而且睡眠毁了、人毁了，也就什么都没了。我不想这样一辈子，我不想总梦见那些提心吊胆的事儿，我还想梦见我以前那些美丽的女朋友以及那些被梨花照过的时光，我提笔在笔记本的扉页上，郑重地写下了我的九字真言：“不着急，不害怕，不要脸。”</p><ul><li>对时间的态度：不着急。有时候，关切是不问；有时候，不做比做什么都强；</li><li>对结果的态度：不害怕；</li><li><p>对他评的态度：不要脸。“是非审之于己，毁誉听之于人，得失安之于数”；</p><blockquote><p>补充一点变成四点吧：不着急，不害怕，不要脸，不抱怨。</p></blockquote></li></ul></li><li><p>“这是最好的时代，这是最坏的时代；这是智慧的时代，这是愚蠢的时代；这是信仰的时期，这是怀疑的时期；这是光明的季节，这是黑暗的季节；这是希望之春，这是失望之冬；人们面前有着各样事物，人们面前一无所有；人们正在直登天堂，人们正在直下地狱。”</p></li><li>女生把自己整修得越来越像孪生姐妹，男生把自己禅修得越来越无聊。菜越来越没有菜味儿，肉越来越没有肉味儿，街上早就没有野花可以摘了，街上早就没有板砖可以拍了。</li><li>面对我们阻止不了的时代变化，多使用肉体，多去狂喜与伤心，多去创造，活出更多人样儿。</li><li>人类改变不了人性中的恶，创造完成后保护，保护不住后破坏，破坏后再创造，永陷轮回。</li><li>亲爱的，给我写首情诗好吗？越虐心越好。</li><li>降维攻击定义：你有道德我没道德，你死，我活；你我都是人你还要做人，我自降为禽兽，你死，我活。</li></ol><h2 id="贰-爱情如何对抗时间"><a href="#贰-爱情如何对抗时间" class="headerlink" title="贰 爱情如何对抗时间"></a>贰 爱情如何对抗时间</h2><center>女人还是要自强<br>不容易生病的身体<br>够用的收入<br>养心的爱好<br>强大到浑蛋的小宇宙</center><blockquote><p>男人同~</p></blockquote><ol><li>再过一些年，或许宇宙这盆火也会最终熄灭，世界彻底安静下来，时间也瘫倒在空间里，仿佛一只死狗瘫倒在地板上。</li><li>爱情大概始于一些及其美妙的刹那。……。在刹那间，希望时间停滞，甚至无疾而终，在刹那间，就此死去。……。幸或者不幸的是，人想死的时候很难死掉，梦幻泡影、闪电烟花之后，生活继续。爱情如何对抗那些璀璨一刹那之外的漫长时间？</li><li>你看他起高楼，你看他楼塌了。起高楼时，这个男的不一定能守得住底线；楼塌时，这个男的不一定能跑得了。</li><li>自己穿暖，才是真暖；自己真暖，才有资格相互温暖。</li><li>梦里三月桃花，二人一马。</li><li>身体极累的时候，心极伤的时候，身外有酒，白、黄、红，心里有姑娘，小鸟、小兽、小妖。白、黄、红流进身体，小鸟、小兽、小妖踏着云彩从心里溜达出来。身体更累，心更伤。风住了，风又起了。沿着伤口，就着酒，往下，再往下，潜水一样，掘井一样，运气好的时候，会看到世界里从来没有的景象。</li><li>男性在修炼成功之前(绝大多数在死前都没成功)，似乎总是有种不知进退而成为二逼的风险，过分执着到死拧，过分淡定到麻木，过分较真儿到迂腐，过分邋遢到鼻毛过唇。</li><li>只有克服了对于牛逼的过分追求，才能真正避免成为一个傻逼，特别是，随着年纪的增长，避免成为一个老傻逼。</li></ol><h2 id="叁-想起一生中后悔的事儿"><a href="#叁-想起一生中后悔的事儿" class="headerlink" title="叁 想起一生中后悔的事儿"></a>叁 想起一生中后悔的事儿</h2><center>只花时间给三类人：<br>好看的人，<br>好玩的人，<br>又好看又好玩的人。</center><ol><li>同样吃一串葡萄，有人先从最好的一颗吃起，好处时每次都吃到可得的最好的一颗；有人先从最差的一颗吃起，好处是每次都能吃到比之前更好的一颗。</li><li>前半生认识的朋友来看我，是因为想看我而来看我，而不是因为我在某大机构任职或者刚得了一个世界第一、宇宙无敌的文艺大奖。</li><li>一个人在二十岁之前呆过十年的地方，就是他真正的故乡。之后无论他活多久，去过多少地方，故乡都在骨头和血液里，挥之不去。</li><li>其实，人一起生活过一段时间，就没了生死的界限，除非彼此的爱意已经被彻底忘记。</li><li>我回到您面前，您总会给我一杯热茶，然后也不说话，手指一下，茶在那儿。您走了之后我才明白，一杯热茶之前，要有被子、茶、热水，要问很久、很多次：我儿子什么时候回来啊？</li><li>人皆草木不用成材。</li><li>万事都如甘蔗，哪有两头甜？</li><li>因为手写有人味儿。……。手写信，给心里真正放不下的人，贴张邮票，去邮局寄了。</li><li>连续七天，口袋里，书包里，我天天带着这只鸟(玉)，手没事儿的时候就摸着它，睡觉的时候也攥着。……。到了第八个晚上，一模那只鸟不见了。我的酒一下醒了，我把行李拆了，没有；我把全身衣服拆了，没有；我把房间拆了，没有；我沿着进房间的路，原路返回到下出租车的那块砖，没有。……。我度过了一个非常清醒、哲学而又精疲力竭的夜晚，和初恋分手的第一晚也比这一晚好过很多。……。我醒来的时候，觉得比睡着之前还要累。我洗把脸，阳光从窗帘缝隙间洒下来，那只玉鸟就安静地待在酒店书桌地一个角落，栖息在酒店的便笺上 —— 应该是我脱裤子之前无意识地把它放到了最安全的地方。……。如果我把那只玉鸟抓过来摔碎，我就成佛了。实际发生的是，在一刹那，我找了根结实的绳儿，穿过玉鸟翅膀上面古老的打眼儿，把玉鸟牢牢地栓在我裤子的皮带扣上。<blockquote><ol><li>人生喜悦，失而复得；</li><li>太过珍惜，却弄丢了，是人性的矛盾；</li><li>愿意被找到的东西，一直在那；不愿意被找到的东西，丢了就丢了把；</li><li>为外物而悲喜，这是人性的桎梏。</li></ol></blockquote></li></ol><h2 id="肆-天用云作字"><a href="#肆-天用云作字" class="headerlink" title="肆 天用云作字"></a>肆 天用云作字</h2><center>在此刻，天用云作字。<br>在未来某处，在未来某刻，<br>天也用我作字，<br>用我的手蘸着墨作字。</center><ol><li>你耐心再看看，再看看，再看看。</li><li>如果你有一个期望，长年挥之不去，而且需要别人来满足，这个期望就是妄念。</li><li>自责是负能量最大的一种情绪。<blockquote><p>任性是被低估的美德。</p></blockquote></li><li>“事情过去好久了，话也没啥可说的了，但是有时想起你，还是真他妈的难过啊。”</li><li><p>饮酒到微醺，脸红脖子粗，脚下多了一截弹簧，整个人一蹦一跳的，似乎手不抓牢栏杆，身体就随着灵魂飞离地面。</p><blockquote><p>饮酒的一个好处是，用肉的迷失换取灵的觉悟。放不下的、看不开的，几口下肚，眼清目明，仿佛都与自己无关了，不自觉地，脸上堆满了笑。</p></blockquote></li><li><p>看看就得了，不要临。字写得漂亮的人太多了，万一你写得漂亮了，再写丑就太难了，你就不是你了，老天给你手上的那一丁丁点独特的东西就没了。</p></li><li>佛界易入，魔界难入。佛界和魔界都入入，人更知道什么是佛、什么是魔，人更容易平衡一点儿，在世上能走的更远点儿。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 冯唐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[REPRODUCTION]A Recipe for Training Neural Networks</title>
      <link href="/2019/04/29/REPRODUCTION-A-Recipe-for-Training-Neural-Networks/"/>
      <url>/2019/04/29/REPRODUCTION-A-Recipe-for-Training-Neural-Networks/</url>
      
        <content type="html"><![CDATA[<p><strong>转载自<a href="http://karpathy.github.io" target="_blank" rel="noopener">Andrej Karpathy blog</a></strong></p><h2 id="The-recipe"><a href="#The-recipe" class="headerlink" title="The recipe"></a>The recipe</h2><p>In light of the above two facts, I have developed a specific process for myself that I follow when applying a neural net to a new problem, which I will try to describe. You will see that it takes the two principles above very seriously. In particular, it builds from simple to complex and at every step of the way we make concrete hypotheses about what will happen and then either validate them with an experiment or investigate until we find some issue. What we try to prevent very hard is the introduction of a lot of “unverified” complexity at once, which is bound to introduce bugs/misconfigurations that will take forever to find (if ever). If writing your neural net code was like training one, you’d want to use a very small learning rate and guess and then evaluate the full test set after every iteration.</p><h4 id="1-Become-one-with-the-data"><a href="#1-Become-one-with-the-data" class="headerlink" title="1. Become one with the data"></a>1. Become one with the data</h4><p>The first step to training a neural net is to not touch any neural net code at all and instead begin by <u>thoroughly inspecting your data</u>. This step is critical. I like to spend copious amount of time (measured in units of hours) scanning through thousands of examples, understanding their distribution and looking for patterns. Luckily, your brain is pretty good at this. One time I discovered that the data contained duplicate examples. Another time I found corrupted images / labels. I look for data imbalances and biases. I will typically also pay attention to my own process for classifying the data, which hints at the kinds of architectures we’ll eventually explore. As an example - are very local features enough or do we need global context? How much variation is there and what form does it take? What variation is spurious and could be preprocessed out? Does spatial position matter or do we want to average pool it out? How much does detail matter and how far could we afford to downsample the images? How noisy are the labels?</p><blockquote><ol><li>data contained duplicate examples</li><li>corrupted images &amp; labels</li><li>data imbalances and biases</li><li>local features v.s. global context</li><li>quantity &amp; form of variation</li><li>preprocess out some variation</li><li>spatial position v.s. average pool</li><li>detail v.s. downsample</li><li>labels are noisy?</li></ol></blockquote><p>In addition, since the neural net is effectively a compressed/compiled version of your dataset, you’ll be able to <u>look at your network (mis)predictions and understand where they might be coming from</u>. And if your network is giving you some prediction that doesn’t seem consistent with what you’ve seen in the data, something is off.</p><p>Once you get a qualitative sense it is also a good idea to write some simple code to <u>search/filter/sort by whatever you can think of (e.g. type of label, size of annotations, number of annotations, etc.) and visualize their distributions and the outliers along any axis.</u> The outliers especially almost always uncover some bugs in data quality or preprocessing.</p><h4 id="2-Set-up-the-end-to-end-training-evaluation-skeleton-get-dumb-baselines"><a href="#2-Set-up-the-end-to-end-training-evaluation-skeleton-get-dumb-baselines" class="headerlink" title="2. Set up the end-to-end training/evaluation skeleton + get dumb baselines"></a>2. Set up the end-to-end training/evaluation skeleton + get dumb baselines</h4><p>Now that we understand our data can we reach for our super fancy Multi-scale ASPP FPN ResNet and begin training awesome models? For sure no. That is the road to suffering. <u>Our next step is to set up a full training + evaluation skeleton and gain trust in its correctness via a series of experiments.</u> At this stage it is best to pick some simple model that you couldn’t possibly have screwed up somehow - e.g. a linear classifier, or a very tiny ConvNet. We’ll want to train it, visualize the losses, any other metrics (e.g. accuracy), model predictions, and perform a series of ablation experiments with explicit hypotheses along the way.</p><p>Tips &amp; tricks for this stage:</p><ul><li><strong>fix random seed</strong>. Always use a fixed random seed to guarantee that when you run the code twice you will get the same outcome. This removes a factor of variation and will help keep you sane.</li><li><strong>simplify</strong>. Make sure to disable any unnecessary fanciness. As an example, definitely turn off any data augmentation at this stage. Data augmentation is a regularization strategy that we may incorporate later, but for now it is just another opportunity to introduce some dumb bug.</li><li><strong>add significant digits to your eval</strong>. When plotting the test loss run the evaluation over the entire (large) test set. Do not just plot test losses over batches and then rely on smoothing them in Tensorboard. We are in pursuit of correctness and are very willing to give up time for staying sane.</li><li><strong>verify loss @ init</strong>. Verify that your loss starts at the correct loss value. E.g. if you initialize your final layer correctly you should measure <code>-log(1/n_classes)</code> on a softmax at initialization. The same default values can be derived for L2 regression, Huber losses, etc.</li><li><strong>init well</strong>. Initialize the final layer weights correctly. E.g. if you are regressing some values that have a mean of 50 then initialize the final bias to 50. If you have an imbalanced dataset of a ratio 1:10 of positives:negatives, set the bias on your logits such that your network predicts probability of 0.1 at initialization. Setting these correctly will speed up convergence and eliminate “hockey stick” loss curves where in the first few iteration your network is basically just learning the bias.</li><li><strong>human baseline</strong>. Monitor metrics other than loss that are human interpretable and checkable (e.g. accuracy). Whenever possible evaluate your own (human) accuracy and compare to it. Alternatively, annotate the test data twice and for each example treat one annotation as prediction and the second as ground truth.</li><li><strong>input-indepent baseline</strong>. Train an input-independent baseline, (e.g. easiest is to just set all your inputs to zero). This should perform worse than when you actually plug in your data without zeroing it out. Does it? i.e. does your model learn to extract any information out of the input at all?</li><li><strong>overfit one batch</strong>. Overfit a single batch of only a few examples (e.g. as little as two). To do so we increase the capacity of our model (e.g. add layers or filters) and verify that we can reach the lowest achievable loss (e.g. zero). I also like to visualize in the same plot both the label and the prediction and ensure that they end up aligning perfectly once we reach the minimum loss. If they do not, there is a bug somewhere and we cannot continue to the next stage.</li><li><strong>verify decreasing training loss</strong>. At this stage you will hopefully be underfitting on your dataset because you’re working with a toy model. Try to increase its capacity just a bit. Did your training loss go down as it should?</li><li><strong>visualize just before the net</strong>. The unambiguously correct place to visualize your data is immediately before your <code>y_hat = model(x)</code> (or <code>sess.run</code> in tf). That is - you want to visualize <em>exactly</em> what goes into your network, decoding that raw tensor of data and labels into visualizations. This is the only “source of truth”. I can’t count the number of times this has saved me and revealed problems in data preprocessing and augmentation.</li><li><strong>visualize prediction dynamics</strong>. I like to visualize model predictions on a fixed test batch during the course of training. The “dynamics” of how these predictions move will give you incredibly good intuition for how the training progresses. Many times it is possible to feel the network “struggle” to fit your data if it wiggles too much in some way, revealing instabilities. Very low or very high learning rates are also easily noticeable in the amount of jitter.</li><li><strong>use backprop to chart dependencies</strong>. Your deep learning code will often contain complicated, vectorized, and broadcasted operations. A relatively common bug I’ve come across a few times is that people get this wrong (e.g. they use <code>view</code> instead of <code>transpose/permute</code> somewhere) and inadvertently mix information across the batch dimension. It is a depressing fact that your network will typically still train okay because it will learn to ignore data from the other examples. One way to debug this (and other related problems) is to set the loss for some example <strong>i</strong> to be 1.0, run the backward pass all the way to the input, and ensure that you get a non-zero gradient only on the <strong>i-th</strong> example. More generally, gradients give you information about what depends on what in your network, which can be useful for debugging.</li><li><strong>generalize a special case</strong>. This is a bit more of a general coding tip but I’ve often seen people create bugs when they bite off more than they can chew, writing a relatively general functionality from scratch. I like to write a very specific function to what I’m doing right now, get that to work, and then generalize it later making sure that I get the same result. Often this applies to vectorizing code, where I almost always write out the fully loopy version first and only then transform it to vectorized code one loop at a time.</li></ul><blockquote><ol><li>固定随机种子，消除随机带来的误差</li><li>简单出发，先不使用数据集扩增</li><li>测试集不要画曲线，不然会疯的</li><li>评估起始损失值，<code>-log(1/n_classes)</code>，各类初始概率应大致相等；<strong>思路一致</strong>, $p\approx$</li><li>初始化最后一层权重很重要；<strong>一般都是采用随机初始化方法？？</strong></li><li>评估人的准确性并与模型比较</li><li>设置一个独立于输入的<code>baseline</code>，观察网络是否提取了想要的特征</li><li>反复训练同一个批次的数据，使网络过拟合，查看损失最低能到多少；<strong>确定网络结构没有问题</strong></li><li>试着增加模型<code>capacity</code>，观察训练集损失是否下降，以确定合适的网络容量；<strong>确定模型参数量</strong></li><li>输入网络前，可视化数据，查看数据是否正确；<strong>确定输入数据没有问题</strong></li><li>可视化一些相同数据的输出，观察输出波动；<strong>观察网络收敛情况</strong></li><li>用反向传播debug网络；<strong>高级技能？技能点还不够</strong></li><li>全循环慢慢改成矢量化代码；<strong>一些复杂的计算可参考</strong></li></ol></blockquote><h4 id="3-Overfit"><a href="#3-Overfit" class="headerlink" title="3. Overfit"></a>3. Overfit</h4><p>At this stage we should have a good understanding of the dataset and we have the full training + evaluation pipeline working. For any given model we can (reproducibly) compute a metric that we trust. We are also armed with our performance for an input-independent baseline, the performance of a few dumb baselines (we better beat these), and we have a rough sense of the performance of a human (we hope to reach this). The stage is now set for iterating on a good model.</p><p>The approach I like to take to finding a good model has two stages: first get a model large enough that it can overfit (i.e. focus on training loss) and then regularize it appropriately (give up some training loss to improve the validation loss). The reason I like these two stages is that if we are not able to reach a low error rate with any model at all that may again indicate some issues, bugs, or misconfiguration.</p><p>A few tips &amp; tricks for this stage:</p><ul><li><strong>picking the model</strong>. To reach a good training loss you’ll want to choose an appropriate architecture for the data. When it comes to choosing this my #1 advice is: <strong>Don’t be a hero</strong>. I’ve seen a lot of people who are eager to get crazy and creative in stacking up the lego blocks of the neural net toolbox in various exotic architectures that make sense to them. Resist this temptation strongly in the early stages of your project. I always advise people to simply find the most related paper and copy paste their simplest architecture that achieves good performance. E.g. if you are classifying images don’t be a hero and just copy paste a ResNet-50 for your first run. You’re allowed to do something more custom later and beat this.</li><li><strong>adam is safe</strong>. In the early stages of setting baselines I like to use Adam with a learning rate of <a href="https://twitter.com/karpathy/status/801621764144971776?lang=en" target="_blank" rel="noopener">3e-4</a>. In my experience Adam is much more forgiving to hyperparameters, including a bad learning rate. For ConvNets a well-tuned SGD will almost always slightly outperform Adam, but the optimal learning rate region is much more narrow and problem-specific. (Note: If you are using RNNs and related sequence models it is more common to use Adam. At the initial stage of your project, again, don’t be a hero and follow whatever the most related papers do.)</li><li><strong>complexify only one at a time</strong>. If you have multiple signals to plug into your classifier I would advise that you plug them in one by one and every time ensure that you get a performance boost you’d expect. Don’t throw the kitchen sink at your model at the start. There are other ways of building up complexity - e.g. you can try to plug in smaller images first and make them bigger later, etc.</li><li><strong>do not trust learning rate decay defaults</strong>. If you are re-purposing code from some other domain always be very careful with learning rate decay. Not only would you want to use different decay schedules for different problems, but - even worse - in a typical implementation the schedule will be based current epoch number, which can vary widely simply depending on the size of your dataset. E.g. ImageNet would decay by 10 on epoch 30. If you’re not training ImageNet then you almost certainly do not want this. If you’re not careful your code could secretely be driving your learning rate to zero too early, not allowing your model to converge. In my own work I always disable learning rate decays entirely (I use a constant LR) and tune this all the way at the very end.</li></ul><blockquote><ol><li>不要逞强，搭建各种奇奇怪怪的模型。先从相近任务效果良好的网络结构出发，慢慢改进再击败它；</li><li><code>Adam</code>对参数敏感性低，<code>SGD</code>往往效果更好；</li><li>慢慢提高输入数据的复杂性，如输入数据的特征数、图像尺寸；</li><li>根据自己的学习任务，调整学习率衰减参数；</li></ol></blockquote><h4 id="4-Regularize"><a href="#4-Regularize" class="headerlink" title="4. Regularize"></a>4. Regularize</h4><p>Ideally, we are now at a place where we have a large model that is fitting at least the training set. Now it is time to regularize it and gain some validation accuracy by giving up some of the training accuracy. Some tips &amp; tricks:</p><ul><li><strong>get more data</strong>. First, the by far best and preferred way to regularize a model in any practical setting is to add more real training data. It is a very common mistake to spend a lot engineering cycles trying to squeeze juice out of a small dataset when you could instead be collecting more data. As far as I’m aware adding more data is pretty much the only guaranteed way to monotonically improve the performance of a well-configured neural network almost indefinitely. The other would be ensembles (if you can afford them), but that tops out after ~5 models.</li><li><strong>data augment</strong>. The next best thing to real data is half-fake data - try out more aggressive data augmentation.</li><li><strong>creative augmentation</strong>. If half-fake data doesn’t do it, fake data may also do something. People are finding creative ways of expanding datasets; For example, <a href="https://openai.com/blog/learning-dexterity/" target="_blank" rel="noopener">domain randomization</a>, use of <a href="http://vladlen.info/publications/playing-data-ground-truth-computer-games/" target="_blank" rel="noopener">simulation</a>, clever <a href="https://arxiv.org/abs/1708.01642" target="_blank" rel="noopener">hybrids</a> such as inserting (potentially simulated) data into scenes, or even GANs.</li><li><strong>pretrain</strong>. It rarely ever hurts to use a pretrained network if you can, even if you have enough data.</li><li><strong>stick with supervised learning</strong>. Do not get over-excited about unsupervised pretraining. Unlike what that blog post from 2008 tells you, as far as I know, no version of it has reported strong results in modern computer vision (though NLP seems to be doing pretty well with BERT and friends these days, quite likely owing to the more deliberate nature of text, and a higher signal to noise ratio).</li><li><strong>smaller input dimensionality</strong>. Remove features that may contain spurious signal. Any added spurious input is just another opportunity to overfit if your dataset is small. Similarly, if low-level details don’t matter much try to input a smaller image.</li><li><strong>smaller model size</strong>. In many cases you can use domain knowledge constraints on the network to decrease its size. As an example, it used to be trendy to use Fully Connected layers at the top of backbones for ImageNet but these have since been replaced with simple average pooling, eliminating a ton of parameters in the process.</li><li><strong>decrease the batch size</strong>. Due to the normalization inside batch norm smaller batch sizes somewhat correspond to stronger regularization. This is because the batch empirical mean/std are more approximate versions of the full mean/std so the scale &amp; offset “wiggles” your batch around more.</li><li><strong>drop</strong>. Add dropout. Use dropout2d (spatial dropout) for ConvNets. Use this sparingly/carefully because dropout <a href="https://arxiv.org/abs/1801.05134" target="_blank" rel="noopener">does not seem to play nice</a> with batch normalization.</li><li><strong>weight decay</strong>. Increase the weight decay penalty.</li><li><strong>early stopping</strong>. Stop training based on your measured validation loss to catch your model just as it’s about to overfit.</li><li><strong>try a larger model</strong>. I mention this last and only after early stopping but I’ve found a few times in the past that larger models will of course overfit much more eventually, but their “early stopped” performance can often be much better than that of smaller models.</li></ul><p>Finally, to gain additional confidence that your network is a reasonable classifier, I like to visualize the network’s first-layer weights and ensure you get nice edges that make sense. If your first layer filters look like noise then something could be off. Similarly, activations inside the net can sometimes display odd artifacts and hint at problems.</p><blockquote><p>略微升高一点训练数据的损失，换取验证集损失的下降。</p><ol><li>扩大数据集；<strong>拼的就是算力和数据量</strong></li><li>数据集扩增；<strong>来了</strong></li><li>使用一些生成的虚假数据；</li><li>预训练模型，即使有足够的数据量；</li><li>监督性学习比非监督好；</li><li>减少数据特征的冗余性，如删减特征、降低图像分辨率；<strong>数据冗余容易过拟合</strong></li><li>减少模型参数容量；<strong>过大可能过拟合</strong></li><li>增大批数据量；<strong>梯度下降方向更准确</strong></li><li><code>Dropout</code>；<strong><code>BatchNorm</code>效果更好？</strong></li><li>权重衰减；<strong>正则惩罚</strong></li><li><code>Early stopping</code>；<strong>提前中断训练防止过拟合</strong></li><li>尝试更大的模型，有时候更大容易过拟合，但是提前中断训练效果会更好；</li><li>第一层网络的权值是否有可解释性；<strong>WTF?</strong></li></ol></blockquote><h4 id="5-Tune"><a href="#5-Tune" class="headerlink" title="5. Tune"></a>5. Tune</h4><p>You should now be “in the loop” with your dataset exploring a wide model space for architectures that achieve low validation loss. A few tips and tricks for this step:</p><ul><li><strong>random over grid search</strong>. For simultaneously tuning multiple hyperparameters it may sound tempting to use grid search to ensure coverage of all settings, but keep in mind that it is <a href="http://jmlr.csail.mit.edu/papers/volume13/bergstra12a/bergstra12a.pdf" target="_blank" rel="noopener">best to use random search instead</a>. Intuitively, this is because neural nets are often much more sensitive to some parameters than others. In the limit, if a parameter <strong>a</strong> matters but changing <strong>b</strong> has no effect then you’d rather sample <strong>a</strong> more throughly than at a few fixed points multiple times.</li><li><strong>hyper-parameter optimization</strong>. There is a large number of fancy bayesian hyper-parameter optimization toolboxes around and a few of my friends have also reported success with them, but my personal experience is that the state of the art approach to exploring a nice and wide space of models and hyperparameters is to use an intern :). Just kidding.</li></ul><blockquote><ol><li>随机搜索超参数，对重要参数调整更多；</li><li>招募一个实习生帮助自己调参hhhhhh；</li></ol></blockquote><h4 id="6-Squeeze-out-the-juice"><a href="#6-Squeeze-out-the-juice" class="headerlink" title="6. Squeeze out the juice"></a>6. Squeeze out the juice</h4><p>Once you find the best types of architectures and hyper-parameters you can still use a few more tricks to squeeze out the last pieces of juice out of the system:</p><ul><li><strong>ensembles</strong>. Model ensembles are a pretty much guaranteed way to gain 2% of accuracy on anything. If you can’t afford the computation at test time look into distilling your ensemble into a network using <a href="https://arxiv.org/abs/1503.02531" target="_blank" rel="noopener">dark knowledge</a>.</li><li><strong>leave it training</strong>. I’ve often seen people tempted to stop the model training when the validation loss seems to be leveling off. In my experience networks keep training for unintuitively long time. One time I accidentally left a model training during the winter break and when I got back in January it was SOTA (“state of the art”).</li></ul><blockquote><ol><li>集成方法；</li><li>坚信模型能收敛并能取得良好的效果，不要手贱中断他。</li></ol></blockquote><h4 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h4><p>Once you make it here you’ll have all the ingredients for success: You have a deep understanding of the technology, the dataset and the problem, you’ve set up the entire training/evaluation infrastructure and achieved high confidence in its accuracy, and you’ve explored increasingly more complex models, gaining performance improvements in ways you’ve predicted each step of the way. You’re now ready to read a lot of papers, try a large number of experiments, and get your SOTA results. Good luck!</p>]]></content>
      
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在宇宙间不易被风吹散</title>
      <link href="/2019/04/28/%E5%9C%A8%E5%AE%87%E5%AE%99%E9%97%B4%E4%B8%8D%E6%98%93%E8%A2%AB%E9%A3%8E%E5%90%B9%E6%95%A3/"/>
      <url>/2019/04/28/%E5%9C%A8%E5%AE%87%E5%AE%99%E9%97%B4%E4%B8%8D%E6%98%93%E8%A2%AB%E9%A3%8E%E5%90%B9%E6%95%A3/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/04/28/%E5%9C%A8%E5%AE%87%E5%AE%99%E9%97%B4%E4%B8%8D%E6%98%93%E8%A2%AB%E9%A3%8E%E5%90%B9%E6%95%A3/在宇宙间不易被风吹散/1.jpg" alt="1"><br><img src="/2019/04/28/%E5%9C%A8%E5%AE%87%E5%AE%99%E9%97%B4%E4%B8%8D%E6%98%93%E8%A2%AB%E9%A3%8E%E5%90%B9%E6%95%A3/在宇宙间不易被风吹散/3.jpg" alt="3"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>喜欢冯唐的文集，用他自己文章里写的句子描述，“毫不掩饰的小说”，露骨但是真实，文字如锦如绣，文字间有墨香、有美人、有Kindle、有古玉和瓷器。</p><blockquote><p>你迷恋什么，什么就是你的障碍。有个笃定的核，在宇宙间不易被风吹散。</p></blockquote><h1 id="精选"><a href="#精选" class="headerlink" title="精选"></a>精选</h1><ol><li>人是需要有点精神的，有点通灵的精神，否则很容易出溜成行尸走肉，任由人性中暗黑的一面驱使自己禽兽一样的肉身，在世间做一些腐朽不堪的事情。</li><li>一杆进洞，四下无人，人生悲惨莫过于此。</li><li>一日茶，一夜酒，一部毫不掩饰的小说，一次没有目的的见面，一群不谈正经事的朋友，用美好的器物消磨必定留不住的时间。</li><li>做一个人性的矿工，挖一挖，再挖一挖，看看下面的下面还有什么。</li><li>我觉得眼睛看到的一切似乎想要告诉我世界是什么但是又不明说到底是什么。</li><li>在纸书里，在啤酒里，在阳光里，在暖气里，宅着，屌着，无所事事，随梦所之。</li><li>我的、我的、我的、我的，一瞬间的我执爆棚，真好。</li><li>宇宙间大多数现象超越人类的知识范围，不可解释的例子比比皆是，比如人骨骼为啥是206块骨头，比如我爱你你为什么不爱我。</li><li>人生苦短，不如不管，继续任性。</li><li>时间在床边和鬓边一路小跑，有些事物在不知不觉中浅吟低唱，明生暗长。</li><li>人又不是黄金，怎么能让所有人都喜欢？任何事做到顶尖，都是政治，都会被人妒忌；即使是黄金，也会被某些人说成是臭狗屎。</li><li>既然死了的人都没睡醒过，活着时候睡觉就是很吃亏的一件事。</li><li>白白的，小小的，紧紧的，香香的，佛说第一次触摸最接近佛。——《初恋》</li><li>有时候，人会因为一两个微不足道的美好，安安渴望一个巨大的负面，比如因为像有机会用一下图案撩骚的Zippo打火机而渴望抽烟，比如因为一把好乳或者一头长发而舍不得一个三观凌乱的悍妇，比如因为一个火炉而期待北京一个漫长而寒冷的冬天。</li><li>脱离长期背在身上的人的羁绊，让身体里的禽兽和仙人在山林里和酒里渐渐增加比例，裸奔、裸泳，在池塘里带着猴子捞月亮，在山顶问神仙：人到底是个什么东西？</li><li>想起后半生最不靠谱的事儿，结论是：最靠谱的还是买个酒庄。</li><li>天大理比不过“我喜欢”。</li><li>涉及终极的事儿，听天，听命，让自己和身体尽人力，其他不必去想，多想无益，徒增烦恼。</li><li>全球化了，各国的建筑师都到处串了，各种时装杂志都到处发行了，各地的楼宇和姑娘越来越像，像到面目模糊，天下一城。</li><li>最后一个能想到的原因，是随身佩带之后，无时无刻不提醒自己一些必须珍惜的事物和必须坚守的品质。君子无辜，玉不去身，时刻提醒自己，不要吃喝嫖赌抽、坑蒙拐骗偷。</li><li>科技的快速进步让很多人变得过时，也让很多器物变得多余。</li><li>我会老到有一天，不需要手表告诉我，时间是如何自己消失，也不需要靠名牌手表告诉周围人类我的品味、格调、富裕程度和牛逼等级。我会根据四季里的光线的变化，大致推断现在是几点了，根据肠胃的叫声决定是否该去街口的小馆儿了。</li><li>男人要有些士的精神，有所不为，有所必为，活着不是唯一的追求和最终的底线。</li><li>女人一头长发，骑匹大马，很迷人，非常迷人，而且，她是来救你的，就无比迷人。无论她要带你去哪，你都不要拒绝，先上马，然后闭嘴，什么都不要问。</li><li>买件立领风衣，浓个眉大个眼，一直走，不要往两边看，还能再混几十年。</li><li>家庭太复杂，涉及太多硬件和软件、生理和心理、现在和未来，一篇文章不容易讲透。</li><li>上天下地，背山面海，每天看看不一样的云，想想昨晚的梦，和自己聊一会天，日子容易丰盛起来。</li><li>朋友们就散住在附近几个街区，不用提前约，菜香升起时，几个电话就能聚起几个人，酒量不同，酒品相近，术业不同，三观接近。菜一般，就多喝点酒；酒不好，就再多喝点，很快就能高兴起来。</li><li>一生中，除了做自己喜欢的事儿，剩下最重要的就是和相看两不厌的人待在一起。</li><li>不和这个世界争，也不和别人争，更不要和自己争。争的结果可能是一时牛逼，也可能是心脑血管意外，后者造成的持续影响大很多。</li><li>尽管没去过南极，但是也见过了风雨，俗事已经懒得分析，不如一起一边慢跑，一边咒骂彼此生活中奇葩一样摇曳的傻逼。</li><li>世界这么多凶狠，他人心里那么多地狱，内心没有一点混蛋，如何走的下去？</li><li>其实我们跟鱼、植物甚至草履虫有很多相近的地方，人或如草木，人可以甚至应该偶尔禽兽。</li><li>如果没有真的存在，所谓的善只能是伪善，所谓的美也只能是妄美。</li><li>因为人是要死的，所以要常常叨念冯唐说的九字箴言：不着急，不害怕，不要脸。</li><li>钱超过一定数目就不是用来个人消费的了，个人能温饱就好。多处的个人欲望需要靠修行来消灭，而不能靠多花钱来满足。</li><li>有帽子是一种相，没帽子也是一种相。内心不必太执着于无帽子的相，也不必太执着于有帽子的相。有帽子，无帽子，都需要亲尝，皆为玩耍。</li><li>既然戴帽子是相，投射到不同人的心识里就是不同的相，何必强求赞美？何必强调一致？何必消除噪音？</li><li>“宇戴王冠，必承其重。不要低头，王冠会掉。不要哭泣，有人会笑。”这个态度也太励志、太谋权，放松，戴戴耍耍，不留神，王冠掉了，掉就掉了，掉了就索性长发飘飘。</li><li>能做到实事求是地自恋其实是自信和自尊。任何领域做到最好之后，人只能相信自己的判断，只能自恋。……。从这个意义上讲，自恋不应该是被诟病的对象，不能实事求是的傻逼才应该是被诟病的对象。……。实事求是地修炼，实事求是地恋他和自恋，让别人闹心去吧。</li><li>矮子更爱居高临下，傻子更容易认为自己充满道理。</li><li>非让矮子明白自己是矮子，非让傻子明白自己是傻子，也是很耗神费时的事儿。对付世间闹心的事儿，只需要搞清楚两件事，一件是“关我屁事”，另一件是“关你屁事”。</li><li>小孩在天地间疯跑，不知道名利为何物，学习基本常识，食蔬饮水，应付无聊的课程，傻愣愣地杀无聊的时间，骂所有看不上的人“傻逼”。本身近佛，不需要佛。</li><li>有多少似乎过不起的事儿过不去一年？有多少看上去的大事最后真是大事？名片上印不下的名头，敌不过左图且书、右琴与壶，抵不过不得不褪去时一颗好心脏、一个好女生。</li><li>这样简单下去，再简单下去，脑子没弯儿了，手脚有劲儿了，山顶慢慢低于脚面了，拉萨就在眼前了。你我竟然像山、云、湖水和星空一样，一直在老去，一直在变化，一直没问题。再简单下去，在这样下去，你我都是佛了。</li><li>我常年劳碌，尽管热爱妇女，但没时间，无法让任何妇女满意。情伤之后，“得不到”，“留不住”，“无可奈何，奈何奈何”，唯一疗伤的方式就是拿伤口当笔头，写几行诗，血干了，诗出了，心里放下了。</li><li>如果去一座荒岛，没电，没电视，没电脑，一片蛮荒。我想了想，如果只能带一个活物。我就带一个和我能聊很多天的女人；如果只能带一本书，我就带一本《唐诗三百首》。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 冯唐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LDA</title>
      <link href="/2019/04/22/LDA/"/>
      <url>/2019/04/22/LDA/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在<a href="https://louishsu.xyz/2018/10/22/PCA/" target="_blank" rel="noopener">PCA</a>中，介绍了无监督降维方法，主成分分析(Principal Components Analysis)。从投影后数据方差最大的角度出发，选取主轴。下面介绍一种有监督的降维方法，线性判别分析(Linear Discriminant Analysis)。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="多分类"><a href="#多分类" class="headerlink" title="多分类"></a>多分类</h2><p>设有$n$维样本集$D={x^{(1)}, …, x^{(i)}, …, x^{(m)}}$，所属类别数目为$C$，现求其第一投影轴$u_1$，即</p><script type="math/tex; mode=display">\tilde{x}^{(i)}_1 = u_1^Tx^{(i)}</script><p>现希望投影后，<strong>类内距离越小越好，类间距离越大越好</strong>，定义衡量指标</p><ol><li><p>类内离差阵</p><script type="math/tex; mode=display"> S_W = \sum_{j=1}^C \frac{m_j}{m} \left[ \frac{1}{m_j} \sum_{i=1}^{m_j} (x^{(i)} - \mu^{(j)}) (x^{(i)} - \mu^{(j)})^T \right]</script><p> 即</p><script type="math/tex; mode=display"> S_W = \frac{1}{m} \sum_{j=1}^C \sum_{i=1}^{m_j} (x^{(i)} - \mu^{(j)}) (x^{(i)} - \mu^{(j)})^T \tag{1}</script></li><li><p>类间离差阵</p><script type="math/tex; mode=display"> S_B = \sum_{j=1}^C \frac{m_j}{m} (\mu^{(j)} - \mu) (\mu^{(j)} - \mu)^T \tag{2}</script></li></ol><p>则投影到第一主轴$u_1$后数据的类内离差阵和类间离差阵为</p><script type="math/tex; mode=display">\tilde{S_W} = \sum_{j=1}^C \frac{m_j}{m} \left[ \frac{1}{m_j} \sum_{i=1}^{m_j} (\tilde{x}^{(i)}_1 - \tilde{\mu}^{(j)}_1) (\tilde{x}^{(i)}_1 - \tilde{\mu}^{(j)}_1)^T \right]</script><script type="math/tex; mode=display">\tilde{S_B} = \sum_{j=1}^C \frac{m_j}{m} (\tilde{\mu}^{(j)}_1 - \tilde{\mu}_1) (\tilde{\mu}^{(j)}_1 - \tilde{\mu}_1)^T</script><blockquote><p>此时$\tilde{S_W}, \tilde{S_B}$均为标量。</p></blockquote><p>其中</p><script type="math/tex; mode=display">\tilde{x}^{(i)}_1 = u_1^T x^{(i)}</script><script type="math/tex; mode=display">\tilde{\mu}^{(j)}_1 = u_1^T \mu^{(j)}</script><script type="math/tex; mode=display">\tilde{\mu}_1 = u_1^T \mu</script><p>带入后得到</p><script type="math/tex; mode=display">\tilde{S_W} = \frac{1}{m} \sum_{j=1}^C \sum_{i=1}^{m_j} (u_1^T x^{(i)} - u_1^T \mu^{(j)}) (u_1^T x^{(i)} - u_1^T \mu^{(j)})^T</script><script type="math/tex; mode=display">= \frac{1}{m} \sum_{j=1}^C \sum_{i=1}^{m_j} u_1^T(x^{(i)} - \mu^{(j)}) (x^{(i)} - \mu^{(j)})^T u_1</script><script type="math/tex; mode=display">= u_1^T S_W u_1</script><p>同理</p><script type="math/tex; mode=display">\tilde{S_B} = u_1^T S_B u_1</script><p>定义优化目标</p><script type="math/tex; mode=display">J = \min \left\{ \frac{\tilde{S_W}}{\tilde{S_B}} \right\}= \min \left\{ \frac{u_1^T S_W u_1}{u_1^T S_B u_1} \right\} \tag{3}</script><p>取</p><script type="math/tex; mode=display">L(u_1) = \frac{u_1^T S_W u_1}{u_1^T S_B u_1} \tag{4}</script><p>则其极值为</p><script type="math/tex; mode=display">\frac{∂L}{∂u_1} = \frac{2(u_1^T S_B u_1) S_W u_1 - 2(u_1^T S_W u_1) S_B u_1}{(u_1^T S_B u_1)^2} = 0</script><p>得到</p><script type="math/tex; mode=display">(u_1^T S_B u_1) S_W u_1 = (u_1^T S_W u_1) S_B u_1</script><p>令$\lambda_1 = \frac{u_1^T S_B u_1}{u_1^T S_W u_1}$，有</p><script type="math/tex; mode=display">S_B u_1 = \lambda_1 S_W u_1 \tag{5}</script><p>当$m$较大时，$S_W$一般非奇异，故</p><script type="math/tex; mode=display">S_W^{-1} S_B u_1 = \lambda_1 u_1 \tag{*1}</script><p>即${\lambda_1, u_1}$为矩阵$S_W^{-1} S_B$的特征对。</p><h2 id="二分类"><a href="#二分类" class="headerlink" title="二分类"></a>二分类</h2><p>特别地，对于二分类问题，有</p><script type="math/tex; mode=display">S_B = \sum_{j=1}^C \frac{m_j}{m} (\mu^{(j)} - \mu) (\mu^{(j)} - \mu)^T</script><script type="math/tex; mode=display">= \frac{m_1}{m} (\mu^{(1)} - \mu) (\mu^{(1)} - \mu)^T + \frac{m_2}{m} (\mu^{(2)} - \mu) (\mu^{(2)} - \mu)^T</script><script type="math/tex; mode=display">= \frac{m_1}{m} \mu^{(1)} \mu^{(1)T} + \frac{m_2}{m} \mu^{(2)} \mu^{(2)T} - 2 \mu \left( \frac{m_1}{m} \mu^{(1)T} + \frac{m_2}{m} \mu^{(2)T} \right) + \mu \mu^T</script><p>其中</p><script type="math/tex; mode=display">\frac{m_1}{m} \mu^{(1)} + \frac{m_2}{m} \mu^{(2)} = \mu \tag{6}</script><p>所以$(6)$代入$S_B$化简得</p><script type="math/tex; mode=display">S_B = \frac{m_1}{m} \mu^{(1)} \mu^{(1)T} + \frac{m_2}{m} \mu^{(2)} \mu^{(2)T} - \mu \mu^T</script><script type="math/tex; mode=display">= \frac{m_1}{m} \mu^{(1)} \mu^{(1)T} + \frac{m_2}{m} \mu^{(2)} \mu^{(2)T} - (\frac{m_1}{m} \mu^{(1)} + \frac{m_2}{m} \mu^{(2)}) (\frac{m_1}{m} \mu^{(1)} + \frac{m_2}{m} \mu^{(2)})^T</script><script type="math/tex; mode=display">= \frac{m_1}{m} \left(1-\frac{m_1}{m}\right) \mu^{(1)} \mu^{(1)T} + \frac{m_2}{m} \left(1-\frac{m_2}{m}\right) \mu^{(2)} \mu^{(2)T} - \frac{m_1}{m} \frac{m_2}{m} \mu^{(2)} \mu^{(1)T} - \frac{m_1}{m} \frac{m_2}{m} \mu^{(1)} \mu^{(2)T}</script><script type="math/tex; mode=display">= \left( \frac{m_1}{m} \mu^{(1)} - \frac{m_2}{m} \mu^{(2)} \right) \left( \frac{m_1}{m} \mu^{(1)} - \frac{m_2}{m} \mu^{(2)} \right)^T</script><p>上式代入$S_W^{-1} S_B u_1$，得</p><script type="math/tex; mode=display">左边 = S_W^{-1} \left( \frac{m_1}{m} \mu^{(1)} - \frac{m_2}{m} \mu^{(2)} \right) \left( \frac{m_1}{m} \mu^{(1)} - \frac{m_2}{m} \mu^{(2)} \right)^T u_1</script><p>其中$\left( \frac{m_1}{m} \mu^{(1)} - \frac{m_2}{m} \mu^{(2)} \right)^T u_1$为常数，记作$\alpha$，所以$\alpha S_W^{-1} \left( \frac{m_1}{m} \mu^{(1)} - \frac{m_2}{m} \mu^{(2)} \right) = \lambda_1 u_1$，也即</p><script type="math/tex; mode=display">u_1 = \frac{\alpha}{\lambda_1} S_W^{-1} \left( \frac{m_1}{m} \mu^{(1)} - \frac{m_2}{m} \mu^{(2)} \right)</script><p>其中常数$\frac{\alpha}{\lambda_1}$不影响投影结果，如取$1$，则得到</p><script type="math/tex; mode=display">u_1 = S_W^{-1} \left( \frac{m_1}{m} \mu^{(1)} - \frac{m_2}{m} \mu^{(2)} \right) \tag{*2}</script><p>同理，可求得第二、三主成分轴</p><h1 id="计算步骤"><a href="#计算步骤" class="headerlink" title="计算步骤"></a>计算步骤</h1><p>给定数据集矩阵</p><script type="math/tex; mode=display">X = \left[ \begin{matrix}    ... \\    x^{(i)T} \\    ... \end{matrix} \right]</script><p>其中$x^{(i)} = \left[ x^{(i)}_1, …, x^{(i)}_j, … x^{(i)}_n \right]^T$</p><ol><li><p>计算类内离差阵$S_W$与类间离差阵$S_B$；</p><script type="math/tex; mode=display"> S_W = \frac{1}{m} \sum_{j=1}^C \sum_{i=1}^{m_j} (x^{(i)} - \mu^{(j)}) (x^{(i)} - \mu^{(j)})^T \tag{1}</script><script type="math/tex; mode=display"> S_B = \sum_{j=1}^C \frac{m_j}{m} (\mu^{(j)} - \mu) (\mu^{(j)} - \mu)^T \tag{2}</script></li><li><p>计算矩阵$S_W^{-1}S_B$的特征对$(\lambda_i, u_i)$；</p><script type="math/tex; mode=display">S_W^{-1}S_B u_i = \lambda_i u_i \tag{*1}</script></li><li><p>将特征对按特征值降序排序，选取最大的特征值对应的特征向量作为投影主轴；</p></li><li>将数据投影到主轴上；</li></ol><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>LDA可用于分类，以二分类为例，在求取主轴$u_1$后，将各类中心投影到主轴上，即</p><script type="math/tex; mode=display">\begin{cases}    \tilde{\mu}^{(1)}_1 = u_1^T \mu^{(1)} \\    \tilde{\mu}^{(2)}_1 = u_1^T \mu^{(2)}\end{cases}</script><p>选取阈值，如</p><script type="math/tex; mode=display">\tilde{x}_1 = \frac{\tilde{\mu}^{(1)}_1 + \tilde{\mu}^{(2)}_1}{2}</script><p>则预测时，判决方程为</p><script type="math/tex; mode=display">\begin{cases}    u_1^T x^{(i)} < \tilde{x}_1 \Rightarrow x^{(i)} \in \omega_1 \\    u_1^T x^{(i)} > \tilde{x}_1 \Rightarrow x^{(i)} \in \omega_2\end{cases}</script><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>详情查看<a href="https://github.com/isLouisHsu/Basic-Machine-Learning-Algorithm/blob/master/algorithm/lda.py" target="_blank" rel="noopener">Github</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eig</span><span class="params">(A1, A2)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Params:</span></span><br><span class="line"><span class="string">        A1, A2: &#123;ndarray(n, n)&#125;</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        eigval: &#123;ndarray(n)&#125;</span></span><br><span class="line"><span class="string">        eigvec: &#123;ndarray(n, n)&#125;</span></span><br><span class="line"><span class="string">    Notes:</span></span><br><span class="line"><span class="string">        A1 \alpha = \lambda A2 \alpha</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    s, u = np.linalg.eigh(A2 + np.diag(np.ones(A2.shape[<span class="number">0</span>]))*<span class="number">1e-3</span>)</span><br><span class="line">    s_sqrt_inv = np.linalg.inv(np.diag(np.sqrt(s)))</span><br><span class="line"></span><br><span class="line">    A = s_sqrt_inv.dot(u.T).dot(A1).dot(u).dot(s_sqrt_inv)</span><br><span class="line">    eigval, P = np.linalg.eigh(A)</span><br><span class="line">    eigvec = u.dot(s_sqrt_inv).dot(P)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> eigval, eigvec</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LDA</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">""" </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Attributes:</span></span><br><span class="line"><span class="string">        n_components: &#123;int&#125;</span></span><br><span class="line"><span class="string">        means_: &#123;ndarray(n_classes, n_features)&#125;</span></span><br><span class="line"><span class="string">        components_:  &#123;ndarray(n_components, n_features)&#125;</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n_components)</span>:</span></span><br><span class="line">        self.n_components = n_components</span><br><span class="line"></span><br><span class="line">        self.means_ = <span class="keyword">None</span></span><br><span class="line">        self.components_ = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X, y)</span>:</span></span><br><span class="line">        <span class="string">""" train the model</span></span><br><span class="line"><span class="string">        Params:</span></span><br><span class="line"><span class="string">            X:      &#123;ndarray(n_samples, n_features)&#125;</span></span><br><span class="line"><span class="string">            y:      &#123;ndarray(n_samples)&#125;</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        labels = list(set(list(y)))</span><br><span class="line">        n_classes = len(labels)</span><br><span class="line">        n_samples, n_features = X.shape</span><br><span class="line"></span><br><span class="line">        self.means_ = np.zeros((n_classes, n_features))</span><br><span class="line">        S_W = np.zeros(shape=(n_features, n_features))</span><br><span class="line">        S_B = np.zeros(shape=(n_features, n_features))</span><br><span class="line">        mean_ = np.mean(X, axis=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> i_class <span class="keyword">in</span> range(n_classes):</span><br><span class="line">            X_ = X[y==labels[i_class]]</span><br><span class="line">            </span><br><span class="line">            means_ = np.mean(X_, axis=<span class="number">0</span>)</span><br><span class="line">            self.means_[i_class] = means_</span><br><span class="line"></span><br><span class="line">            X_ = X_ - means_</span><br><span class="line">            means_ = (means_ - mean_).reshape(<span class="number">1</span>, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">            S_W += (X_.T).dot(X_) * (<span class="number">1</span> / n_samples)</span><br><span class="line">            S_B += (means_.T).dot(means_) * (X_.shape[<span class="number">0</span>] / n_samples)</span><br><span class="line"></span><br><span class="line">        eigval, eigvec = eig(S_B, S_W)</span><br><span class="line"></span><br><span class="line">        order = np.argsort(eigval)[::<span class="number">-1</span>]</span><br><span class="line">        eigval = eigval[order]</span><br><span class="line">        eigvec = eigvec[:, order]</span><br><span class="line"></span><br><span class="line">        self.components_ = eigvec[:, :self.n_components].T</span><br><span class="line">        self.components_ /= np.linalg.norm(self.components_, axis=<span class="number">1</span>).reshape(<span class="number">1</span>, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transform</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Params:</span></span><br><span class="line"><span class="string">            X:  &#123;ndarray(n_samples, n_features)&#125;</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            X:  &#123;ndarray(n_samples, n_components)&#125;</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        X_ = X.dot(self.components_.T)</span><br><span class="line">        <span class="keyword">return</span> X_</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit_transform</span><span class="params">(self, X, y)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Params:</span></span><br><span class="line"><span class="string">            X:  &#123;ndarray(n_samples, n_features)&#125;</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            X:  &#123;ndarray(n_samples, n_components)&#125;</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.fit(X, y)</span><br><span class="line">        X_ = self.transform(X)</span><br><span class="line">        <span class="keyword">return</span> X_</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transform_inv</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Params:</span></span><br><span class="line"><span class="string">            X:  &#123;ndarray(n_samples, n_components)&#125;</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            X:  &#123;ndarray(n_samples, n_features)&#125;</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        X_ = X.dot(self.components_)</span><br><span class="line">        <span class="keyword">return</span> X_</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Params:</span></span><br><span class="line"><span class="string">            X:  &#123;ndarray(n_samples, n_features)&#125;</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            y:  &#123;ndarray(n_samples)&#125;</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n_samples, n_features = X.shape</span><br><span class="line">        y = np.zeros(n_samples, dtype=np.int)</span><br><span class="line">        </span><br><span class="line">        X_ = self.transform(X)</span><br><span class="line">        means_ = self.transform(self.means_)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n_samples):</span><br><span class="line">            y[i] = np.argmin(np.linalg.norm(means_ - X_[i], axis=<span class="number">1</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><p>与PCA投影结果对比如下</p><ul><li>PCA<br>  <img src="/2019/04/22/LDA/PCA.png" alt="PCA"></li><li>LDA<br>  <img src="/2019/04/22/LDA/LDA.png" alt="LDA"></li></ul><p>上图不明显，下图生成了两簇高斯分布的样本点，作出主轴显示，红色为LDA第一主轴方向，蓝色为PCA第一主轴方向<br><img src="/2019/04/22/LDA/Figure_1.png" alt="Figure_1"></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.cnblogs.com/LeftNotEasy/archive/2011/01/08/lda-and-pca-machine-learning.html" target="_blank" rel="noopener">机器学习中的数学(4)-线性判别分析（LDA）, 主成分分析(PCA)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 降维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>N-dim Array PCA</title>
      <link href="/2019/04/18/n-dim-Array-PCA/"/>
      <url>/2019/04/18/n-dim-Array-PCA/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在<a href="https://louishsu.xyz/2018/10/22/PCA/" target="_blank" rel="noopener">PCA</a>中介绍了1维数据的主成分分析，那么对于多维数据，如何进行处理呢？有一种做法是，将单份的样本数据展开为1维向量，再进行PCA，例如著名的<a href="https://zh.wikipedia.org/wiki/%E7%89%B9%E5%BE%81%E8%84%B8" target="_blank" rel="noopener">Eigenface</a>，如图所示</p><p><img src="/2019/04/18/n-dim-Array-PCA/Eigenfaces.png" alt="Eigenfaces"></p><p>这有一个缺点是，忽略了多维数据的空间信息，且计算时，若展开后维度过大，协方差矩阵的求逆过程非常耗时间，以下介绍多维主成分分析。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>对于单维$n$维度数据$X = \left[\begin{matrix} x^{(1)} \ x^{(2)} \ … \ x^{(N)} \end{matrix}\right]$，我们有</p><script type="math/tex; mode=display">X' = XU</script><p>其中，$x^{(i)}$为$n$维行向量，组成样本矩阵$X_{N \times n}$，$U_{n \times n_1}$为投影矩阵，$X’_{N \times n_1}$为降维后的样本矩阵。</p><p>对于多(n)维样本张量数据$X_{N \times n_{d_1} \times n_{d_2} \times … \times n_{d_n}}$，指定各维度降维顺序，在$d_i$维度上，我们将张量在该维度上展开为$1$维向量</p><script type="math/tex; mode=display">X_{N_{d_i} \times n_{d_i}}</script><p>其中</p><script type="math/tex; mode=display">N_{d_i} = \prod_{j=0,j≠i}^n n_{d_j}</script><p>然后在$d_i$维度上进行降维，即</p><script type="math/tex; mode=display">X'_{N_{d_i} \times n'_{d_i}} = X_{N_{d_i} \times n_{d_i}} U^{d_i}</script><p>其中$U^{d_i}$表示$d_i$维度的投影矩阵，其大小为$n_{d_i} \times n’_{d_i}$，然后，将该张量其余维度恢复，得到</p><script type="math/tex; mode=display">X^{d_i}_{N \times n_{d_1} \times .. \times n'_{d_i} \times ... \times n_{d_n}}</script><p>如此循环，在各维度进行降维，得到张量</p><script type="math/tex; mode=display">X^{d_1, ..., d_n}_{N \times n'_{d_1} \times .. \times n'_{d_i} \times ... \times n'_{d_n}}</script><p><strong>注意，不同的降维顺序得到的参数会存在差异。</strong></p><p>以3维张量$X(H, W, C)$为例，指定降维顺序为$(d_1, d_2, d_3)$，其降维过程表示如图</p><ul><li><p>在$H$维度上</p><p>  <img src="/2019/04/18/n-dim-Array-PCA/d1.JPG" alt="d1"></p></li><li><p>在$W$维度上</p><p>  <img src="/2019/04/18/n-dim-Array-PCA/d2.JPG" alt="d2"></p></li><li><p>在$C$维度上</p><p>  <img src="/2019/04/18/n-dim-Array-PCA/d3.JPG" alt="d3"></p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>同样的，以3维张量$X(H, W, C)$为例，指定降维顺序为$(d_1, d_2, d_3)$</p><ol><li><p>在$H$维度上</p><ol><li>将该张量转置，得到$X^{T_{d_1d_3}}(C, W, H)$</li><li>将其展开为$X_{flatten}(N_H \times H)$，其中$N_H=C \times W$</li><li>降维得到$X’_{flatten}(N_H \times H’)$</li><li>重新将另外两维恢复，得到$X^{T_{d_1d_3}’}(C, W, H’)$</li><li>将张量转置，得到$X^{d_1}(H’, W, C)$</li></ol></li><li><p>在$W$维度上</p><ol><li>将$X^{d_1}(H’, W, C)$转置，得到$X^{T_{d_2d_3}}(H’, C, W)$</li><li>将其展开为$X_{flatten}(N_W \times W)$，其中$N_W=H’ \times C$</li><li>降维得到$X’_{flatten}(N_W \times W’)$</li><li>重新将另外两维恢复，得到$X^{T_{d_2d_3}’}(H’, C, W’)$</li><li>将张量转置，得到$X^{d_1d_2}(H’, W’, C)$</li></ol></li><li><p>在$C$维度上</p><ol><li>将$X^{d_1d_2}(H’, W’, C)$展开为$X_{flatten}(N_C \times C)$，其中$N_C=H’ \times W’$</li><li>降维得到$X’_{flatten}(N_C \times C’)$</li><li>重新将另外两维恢复，得到$X^{d_1d_2d_3}(H’, W’, C’)$</li></ol></li></ol><p>详细查看<a href="https://github.com/isLouisHsu/Basic-Machine-Learning-Algorithm" target="_blank" rel="noopener">isLouisHsu/Basic-Machine-Learning-Algorithm/algorithm/tensor_pca.py- GitHub</a>，其核心代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transform</span><span class="params">(self, X)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Params:</span></span><br><span class="line"><span class="string">        X: &#123;ndarray(n_samples, d0, d1, d2, ..., dn-1)&#125; n-dim array</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        X: &#123;ndarray(n_samples, d0, d1, d2, ..., dn-1)&#125; n-dim array</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> self.n_dims == len(X.shape) - <span class="number">1</span>, <span class="string">'please check input dimension! '</span></span><br><span class="line">    idx = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(len(X.shape))]   <span class="comment"># index of dimensions</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i_dim <span class="keyword">in</span> range(self.n_dims):</span><br><span class="line">            </span><br><span class="line">        <span class="comment">## transpose tensor</span></span><br><span class="line">        idx[<span class="number">-1</span>], idx[i_dim + <span class="number">1</span>] = idx[i_dim + <span class="number">1</span>], idx[<span class="number">-1</span>]</span><br><span class="line">        X = X.transpose(idx)</span><br><span class="line">        shape = list(X.shape)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1-dim pca</span></span><br><span class="line">        X = X.reshape((<span class="number">-1</span>, shape[<span class="number">-1</span>]))</span><br><span class="line">        X = self.decomposers[i_dim].transform(X)</span><br><span class="line"></span><br><span class="line">        <span class="comment">## transpose tensor</span></span><br><span class="line">        X = X.reshape(shape[:<span class="number">-1</span>]+[X.shape[<span class="number">-1</span>]])</span><br><span class="line">        X = X.transpose(idx)</span><br><span class="line">        idx[<span class="number">-1</span>], idx[i_dim + <span class="number">1</span>] = idx[i_dim + <span class="number">1</span>], idx[<span class="number">-1</span>]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> X</span><br></pre></td></tr></table></figure><h1 id="实验显示"><a href="#实验显示" class="headerlink" title="实验显示"></a>实验显示</h1><p>将2维数据降维，指定通道维度数目从$3$降至$1$，得到实验结果如下</p><ul><li><p>原始数据<br>  <img src="/2019/04/18/n-dim-Array-PCA/origin_data.png" alt="origin_data"></p></li><li><p>降维后数据<br>  <img src="/2019/04/18/n-dim-Array-PCA/transform.png" alt="transform"></p></li><li><p>重建数据<br>  <img src="/2019/04/18/n-dim-Array-PCA/inv_transform.png" alt="inv_transform"></p></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://zh.wikipedia.org/wiki/%E7%89%B9%E5%BE%81%E8%84%B8" target="_blank" rel="noopener">特征脸 - 维基百科，自由的百科全书</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python字符串格式化</title>
      <link href="/2019/02/19/Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
      <url>/2019/02/19/Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Python操作字符串行云流水，当然也支持格式化字符串。</p><h1 id="通过格式符"><a href="#通过格式符" class="headerlink" title="通过格式符"></a>通过格式符</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;我叫%s, 今年%d岁&quot; % (&#39;Louis Hsu&#39;, 18))</span><br></pre></td></tr></table></figure><p>或者使用字典进行值传递<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;我叫%(name), 今年%(age)岁&quot; % &#123;&#39;name&#39;: &#39;Louis Hsu&#39;, &#39;age&#39;: 18&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>typecode</strong><br>|  格式符 | 含义 |<br>| ——— | ———- |<br>| %s | 字符串 (采用str()的显示) |<br>| %r | 字符串 (采用repr()的显示) |<br>| %c | 单个字符 |<br>| %b | 二进制整数 |<br>| %d | 十进制整数 |<br>| %i | 十进制整数 |<br>| %o | 八进制整数 |<br>| %x | 十六进制整数 |<br>| %e | 指数 (基底写为e) |<br>| %E | 指数 (基底写为E) |<br>| %f | 浮点数 |<br>| %F | 浮点数，与上相同 |<br>| %g | 指数(e)或浮点数 (根据显示长度) |<br>| %G | 指数(E)或浮点数 (根据显示长度) |<br>| %% | 字符”%” | </p><p><strong>高阶</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">% [flags] [width].[precision] typecode</span><br><span class="line">- flags:        &#39;+&#39;(右对齐), &#39;-&#39;(左对齐), &#39; &#39;(左侧填充一个空格，与负数对齐), &#39;0&#39;(用0填充)</span><br><span class="line">- width:        显示宽度</span><br><span class="line">- precision:    小数精度位数，可使用&#39;*&#39;进行动态代入</span><br><span class="line">- typecode:     格式符</span><br></pre></td></tr></table></figure></p><p>例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">print(&#39;pi is %+2.2f&#39; % (3.1415926)) -&gt; pi is +3.14</span><br><span class="line">print(&#39;pi is %-2.2f&#39; % (3.1415926)) -&gt; pi is 3.14</span><br><span class="line">print(&#39;pi is % 2.2f&#39; % (3.1415926)) -&gt; pi is  3.14</span><br><span class="line">print(&#39;pi is %02.2f&#39; % (3.1415926)) -&gt; pi is 3.14</span><br><span class="line"></span><br><span class="line"># 同</span><br><span class="line">print(&#39;pi is %+*.*f&#39; % (2, 2, 3.1415926))</span><br><span class="line">print(&#39;pi is %-*.*f&#39; % (2, 2, 3.1415926))</span><br><span class="line">print(&#39;pi is % *.*f&#39; % (2, 2, 3.1415926))</span><br><span class="line">print(&#39;pi is %0*.*f&#39; % (2, 2, 3.1415926))</span><br></pre></td></tr></table></figure></p><h1 id="通过format"><a href="#通过format" class="headerlink" title="通过format"></a>通过format</h1><h2 id="位置传递"><a href="#位置传递" class="headerlink" title="位置传递"></a>位置传递</h2><ol><li><p>使用位置参数</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; li &#x3D; [&#39;hoho&#39;,18]</span><br><span class="line">&gt;&gt;&gt; &#39;my name is &#123;&#125; ,age &#123;&#125;&#39;.format(&#39;hoho&#39;,18)</span><br><span class="line">&#39;my name is hoho ,age 18&#39;</span><br><span class="line">&gt;&gt;&gt; &#39;my name is &#123;1&#125; ,age &#123;0&#125;&#39;.format(10,&#39;hoho&#39;)</span><br><span class="line">&#39;my name is hoho ,age 10&#39;</span><br><span class="line">&gt;&gt;&gt; &#39;my name is &#123;1&#125; ,age &#123;0&#125; &#123;1&#125;&#39;.format(10,&#39;hoho&#39;)</span><br><span class="line">&#39;my name is hoho ,age 10 hoho&#39;</span><br><span class="line">&gt;&gt;&gt; &#39;my name is &#123;&#125; ,age &#123;&#125;&#39;.format(*li)</span><br><span class="line">&#39;my name is hoho ,age 18&#39;</span><br></pre></td></tr></table></figure></li><li><p>使用关键字参数</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; hash &#x3D; &#123;&#39;name&#39;:&#39;hoho&#39;,&#39;age&#39;:18&#125;</span><br><span class="line">&gt;&gt;&gt; &#39;my name is &#123;name&#125;,age is &#123;age&#125;&#39;.format(name&#x3D;&#39;hoho&#39;,age&#x3D;19)</span><br><span class="line">&#39;my name is hoho,age is 19&#39;</span><br><span class="line">&gt;&gt;&gt; &#39;my name is &#123;name&#125;,age is &#123;age&#125;&#39;.format(**hash)</span><br><span class="line">&#39;my name is hoho,age is 18&#39;</span><br></pre></td></tr></table></figure></li></ol><h2 id="格式限定"><a href="#格式限定" class="headerlink" title="格式限定"></a>格式限定</h2><p>基本格式如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;[:pad][align][sign][typecode]&#125;</span><br><span class="line">- :pad :    填充字符，空白位用该字符填充</span><br><span class="line">- align:    &#39;^&#39;, &#39;&lt;&#39;, &#39;&gt;&#39; 分别表示 &#39;居中&#39;, &#39;左对齐&#39;, &#39;右对齐&#39;(默认)，后面加宽度</span><br><span class="line">- sign :    &#39;+&#39;, &#39;-&#39; , &#39; &#39; 分别表示 &#39;正&#39;, &#39;负&#39;, &#39;正数前加空格&#39;</span><br><span class="line">- typecode: &#39;b&#39;, &#39;d&#39;, &#39;o&#39;, &#39;x&#39;, &#39;f&#39;, &#39;,&#39;, &#39;%&#39;, &#39;e&#39; 分别表示 &#39;二进制&#39;, &#39;十进制&#39;, &#39;八进制&#39;, &#39;十六进制&#39;, &#39;浮点数&#39;, &#39;逗号分隔&#39;, &#39;百分比格式&#39;,  &#39;指数记法&#39;</span><br></pre></td></tr></table></figure></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><blockquote><p>python之字符串格式化(format) - benric - 博客园 <a href="https://www.cnblogs.com/benric/p/4965224.html" target="_blank" rel="noopener">https://www.cnblogs.com/benric/p/4965224.html</a><br>Python format 格式化函数 | 菜鸟教程 <a href="http://www.runoob.com/python/att-string-format.html" target="_blank" rel="noopener">http://www.runoob.com/python/att-string-format.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python命令行参数解析</title>
      <link href="/2019/02/18/Python%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90/"/>
      <url>/2019/02/18/Python%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="C-C-的参数传递"><a href="#C-C-的参数传递" class="headerlink" title="C/C++的参数传递"></a>C/C++的参数传递</h1><p>我们知道C/C++主函数形式如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc,char * argv[],char * envp[])</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中各参数含义如下</p><ul><li><code>argc</code>：<code>argument count</code>，表示参数数量</li><li><code>argv</code>：<code>argument value</code>，表示参数值<br>  最后一个元素存放了一个NULL的指针</li><li><code>envp</code>：系统环境变量<br>  最后一个元素存放了一个NULL的指针</li></ul><p>例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc,char * argv[],char * envp[])</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;argc is %d \n&quot;, argc);</span><br><span class="line"> </span><br><span class="line">    int i;</span><br><span class="line">    for (i&#x3D;0; i&lt;argc; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;arcv[%d] is %s\n&quot;, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (i&#x3D;0; envp[i]!&#x3D;NULL; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;envp[%d] is %s\n&quot;, i, envp[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试平台为Windows10，执行编译和运行操作，结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; gcc main.c -o main.exe</span><br><span class="line">&gt; .&#x2F;main.exe param1 param2 param3 param4</span><br><span class="line">argc is 5</span><br><span class="line">arcv[0] is C:\OneDrive\▒ĵ▒\Louis&#39; Blog\source\_drafts\Python▒▒▒▒▒в▒▒▒▒▒▒▒\test.exe</span><br><span class="line">arcv[1] is param1</span><br><span class="line">arcv[2] is param2</span><br><span class="line">arcv[3] is param3</span><br><span class="line">arcv[4] is param4</span><br><span class="line">envp[0] is ACLOCAL_PATH&#x3D;C:\MyApplications\Git\mingw64\share\aclocal;C:\MyApplica                                                                                                                tions\Git\usr\share\aclocal</span><br><span class="line">envp[1] is ALLUSERSPROFILE&#x3D;C:\ProgramData</span><br><span class="line">...(省略)</span><br><span class="line">envp[71] is WINDIR&#x3D;C:\WINDOWS</span><br><span class="line">envp[72] is _&#x3D;.&#x2F;main.exe</span><br></pre></td></tr></table></figure></p><h1 id="Python的参数传递"><a href="#Python的参数传递" class="headerlink" title="Python的参数传递"></a>Python的参数传递</h1><p>可以使用sys模块得到命令行参数，主函数文件<code>main.py</code>如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    print(sys.argv)</span><br></pre></td></tr></table></figure></p><p>执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; python main.py param1 param2 pram3</span><br><span class="line">[&#39;main.py&#39;, &#39;param1&#39;, &#39;param2&#39;, &#39;pram3&#39;]</span><br></pre></td></tr></table></figure></p><h1 id="getopt"><a href="#getopt" class="headerlink" title="getopt"></a>getopt</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import getopt</span><br><span class="line">import argparse</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    argv &#x3D; sys.argv</span><br><span class="line">    </span><br><span class="line">    if len(argv) &#x3D;&#x3D; 1:</span><br><span class="line">        print(</span><br><span class="line">            &quot;&quot;&quot;</span><br><span class="line">            Usage: python main.py [option]</span><br><span class="line">            -h or --help:    显示帮助信息</span><br><span class="line">            -v or --version: 显示版本</span><br><span class="line">            -i or --input:   指定输入文件路径</span><br><span class="line">            -o or --output:  指定输出文件路径</span><br><span class="line"></span><br><span class="line">            &quot;&quot;&quot;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        opts, args &#x3D; getopt.getopt(args&#x3D;argv[1:],</span><br><span class="line">                                   shortopts&#x3D;&#39;hvi:o:&#39;,</span><br><span class="line">                                   longopts&#x3D;[&#39;help&#39;, &#39;version&#39;, &#39;input&#x3D;&#39;, &#39;output&#x3D;&#39;]</span><br><span class="line">                                )</span><br><span class="line">    except getopt.GetoptError:</span><br><span class="line">        print(&quot;argv error,please input&quot;)</span><br><span class="line">        sys.exit(1)</span><br><span class="line"></span><br><span class="line">    for cmd, arg in opts:</span><br><span class="line"></span><br><span class="line">        if cmd in [&#39;-h&#39;, &#39;--help&#39;]:</span><br><span class="line">            print(&quot;help info&quot;)</span><br><span class="line">            sys.exit(0)</span><br><span class="line">        elif cmd in [&#39;-v&#39;, &#39;--version&#39;]:</span><br><span class="line">            print(&quot;main 1.0&quot;)</span><br><span class="line">            sys.exit(0)</span><br><span class="line"></span><br><span class="line">        if cmd in [&#39;-i&#39;, &#39;--input&#39;]:</span><br><span class="line">            input &#x3D; arg</span><br><span class="line">        if cmd in [&#39;-o&#39;, &#39;--output&#39;]:</span><br><span class="line">            output &#x3D; arg</span><br></pre></td></tr></table></figure><p>说明</p><ul><li><p><code>args=sys.argv[1:]</code><br>  传入的参数，除去<code>sys.argv[0]</code>，即主函数文件路径</p></li><li><p><code>shortopts=&#39;hvi:o:&#39;</code><br>  字符串，支持形如<code>-h</code>的选项</p><ul><li>若无需指定参数，形如<code>c</code>；</li><li>若必须指定参数，则需为<code>c:</code>；</li></ul></li><li><p><code>longopts=[&#39;help&#39;, &#39;version&#39;, &#39;input=&#39;, &#39;output=&#39;]</code><br>  字符串列表，可选参数，是否支持形如<code>--help</code>的选项</p><ul><li>若无需指定参数，形如<code>cmd</code>；</li><li>若必须指定参数，则需为<code>cmd=</code>；</li></ul></li></ul><p>执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; python main.py</span><br><span class="line"></span><br><span class="line">            Usage: python main.py [option]</span><br><span class="line">            -h or --help:    显示帮助信息</span><br><span class="line">            -v or --version: 显示版本</span><br><span class="line">            -i or --input:   指定输入文件路径</span><br><span class="line">            -o or --output:  指定输出文件路径</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; python main.py -h</span><br><span class="line">help info</span><br><span class="line"></span><br><span class="line">&gt; python main.py -v</span><br><span class="line">main 1.0</span><br><span class="line"></span><br><span class="line">&gt; python main.py -i</span><br><span class="line">argv error,please input</span><br><span class="line"></span><br><span class="line">&gt; python main.py -i a.txt -o b.txt</span><br></pre></td></tr></table></figure></p><h1 id="argsparse"><a href="#argsparse" class="headerlink" title="argsparse"></a>argsparse</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import argparse</span><br><span class="line"></span><br><span class="line">def show_args(args):</span><br><span class="line">    if args.opencv:</span><br><span class="line">        print(&quot;opencv is used &quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;opencv is not used &quot;)</span><br><span class="line"></span><br><span class="line">    print(args.steps)</span><br><span class="line">    print(args.file)</span><br><span class="line">    print(args.data)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    parser &#x3D; argparse.ArgumentParser(description&#x3D;&quot;learn to use &#96;argparse&#96;&quot;)</span><br><span class="line"></span><br><span class="line">    # 标志位</span><br><span class="line">    parser.add_argument(&#39;--opencv&#39;, &#39;-cv&#39;, action&#x3D;&#39;store_true&#39;, help&#x3D;&#39;use opencv if set &#39;)</span><br><span class="line">    # 必需参数</span><br><span class="line">    parser.add_argument(&#39;--steps&#39;, &#39;-s&#39;, required&#x3D;True, type&#x3D;int, help&#x3D;&#39;number of steps&#39;)</span><br><span class="line">    # 默认参数</span><br><span class="line">    parser.add_argument(&#39;--file&#39;, &#39;-f&#39;, default&#x3D;&#39;a.txt&#39;)</span><br><span class="line">    # 候选参数</span><br><span class="line">    parser.add_argument(&#39;--data&#39;, &#39;-d&#39;, choices&#x3D;[&#39;data1&#39;, &#39;data2&#39;])</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    args &#x3D; parser.parse_args()</span><br><span class="line">    show_args(args)</span><br></pre></td></tr></table></figure><p>说明</p><ul><li>帮助信息<br>  参数<code>help</code>，用于显示在<code>-h</code>帮助信息中</li><li>标志位参数<br>  参数<code>action=&#39;store_true&#39;</code>，即保存该参数为<code>True</code></li><li>必需参数<br>  置位<code>required</code>，即运行该程序必须带上该参数，否则报错</li><li>默认参数<br>  参数<code>default</code>填写默认参数</li><li>候选参数<br>  参数<code>choices</code>填写候选参数列表</li></ul><p>运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"># 显示帮助信息</span><br><span class="line">&gt; python main.py -h</span><br><span class="line">usage: main.py [-h] [--opencv] --steps STEPS [--file FILE]</span><br><span class="line">               [--data &#123;data1,data2&#125;]</span><br><span class="line"></span><br><span class="line">learn to use &#96;argparse&#96;</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  --opencv, -cv         use opencv if set</span><br><span class="line">  --steps STEPS, -s STEPS</span><br><span class="line">                        number of steps</span><br><span class="line">  --file FILE, -f FILE</span><br><span class="line">  --data &#123;data1,data2&#125;, -d &#123;data1,data2&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 测试必须参数</span><br><span class="line">&gt; python main.py</span><br><span class="line">usage: main.py [-h] [--opencv] --steps STEPS [--file FILE]</span><br><span class="line">               [--data &#123;data1,data2&#125;]</span><br><span class="line">main.py: error: the following arguments are required: --steps&#x2F;-s</span><br><span class="line"></span><br><span class="line">&gt; python main.py -s 100</span><br><span class="line">opencv is not used</span><br><span class="line">100</span><br><span class="line">a.txt</span><br><span class="line">None</span><br><span class="line"></span><br><span class="line"># 测试标志位参数</span><br><span class="line">&gt; python main.py -s 100 -cv</span><br><span class="line">opencv is used</span><br><span class="line">100</span><br><span class="line">a.txt</span><br><span class="line">None</span><br><span class="line"></span><br><span class="line"># 测试默认参数</span><br><span class="line">&gt; python main.py -s 100 -f b.txt</span><br><span class="line">opencv is not used</span><br><span class="line">100</span><br><span class="line">b.txt</span><br><span class="line">None</span><br><span class="line"></span><br><span class="line"># 测试可选参数</span><br><span class="line">&gt; python main.py -s 100 -d data1</span><br><span class="line">opencv is not used</span><br><span class="line">100</span><br><span class="line">a.txt</span><br><span class="line">data1</span><br><span class="line"></span><br><span class="line">&gt; python main.py -s 100 -d data0</span><br><span class="line">usage: main.py [-h] [--opencv] --steps STEPS [--file FILE]</span><br><span class="line">               [--data &#123;data1,data2&#125;]</span><br><span class="line">main.py: error: argument --data&#x2F;-d: invalid choice: &#39;data0&#39; (choose from &#39;data1&#39;, &#39;data2&#39;)</span><br></pre></td></tr></table></figure></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><blockquote><p>Python命令行参数解析：getopt和argparse - 死胖子的博客 - CSDN博客 <a href="https://blog.csdn.net/lanzheng_1113/article/details/77574446" target="_blank" rel="noopener">https://blog.csdn.net/lanzheng_1113/article/details/77574446</a><br>Python模块之命令行参数解析 - 每天进步一点点！！！ - 博客园 <a href="https://www.cnblogs.com/madsnotes/articles/5687079.html" target="_blank" rel="noopener">https://www.cnblogs.com/madsnotes/articles/5687079.html</a><br>Python解析命令行读取参数 — argparse模块 - Arkenstone - 博客园 <a href="https://www.cnblogs.com/arkenstone/p/6250782.html" target="_blank" rel="noopener">https://www.cnblogs.com/arkenstone/p/6250782.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python生成词云图</title>
      <link href="/2019/02/17/Python%E7%94%9F%E6%88%90%E8%AF%8D%E4%BA%91%E5%9B%BE/"/>
      <url>/2019/02/17/Python%E7%94%9F%E6%88%90%E8%AF%8D%E4%BA%91%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一个没什么用的小技能</p><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><blockquote><p>wordcloud · PyPI <a href="https://pypi.org/project/wordcloud/" target="_blank" rel="noopener">https://pypi.org/project/wordcloud/</a></p></blockquote><p>安装该模块<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> pip install wordcloud</span></span><br></pre></td></tr></table></figure></p><p>主要用到的为<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wordcloud.WordCloud(font_path=<span class="keyword">None</span>, width=<span class="number">400</span>, height=<span class="number">200</span>, margin=<span class="number">2</span>,</span><br><span class="line">                ranks_only=<span class="keyword">None</span>, prefer_horizontal=<span class="number">.9</span>, mask=<span class="keyword">None</span>, scale=<span class="number">1</span>,</span><br><span class="line">                color_func=<span class="keyword">None</span>, max_words=<span class="number">200</span>, min_font_size=<span class="number">4</span>,</span><br><span class="line">                stopwords=<span class="keyword">None</span>, random_state=<span class="keyword">None</span>, background_color=<span class="string">'black'</span>,</span><br><span class="line">                max_font_size=<span class="keyword">None</span>, font_step=<span class="number">1</span>, mode=<span class="string">"RGB"</span>,</span><br><span class="line">                relative_scaling=<span class="string">'auto'</span>, regexp=<span class="keyword">None</span>, collocations=<span class="keyword">True</span>,</span><br><span class="line">                colormap=<span class="keyword">None</span>, normalize_plurals=<span class="keyword">True</span>, contour_width=<span class="number">0</span>,</span><br><span class="line">                contour_color=<span class="string">'black'</span>, repeat=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure></p><h1 id="使用例程"><a href="#使用例程" class="headerlink" title="使用例程"></a>使用例程</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</span><br><span class="line"></span><br><span class="line">font = <span class="string">'C:/Windows/Fonts/SIMYOU.TTF'</span>    <span class="comment"># 幼圆</span></span><br><span class="line">string = <span class="string">'LouisHsu 单键 小叔叔 想静静 95后 傲娇 skrrrrrrr 大猫座 佛了 要秃 嘤嘤嘤 真香'</span></span><br><span class="line"></span><br><span class="line">mask = cv2.imread(<span class="string">'./mask.jpg'</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">thresh, mask = cv2.threshold(mask, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line"></span><br><span class="line">wc = WordCloud(</span><br><span class="line">        font_path=font, </span><br><span class="line">        background_color=<span class="string">'white'</span>,</span><br><span class="line">        color_func=<span class="keyword">lambda</span> *args, **kwargs: (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),</span><br><span class="line">        mask=mask,</span><br><span class="line">        max_words=<span class="number">500</span>,</span><br><span class="line">        min_font_size=<span class="number">4</span>,</span><br><span class="line">        max_font_size=<span class="keyword">None</span>,</span><br><span class="line">        contour_width=<span class="number">1</span>,</span><br><span class="line">        repeat=<span class="keyword">True</span>                     <span class="comment"># 允许词重复</span></span><br><span class="line">    )</span><br><span class="line">wc.generate_from_text(string)</span><br><span class="line">wc.to_file(<span class="string">'./wc.jpg'</span>)                  <span class="comment">#保存图片</span></span><br></pre></td></tr></table></figure><p>输入原图为<br><img src="/2019/02/17/Python%E7%94%9F%E6%88%90%E8%AF%8D%E4%BA%91%E5%9B%BE/Python生成词云图/mask.jpg" alt="mask"></p><p>生成图像<br><img src="/2019/02/17/Python%E7%94%9F%E6%88%90%E8%AF%8D%E4%BA%91%E5%9B%BE/Python生成词云图/wc.jpg" alt="wc"></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><blockquote><p>python WordCloud 简单实例 - 博客 - CSDN博客 <a href="https://blog.csdn.net/cy776719526/article/details/80171790" target="_blank" rel="noopener">https://blog.csdn.net/cy776719526/article/details/80171790</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Makefile简单教程</title>
      <link href="/2019/01/05/makefile%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/"/>
      <url>/2019/01/05/makefile%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="准备源文件"><a href="#准备源文件" class="headerlink" title="准备源文件"></a>准备源文件</h1><p>新建目录<code>demo/</code>，其结构如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">demo</span><br><span class="line">├─bin# 二进制文件，即可执行文件</span><br><span class="line">├─include# 头文件&#96;.h&#96;</span><br><span class="line">│      hello.h</span><br><span class="line">│</span><br><span class="line">├─obj# 目标文件&#96;.o&#96;</span><br><span class="line">└─src# 源文件&#96;.c&#96;</span><br><span class="line">        hello.c</span><br><span class="line">        test.c</span><br></pre></td></tr></table></figure></p><p>编辑<code>hello.h</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __HELLO_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HELLO_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __hello();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p>编辑<code>hello.c</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"hello.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __hello()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello world!\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编辑<code>test.h</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"hello.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">__hello();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="命令行编译"><a href="#命令行编译" class="headerlink" title="命令行编译"></a>命令行编译</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  makefile  README.md  test.c</span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc test.c hello.c -o <span class="built_in">test</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  makefile  README.md  test  test.c</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./<span class="built_in">test</span></span></span><br><span class="line">Hello world!</span><br></pre></td></tr></table></figure><p>但是这样编译会每次都重新编译整个工程，时间比较长，所以可以先生成<code>.o</code>文件，当<code>test.c</code>代码改动后，重新生成<code>test.o</code>即可，<code>hello.o</code>不用重新编译<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  makefile  README.md  test.c</span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc test.c hello.c -c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  hello.o  makefile  README.md  test.c  test.o</span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc test.o hello.o -o <span class="built_in">test</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  hello.o  makefile  README.md  test  test.c  test.o</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./<span class="built_in">test</span></span></span><br><span class="line">Hello world!</span><br></pre></td></tr></table></figure></p><h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;target&gt;: &lt;dependencies&gt;</span></span><br><span class="line">&lt;command&gt;<span class="comment"># [TAB]&lt;command&gt;</span></span><br></pre></td></tr></table></figure><p>例如<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">test: test.c</span></span><br><span class="line">gcc test.c -o test</span><br></pre></td></tr></table></figure></p><p>编辑<code>Makefile</code><br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># directories &amp; target name</span></span><br><span class="line">DIR_INC = ./<span class="keyword">include</span>  </span><br><span class="line">DIR_SRC = ./src</span><br><span class="line">DIR_OBJ = ./obj</span><br><span class="line">DIR_BIN = ./bin</span><br><span class="line">TARGET  = test</span><br><span class="line"></span><br><span class="line"><span class="comment"># compile macro  </span></span><br><span class="line">CC = gcc</span><br><span class="line">CFLAGS = -g -Wall -I$&#123;DIR_INC&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">all: $&#123;TARGET&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="section">$&#123;TARGET&#125;: $&#123;DIR_OBJ&#125;/hello.o $&#123;DIR_OBJ&#125;/test.o</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(DIR_OBJ)</span>/hello.o <span class="variable">$(DIR_OBJ)</span>/test.o -o $&#123;TARGET&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">$&#123;DIR_OBJ&#125;/hello.o: <span class="variable">$(DIR_SRC)</span>/hello.c</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(DIR_SRC)</span>/hello.c -o $&#123;DIR_OBJ&#125;/hello.o</span><br><span class="line"></span><br><span class="line"><span class="section">$&#123;DIR_OBJ&#125;/test.o: <span class="variable">$(DIR_SRC)</span>/test.c</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(DIR_SRC)</span>/test.c -o $&#123;DIR_OBJ&#125;/test.o</span><br></pre></td></tr></table></figure></p><p>或通用性格式<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># directories &amp; target name</span></span><br><span class="line">DIR_INC = ./<span class="keyword">include</span>  </span><br><span class="line">DIR_SRC = ./src</span><br><span class="line">DIR_OBJ = ./obj</span><br><span class="line">DIR_BIN = ./bin</span><br><span class="line">TARGET  = test</span><br><span class="line"></span><br><span class="line"><span class="comment"># compile macro  </span></span><br><span class="line">CC      = gcc</span><br><span class="line">CFLAGS  = -g -Wall -I$&#123;DIR_INC&#125;                 <span class="comment"># `-g`表示调试选项，`-Wall`表示编译后显示所有警告</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># load source files</span></span><br><span class="line">SRC = <span class="variable">$(<span class="built_in">wildcard</span> $&#123;DIR_SRC&#125;/*.c)</span>                         <span class="comment"># 匹配目录中所有的`.c`文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># build target</span></span><br><span class="line">OBJ = <span class="variable">$(<span class="built_in">patsubst</span> %.c, $&#123;DIR_OBJ&#125;/%.o, $&#123;<span class="built_in">notdir</span> $&#123;SRC&#125;&#125;)</span>  <span class="comment"># 由`SRC`字符串内容，指定生成`.o`文件的名称与目录</span></span><br><span class="line">BIN = $&#123;DIR_BIN&#125;/$&#123;TARGET&#125;                               <span class="comment"># 指定可执行文件名称与目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># build</span></span><br><span class="line"><span class="section">$&#123;BIN&#125;: $&#123;OBJ&#125;</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(OBJ)</span> -o <span class="variable">$@</span>                               <span class="comment"># 即 `$ gcc ./obj/*.o -o ./bin/test`</span></span><br><span class="line"><span class="section">$&#123;DIR_OBJ&#125;/%.o: $&#123;DIR_SRC&#125;/%.c</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span>                      <span class="comment"># 即 `$ gcc ./src/*.c -g -Wall -I./include -c ./obj/*.o`</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># clean</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean                                            # 伪目标</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">find $&#123;DIR_OBJ&#125; -name *.o -exec rm -rf &#123;&#125; \;</span><br></pre></td></tr></table></figure></p><p>执行<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line">gcc -g -Wall -I./include   -c src/hello.c -o obj/hello.o</span><br><span class="line">gcc -g -Wall -I./include   -c src/test.c -o obj/test.o</span><br><span class="line">gcc  ./obj/hello.o  ./obj/test.o  -o bin/test</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls obj/</span></span><br><span class="line">hello.o  test.o</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls bin/</span></span><br><span class="line">test</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./bin/<span class="built_in">test</span> </span></span><br><span class="line">Hello world!</span><br><span class="line"><span class="meta">$</span><span class="bash"> make clean</span></span><br><span class="line">find ./obj -name *.o -exec rm -rf &#123;&#125; \;</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls obj/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls bin/</span></span><br><span class="line">test</span><br></pre></td></tr></table></figure></p><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ol><li>符号 <code>$@</code>, <code>$^</code>, <code>$&lt;</code>，<code>$?</code><ul><li><code>$@</code>: 表示目标文件</li><li><code>$^</code>: 表示所有的依赖文件</li><li><code>$&lt;</code>: 表示第一个依赖文件</li><li><code>$?</code>: 表示比目标还要新的依赖文件列表</li></ul></li><li><code>wildcard</code>，<code>notdir</code>，<code>patsubst</code><ul><li><code>wildcard</code>    : 扩展通配符<br>  <code>SOURCES = $(wildcard *.c)</code>: 产生一个所有以 ’.c’ 结尾的文件的列表，然后存入变量 SOURCES 里。 </li><li><code>notdir</code>    : 去除路径，可以在使用<code>wildcard</code>函数后，再配合使用<code>notdir</code>函数只得到文件名（不含路径）。</li><li><code>patsubst</code>    : 替换通配符，需要３个参数，第一个是个需要匹配的式样，第二个表示用什么来替换他，第三个是个需要被处理的由空格分隔的字列。<br>  <code>OBJS = $(patsubst %.c,%.o,$(SOURCES))</code><pre><code>  - 将处理所有在 SOURCES 字列中的字（一列文件名），如果他的 结尾是 `.c` ，就用 `.o` 把 `.c`取代  - 这里的 % 符号将匹配一个或多个字符，而他每次所匹配的字串叫做一个‘柄’(stem)   - 在第二个参数里， %被解读成用第一参数所匹配的那个柄。</code></pre></li></ul></li><li><code>-I</code>，<code>-L</code>，<code>-l</code><ul><li><code>-I</code>: 将指定目录作为第一个寻找头文件的目录</li><li><code>-L</code>: 将指定目录作为第一个寻找库文件的目录</li><li><code>-l</code>: 在库文件路径中寻找<code>.so</code>动态库文件（如果gcc编译选项中加入了<code>-static</code>表示寻找<code>.a</code>静态库文件）</li></ul></li><li><code>.PHONY</code>后面的<code>target</code>表示的也是一个伪造的<code>target</code>, 而不是真实存在的文件<code>target</code>，注意<code>Makefile</code>的<code>target</code>默认是文件。</li></ol><h2 id="关于三个函数的使用"><a href="#关于三个函数的使用" class="headerlink" title="关于三个函数的使用"></a>关于三个函数的使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DIR_INC &#x3D; .&#x2F;include</span><br><span class="line">DIR_SRC &#x3D; .&#x2F;src</span><br><span class="line">DIR_OBJ &#x3D; .&#x2F;obj</span><br><span class="line"></span><br><span class="line">SRC &#x3D; $(wildcard $&#123;DIR_SRC&#125;&#x2F;*.c)# 指定编译当前目录下所有&#96;.c&#96;文件，全路径&#96;.&#x2F;src&#x2F;*.c&#96;</span><br><span class="line">DIR &#x3D; $(notdir $&#123;SRC&#125;)# 去除路径名，只留下文件名&#96;*.c&#96;</span><br><span class="line">OBJ &#x3D; $(patsubst %.c, $&#123;DIR_OBJ&#125;&#x2F;%.o, $&#123;DIR&#125;)# 将&#96;DIR&#96;中匹配到的&#96;%.c&#96;，替换为&#96;$&#123;DIR_OBJ&#125;&#x2F;%.o&#96;</span><br><span class="line"></span><br><span class="line">ALL:</span><br><span class="line">@echo $(SRC)</span><br><span class="line">@echo $(DIR)</span><br><span class="line">@echo $(OBJ)</span><br></pre></td></tr></table></figure><p>执行<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line">./src/hello.c ./src/test.c</span><br><span class="line">hello.c test.c</span><br><span class="line">./obj/hello.o ./obj/test.o</span><br></pre></td></tr></table></figure></p><blockquote><p>注：若<code>./src</code>目录下还有子目录<code>./src/inc</code>，则<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SRC = <span class="variable">$(<span class="built_in">wildcard</span> $&#123;DIR_SRC&#125;/*.c)</span> <span class="variable">$(<span class="built_in">wildcard</span> $&#123;DIR_SRC&#125;/inc/*.c)</span></span><br></pre></td></tr></table></figure></p></blockquote><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><blockquote><p>Makefile 使用总结 - wang_yb - 博客园 <a href="https://www.cnblogs.com/wang_yb/p/3990952.html" target="_blank" rel="noopener">https://www.cnblogs.com/wang_yb/p/3990952.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CMake编译库文件</title>
      <link href="/2019/01/05/Cmake%E7%BC%96%E8%AF%91%E5%BA%93%E6%96%87%E4%BB%B6/"/>
      <url>/2019/01/05/Cmake%E7%BC%96%E8%AF%91%E5%BA%93%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>库文件即源代码的二进制文件，我们通常把一些公用函数制作成函数库，供其它程序使用。函数库分为静态库和动态库两种。静态库在程序编译时会被连接到目标代码中，程序运行时将不再需要该静态库；动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入，因此在程序运行时还需要动态库存在。</p><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>以DarkNet为例，我们将其源代码编译成<code>.a</code>静态库文件。</p><ol><li><p>下载源码</p><blockquote><p>YOLO: Real-Time Object Detection <a href="https://pjreddie.com/darknet/yolo/" target="_blank" rel="noopener">https://pjreddie.com/darknet/yolo/</a></p></blockquote> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/pjreddie/darknet</span><br></pre></td></tr></table></figure></li><li><p>整理文件<br> 我们将<code>include/</code>与<code>src/</code>目录复制到新建文件夹<code>darknet/</code>。目录结构如下</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">darknet</span><br><span class="line">├── include</span><br><span class="line">│   └── darknet.h</span><br><span class="line">└── src</span><br><span class="line">    ├── activation_kernels.cu</span><br><span class="line">    ├── activation_layer.c</span><br><span class="line">    ├── activation_layer.h</span><br><span class="line">    ├── ...</span><br><span class="line">    ├── utils.c</span><br><span class="line">    ├── utils.h</span><br><span class="line">    ├── yolo_layer.c</span><br><span class="line">    └── yolo_layer.h</span><br></pre></td></tr></table></figure></li><li><p>在<code>darknet/</code>目录下编写<code>CmakeLists.txt</code>文件，内容如下</p> <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">CMAKE_MINIMUM_REQUIRED(VERSION 2.8)                                <span class="comment"># cmake需要的最小版本号</span></span><br><span class="line">PROJECT(darknet)                                        <span class="comment"># 项目名</span></span><br><span class="line"></span><br><span class="line">MESSAGE(STATUS </span><br><span class="line">    <span class="string">"----------------------------------------------------------------------"</span></span><br><span class="line">)</span><br><span class="line">MESSAGE(STATUS </span><br><span class="line">    <span class="string">"project name:      "</span> $&#123;PROJECT_NAME&#125;           <span class="comment"># cmake默认参数</span></span><br><span class="line">)</span><br><span class="line">MESSAGE(STATUS </span><br><span class="line">    <span class="string">"source directory:  "</span> $&#123;PROJECT_SOURCE_DIR&#125;     <span class="comment"># cmake默认参数</span></span><br><span class="line">)</span><br><span class="line">MESSAGE(STATUS </span><br><span class="line">    <span class="string">"binary directory:  "</span> $&#123;PROJECT_BINARY_DIR&#125;     <span class="comment"># cmake默认参数</span></span><br><span class="line">)</span><br><span class="line">MESSAGE(STATUS </span><br><span class="line">    <span class="string">"----------------------------------------------------------------------"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------------------</span></span><br><span class="line">INCLUDE_DIRECTORIES(                                <span class="comment"># 头文件目录</span></span><br><span class="line">    $&#123;PROJECT_SOURCE_DIR&#125;/<span class="keyword">include</span></span><br><span class="line">    $&#123;PROJECT_SOURCE_DIR&#125;/src</span><br><span class="line">)                                                   </span><br><span class="line">AUX_SOURCE_DIRECTORY(                               <span class="comment"># 源文件</span></span><br><span class="line">    $&#123;PROJECT_SOURCE_DIR&#125;/src </span><br><span class="line">    lib_srcfile</span><br><span class="line">)                                                   </span><br><span class="line">SET(LIBRARY_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/lib)  <span class="comment"># 设置保存`.a`的目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------------------</span></span><br><span class="line">ADD_LIBRARY(                                        <span class="comment"># 生成库文件，可选择`.a`或`.so`</span></span><br><span class="line">    $&#123;PROJECT_NAME&#125;</span><br><span class="line">    STATIC                                          <span class="comment"># `.a`</span></span><br><span class="line">    <span class="comment"># SHARED                                        # `.so`</span></span><br><span class="line">    $&#123;lib_srcfile&#125;</span><br><span class="line">) </span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------------------</span></span><br><span class="line">SET_TARGET_PROPERTIES(</span><br><span class="line">    $&#123;PROJECT_NAME&#125;</span><br><span class="line">    PROPERTIES</span><br><span class="line">    LINKER_LANGUAGE C</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>执行命令<br> 我们在<code>darknet/</code>目录打开终端</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> build</span></span><br><span class="line">/build$ cmake ..</span><br><span class="line">-- The C compiler identification is GNU 7.4.0</span><br><span class="line">-- The CXX compiler identification is GNU 7.4.0</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/louishsu/Work/Codes/MTCNN_Darknet/darknet/build</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line">Scanning dependencies of target darknet</span><br><span class="line">[  2%] Building C object CMakeFiles/darknet.dir/src/activation_layer.c.o</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">[ 97%] Building C object CMakeFiles/darknet.dir/src/yolo_layer.c.o</span><br><span class="line"><span class="meta">[100%</span><span class="bash">] Linking C shared library lib/libdarknet.so</span></span><br><span class="line"><span class="meta">[100%</span><span class="bash">] Built target darknet</span></span><br></pre></td></tr></table></figure></li></ol><p>在<code>darknet/build/lib</code>目录下即可找到<code>libdarknet.a</code>库文件，<code>build</code>目录结构如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">build</span><br><span class="line">└── lib</span><br><span class="line">    └── libdarknet.so (*)</span><br></pre></td></tr></table></figure></p><h1 id="调用库函数"><a href="#调用库函数" class="headerlink" title="调用库函数"></a>调用库函数</h1><p>为测试该库函数是否编译成功，编写测试代码，新建目录<code>/test/</code>，其文件结构为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test</span><br><span class="line">├── include</span><br><span class="line">│   └── test.h</span><br><span class="line">├── src</span><br><span class="line">│   └── test.c</span><br><span class="line">├── build</span><br><span class="line">│   └── test</span><br><span class="line">└── CMakeLists.txt</span><br></pre></td></tr></table></figure></p><p>头文件<code>/include/test.h</code>内容为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TEST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"darknet.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p>源文件<code>/src/test.c</code>内容如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello! Darknet!\n"</span>);</span><br><span class="line">matrix M = make_matrix(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The size of matrix M is %ld bytes\n"</span>, <span class="keyword">sizeof</span>(M));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译文件<code>CMakeLists.txt</code>内容如下<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">CMAKE_MINIMUM_REQUIRED(VERSION 2.8)                        <span class="comment"># cmake需要的最小版本号</span></span><br><span class="line">PROJECT(Test)                               <span class="comment"># 项目名</span></span><br><span class="line"></span><br><span class="line">ADD_DEFINITIONS(-DOPENCV=1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------------------</span></span><br><span class="line">SET(DARKNET ../darknet)</span><br><span class="line">INCLUDE_DIRECTORIES(                                            <span class="comment"># 头文件目录</span></span><br><span class="line">$&#123;DARKNET&#125;/<span class="keyword">include</span></span><br><span class="line">$&#123;DARKNET&#125;/src</span><br><span class="line">)          </span><br><span class="line">LINK_DIRECTORIES(                                               <span class="comment"># 库文件目录</span></span><br><span class="line">    $&#123;DARKNET&#125;/build/lib</span><br><span class="line">)                  </span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------------------</span></span><br><span class="line">INCLUDE_DIRECTORIES(./<span class="keyword">include</span>)                                <span class="comment"># 当前项目头文件目录</span></span><br><span class="line">AUX_SOURCE_DIRECTORY(./src SRC_FILES)                          <span class="comment"># 当前项目源文件目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------------------</span></span><br><span class="line">ADD_EXECUTABLE($&#123;PROJECT_NAME&#125; $&#123;SRC_FILES&#125;)                 <span class="comment"># 添加可执行文件</span></span><br><span class="line">TARGET_LINK_LIBRARIES(<span class="comment"># 引用库</span></span><br><span class="line">$&#123;PROJECT_NAME&#125;</span><br><span class="line">darknet<span class="comment"># darknet</span></span><br><span class="line">m<span class="comment"># 数学函数库</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>执行指令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake ..</span></span><br><span class="line">-- The C compiler identification is GNU 5.4.0</span><br><span class="line">-- The CXX compiler identification is GNU 5.4.0</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/louishsu/Work/Codes/makefile/test/build</span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line">Scanning dependencies of target Test</span><br><span class="line">[ 50%] Building C object CMakeFiles/Test.dir/src/test.c.o</span><br><span class="line"><span class="meta">[100%</span><span class="bash">] Linking C executable Test</span></span><br><span class="line"><span class="meta">[100%</span><span class="bash">] Built target Test</span></span><br></pre></td></tr></table></figure></p><p>运行可执行文件<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./Test</span></span><br><span class="line">Hello! Darknet!</span><br><span class="line">The size of matrix M is 16 bytes</span><br></pre></td></tr></table></figure></p><p>查看结构体<code>matrix</code>定义<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">matrix</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> rows, cols;</span><br><span class="line">    <span class="keyword">float</span> **vals;</span><br><span class="line">&#125; matrix;</span><br></pre></td></tr></table></figure><br><code>int</code>占<code>32bit</code>，<code>float*</code>占<code>64bit</code>，故<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(32bit * 2 + 64bit) &#x2F; 8 &#x3D; 16byte</span><br></pre></td></tr></table></figure><br>运行成功。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><blockquote><p>静态库和动态库的优缺点 - 默默淡然 - 博客园 <a href="https://www.cnblogs.com/liangxiaofeng/p/3228145.html" target="_blank" rel="noopener">https://www.cnblogs.com/liangxiaofeng/p/3228145.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu编译安装Tensorflow</title>
      <link href="/2019/01/04/Ubuntu%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85Tensorflow/"/>
      <url>/2019/01/04/Ubuntu%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85Tensorflow/</url>
      
        <content type="html"><![CDATA[<h1 id="非常重要"><a href="#非常重要" class="headerlink" title="非常重要"></a>非常重要</h1><p>如果中途出现错误，<code>xxxx</code>文件找不到，不要怀疑！就是大天朝的网络问题！推荐科学上网！</p><h1 id="安装CUDA与CUDNN"><a href="#安装CUDA与CUDNN" class="headerlink" title="安装CUDA与CUDNN"></a>安装CUDA与CUDNN</h1><p>首先查看显卡是否支持<code>CUDA</code>加速，输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nvidia-smi</span><br></pre></td></tr></table></figure></p><p><img src="/2019/01/04/Ubuntu%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85Tensorflow/Ubuntu编译安装Tensorflow/nvidia-smi.png" alt="nvidia-smi"></p><p>在<code>Ubuntu16.04 LTS</code>下，推荐安装<code>CUDA9.0</code>和<code>CUDNN 7</code>。</p><p><img src="/2019/01/04/Ubuntu%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85Tensorflow/Ubuntu编译安装Tensorflow/cuda_cudnn1.png" alt="cuda_cudnn1"></p><ul><li><p>CUDA</p><blockquote><p>CUDA Toolkit 9.0 Downloads | NVIDIA Developer <a href="https://developer.nvidia.com/cuda-90-download-archive" target="_blank" rel="noopener">https://developer.nvidia.com/cuda-90-download-archive</a></p></blockquote><p>  <img src="/2019/01/04/Ubuntu%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85Tensorflow/Ubuntu编译安装Tensorflow/cuda.png" alt="cuda"></p><p>  下载<code>.run</code>版本，安装方法如下</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chmod +x cuda_9.0.176_384.81_linux.run </span><br><span class="line">$ sudo sh .&#x2F;cuda_9.0.176_384.81_linux.run</span><br></pre></td></tr></table></figure><p>  服务条款很长。。。。</p></li></ul><ul><li><p>CUDNN</p><blockquote><p>NVIDIA cuDNN | NVIDIA Developer <a href="https://developer.nvidia.com/cudnn" target="_blank" rel="noopener">https://developer.nvidia.com/cudnn</a></p></blockquote><p>  <img src="/2019/01/04/Ubuntu%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85Tensorflow/Ubuntu编译安装Tensorflow/cudnn1.png" alt="cudnn1"></p><p>  <img src="/2019/01/04/Ubuntu%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85Tensorflow/Ubuntu编译安装Tensorflow/cudnn2.png" alt="cudnn2"></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ tar -xzvf cudnn-9.0-linux-x64-v7.4.1.5.tgz</span><br><span class="line">$ sudo cp cuda&#x2F;include&#x2F;cudnn.h &#x2F;usr&#x2F;local&#x2F;cuda&#x2F;include</span><br><span class="line">$ sudo cp cuda&#x2F;lib64&#x2F;libcudnn* &#x2F;usr&#x2F;local&#x2F;cuda&#x2F;lib64</span><br><span class="line">$ sudo chmod a+r &#x2F;usr&#x2F;local&#x2F;cuda&#x2F;include&#x2F;cudnn.h &#x2F;usr&#x2F;local&#x2F;cuda&#x2F;lib64&#x2F;libcudnn*</span><br></pre></td></tr></table></figure><p>  安装后进行验证</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cp -r &#x2F;usr&#x2F;src&#x2F;cudnn_samples_v7&#x2F; $HOME</span><br><span class="line">$ cd  $HOME&#x2F;cudnn_samples_v7&#x2F;mnistCUDNN</span><br><span class="line">$ make clean &amp;&amp; make</span><br><span class="line">$ .&#x2F;mnistCUDNN</span><br></pre></td></tr></table></figure><p>  <img src="/2019/01/04/Ubuntu%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85Tensorflow/Ubuntu编译安装Tensorflow/cuda_cudnn_verifying.png" alt="cuda_cudnn_verifying"></p><p>  <img src="/2019/01/04/Ubuntu%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85Tensorflow/Ubuntu编译安装Tensorflow/cuda_cudnn_verifying2.png" alt="cuda_cudnn_verifying2"></p></li></ul><h1 id="编译Tensorflow-CPU-version"><a href="#编译Tensorflow-CPU-version" class="headerlink" title="编译Tensorflow(CPU version)"></a>编译Tensorflow(CPU version)</h1><p>由于训练代码使用<code>Python</code>实现，故<code>C++</code>版本的<code>Tensorflow</code>不使用<code>GPU</code>，仅实现预测代码即可。</p><h2 id="bazel"><a href="#bazel" class="headerlink" title="bazel"></a>bazel</h2><blockquote><p>Installing Bazel on Ubuntu - Bazel <a href="https://docs.bazel.build/versions/master/install-ubuntu.html" target="_blank" rel="noopener">https://docs.bazel.build/versions/master/install-ubuntu.html</a><br>一定要用源码安装！！！</p></blockquote><p>download the Bazel binary installer named <code>bazel-&lt;version&gt;-installer-linux-x86_64.sh</code> from the <a href="https://github.com/bazelbuild/bazel/releases" target="_blank" rel="noopener">Bazel releases page on GitHub</a>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install pkg-config zip g++ zlib1g-dev unzip python</span><br><span class="line">$ chmod +x bazel-&lt;version&gt;-installer-linux-x86_64.sh</span><br><span class="line">$ .&#x2F;bazel-&lt;version&gt;-installer-linux-x86_64.sh --user</span><br><span class="line">$ sudo nano ~&#x2F;.bashrc # export PATH&#x3D;&quot;$PATH:$HOME&#x2F;bin&quot;</span><br><span class="line">$ source ~&#x2F;.bashrc </span><br><span class="line">$ bazel version</span><br></pre></td></tr></table></figure><p><img src="/2019/01/04/Ubuntu%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85Tensorflow/Ubuntu编译安装Tensorflow/bazel.png" alt="bazel"></p><h2 id="编译CPU版本的CPU"><a href="#编译CPU版本的CPU" class="headerlink" title="编译CPU版本的CPU"></a>编译CPU版本的CPU</h2><p>查看<code>java</code>版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ java -version</span><br><span class="line">openjdk version &quot;1.8.0_191&quot;</span><br><span class="line">OpenJDK Runtime Environment (build 1.8.0_191-8u191-b12-0ubuntu0.16.04.1-b12)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 25.191-b12, mixed mode)</span><br></pre></td></tr></table></figure></p><h2 id="安装依赖软件包环境"><a href="#安装依赖软件包环境" class="headerlink" title="安装依赖软件包环境"></a>安装依赖软件包环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install python3-dev</span><br><span class="line">$ pip3 install six</span><br><span class="line">$ pip3 install numpy</span><br><span class="line">$ pip3 instal wheel</span><br></pre></td></tr></table></figure><h2 id="下载Tensorflow源码"><a href="#下载Tensorflow源码" class="headerlink" title="下载Tensorflow源码"></a>下载<code>Tensorflow</code>源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;tensorflow&#x2F;tensorflow</span><br></pre></td></tr></table></figure><h2 id="编译与安装"><a href="#编译与安装" class="headerlink" title="编译与安装"></a>编译与安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd tensorflow</span><br><span class="line">$ .&#x2F;configure</span><br></pre></td></tr></table></figure><p>配置选项如下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">WARNING: --batch mode is deprecated. Please instead explicitly shut down your Bazel server using the command "bazel shutdown".</span><br><span class="line">INFO: Invocation ID: ce26fc12-2926-4ca7-8775-febc553c8ab5</span><br><span class="line">You have bazel 0.20.0 installed.</span><br><span class="line">Please specify the location of python. [Default is /usr/bin/python]: /usr/bin/python3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Found possible Python library paths:</span><br><span class="line">  /usr/local/lib/python3.5/dist-packages</span><br><span class="line">  /usr/lib/python3/dist-packages</span><br><span class="line">Please input the desired Python library path to use.  Default is [/usr/local/lib/python3.5/dist-packages]</span><br><span class="line"></span><br><span class="line">Do you wish to build TensorFlow with XLA JIT support? [Y/n]: n</span><br><span class="line">No XLA JIT support will be enabled for TensorFlow.</span><br><span class="line"></span><br><span class="line">Do you wish to build TensorFlow with OpenCL SYCL support? [y/N]: n</span><br><span class="line">No OpenCL SYCL support will be enabled for TensorFlow.</span><br><span class="line"></span><br><span class="line">Do you wish to build TensorFlow with ROCm support? [y/N]: n</span><br><span class="line">No ROCm support will be enabled for TensorFlow.</span><br><span class="line"></span><br><span class="line">Do you wish to build TensorFlow with CUDA support? [y/N]: n</span><br><span class="line">No CUDA support will be enabled for TensorFlow.</span><br><span class="line"></span><br><span class="line">Do you wish to download a fresh release of clang? (Experimental) [y/N]: n</span><br><span class="line">Clang will not be downloaded.</span><br><span class="line"></span><br><span class="line">Do you wish to build TensorFlow with MPI support? [y/N]: n</span><br><span class="line">No MPI support will be enabled for TensorFlow.</span><br><span class="line"></span><br><span class="line">Please specify optimization flags to use during compilation when bazel option "--config=opt" is specified [Default is -march=native -Wno-sign-compare]: </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Would you like to interactively configure ./WORKSPACE for Android builds? [y/N]: n</span><br><span class="line">Not configuring the WORKSPACE for Android builds.</span><br><span class="line"></span><br><span class="line">Preconfigured Bazel build configs. You can use any of the below by adding "--config=&lt;&gt;" to your build command. See .bazelrc for more details.</span><br><span class="line">--config=mkl         # Build with MKL support.</span><br><span class="line">--config=monolithic  # Config for mostly static monolithic build.</span><br><span class="line">--config=gdr         # Build with GDR support.</span><br><span class="line">--config=verbs       # Build with libverbs support.</span><br><span class="line">--config=ngraph      # Build with Intel nGraph support.</span><br><span class="line">--config=dynamic_kernels# (Experimental) Build kernels into separate shared objects.</span><br><span class="line">Preconfigured Bazel build configs to DISABLE default on features:</span><br><span class="line">--config=noaws       # Disable AWS S3 filesystem support.</span><br><span class="line">--config=nogcp       # Disable GCP support.</span><br><span class="line">--config=nohdfs      # Disable HDFS support.</span><br><span class="line">--config=noignite    # Disable Apacha Ignite support.</span><br><span class="line">--config=nokafka     # Disable Apache Kafka support.</span><br><span class="line">--config=nonccl      # Disable NVIDIA NCCL support.</span><br><span class="line">Configuration finished</span><br></pre></td></tr></table></figure></p><p>使用<code>bazel</code>编译<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bazel build --config&#x3D;opt &#x2F;&#x2F;tensorflow:libtensorflow_cc.so</span><br></pre></td></tr></table></figure></p><p>出现错误</p><blockquote><p>TF failing to build on Bazel CI · Issue #19464 · tensorflow/tensorflow <a href="https://github.com/tensorflow/tensorflow/issues/19464" target="_blank" rel="noopener">https://github.com/tensorflow/tensorflow/issues/19464</a><br>Failure to build TF 1.12 from source - multiple definitions in grpc · Issue #23402 · tensorflow/tensorflow <a href="https://github.com/tensorflow/tensorflow/issues/23402#issuecomment-436932197" target="_blank" rel="noopener">https://github.com/tensorflow/tensorflow/issues/23402#issuecomment-436932197</a><br>Explicitly import tools/bazel.rc by meteorcloudy · Pull Request #23583 · tensorflow/tensorflow <a href="https://github.com/tensorflow/tensorflow/pull/23583" target="_blank" rel="noopener">https://github.com/tensorflow/tensorflow/pull/23583</a><br>Explicitly import tools/bazel.rc by meteorcloudy · Pull Request #23583 · tensorflow/tensorflow <a href="https://github.com/tensorflow/tensorflow/pull/23583/commits/03e63a291bc95dacaa821585f39a360b43465cb5" target="_blank" rel="noopener">https://github.com/tensorflow/tensorflow/pull/23583/commits/03e63a291bc95dacaa821585f39a360b43465cb5</a></p></blockquote><p>解决方法</p><ul><li>方法1<br>  <img src="/2019/01/04/Ubuntu%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85Tensorflow/Ubuntu编译安装Tensorflow/tools_bazel.rc.png" alt="tools_bazel.rc"></li><li><p>方法2<br>  将<code>tools/bazel.rc</code>中内容粘到<code>.tf_configure.bazelrc</code>中，每次重新配置后需要重新粘贴一次。</p></li><li><p>源码安装<code>protobuf3.6.0</code></p><blockquote><p><a href="https://github.com/protocolbuffers/protobuf" target="_blank" rel="noopener">https://github.com/protocolbuffers/protobuf</a></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;autogen.sh</span><br><span class="line">.&#x2F;configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></blockquote></li></ul><ul><li><p>下载其他文件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;tensorflow&#x2F;contrib&#x2F;makefile&#x2F;download_dependencies.sh</span><br><span class="line">mkdir &#x2F;tmp&#x2F;eigen</span><br></pre></td></tr></table></figure><ul><li><p>值得注意，<code>download_dependencies.sh</code>中下载依赖包时，需要用到<code>curl</code>，但是默认方式安装</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install curl</span><br></pre></td></tr></table></figure><blockquote><p>现在是2018/12/19/02:48，被这个问题折腾了3个小时。</p></blockquote></li></ul></li></ul><pre><code>时不支持`https`协议，故需要安装`OpenSSL`，并源码安装，详细资料见[curl提示不支持https协议解决方法 - 标配的小号 - 博客园](https://www.cnblogs.com/biaopei/p/8669810.html)- 执行`./autogen.sh`时，发生错误`autoreconf: not found`，则安装    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install autoconf aotomake libtool</span><br><span class="line">$ sudo apt install libffi-dev</span><br></pre></td></tr></table></figure></code></pre><ul><li>源码安装<code>Eigen</code>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd tensorflow/contrib/makefile/Downloads/eigen</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></li></ul><h1 id="调用C-版本的Tensorflow"><a href="#调用C-版本的Tensorflow" class="headerlink" title="调用C++版本的Tensorflow"></a>调用C++版本的Tensorflow</h1><p>创建文件目录如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|-- tf_test</span><br><span class="line">    |-- build</span><br><span class="line">    |-- main.cpp</span><br><span class="line">    |-- CMakeLists.txt</span><br></pre></td></tr></table></figure></p><p><code>main.cpp</code>文件内容如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tensorflow/cc/client/client_session.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tensorflow/cc/ops/standard_ops.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tensorflow/core/framework/tensor.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> tensorflow;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> tensorflow::ops;</span><br><span class="line">    Scope root = Scope::NewRootScope();</span><br><span class="line">    <span class="comment">// Matrix A = [3 2; -1 0]</span></span><br><span class="line">    <span class="keyword">auto</span> A = Const(root, &#123; &#123;<span class="number">3.f</span>, <span class="number">2.f</span>&#125;, &#123;<span class="number">-1.f</span>, <span class="number">0.f</span>&#125;&#125;);</span><br><span class="line">    <span class="comment">// Vector b = [3 5]</span></span><br><span class="line">    <span class="keyword">auto</span> b = Const(root, &#123; &#123;<span class="number">3.f</span>, <span class="number">5.f</span>&#125;&#125;);</span><br><span class="line">    <span class="comment">// v = Ab^T</span></span><br><span class="line">    <span class="keyword">auto</span> v = MatMul(root.WithOpName(<span class="string">"v"</span>), A, b, MatMul::TransposeB(<span class="literal">true</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Tensor&gt; outputs;</span><br><span class="line">    <span class="function">ClientSession <span class="title">session</span><span class="params">(root)</span></span>;</span><br><span class="line">    <span class="comment">// Run and fetch v</span></span><br><span class="line">    TF_CHECK_OK(session.Run(&#123;v&#125;, &amp;outputs));</span><br><span class="line">    <span class="comment">// Expect outputs[0] == [19; -3]</span></span><br><span class="line">    LOG(INFO) &lt;&lt; outputs[<span class="number">0</span>].matrix&lt;<span class="keyword">float</span>&gt;();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>CMakeLists.txt</code>内容如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required (VERSION 2.8.8)</span><br><span class="line">project (tf_example)</span><br><span class="line"></span><br><span class="line">set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -g -std&#x3D;c++11 -W&quot;)</span><br><span class="line"></span><br><span class="line">set(EIGEN_DIR &#x2F;usr&#x2F;local&#x2F;include&#x2F;eigen3)</span><br><span class="line">set(PROTOBUF_DIR&#x2F;usr&#x2F;local&#x2F;include&#x2F;google&#x2F;protobuf)</span><br><span class="line">set(TENSORFLOW_DIR &#x2F;home&#x2F;louishsu&#x2F;install&#x2F;tensorflow-1.12.0)</span><br><span class="line"></span><br><span class="line">include_directories(</span><br><span class="line">$&#123;EIGEN_DIR&#125;</span><br><span class="line">$&#123;PROTOBUF_DIR&#125;</span><br><span class="line">   $&#123;TENSORFLOW_DIR&#125;</span><br><span class="line">$&#123;TENSORFLOW_DIR&#125;&#x2F;bazel-genfiles</span><br><span class="line">$&#123;TENSORFLOW_DIR&#125;&#x2F;tensorflow&#x2F;contrib&#x2F;makefile&#x2F;downloads&#x2F;absl</span><br><span class="line">)</span><br><span class="line">link_directories(</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;lib</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">add_executable(</span><br><span class="line">tf_test</span><br><span class="line">main.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">target_link_libraries(</span><br><span class="line">tf_test</span><br><span class="line">tensorflow_cc</span><br><span class="line">tensorflow_framework</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir build &amp;&amp; cd build</span><br><span class="line">$ cmake .. &amp;&amp; make</span><br><span class="line">$ .&#x2F;tf_test</span><br></pre></td></tr></table></figure><h1 id="install-tensorflow-gpu-for-python"><a href="#install-tensorflow-gpu-for-python" class="headerlink" title="install tensorflow-gpu for python"></a>install tensorflow-gpu for python</h1><p>可使用<code>pip</code>指令安装，推荐下载安装包，</p><blockquote><p>tensorflow · PyPI <a href="https://pypi.org/project/tensorflow/" target="_blank" rel="noopener">https://pypi.org/project/tensorflow/</a></p></blockquote><p><img src="/2019/01/04/Ubuntu%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85Tensorflow/Ubuntu编译安装Tensorflow/tensorflow_for_python.png" alt="tensorflow_for_python"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~&#x2F;Downloads</span><br><span class="line">$ pip3 --default-timeout&#x3D;1000 install tensorflow_gpu-1.12.0-cp35-cp35m-manylinux1_x86_64.whl --user</span><br></pre></td></tr></table></figure><p>安装后进行验证<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> python3</span></span><br><span class="line">Python 3.5.2 (default, Nov 12 2018, 13:43:14) </span><br><span class="line">[GCC 5.4.0 20160609] on linux</span><br><span class="line">Type "help", "copyright", "credits" or "license" for more information.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; import tensorflow as tf</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; sess = tf.Session()</span></span><br><span class="line">2018-12-12 11:58:17.817417: I tensorflow/core/platform/cpu_feature_guard.cc:141] Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX2 FMA</span><br><span class="line">2018-12-12 11:58:17.953931: I tensorflow/stream_executor/cuda/cuda_gpu_executor.cc:964] successful NUMA node read from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero</span><br><span class="line">2018-12-12 11:58:17.954686: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1432] Found device 0 with properties: </span><br><span class="line">name: GeForce GT 730M major: 3 minor: 5 memoryClockRate(GHz): 0.758</span><br><span class="line">pciBusID: 0000:04:00.0</span><br><span class="line">totalMemory: 983.44MiB freeMemory: 177.19MiB</span><br><span class="line">2018-12-12 11:58:17.954728: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1511] Adding visible gpu devices: 0</span><br><span class="line">2018-12-12 11:58:18.276013: I tensorflow/core/common_runtime/gpu/gpu_device.cc:982] Device interconnect StreamExecutor with strength 1 edge matrix:</span><br><span class="line">2018-12-12 11:58:18.276057: I tensorflow/core/common_runtime/gpu/gpu_device.cc:988]      0 </span><br><span class="line">2018-12-12 11:58:18.276069: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1001] 0:   N </span><br><span class="line">2018-12-12 11:58:18.276223: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1115] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 131 MB memory) -&gt; physical GPU (device: 0, name: GeForce GT 730M, pci bus id: 0000:04:00.0, compute capability: 3.5)</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a = tf.Variable([233])</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; init = tf.initialize_all_variables()</span></span><br><span class="line">WARNING:tensorflow:From /home/louishsu/.local/lib/python3.5/site-packages/tensorflow/python/util/tf_should_use.py:189: initialize_all_variables (from tensorflow.python.ops.variables) is deprecated and will be removed after 2017-03-02.</span><br><span class="line">Instructions for updating:</span><br><span class="line">Use `tf.global_variables_initializer` instead.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; sess.run(init)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; sess.run(a)</span></span><br><span class="line">array([233], dtype=int32)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; sess.close()</span></span><br></pre></td></tr></table></figure></p><p>注意，如果异常中断程序，显存不会被释放，需要自行<code>kill</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nvidia-smi</span><br></pre></td></tr></table></figure></p><p>获得<code>PID</code>序号，使用指令结束进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kill -9 pid</span><br></pre></td></tr></table></figure></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><blockquote><p>TensorFlow C++动态库编译 - 简书 <a href="https://www.jianshu.com/p/d46596558640" target="_blank" rel="noopener">https://www.jianshu.com/p/d46596558640</a><br>Tensorflow C++ 从训练到部署(1)：环境搭建 | 技术刘 <a href="http://www.liuxiao.org/2018/08/ubuntu-tensorflow-c-%E4%BB%8E%E8%AE%AD%E7%BB%83%E5%88%B0%E9%A2%84%E6%B5%8B1%EF%BC%9A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" target="_blank" rel="noopener">http://www.liuxiao.org/2018/08/ubuntu-tensorflow-c-%E4%BB%8E%E8%AE%AD%E7%BB%83%E5%88%B0%E9%A2%84%E6%B5%8B1%EF%BC%9A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu编译安装OpenCV</title>
      <link href="/2019/01/04/Ubuntu%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85OpenCV/"/>
      <url>/2019/01/04/Ubuntu%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85OpenCV/</url>
      
        <content type="html"><![CDATA[<h1 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h1><blockquote><p>OpenCV library <a href="https://opencv.org/" target="_blank" rel="noopener">https://opencv.org/</a></p></blockquote><h1 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h1><h2 id="依赖软件包"><a href="#依赖软件包" class="headerlink" title="依赖软件包"></a>依赖软件包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install cmake</span><br><span class="line">$ sudo apt-get install build-essential libgtk2.0-dev libavcodec-dev libavformat-dev libjpeg.dev libtiff4.dev libswscale-dev libjasper-dev</span><br></pre></td></tr></table></figure><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ unzip opencv-3.4.4.zip</span><br><span class="line">$ cd opencv-3.4.4</span><br><span class="line">$ mkdir build &amp;&amp; cd build</span><br><span class="line">$ cmake ..</span><br><span class="line">$ make -j4</span><br></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo make install</span><br><span class="line">$ sudo nano &#x2F;etc&#x2F;ld.so.conf.d&#x2F;opencv.conf # add &#96;&#x2F;usr&#x2F;local&#x2F;lib&#96;</span><br><span class="line">$ sudo ldconfig</span><br></pre></td></tr></table></figure><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p><code>OpenCV</code>自带验证程序，在<code>opencv-3.4.4/samples/cpp/example_cmake</code>中可以找到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd opencv-3.4.4&#x2F;samples&#x2F;cpp&#x2F;example_cmake</span><br><span class="line">$ cmake .</span><br><span class="line">$ make</span><br><span class="line">$ .&#x2F;opencv_example</span><br></pre></td></tr></table></figure><p>如果没问题，可以看到你的大脸了~</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><blockquote><p>Ubuntu16.04安装openCV3.4.4 - 辣屁小心的学习笔记 - CSDN博客 <a href="https://blog.csdn.net/weixin_39992397/article/details/84345197" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39992397/article/details/84345197</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python读写配置文件</title>
      <link href="/2019/01/04/Python%E8%AF%BB%E5%86%99%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
      <url>/2019/01/04/Python%E8%AF%BB%E5%86%99%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>在深度学习中，有许多运行参数需要指定，有几种方法可以解决</p><ul><li>定义<code>.py</code>文件存储变量</li><li>定义命名元组<code>collections.namedtuple()</code></li><li>创建<code>.config</code>，<code>.ini</code>等配置文件</li></ul><p>Python 读取写入配置文件很方便，使用内置模块<code>configparser</code>即可</p><h1 id="读出"><a href="#读出" class="headerlink" title="读出"></a>读出</h1><p>首先创建文件<code>test.config</code>或<code>test.ini</code>，写入如下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[db]</span><br><span class="line">db_port &#x3D; 3306</span><br><span class="line">db_user &#x3D; root</span><br><span class="line">db_host &#x3D; 127.0.0.1</span><br><span class="line">db_pass &#x3D; test</span><br><span class="line"></span><br><span class="line">[concurrent]</span><br><span class="line">processor &#x3D; 20</span><br><span class="line">thread &#x3D; 10</span><br></pre></td></tr></table></figure></p><p>读取操作如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import os</span><br><span class="line">&gt;&gt;&gt; import configparser</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; configfile &#x3D; &quot;.&#x2F;test.config&quot;</span><br><span class="line">&gt;&gt;&gt; inifile &#x3D; &quot;.&#x2F;test.ini&quot;</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; cf &#x3D; configparser.ConfigParser()</span><br><span class="line">&gt;&gt;&gt; cf.read(configfile)                     # 读取文件内容</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; sections &#x3D; cf.sections()                # 所有的section，以列表的形式返回</span><br><span class="line">&gt;&gt;&gt; sections</span><br><span class="line">[&#39;db&#39;, &#39;concurrent&#39;]</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; options &#x3D; cf.options(&#39;db&#39;)              # 该section的所有option</span><br><span class="line">&gt;&gt;&gt; options</span><br><span class="line">[&#39;db_port&#39;, &#39;db_user&#39;, &#39;db_host&#39;, &#39;db_pass&#39;]</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; items &#x3D; cf.items(&#39;db&#39;)                  # 该section的所有键值对</span><br><span class="line">&gt;&gt;&gt; items</span><br><span class="line">[(&#39;db_port&#39;, &#39;3306&#39;), (&#39;db_user&#39;, &#39;root&#39;), (&#39;db_host&#39;, &#39;127.0.0.1&#39;), (&#39;db_pass&#39;, &#39;test&#39;)]</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; db_user &#x3D; cf.get(&#39;db&#39;, &#39;db_user&#39;)       # section中option的值，返回为string类型</span><br><span class="line">&gt;&gt;&gt; db_user</span><br><span class="line">&#39;root&#39;</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; db_port &#x3D; cf.getint(&#39;db&#39;, &#39;db_port&#39;)    # 得到section中option的值，返回为int类型</span><br><span class="line">&gt;&gt;&gt;                                         # 类似的还有getboolean()与getfloat()</span><br><span class="line">&gt;&gt;&gt; db_port</span><br><span class="line">3306</span><br></pre></td></tr></table></figure></p><h1 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import os</span><br><span class="line">&gt;&gt;&gt; import configparser</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; cf &#x3D; configparser.ConfigParser()</span><br><span class="line">&gt;&gt;&gt; cf.add_section(&#39;test1&#39;)                 # 新增section</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; cf.set(&quot;test&quot;, &quot;count&quot;, 1)              # 新增option：错误示范</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#7&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    cf.set(&quot;test&quot;, &quot;count&quot;, 1)</span><br><span class="line">  File &quot;C:\MyApplications\Python3\lib\configparser.py&quot;, line 1192, in set</span><br><span class="line">    self._validate_value_types(option&#x3D;option, value&#x3D;value)</span><br><span class="line">  File &quot;C:\MyApplications\Python3\lib\configparser.py&quot;, line 1177, in _validate_value_types</span><br><span class="line">    raise TypeError(&quot;option values must be strings&quot;)</span><br><span class="line">TypeError: option values must be strings</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; cf.set(&quot;test&quot;, &quot;count&quot;, &#39;1&#39;)            # 新增option</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; cf.set(&quot;test1&quot;, &quot;opt1&quot;, &#39;ok&#39;)           # 新增option</span><br><span class="line">&gt;&gt;&gt; cf.remove_option(&quot;test1&quot;, &quot;opt1&quot;)       # 删除option</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; cf.add_section(&#39;test2&#39;)                 # 新增section</span><br><span class="line">&gt;&gt;&gt; cf.remove_section(&#39;test2&#39;)              # 删除section</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; with open(&quot;.&#x2F;test_wr.config&quot;, &#39;w+&#39;) as f:</span><br><span class="line">        cf.write(f)                         # 写入文件test_wr.config</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>现在目录已创建文件<code>test_wr.config</code>，打开可以看到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[test1]</span><br><span class="line">count &#x3D; 1</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python更新安装的包</title>
      <link href="/2019/01/04/Python%E6%9B%B4%E6%96%B0%E5%AE%89%E8%A3%85%E7%9A%84%E5%8C%85/"/>
      <url>/2019/01/04/Python%E6%9B%B4%E6%96%B0%E5%AE%89%E8%A3%85%E7%9A%84%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p><code>pip</code>不提供升级全部已安装模块的方法，以下指令可查看更新信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip list --outdate</span><br></pre></td></tr></table></figure></p><p>得到输出信息如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Package           Version   Latest     Type</span><br><span class="line">----------------- --------- ---------- -----</span><br><span class="line">absl-py           0.3.0     0.6.1      sdist</span><br><span class="line">autopep8          1.3.5     1.4.2      sdist</span><br><span class="line">bleach            2.1.4     3.0.2      wheel</span><br><span class="line">certifi           2018.8.24 2018.10.15 wheel</span><br><span class="line">dask              0.20.0    0.20.1     wheel</span><br><span class="line">grpcio            1.14.1    1.16.0     wheel</span><br><span class="line">ipykernel         5.0.0     5.1.0      wheel</span><br><span class="line">ipython           7.0.1     7.1.1      wheel</span><br><span class="line">jedi              0.12.1    0.13.1     wheel</span><br><span class="line">jupyter-console   5.2.0     6.0.0      wheel</span><br><span class="line">Markdown          2.6.11    3.0.1      wheel</span><br><span class="line">MarkupSafe        1.0       1.1.0      wheel</span><br><span class="line">matplotlib        2.2.2     3.0.2      wheel</span><br><span class="line">mistune           0.8.3     0.8.4      wheel</span><br><span class="line">numpy             1.14.5    1.15.4     wheel</span><br><span class="line">opencv-python     3.4.2.17  3.4.3.18   wheel</span><br><span class="line">Pillow            5.2.0     5.3.0      wheel</span><br><span class="line">prometheus-client 0.3.1     0.4.2      sdist</span><br><span class="line">pyparsing         2.2.0     2.3.0      wheel</span><br><span class="line">python-dateutil   2.7.3     2.7.5      wheel</span><br><span class="line">pytz              2018.5    2018.7     wheel</span><br><span class="line">urllib3           1.23      1.24.1     wheel</span><br></pre></td></tr></table></figure></p><p>以下提供一键升级的方法，可能比较久hhhh<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> call</span><br><span class="line"><span class="keyword">from</span> pip._internal.utils.misc <span class="keyword">import</span> get_installed_distributions</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> dist <span class="keyword">in</span> tqdm(get_installed_distributions()):</span><br><span class="line">    call(<span class="string">"pip install --upgrade &#123;&#125;"</span>.format(dist.project_name), shell=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></p><p>另外，从已有的安装列表，安装所需要的包，可使用以下指令</p><ul><li><p>在已安装的机器中，生成列表</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip freeze &gt; xxx.list</span><br></pre></td></tr></table></figure></li><li><p>在未安装的机器中，使用列表安装</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r xxx.list</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python记录日志</title>
      <link href="/2019/01/04/Python%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97/"/>
      <url>/2019/01/04/Python%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>日志可以用来记录应用程序的状态、错误和信息消息，也经常作为调试程序的工具。<br><code>Python</code>提供了一个标准的日志接口，就是<code>logging</code>模块。日志级别有<code>DEBUG</code>、<code>INFO</code>、<code>WARNING</code>、<code>ERROR</code>、<code>CRITICAL</code>五种。</p><p><a href="https://docs.python.org/3/library/logging.html" target="_blank" rel="noopener">logging — Logging facility for Python — Python 3.7.1 documentation</a></p><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><h2 id="logger对象"><a href="#logger对象" class="headerlink" title="logger对象"></a><code>logger</code>对象</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; import logging</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; logger = logging.getLogger(__name__)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; logger</span></span><br><span class="line">&lt;Logger __main__ (WARNING)&gt;</span><br></pre></td></tr></table></figure><h2 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h2><p>可输出五种不同的日志级别，分别为有<code>DEBUG</code>、<code>INFO</code>、<code>WARNING</code>、<code>ERROR</code>、<code>CRITICAL</code><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; logger.debug(<span class="string">'test log'</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; logger.info(<span class="string">'test log'</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; logger.warning(<span class="string">'test log'</span>)</span></span><br><span class="line">test log</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; logger.error(<span class="string">'test log'</span>)</span></span><br><span class="line">test log</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; logger.critical(<span class="string">'test log'</span>)</span></span><br><span class="line">test log</span><br></pre></td></tr></table></figure></p><p>可以看到只有<code>WARNING</code>及以上级别日志被输出，这是由于默认的日志级别是<code>WARNING</code> ，所以低于此级别的日志不会记录。</p><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.basicConfig(**kwarg)</span><br></pre></td></tr></table></figure><p><code>**kwarg</code>中部分参数如下</p><ul><li><code>format</code>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%(levelname)：日志级别的名字格式</span><br><span class="line">%(levelno)s：日志级别的数字表示</span><br><span class="line">%(name)s：日志名字</span><br><span class="line">%(funcName)s：函数名字</span><br><span class="line">%(asctime)：日志时间，可以使用datefmt去定义时间格式，如上图。</span><br><span class="line">%(pathname)：脚本的绝对路径</span><br><span class="line">%(filename)：脚本的名字</span><br><span class="line">%(module)：模块的名字</span><br><span class="line">%(thread)：thread id</span><br><span class="line">%(threadName)：线程的名字</span><br></pre></td></tr></table></figure></li><li><code>datefmt</code>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;%Y-%m-%d %H:%M:%S&#39;</span><br></pre></td></tr></table></figure></li><li><code>level</code><br>  默认为<code>ERROR</code>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">logging.DEBUG</span><br><span class="line">logging.INFO</span><br><span class="line">logging.WARNING</span><br><span class="line">logging.ERROR</span><br><span class="line">logging.CRITICAL</span><br></pre></td></tr></table></figure></li></ul><p>例如<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="comment"># 未输出debug</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; logger = logging.getLogger()</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; logger.debug(<span class="string">'test log'</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="comment"># 修改配置</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; log_format = <span class="string">'%(filename)s [%(asctime)s] [%(levelname)s] %(message)s'</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; log_datefmt = <span class="string">'%Y-%m-%d %H:%M:%S'</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; log_level = logging.DEBUG</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; logging.basicConfig(format=log_format, </span></span><br><span class="line">                        datefmt=log_datefmt, </span><br><span class="line">                        level=log_level)</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="comment"># 输出debug</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; logger = logging.getLogger()</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; logger.debug(<span class="string">'test log'</span>)</span></span><br><span class="line">&lt;pyshell#8&gt; [2018-11-13 11:59:52] [DEBUG] test log</span><br></pre></td></tr></table></figure></p><h2 id="输出到日志文件"><a href="#输出到日志文件" class="headerlink" title="输出到日志文件"></a>输出到日志文件</h2><p>保存代码为文件<code>log_test.py</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">log_format = <span class="string">'%(filename)s [%(asctime)s] [%(levelname)s] %(message)s'</span></span><br><span class="line">log_datefmt = <span class="string">'%Y-%m-%d %H:%M:%S'</span></span><br><span class="line">log_level = logging.DEBUG</span><br><span class="line">log_filename = <span class="string">'./test.log'</span></span><br><span class="line">log_filemode = <span class="string">'a'</span>  <span class="comment"># 也可以为'w', 'w+'等</span></span><br><span class="line"></span><br><span class="line">logging.basicConfig(format=log_format,</span><br><span class="line">                    datefmt=log_datefmt, </span><br><span class="line">                    level=log_level,</span><br><span class="line">                    filename=log_filename, </span><br><span class="line">                    filemode=log_filemode)</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line">logger.debug(<span class="string">'test log'</span>)</span><br><span class="line">logger.info(<span class="string">'test log'</span>)</span><br><span class="line">logger.warning(<span class="string">'test log'</span>)</span><br><span class="line">logger.error(<span class="string">'test log'</span>)</span><br><span class="line">logger.critical(<span class="string">'test log'</span>)</span><br></pre></td></tr></table></figure></p><p>运行完毕，打开<code>log_test.log</code>文件可以看到<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">log_test.py [2018-11-13 12:11:04] [DEBUG] test log</span><br><span class="line">log_test.py [2018-11-13 12:11:04] [INFO] test log</span><br><span class="line">log_test.py [2018-11-13 12:11:04] [WARNING] test log</span><br><span class="line">log_test.py [2018-11-13 12:11:04] [ERROR] test log</span><br><span class="line">log_test.py [2018-11-13 12:11:04] [CRITICAL] test log</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Github博客搭建</title>
      <link href="/2019/01/04/Github-Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2019/01/04/Github-Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>那么问题来了，现有的博客还是现有的这篇文章呢？</p><h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><p>安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">node.js</a>, <a href="https://git-scm.com/" target="_blank" rel="noopener">git</a>, <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo</a></p><h1 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>推荐使用<code>git</code>命令窗口，执行如下指令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir Blog</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> Blog</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo init</span></span><br><span class="line">INFO  Cloning hexo-starter to ~\Desktop\Blog</span><br><span class="line">Cloning into 'C:\Users\LouisHsu\Desktop\Blog'...</span><br><span class="line">remote: Enumerating objects: 68, done.</span><br><span class="line">remote: Total 68 (delta 0), reused 0 (delta 0), pack-reused 68</span><br><span class="line">Unpacking objects: 100% (68/68), done.</span><br><span class="line">Submodule 'themes/landscape' (https://github.com/hexojs/hexo-theme-landscape.git) registered for path 'themes/landscape'</span><br><span class="line">Cloning into 'C:/Users/LouisHsu/Desktop/Blog/themes/landscape'...</span><br><span class="line">remote: Enumerating objects: 1, done.</span><br><span class="line">remote: Counting objects: 100% (1/1), done.</span><br><span class="line">remote: Total 867 (delta 0), reused 0 (delta 0), pack-reused 866</span><br><span class="line">Receiving objects: 100% (867/867), 2.55 MiB | 494.00 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (459/459), done.</span><br><span class="line">Submodule path 'themes/landscape': checked out '73a23c51f8487cfcd7c6deec96ccc7543960d350'</span><br><span class="line">Install dependencies</span><br><span class="line">npm WARN deprecated titlecase@1.1.2: no longer maintained</span><br><span class="line">npm WARN deprecated postinstall-build@5.0.3: postinstall-build's behavior is now built into npm! You should migrate off of postinstall-build and use the new `prepare` lifecycle script with npm 5.0.0 or greater.</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> nunjucks@3.1.6 postinstall C:\Users\LouisHsu\Desktop\Blog\node_modules\nunjucks</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> node postinstall-build.js src</span></span><br><span class="line"></span><br><span class="line">npm notice created a lockfile as package-lock.json. You should commit this file.</span><br><span class="line">npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.4 (node_modules\fsevents):</span><br><span class="line">npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.4: wanted &#123;"os":"darwin","arch":"any"&#125; (current: &#123;"os":"win32","arch":"x64"&#125;)</span><br><span class="line"></span><br><span class="line">added 422 packages from 501 contributors and audited 4700 packages in 59.195s</span><br><span class="line">found 0 vulnerabilities</span><br><span class="line"></span><br><span class="line">INFO  Start blogging with Hexo!</span><br></pre></td></tr></table></figure></p><p>生成目录结构如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\-- scaffolds</span><br><span class="line">\-- source</span><br><span class="line">    \-- _posts</span><br><span class="line">\-- themes</span><br><span class="line">|-- _config.yml</span><br><span class="line">|-- package.json</span><br></pre></td></tr></table></figure></p><p>继续<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br><span class="line">npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.4 (node_modules\fsevents):</span><br><span class="line">npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.4: wanted &#123;"os":"darwin","arch":"any"&#125; (current: &#123;"os":"win32","arch":"x64"&#125;)</span><br><span class="line"></span><br><span class="line">audited 4700 packages in 5.99s</span><br><span class="line">found 0 vulnerabilities</span><br></pre></td></tr></table></figure></p><p>现在该目录执行指令，开启<code>hexo</code>服务器<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo s</span></span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure><br><img src="/2019/01/04/Github-Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Github-Hexo博客搭建/hexo_server.png" alt="hexo_server"></p><h2 id="生成目录和标签"><a href="#生成目录和标签" class="headerlink" title="生成目录和标签"></a>生成目录和标签</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo n page about</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo n page archives</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo n page categories</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo n page tags</span></span><br></pre></td></tr></table></figure><p>修改<code>/source/tags/index.md</code>，其他同理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">01| ---</span><br><span class="line">02| title: tags</span><br><span class="line">03| date: 2019-01-04 17:34:15</span><br><span class="line">04| ---</span><br><span class="line"></span><br><span class="line">-&gt;</span><br><span class="line"></span><br><span class="line">01| ---</span><br><span class="line">02| title: tags</span><br><span class="line">03| date: 2019-01-04 17:34:15</span><br><span class="line">04| type: &quot;tags&quot;</span><br><span class="line">05| comments: false</span><br><span class="line">06| ---</span><br></pre></td></tr></table></figure></p><h2 id="关联Github"><a href="#关联Github" class="headerlink" title="关联Github"></a>关联<code>Github</code></h2><p>在<code>Github</code>新建一个仓库，命名为<code>username.github.io</code>，例如<code>isLouisHsu.github.io</code>，新建时勾选<code>Initialize this repository with a README</code>，因为这个仓库必须不能为空。<br><img src="/2019/01/04/Github-Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Github-Hexo博客搭建/github_io.png" alt="github_io"></p><p>打开博客目录下的<code>_config.yml</code>配置文件，定位到最后的<code>deploy</code>选项，修改如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repository: git@github.com:isLouisHsu&#x2F;isLouisHsu.github.io.git</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure></p><p>安装插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><p>现在就可以将该目录内容推送到<code>Github</code>新建的仓库中了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure></p><h2 id="使用个人域名"><a href="#使用个人域名" class="headerlink" title="使用个人域名"></a>使用个人域名</h2><ol><li>在<code>source</code>目录下新建文件<code>CNAME</code>，输入解析后的个人域名</li><li>在<code>Github</code>主页修改域名</li></ol><h1 id="备份博客"><a href="#备份博客" class="headerlink" title="备份博客"></a>备份博客</h1><blockquote><p>没。没什么用<br>我。我不备份了<br>可以新建一个仓库专门保存文件试试</p></blockquote><p>现在博客的源文件仅保存在<code>PC</code>上， 我们对它们进行备份，并将仓库作为博客文件夹</p><ol><li>在仓库新建分支<code>hexo</code>，设置为默认分支<br> <img src="/2019/01/04/Github-Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Github-Hexo博客搭建/create_branch_hexo.png" alt="create_branch_hexo"><br> <img src="/2019/01/04/Github-Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Github-Hexo博客搭建/change_branch_hexo.png" alt="change_branch_hexo"></li><li>将仓库克隆至本地 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;isLouisHsu&#x2F;isLouisHsu.github.io.git</span><br></pre></td></tr></table></figure></li><li>克隆文件<br> 将之前的Hexo文件夹中的 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scffolds&#x2F;</span><br><span class="line">source&#x2F;</span><br><span class="line">themes&#x2F;</span><br><span class="line">.gitignore</span><br><span class="line">_config.yml</span><br><span class="line">package.json</span><br></pre></td></tr></table></figure> 复制到克隆下来的仓库文件夹<code>isLouisHsu.github.io</code><br> <img src="/2019/01/04/Github-Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Github-Hexo博客搭建/backup_blog.png" alt="backup_blog"></li><li><p>安装包</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br><span class="line">$ npm install hexo --save</span><br><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p> 备份博客使用以下指令</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -m &quot;backup&quot;</span><br><span class="line">$ git push origin hexo</span><br></pre></td></tr></table></figure></li><li><p>部署博客指令</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure></li><li><p><code>单键</code>提交<br> 编写脚本<code>commit.bat</code>，双击即可</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &#39;backup&#39;</span><br><span class="line">git push origin hexo</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure></li></ol><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><ul><li><p>目录结构</p><ul><li><code>public</code>  生成的网站文件，发布的站点文件。</li><li><code>source</code>  资源文件夹，用于存放内容。</li><li><code>tag</code>     标签文件夹。</li><li><code>archive</code> 归档文件夹。</li><li><code>category</code>分类文件夹。</li><li><code>downloads/code include code</code>文件夹。</li><li><code>:lang i18n_dir</code> 国际化文件夹。</li><li><code>_config.yml</code> 配置文件</li></ul></li><li><p>指令</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ hexo help</span><br><span class="line">Usage: hexo &lt;command&gt;</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">    clean     Remove generated files and cache.</span><br><span class="line">    config    Get or set configurations.</span><br><span class="line">    deploy    Deploy your website.</span><br><span class="line">    generate  Generate static files.</span><br><span class="line">    help      Get help on a command.</span><br><span class="line">    init      Create a new Hexo folder.</span><br><span class="line">    list      List the information of the site</span><br><span class="line">    migrate   Migrate your site from other system to Hexo.</span><br><span class="line">    new       Create a new post.</span><br><span class="line">    publish   Moves a draft post from _drafts to _posts folder.</span><br><span class="line">    render    Render files with renderer plugins.</span><br><span class="line">    server    Start the server.</span><br><span class="line">    version   Display version information.</span><br><span class="line"></span><br><span class="line">Global Options:</span><br><span class="line">    --config  Specify config file instead of using _config.yml</span><br><span class="line">    --cwd     Specify the CWD</span><br><span class="line">    --debug   Display all verbose messages in the terminal</span><br><span class="line">    --draft   Display draft posts</span><br><span class="line">    --safe    Disable all plugins and scripts</span><br><span class="line">    --silent  Hide output on console</span><br><span class="line"></span><br><span class="line">For more help, you can use &#39;hexo help [command]&#39; for the detailed information or you can check the docs: http:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;</span><br></pre></td></tr></table></figure></li></ul><!-- # 修改主题 --><h1 id="拓展功能支持"><a href="#拓展功能支持" class="headerlink" title="拓展功能支持"></a>拓展功能支持</h1><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>修改文件<code>_config.yml</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure><br>在执行<code>$ hexo n [layout] &lt;title&gt;</code>时会生成同名文件夹，把图片放在这个文件夹内，在<code>.md</code>文件中插入图片<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![image_name](&#x2F;title&#x2F;image_name.png)</span><br></pre></td></tr></table></figure></p><h2 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br><span class="line">$ npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><p>站点配置文件<code>_config.yml</code>中添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure><br>修改主题配置文件<code>/themes/xxx/_config.yml</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure></p><h2 id="带过滤功能的首页插件"><a href="#带过滤功能的首页插件" class="headerlink" title="带过滤功能的首页插件"></a>带过滤功能的首页插件</h2><p>在首页只显示指定分类下面的文章列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-index2 --save</span><br><span class="line">$ npm uninstall hexo-generator-index --save</span><br></pre></td></tr></table></figure><br>修改<code>_config.yml</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">index_generator:</span><br><span class="line">  per_page: 10</span><br><span class="line">  order_by: -date</span><br><span class="line">  include:</span><br><span class="line">    - category Web  # 只包含Web分类下的文章</span><br><span class="line">  exclude:</span><br><span class="line">    - tag Hexo      # 不包含标签为Hexo的文章</span><br></pre></td></tr></table></figure></p><h2 id="数学公式支持"><a href="#数学公式支持" class="headerlink" title="数学公式支持"></a>数学公式支持</h2><p><code>hexo</code>默认的渲染引擎是<code>marked</code>，但是<code>marked</code>不支持<code>mathjax</code>。<code>kramed</code>是在<code>marked</code>的基础上进行修改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ npm uninstall hexo-math --save              # 停止使用 hexo-math</span><br><span class="line">$ npm install hexo-renderer-mathjax --save    # 安装hexo-renderer-mathjax包：</span><br><span class="line">$ npm uninstall hexo-renderer-marked --save   # 卸载原来的渲染引擎</span><br><span class="line">$ npm install hexo-renderer-kramed --save     # 安装新的渲染引擎</span><br></pre></td></tr></table></figure><br>修改<code>/node_modules/kramed/lib/rules/inline.js</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">11| escape: &#x2F;^\\([\\&#96;*&#123;&#125;\[\]()#$+\-.!_&gt;])&#x2F;,</span><br><span class="line">...</span><br><span class="line">20| em: &#x2F;^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)&#x2F;,</span><br><span class="line"></span><br><span class="line">-&gt;</span><br><span class="line"></span><br><span class="line">11| escape: &#x2F;^\\([&#96;*\[\]()#$+\-.!_&gt;])&#x2F;,</span><br><span class="line">...</span><br><span class="line">20| em: &#x2F;^\*((?:\*\*|[\s\S])+?)\*(?!\*)&#x2F;,</span><br></pre></td></tr></table></figure><br>修改<code>/node_modules/hexo-renderer-kramed/lib/renderer.js</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">64| &#x2F;&#x2F; Change inline math rule</span><br><span class="line">65| function formatText(text) &#123;</span><br><span class="line">66|   &#x2F;&#x2F; Fit kramed&#39;s rule: $$ + \1 + $$</span><br><span class="line">67|   return text.replace(&#x2F;&#96;\$(.*?)\$&#96;&#x2F;g, &#39;$$$$$1$$$$&#39;);</span><br><span class="line">68| &#125;</span><br><span class="line"></span><br><span class="line">-&gt;</span><br><span class="line"></span><br><span class="line">64| &#x2F;&#x2F; Change inline math rule</span><br><span class="line">65| function formatText(text) &#123;</span><br><span class="line">66|   &#x2F;&#x2F; Fit kramed&#39;s rule: $$ + \1 + $$</span><br><span class="line">67|   &#x2F;&#x2F; return text.replace(&#x2F;&#96;\$(.*?)\$&#96;&#x2F;g, &#39;$$$$$1$$$$&#39;);</span><br><span class="line">68|   return text;</span><br><span class="line">69| &#125;</span><br></pre></td></tr></table></figure><br>在主题中开启<code>mathjax</code>开关，例如<code>next</code>主题中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># MathJax Support</span><br><span class="line">mathjax:</span><br><span class="line">  enable: true</span><br><span class="line">  per_page: true</span><br></pre></td></tr></table></figure><br>在文章中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: title.md</span><br><span class="line">date: 2019-01-04 12:47:37</span><br><span class="line">categories:</span><br><span class="line">tags:</span><br><span class="line">mathjax: true</span><br><span class="line">top:</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>测试</p><script type="math/tex; mode=display">A = \left[\begin{matrix}    a_{11} & a_{12} \\    a_{21} & a_{22}\end{matrix}\right]</script><h2 id="背景图片更换"><a href="#背景图片更换" class="headerlink" title="背景图片更换"></a>背景图片更换</h2><p>在主题配置文件夹中，如<code>next</code>主题，打开文件<code>hexo-theme-next/source/css/_custom/custom.styl</code>，修改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Custom styles.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加背景图片</span><br><span class="line">body &#123;</span><br><span class="line">  background: url(&#x2F;images&#x2F;background.jpg);</span><br><span class="line">  background-size: cover;</span><br><span class="line">  background-repeat: no-repeat;</span><br><span class="line">  background-attachment: fixed;</span><br><span class="line">  background-position: 50% 50%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 修改主体透明度</span><br><span class="line">.main-inner &#123;</span><br><span class="line">  background: #fff;</span><br><span class="line">  opacity: 0.95;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 修改菜单栏透明度</span><br><span class="line">.header-inner &#123;</span><br><span class="line">  opacity: 0.95;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="背景音乐"><a href="#背景音乐" class="headerlink" title="背景音乐"></a>背景音乐</h2><p>首先生成外链</p><p><img src="/2019/01/04/Github-Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Github-Hexo博客搭建/bgm1.jpg" alt="bgm1"></p><p><img src="/2019/01/04/Github-Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Github-Hexo博客搭建/bgm2.jpg" alt="bgm2"></p><p>添加到合适位置，如<code>Links</code>一栏后</p><p><img src="/2019/01/04/Github-Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Github-Hexo博客搭建/bgm3.jpg" alt="bgm3"></p><h2 id="鼠标特效"><a href="#鼠标特效" class="headerlink" title="鼠标特效"></a>鼠标特效</h2><ol><li><p><a href="https://github.com/hustcc/canvas-nest.js" target="_blank" rel="noopener">hustcc/canvas-nest.js</a></p></li><li><p>点击文本特效<br>新建<code>hexo-theme-next/source/js/click_show_text.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a_idx = <span class="number">0</span>;</span><br><span class="line">jQuery(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123;</span><br><span class="line">    $(<span class="string">"body"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span></span><br><span class="line">        (<span class="string">"for"</span>, <span class="string">"while"</span>, <span class="string">"catch"</span>, <span class="string">"except"</span>, <span class="string">"if"</span>, <span class="string">"range"</span>, </span><br><span class="line">        <span class="string">"class"</span>, <span class="string">"min"</span>, <span class="string">"max"</span>, <span class="string">"sort"</span>, <span class="string">"map"</span>, <span class="string">"filter"</span>, </span><br><span class="line">        <span class="string">"lambda"</span>, <span class="string">"switch"</span>, <span class="string">"case"</span>, <span class="string">"iter"</span>, <span class="string">"next"</span>, <span class="string">"enum"</span>, <span class="string">"struct"</span>,  </span><br><span class="line">        <span class="string">"void"</span>, <span class="string">"int"</span>, <span class="string">"float"</span>, <span class="string">"double"</span>, <span class="string">"char"</span>, <span class="string">"signed"</span>, <span class="string">"unsigned"</span>);</span><br><span class="line">        <span class="keyword">var</span> $i = $(<span class="string">"&lt;span/&gt;"</span>).text(a[a_idx]);</span><br><span class="line">        a_idx = (a_idx + <span class="number">3</span>) % a.length;</span><br><span class="line">        <span class="keyword">var</span> x = e.pageX, </span><br><span class="line">        y = e.pageY;</span><br><span class="line">        $i.css(&#123;</span><br><span class="line">            <span class="string">"z-index"</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="string">"top"</span>: y - <span class="number">20</span>,</span><br><span class="line">            <span class="string">"left"</span>: x,</span><br><span class="line">            <span class="string">"position"</span>: <span class="string">"absolute"</span>,</span><br><span class="line">            <span class="string">"font-weight"</span>: <span class="string">"bold"</span>,</span><br><span class="line">            <span class="string">"color"</span>: <span class="string">"#333333"</span></span><br><span class="line">        &#125;);</span><br><span class="line">        $(<span class="string">"body"</span>).append($i);</span><br><span class="line">        $i.animate(&#123;</span><br><span class="line">            <span class="string">"top"</span>: y - <span class="number">180</span>,</span><br><span class="line">            <span class="string">"opacity"</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="number">3000</span>,</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $i.remove();</span><br><span class="line">&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    setTimeout(<span class="string">'delay()'</span>, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">".buryit"</span>).removeAttr(<span class="string">"onclick"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>在文件<code>hexo-theme-next/layout/_layout.swig</code>中添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">...</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;js&#x2F;click_show_text.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure></p><h2 id="看板娘"><a href="#看板娘" class="headerlink" title="看板娘"></a>看板娘</h2><p><a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener">xiazeyu/live2d-widget-models</a>，预览效果见<a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">作者博客</a>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br><span class="line">npm install live2d-widget-model-hijiki</span><br></pre></td></tr></table></figure><p>站点配置文件添加<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">live2d:</span></span><br><span class="line"><span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">scriptFrom:</span> <span class="string">local</span></span><br><span class="line"><span class="attr">model:</span> </span><br><span class="line"><span class="attr">use:</span> <span class="string">live2d-widget-model-hijiki</span> <span class="comment">#模型选择</span></span><br><span class="line"><span class="attr">display:</span> </span><br><span class="line"><span class="attr">position:</span> <span class="string">right</span>  <span class="comment">#模型位置</span></span><br><span class="line"><span class="attr">width:</span> <span class="number">150</span>       <span class="comment">#模型宽度</span></span><br><span class="line"><span class="attr">height:</span> <span class="number">300</span>      <span class="comment">#模型高度</span></span><br><span class="line"><span class="attr">mobile:</span> </span><br><span class="line"><span class="attr">show:</span> <span class="literal">false</span>      <span class="comment">#是否在手机端显示</span></span><br></pre></td></tr></table></figure></p><h2 id="人体时钟"><a href="#人体时钟" class="headerlink" title="人体时钟"></a>人体时钟</h2><p>新建<code>hexo-theme-next/source/js/honehone_clock_tr.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment">初期設定</span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="keyword">var</span> swfUrl = <span class="string">"http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_tr.swf"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> swfTitle = <span class="string">"honehoneclock"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 実行</span></span><br><span class="line">LoadBlogParts();</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment">入力なし</span></span><br><span class="line"><span class="comment">出力document.writeによるHTML出力</span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LoadBlogParts</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> sUrl = swfUrl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sHtml = <span class="string">""</span>;</span><br><span class="line">sHtml += <span class="string">'&lt;object classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" codebase="http://fpdownload.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=8,0,0,0" width="160" height="70" id="'</span> + swfTitle + <span class="string">'" align="middle"&gt;'</span>;</span><br><span class="line">sHtml += <span class="string">'&lt;param name="allowScriptAccess" value="always" /&gt;'</span>;</span><br><span class="line">sHtml += <span class="string">'&lt;param name="movie" value="'</span> + sUrl + <span class="string">'" /&gt;'</span>;</span><br><span class="line">sHtml += <span class="string">'&lt;param name="quality" value="high" /&gt;'</span>;</span><br><span class="line">sHtml += <span class="string">'&lt;param name="bgcolor" value="#ffffff" /&gt;'</span>;</span><br><span class="line">sHtml += <span class="string">'&lt;param name="wmode" value="transparent" /&gt;'</span>;</span><br><span class="line">sHtml += <span class="string">'&lt;embed wmode="transparent" src="'</span> + sUrl + <span class="string">'" quality="high" bgcolor="#ffffff" width="160" height="70" name="'</span> + swfTitle + <span class="string">'" align="middle" allowScriptAccess="always" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" /&gt;'</span>;</span><br><span class="line">sHtml += <span class="string">'&lt;/object&gt;'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(sHtml);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script charset&#x3D;&quot;Shift_JIS&quot; src&#x3D;&quot;&#x2F;js&#x2F;honehone_clock_tr.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="代码雨"><a href="#代码雨" class="headerlink" title="代码雨"></a>代码雨</h2><p>新建<code>hexo-theme-next/source/js/digital_rain.js</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//获取画布对象</span></span><br><span class="line">    <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">"canvas"</span>);</span><br><span class="line">    <span class="comment">//获取画布的上下文</span></span><br><span class="line">    <span class="keyword">var</span> context =canvas.getContext(<span class="string">"2d"</span>);</span><br><span class="line">    <span class="keyword">var</span> s = <span class="built_in">window</span>.screen;</span><br><span class="line">    <span class="keyword">var</span> W = canvas.width = s.width;</span><br><span class="line">    <span class="keyword">var</span> H = canvas.height;</span><br><span class="line">    <span class="comment">//获取浏览器屏幕的宽度和高度</span></span><br><span class="line">    <span class="comment">//var W = window.innerWidth;</span></span><br><span class="line">    <span class="comment">//var H = window.innerHeight;</span></span><br><span class="line">    <span class="comment">//设置canvas的宽度和高度</span></span><br><span class="line">    canvas.width = W;</span><br><span class="line">    canvas.height = H;</span><br><span class="line">    <span class="comment">//每个文字的字体大小</span></span><br><span class="line">    <span class="keyword">var</span> fontSize = <span class="number">12</span>;</span><br><span class="line">    <span class="comment">//计算列</span></span><br><span class="line">    <span class="keyword">var</span> colunms = <span class="built_in">Math</span>.floor(W /fontSize);</span><br><span class="line">    <span class="comment">//记录每列文字的y轴坐标</span></span><br><span class="line">    <span class="keyword">var</span> drops = [];</span><br><span class="line">    <span class="comment">//给每一个文字初始化一个起始点的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;colunms;i++)&#123;</span><br><span class="line">        drops.push(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//运动的文字</span></span><br><span class="line">    <span class="keyword">var</span> str =<span class="string">"WELCOME TO WWW.ITRHX.COM"</span>;</span><br><span class="line">    <span class="comment">//4:fillText(str,x,y);原理就是去更改y的坐标位置</span></span><br><span class="line">    <span class="comment">//绘画的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        context.fillStyle = <span class="string">"rgba(238,238,238,.08)"</span>;<span class="comment">//遮盖层</span></span><br><span class="line">        context.fillRect(<span class="number">0</span>,<span class="number">0</span>,W,H);</span><br><span class="line">        <span class="comment">//给字体设置样式</span></span><br><span class="line">        context.font = <span class="string">"600 "</span>+fontSize+<span class="string">"px  Georgia"</span>;</span><br><span class="line">        <span class="comment">//给字体添加颜色</span></span><br><span class="line">        context.fillStyle = [<span class="string">"#33B5E5"</span>, <span class="string">"#0099CC"</span>, <span class="string">"#AA66CC"</span>, <span class="string">"#9933CC"</span>, <span class="string">"#99CC00"</span>, <span class="string">"#669900"</span>, <span class="string">"#FFBB33"</span>, <span class="string">"#FF8800"</span>, <span class="string">"#FF4444"</span>, <span class="string">"#CC0000"</span>][<span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">10</span>)];<span class="comment">//randColor();可以rgb,hsl, 标准色，十六进制颜色</span></span><br><span class="line">        <span class="comment">//写入画布中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;colunms;i++)&#123;</span><br><span class="line">            <span class="keyword">var</span> index = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * str.length);</span><br><span class="line">            <span class="keyword">var</span> x = i*fontSize;</span><br><span class="line">            <span class="keyword">var</span> y = drops[i] *fontSize;</span><br><span class="line">            context.fillText(str[index],x,y);</span><br><span class="line">            <span class="comment">//如果要改变时间，肯定就是改变每次他的起点</span></span><br><span class="line">            <span class="keyword">if</span>(y &gt;= canvas.height &amp;&amp; <span class="built_in">Math</span>.random() &gt; <span class="number">0.99</span>)&#123;</span><br><span class="line">                drops[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            drops[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">randColor</span>(<span class="params"></span>)</span>&#123;<span class="comment">//随机颜色</span></span><br><span class="line">        <span class="keyword">var</span> r = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">256</span>);</span><br><span class="line">        <span class="keyword">var</span> g = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">256</span>);</span><br><span class="line">        <span class="keyword">var</span> b = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">256</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"rgb("</span>+r+<span class="string">","</span>+g+<span class="string">","</span>+b+<span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    draw();</span><br><span class="line">    setInterval(draw,<span class="number">35</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><code>hexo-theme-next/source/css/main.styl</code>添加<br><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">canvas</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">min-width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">min-height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: auto;</span><br><span class="line">  <span class="attribute">width</span>: auto;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>hexo-theme-next/layout/_layout.swig</code>添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas id&#x3D;&quot;canvas&quot; width&#x3D;&quot;1440&quot; height&#x3D;&quot;900&quot; &gt;&lt;&#x2F;canvas&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;js&#x2F;DigitalRain.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></p><h2 id="留言板"><a href="#留言板" class="headerlink" title="留言板"></a>留言板</h2><p>用<a href="https://www.livere.com/" target="_blank" rel="noopener">来比力</a>作为后台系统。</p><p>打开主题配置文件<code>hexo-theme-next/_config.yml</code>，修改<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Support for LiveRe comments system.</span></span><br><span class="line"><span class="comment"># You can get your uid from https://livere.com/insight/myCode (General web site)</span></span><br><span class="line"><span class="attr">livere_uid:</span> <span class="string">your</span> <span class="string">uid</span></span><br></pre></td></tr></table></figure></p><p>在<code>hexo-theme-next/layout/_scripts/third-party/comments/</code> 目录中添加<code>livere.swig</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname and not theme.disqus_shortname and not theme.hypercomments_id and not theme.gentie_productKey %&#125;</span><br><span class="line"></span><br><span class="line">  &#123;% if theme.livere_uid %&#125;</span><br><span class="line">    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    (function(d, s) &#123;</span><br><span class="line">        var j, e &#x3D; d.getElementsByTagName(s)[0];</span><br><span class="line"></span><br><span class="line">        if (typeof LivereTower &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123; return; &#125;</span><br><span class="line"></span><br><span class="line">        j &#x3D; d.createElement(s);</span><br><span class="line">        j.src &#x3D; &#39;https:&#x2F;&#x2F;cdn-city.livere.com&#x2F;js&#x2F;embed.dist.js&#39;;</span><br><span class="line">        j.async &#x3D; true;</span><br><span class="line"></span><br><span class="line">        e.parentNode.insertBefore(j, e);</span><br><span class="line">    &#125;)(document, &#39;script&#39;);</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><p>在<code>hexo-theme-next/layout/_scripts/third-party/comments.swig</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% include &#39;.&#x2F;comments&#x2F;livere.swig&#39; %&#125;</span><br></pre></td></tr></table></figure></p><p><strong>评论无法保留？？？换成<code>Gitment</code>。</strong></p><p>安装模块<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save gitment</span><br></pre></td></tr></table></figure></p><p>在<a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">New OAuth App</a>为博客应用一个密钥<br><img src="/2019/01/04/Github-Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Github-Hexo博客搭建/new_oauth_app.png" alt="new_oauth_app"></p><p>定位到主题配置文件，填写<code>`enable</code>，<code>github_user</code>，<code>github_repo</code>，<code>client_id</code>，<code>client_secret</code><br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Gitment</span></span><br><span class="line"><span class="comment"># Introduction: https://imsun.net/posts/gitment-introduction/</span></span><br><span class="line"><span class="attr">gitment:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  mint:</span> <span class="literal">true</span> <span class="comment"># RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway</span></span><br><span class="line"><span class="attr">  count:</span> <span class="literal">true</span> <span class="comment"># Show comments count in post meta area</span></span><br><span class="line"><span class="attr">  lazy:</span> <span class="literal">false</span> <span class="comment"># Comments lazy loading with a button</span></span><br><span class="line"><span class="attr">  cleanly:</span> <span class="literal">false</span> <span class="comment"># Hide 'Powered by ...' on footer, and more</span></span><br><span class="line"><span class="attr">  language:</span> <span class="comment"># Force language, or auto switch by theme</span></span><br><span class="line"><span class="attr">  github_user:</span> <span class="comment"># MUST HAVE, Your Github Username</span></span><br><span class="line"><span class="attr">  github_repo:</span> <span class="comment"># MUST HAVE, The name of the repo you use to store Gitment comments</span></span><br><span class="line"><span class="attr">  client_id:</span> <span class="comment"># MUST HAVE, Github client id for the Gitment</span></span><br><span class="line"><span class="attr">  client_secret:</span> <span class="comment"># EITHER this or proxy_gateway, Github access secret token for the Gitment</span></span><br><span class="line"><span class="attr">  proxy_gateway:</span> <span class="comment"># Address of api proxy, See: https://github.com/aimingoo/intersect</span></span><br><span class="line"><span class="attr">  redirect_protocol:</span> <span class="comment"># Protocol of redirect_uri with force_redirect_protocol when mint enabled</span></span><br></pre></td></tr></table></figure></p><p>如果遇到登陆不上的问题，转到<a href="https://gh-oauth.imsun.net/" target="_blank" rel="noopener">gh-oauth.imsun.net</a>页面，点高级-&gt;继续访问就可以了。</p><p><strong>服务器问题不能解决，换成<code>Gitalk</code>。</strong></p><p>定位到路径 themes/next/layout/_third-party/comments下面，创建一个叫做 gitalk.swig的文件，写入如下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if page.comments &amp;&amp; theme.gitalk.enable %&#125;</span><br><span class="line">  &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;gitalk&#x2F;dist&#x2F;gitalk.css&quot;&gt;</span><br><span class="line">  &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;gitalk&#x2F;dist&#x2F;gitalk.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;blueimp-md5&#x2F;2.10.0&#x2F;js&#x2F;md5.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">   &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">        var gitalk &#x3D; new Gitalk(&#123;</span><br><span class="line">          clientID: &#39;&#123;&#123; theme.gitalk.ClientID &#125;&#125;&#39;,</span><br><span class="line">          clientSecret: &#39;&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;&#39;,</span><br><span class="line">          repo: &#39;&#123;&#123; theme.gitalk.repo &#125;&#125;&#39;,</span><br><span class="line">          owner: &#39;&#123;&#123; theme.gitalk.githubID &#125;&#125;&#39;,</span><br><span class="line">          admin: [&#39;&#123;&#123; theme.gitalk.adminUser &#125;&#125;&#39;],</span><br><span class="line">          id: md5(window.location.pathname),</span><br><span class="line">          distractionFreeMode: &#39;&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;&#39;</span><br><span class="line">        &#125;)</span><br><span class="line">        gitalk.render(&#39;gitalk-container&#39;)</span><br><span class="line">       &lt;&#x2F;script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>在 上面的同级目录下的 index.swig 里面加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% include &#39;gitalk.swig&#39; %&#125;</span><br></pre></td></tr></table></figure><p>在使能化之前，我们还需要修改或者说是美化一下gitalk的默认样式，如果你不进行这一步也没有影响，可能结果会丑一点。<br>定位到： themes/next/source/css/_common/components/third-party. 然后你需要创建一个 gitalk.styl 文件。</p><p>这个文件里面写入：<br><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.gt-header</span> <span class="selector-tag">a</span>, <span class="selector-class">.gt-comments</span> <span class="selector-tag">a</span>, <span class="selector-class">.gt-popup</span> a</span><br><span class="line">  <span class="attribute">border-bottom</span>: none;</span><br><span class="line"><span class="selector-class">.gt-container</span> <span class="selector-class">.gt-popup</span> <span class="selector-class">.gt-action</span><span class="selector-class">.is--active</span>:before</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0.7em</span>;</span><br></pre></td></tr></table></figure></p><p>然后同样的，在 third-party.styl里面导入一下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import "gitalk";</span><br></pre></td></tr></table></figure></p><p>在 layout/_partials/comments.swig 里面加入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% elseif theme.gitalk.enable %&#125;</span><br><span class="line">  &lt;div id&#x3D;&quot;gitalk-container&quot;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><p>在主题配置文件<code>_config.yml</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gitalk:</span><br><span class="line">  enable: true</span><br><span class="line">  githubID:   # MUST HAVE, Your Github Username    </span><br><span class="line">  repo:       # MUST HAVE, The name of the repo you use to store Gitment comments</span><br><span class="line">  ClientID:   # MUST HAVE, Github client id for the Gitment</span><br><span class="line">  ClientSecret: # EITHER this or proxy_gateway, Github access secret token for the Gitment</span><br><span class="line">  adminUser: isLouisHsu</span><br><span class="line">  distractionFreeMode: true</span><br></pre></td></tr></table></figure></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><blockquote><p>基于hexo+github搭建一个独立博客 - 牧云云 - 博客园 <a href="https://www.cnblogs.com/MuYunyun/p/5927491.html" target="_blank" rel="noopener">https://www.cnblogs.com/MuYunyun/p/5927491.html</a><br>hexo+github pages轻松搭博客(1) | ex2tron’s Blog <a href="http://ex2tron.wang/hexo-blog-with-github-pages-1/" target="_blank" rel="noopener">http://ex2tron.wang/hexo-blog-with-github-pages-1/</a><br>hexo下LaTeX无法显示的解决方案 - crazy_scott的博客 - CSDN博客 <a href="https://blog.csdn.net/crazy_scott/article/details/79293576" target="_blank" rel="noopener">https://blog.csdn.net/crazy_scott/article/details/79293576</a><br>在Hexo中渲染MathJax数学公式 - 简书 <a href="https://www.jianshu.com/p/7ab21c7f0674" target="_blank" rel="noopener">https://www.jianshu.com/p/7ab21c7f0674</a><br>怎么去备份你的Hexo博客 - 简书 <a href="https://www.jianshu.com/p/baab04284923" target="_blank" rel="noopener">https://www.jianshu.com/p/baab04284923</a><br>Hexo中添加本地图片 - 蜕变C - 博客园 <a href="https://www.cnblogs.com/codehome/p/8428738.html?utm_source=debugrun&amp;utm_medium=referral" target="_blank" rel="noopener">https://www.cnblogs.com/codehome/p/8428738.html?utm_source=debugrun&amp;utm_medium=referral</a><br>hexo 搜索功能 - 阿甘的博客 - CSDN博客 <a href="https://blog.csdn.net/ganzhilin520/article/details/79047983" target="_blank" rel="noopener">https://blog.csdn.net/ganzhilin520/article/details/79047983</a><br>为 Hexo 博客主题 NexT 添加 LiveRe 评论支持 <a href="https://blog.smoker.cc/web/add-comments-livere-for-hexo-theme-next.html" target="_blank" rel="noopener">https://blog.smoker.cc/web/add-comments-livere-for-hexo-theme-next.html</a><br>终于！！！记录如何在hexo next主题下配置gitalk评论系统 <a href="https://jinfagang.github.io/2018/10/07/%E7%BB%88%E4%BA%8E%EF%BC%81%EF%BC%81%EF%BC%81%E8%AE%B0%E5%BD%95%E5%A6%82%E4%BD%95%E5%9C%A8hexo-next%E4%B8%BB%E9%A2%98%E4%B8%8B%E9%85%8D%E7%BD%AEgitalk%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/" target="_blank" rel="noopener">https://jinfagang.github.io/2018/10/07/%E7%BB%88%E4%BA%8E%EF%BC%81%EF%BC%81%EF%BC%81%E8%AE%B0%E5%BD%95%E5%A6%82%E4%BD%95%E5%9C%A8hexo-next%E4%B8%BB%E9%A2%98%E4%B8%8B%E9%85%8D%E7%BD%AEgitalk%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Metrics</title>
      <link href="/2018/11/21/Metrics/"/>
      <url>/2018/11/21/Metrics/</url>
      
        <content type="html"><![CDATA[<h1 id="回归-regression-评估指标"><a href="#回归-regression-评估指标" class="headerlink" title="回归(regression)评估指标"></a>回归(regression)评估指标</h1><h2 id="解释方差-Explained-Variance"><a href="#解释方差-Explained-Variance" class="headerlink" title="解释方差(Explained Variance)"></a>解释方差(Explained Variance)</h2><script type="math/tex; mode=display">EV(\hat{y}, y)= 1 - \frac{Var(y-\hat{y})}{Var(y)}</script><p>解释方差越接近$1$表示回归效果越好。</p><h2 id="平均绝对误差-Mean-Absolute-Error-MAE"><a href="#平均绝对误差-Mean-Absolute-Error-MAE" class="headerlink" title="平均绝对误差(Mean Absolute Error - MAE)"></a>平均绝对误差(Mean Absolute Error - MAE)</h2><script type="math/tex; mode=display">MAE(\hat{y}, y) = E(||\hat{y} - y||_1)= \frac{1}{n_{samples}} \sum_{i=1}^{n_{samples}} |\hat{y}^{(i)} - y^{(i)}|</script><p>$MAE$越小表示回归效果越好。</p><h2 id="平均平方误差-Mean-Squared-Error-MSE"><a href="#平均平方误差-Mean-Squared-Error-MSE" class="headerlink" title="平均平方误差(Mean Squared Error - MSE)"></a>平均平方误差(Mean Squared Error - MSE)</h2><p>在<a href="https://louishsu.xyz/2018/10/18/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/" target="_blank" rel="noopener">线性回归</a>一节，使用的损失函数即$MSE$</p><script type="math/tex; mode=display">MSE(\hat{y}, y) = E(||\hat{y} - y||_2^2)= \frac{1}{n_{samples}} \sum_{i=1}^{n_{samples}} (\hat{y}^{(i)} - y^{(i)})^2</script><p>其中$y$与$\hat{y}$均为$1$维向量，$MSE$越小表示回归效果越好。</p><p>其含义比较直观，即偏差的平方和。也可以从最小化方差的角度解释，定义误差向量</p><script type="math/tex; mode=display">e = \hat{y} - y</script><p>我们假定其期望为$0$，即</p><script type="math/tex; mode=display">E(e) = 0　或　\overline{e} = 0</script><p>那么误差的方差为</p><script type="math/tex; mode=display">Var(e) = E[(e - \overline{e})^T (e - \overline{e})] = E(||e||_2^2)</script><p>也即$MSE$。</p><h2 id="均方根误差-Root-Mean-Squared-Error-RMSE"><a href="#均方根误差-Root-Mean-Squared-Error-RMSE" class="headerlink" title="均方根误差(Root Mean Squared Error - RMSE)"></a>均方根误差(Root Mean Squared Error - RMSE)</h2><script type="math/tex; mode=display">RMSE(\hat{y}, y) = \sqrt{\frac{1}{n_{samples}} \sum_{i=1}^{n_{samples}} (\hat{y}^{(i)} - y^{(i)})^2}</script><p>实质与$MSE$是一样的。只不过用于数据更好的描述，使计算得损失的值较小。$RMSE$越小表示回归效果越好。</p><h2 id="均方对数误差-Mean-Squard-Logarithmic-Error-MSLE"><a href="#均方对数误差-Mean-Squard-Logarithmic-Error-MSLE" class="headerlink" title="均方对数误差(Mean Squard Logarithmic Error - MSLE)"></a>均方对数误差(Mean Squard Logarithmic Error - MSLE)</h2><script type="math/tex; mode=display">MSLE(\hat{y}, y) = \frac{1}{n_{samples}} \sum_{i=1}^{n_{samples}} \left[\log (1+y^{(i)}) - \log (1+\hat{y}^{(i)})\right]^2</script><p>通常用于输出指数增长的模型，如，人口统计，商品的平均销售量，以及一段时间内的平均销售量等。注意，由对数性质，这一指标对过小的预测的惩罚大于预测过大的预测的惩罚。</p><h2 id="中值绝对误差-Median-Absolute-Error-MedAE"><a href="#中值绝对误差-Median-Absolute-Error-MedAE" class="headerlink" title="中值绝对误差(Median Absolute Error - MedAE)"></a>中值绝对误差(Median Absolute Error - MedAE)</h2><script type="math/tex; mode=display">MedAE(\hat{y}, y) = median(|y - \hat{y}|)</script><h2 id="R决定系数-R2"><a href="#R决定系数-R2" class="headerlink" title="R决定系数(R2)"></a>R决定系数(R2)</h2><p>又称拟合优度，提供了一个衡量未来样本有多好的预测模型。最佳可能的分数是$1.0$，它可以是负的(因为模型可以任意恶化)。一个常数模型总是预测$y$的期望值，而不考虑输入特性，则得到$R^2$分数为$0.0$。</p><script type="math/tex; mode=display">R^2(\hat{y}, y) = 1 - \frac{\sum_{i=1}^{n_{samples}} (y^{(i)} - \hat{y}^{(i)})^2}{\sum_{i=1}^{n_{samples}} (y^{(i)} - \overline{y})^2}</script><p>其中</p><script type="math/tex; mode=display">\overline{y} = \frac{1}{n_{samples}} \sum_{i=1}^{n_{samples}} y^{(i)}</script><h1 id="分类-classification-评估指标"><a href="#分类-classification-评估指标" class="headerlink" title="分类(classification)评估指标"></a>分类(classification)评估指标</h1><p>先作如下定义<br><img src="/2018/11/21/Metrics/terminology_and_derivations_1.png" alt="terminology_and_derivations_1"><br><img src="/2018/11/21/Metrics/terminology_and_derivations_2.png" alt="terminology_and_derivations_2"><br><img src="/2018/11/21/Metrics/terminology_and_derivations_3.png" alt="terminology_and_derivations_3"></p><p><img src="/2018/11/21/Metrics/metrics_classification2.png" alt="metrics_classification2"></p><h2 id="准确率-Accuracy"><a href="#准确率-Accuracy" class="headerlink" title="准确率(Accuracy)"></a>准确率(Accuracy)</h2><script type="math/tex; mode=display">Accuracy(y, \hat{y})= \frac{1}{n_{samples}} \sum_{i=1}^{n_{samples}} 1(y^{(i)}=\hat{y}^{(i)})</script><p>也即</p><script type="math/tex; mode=display">Accuracy= \frac{TN+TP}{TN+TP+FN+FP}</script><p>精度只是简单地计算出比例，但是没有对不同类别进行区分。因为不同类别错误代价可能不同。例如：判断这个病人是不是病危，如果不是病危错误判断为病危，那只是损失一点医务人员的时间和精力，如果是把病危的人判断为非病危状态，那损失的就是一条人命。他们之间存在重要性差异，这时候就不能用精度。对于样本不均衡的情况，也不是用精度来衡量。例如：有A类1000个，B类5个，如果我把这1005个样本都预测成A类，正确率=1000/1005=99.5%。</p><h2 id="精确率-Precision-与召回率-Recall"><a href="#精确率-Precision-与召回率-Recall" class="headerlink" title="精确率(Precision)与召回率(Recall)"></a>精确率(Precision)与召回率(Recall)</h2><ul><li><p>精确率<code>(Precision)</code><br>  即预测正样本中，实际为正样本的百分比，度量了分类器不会将真正的负样本错误地分为正样本的能力。</p><script type="math/tex; mode=display">  Precision = \frac{TP}{TP+FP}</script></li><li><p>召回率<code>(Recall)</code><br>  又称查全率，即实际正样本中，被预测为正样本的百分比，度量了分类器找到所有正样本的能力。</p><script type="math/tex; mode=display">  Recall = \frac{TP}{TP + FN}</script><p><img src="/2018/11/21/Metrics/precision_recall.png" alt="precision_recall"></p></li></ul><h2 id="F度量"><a href="#F度量" class="headerlink" title="F度量"></a>F度量</h2><blockquote><p><a href="https://en.wikipedia.org/wiki/F1_score" target="_blank" rel="noopener">F1 score - Wikipedia</a></p></blockquote><ul><li><p>$F_1$<br>  为精确率<code>(Precision)</code>与召回率<code>(Recall)</code>的调和均值<code>(harmonic mean)</code>。</p><script type="math/tex; mode=display">  \frac{1}{F_1}   = \frac{1}{2} (\frac{1}{Precision} + \frac{1}{Recall})</script><p>  也即</p><script type="math/tex; mode=display">  F_1 = 2 · \frac{Precision·Recall}{Precision + Recall}</script></li><li><p>$F_{\beta}$<br>  在$F_1$度量的基础上增加权值$\beta$，$\beta$越大，$Recall$的权重越大，否则$Precision$的权重越大。</p><script type="math/tex; mode=display">  \frac{1}{F_{\beta}} = \frac{1}{1+\beta^2} \frac{1}{Precision} + \frac{\beta^2}{1+\beta^2}\frac{1}{Recall}</script><p>  也即</p><script type="math/tex; mode=display">  F_{\beta} = (1+\beta^2)·\frac{Precision·Recall}{(\beta^2·Precision) + Recall}</script></li></ul><h2 id="混淆矩阵"><a href="#混淆矩阵" class="headerlink" title="混淆矩阵"></a>混淆矩阵</h2><p><code>Confusion matrix</code>，也被称作错误矩阵<code>(Error matrix)</code>，是一个特别的表。无监督学习中，通常称作匹配矩阵<code>(Matching matrix)</code>。每一列表达了分类器对样本的类别预测，每一行表达了样本所属的真实类别。</p><p>例如我们有$27$个待分类样本，将其划分为<code>Cat</code>，<code>Dog</code>，<code>Rabbit</code>，讲实际标签与预测标签数目统计后填入混淆矩阵。</p><p><img src="/2018/11/21/Metrics/confusion_matrix.png" alt="confusion_matrix"></p><p>例如实际上有$8$个样本为<code>Cat</code>，而该分类器将其中$3$个划分为<code>Dog</code>，将$2$个为<code>Dog</code>的样本划分为<code>Cat</code>。我们可以根据上述混淆矩阵得出结论，该分类器对<code>Dog</code>和<code>Cat</code>分类能力较弱，而对<code>Rabbit</code>分类能力较强。而且正确预测的样本数目都在对角线上，很容易直观地检查表中的预测错误。</p><p>以下为<code>scikit-learn</code>中混淆矩阵的<code>API</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn.metrics import confusion_matrix</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; y_true &#x3D; [2, 0, 2, 2, 0, 1]</span><br><span class="line">&gt;&gt;&gt; y_pred &#x3D; [0, 0, 2, 2, 0, 2]</span><br><span class="line">&gt;&gt;&gt; confusion_matrix(y_true, y_pred)</span><br><span class="line">array([[2, 0, 0],</span><br><span class="line">       [0, 0, 1],</span><br><span class="line">       [1, 0, 2]])</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; y_true &#x3D; [&quot;cat&quot;, &quot;ant&quot;, &quot;cat&quot;, &quot;cat&quot;, &quot;ant&quot;, &quot;bird&quot;]</span><br><span class="line">&gt;&gt;&gt; y_pred &#x3D; [&quot;ant&quot;, &quot;ant&quot;, &quot;cat&quot;, &quot;cat&quot;, &quot;ant&quot;, &quot;cat&quot;]</span><br><span class="line">&gt;&gt;&gt; confusion_matrix(y_true, y_pred, labels&#x3D;[&quot;ant&quot;, &quot;bird&quot;, &quot;cat&quot;])</span><br><span class="line">array([[2, 0, 0],</span><br><span class="line">       [0, 0, 1],</span><br><span class="line">       [1, 0, 2]])</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; # In the binary case, we can extract true positives, etc as follows:</span><br><span class="line">&gt;&gt;&gt; tn, fp, fn, tp &#x3D; confusion_matrix([0, 1, 0, 1], [1, 1, 1, 0]).ravel()</span><br><span class="line">&gt;&gt;&gt; (tn, fp, fn, tp)</span><br><span class="line">(0, 2, 1, 1)</span><br></pre></td></tr></table></figure></p><h2 id="ROC曲线"><a href="#ROC曲线" class="headerlink" title="ROC曲线"></a>ROC曲线</h2><p><code>Receiver Operating Characteristic</code>，是根据一系列不同的二分类方式(分界值或决定阈)，以召回率(真正率<code>TPR</code>、灵敏度)为纵坐标，<code>fall-out</code>(假正率<code>FPR</code>、$1$-特异度)为横坐标绘制的曲线。</p><ul><li><p><code>true positive rate - TPR</code><br>  所有阳性样本中有多少正确的阳性结果。</p><script type="math/tex; mode=display">  TPR = \frac{TP}{P} = \frac{TP}{TP + FN}</script></li><li><p><code>false positive rate - FPR</code><br>  所有阴性样本中有多少不正确的阳性结果。</p><script type="math/tex; mode=display">  FPR = \frac{FP}{N} = \frac{FP}{FP + TN}</script></li></ul><h3 id="ROC-space"><a href="#ROC-space" class="headerlink" title="ROC space"></a>ROC space</h3><p><img src="/2018/11/21/Metrics/模型的评估指标/ROC_space.png" alt="ROC_space"></p><ul><li>分别以<code>FPR</code>与<code>TPR</code>作为横纵轴(又称灵敏度-$1$特异度曲线<code>sensitivity vs (1 − specificity) plot</code>)；</li><li>每次预测结果或混淆矩阵的实例代表了<code>ROC</code>空间中的一个点；<br>  例如上图中$A, B, C, C’$是以下表数据计算得到的点。<br>  <img src="/2018/11/21/Metrics/ROC_space_samples.png" alt="ROC_space_samples"></li><li>在<code>ROC</code>空间中最左上方的点$(0, 1)$称作完美分类器<code>(perfect classification)</code>；</li><li>随机分类器的结果分布在<code>ROC space</code>对角线$(0, 0)-(1, 1)$上，当实验次数足够多，其分区趋向$(0.5, 0.5)$;</li><li>对角线以上的点代表好的分类结果(比随机的好)；线下的点代表坏的结果(比随机的差)；</li><li>注意，持续不良分类器的输出可以简单地反转以获得一个好的分类器，反转后的分类器与原分类器在平面上关于对角线对称，例如点$C’$。</li></ul><h3 id="ROC曲线的绘制"><a href="#ROC曲线的绘制" class="headerlink" title="ROC曲线的绘制"></a>ROC曲线的绘制</h3><p>若训练集样本中，正样本与负样本以正态分布的形式分布在样本平面上，如下图，左峰为负样本，右峰为正样本，存在部分重叠(不然就不用搞这么多分类算法了)。</p><p><img src="/2018/11/21/Metrics/ROC_curves.svg.png" alt="ROC_curves.svg"></p><p>若假设正样本概率密度为$f_1(x)$，负样本的概率密度为$f_0(x)$，给定阈值$T$，则右</p><script type="math/tex; mode=display">TPR(T) = \int_T^{\infty} f_1(x) dx</script><script type="math/tex; mode=display">FPR(T) = \int_T^{\infty} f_0(x) dx</script><p>选取不同的阈值划分分类器输出，就能得到<code>ROC</code>曲线。</p><p>在基于有限样本作<code>ROC</code>图时，可以看到曲线每次都是一个“爬坡”，遇到正例往上爬一格$(1/m+)$，错了往右爬一格$(1/m-)$，显然往上爬对于算法性能来说是最好的。<br><img src="/2018/11/21/Metrics/ROC_curves_up_right.png" alt="ROC_curves_up_right"></p><h3 id="Area-Under-the-Curve-AUC"><a href="#Area-Under-the-Curve-AUC" class="headerlink" title="Area Under the Curve - AUC"></a>Area Under the Curve - AUC</h3><p><code>ROC</code>曲线下的面积<code>AUC</code>物理意义为，任取一对正负样本，正样本的预测值大于负样本的预测值的概率。</p><script type="math/tex; mode=display">A = \int_{-\infty}^{\infty} TPR(T) dFPR(T)</script><script type="math/tex; mode=display">= \int_{-\infty}^{\infty} \int_{-\infty}^{\infty}I(T'> T)f_1(T') f_0(T)dT' dT</script><script type="math/tex; mode=display">= P(X_1 > X_0)</script><p>同样的，在有限个样本下，其面积用累加的方法计算(梯形面积)</p><p><img src="/2018/11/21/Metrics/ROC_curves_AUC.png" alt="ROC_curves_AUC"></p><script type="math/tex; mode=display">AUC = \sum_{i=1}^{m-1} \frac{1}{2} (y_{i+1} + y_i)(x_{i+1} - x_i)</script><ul><li>$AUC = 1$，是完美分类器，采用这个预测模型时，存在至少一个阈值能得出完美预测。绝大多数预测的场合，不存在完美分类器。</li><li>$0.5 &lt; AUC &lt; 1$，优于随机猜测。这个分类器（模型）妥善设定阈值的话，能有预测价值。</li><li>$AUC = 0.5$，跟随机猜测一样（例：丢铜板），模型没有预测价值。</li><li>$AUC &lt; 0.5$，比随机猜测还差；但只要总是反预测而行，就优于随机猜测。</li></ul><h3 id="sklearn"><a href="#sklearn" class="headerlink" title="sklearn"></a>sklearn</h3><p>以下为<code>scikit-learn</code>中混淆矩阵的<code>ROC</code>曲线<code>API</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import numpy as np</span><br><span class="line">&gt;&gt;&gt; from sklearn import metrics</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; y &#x3D; np.array([1, 1, 2, 2])</span><br><span class="line">&gt;&gt;&gt; scores &#x3D; np.array([0.1, 0.4, 0.35, 0.8])</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; fpr, tpr, thresholds &#x3D; metrics.roc_curve(y, scores, pos_label&#x3D;2)</span><br><span class="line">&gt;&gt;&gt; fpr</span><br><span class="line">array([ 0. ,  0.5,  0.5,  1. ])</span><br><span class="line">&gt;&gt;&gt; tpr</span><br><span class="line">array([ 0.5,  0.5,  1. ,  1. ])</span><br><span class="line">&gt;&gt;&gt; thresholds</span><br><span class="line">array([ 0.8 ,  0.4 ,  0.35,  0.1 ])</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; metrics.auc(fpr, tpr)</span><br><span class="line">0.75</span><br></pre></td></tr></table></figure></p><h1 id="聚类-clustering-评估指标"><a href="#聚类-clustering-评估指标" class="headerlink" title="聚类(clustering)评估指标"></a>聚类(clustering)评估指标</h1><blockquote><ul><li><a href="https://blog.csdn.net/darkrabbit/article/details/80378597" target="_blank" rel="noopener">AI（005） - 笔记 - 聚类性能评估（Clustering Evaluation） - DarkRabbit的专栏 - CSDN博客 </a></li><li><a href="https://en.wikipedia.org/wiki/Main_Page" target="_blank" rel="noopener">Wikipedia, the free encyclopedia</a></li></ul></blockquote><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>聚类性能比较好，就是聚类结果簇内相似度<code>(intra-cluster similarity)</code>高，而簇间相似度<code>(inter-cluster similarity)</code>低，即同一簇的样本尽可能的相似，不同簇的样本尽可能不同。</p><p>聚类性能的评估（度量）分为两大类：</p><ul><li>外部评估<code>(external evaluation)</code>：将结果与某个参考模型<code>(reference model)</code>进行比较；</li><li>内部评估<code>(internal evaluation)</code>：直接考虑聚类结果而不利用任何参考模型。</li></ul><p>将$n_{samples}$个样本${x^{(1)}, …, x^{(n_{samples})}}$用待评估聚类算法划分为$K$个类${X_1, …, X_K}$，假定参考模型将其划分为$L$类${Y_1, …, Y_L}$，将样本两辆匹配</p><script type="math/tex; mode=display">\begin{cases}    a = |SS| &  SS = \{(x^{(i)}, x^{(j)}) | x^{(i)}, x^{(j)} \in X_k; x^{(i)}, x^{(j)} \in Y_l\} \\    b = |SD| &  SD = \{(x^{(i)}, x^{(j)}) | x^{(i)}, x^{(j)} \in X_k; x^{(i)} \in Y_{l1}, x^{(j)} \in Y_{l2}\} \\    c = |DS| &  DS = \{(x^{(i)}, x^{(j)}) | x^{(i)} \in X_{k1}, x^{(j)} \in X_{k2}; x^{(i)}, x^{(j)} \in Y_l\} \\    d = |DD| &  DD = \{(x^{(i)}, x^{(j)}) | x^{(i)} \in X_{k1}, x^{(j)} \in X_{k2}; x^{(i)} \in Y_{l1}, x^{(j)} \in Y_{l2}\}\end{cases}</script><p>其中$k = 1, …, K; l = 1, …, L$</p><script type="math/tex; mode=display">a + b + c + d=   \left(        \begin{matrix}            n \\ 2        \end{matrix}    \right)= \frac{n(n-1)}{2}</script><blockquote><ul><li>$SS$包含两种划分中均属于同一类的样本对；</li><li>$SD$包含用待评估聚类算法划分中属于同一类，而在参考模型中属于不同类的样本对；</li><li>$DS$包含用待评估聚类算法划分中属于不同类，而在参考模型中属于同一类的样本对；</li><li>$DD$包含两种划分中均不属于同一类的样本对。</li></ul></blockquote><h2 id="常用外部评估-external-evaluation"><a href="#常用外部评估-external-evaluation" class="headerlink" title="常用外部评估(external evaluation)"></a>常用外部评估(external evaluation)</h2><h3 id="Rand-Index-RI"><a href="#Rand-Index-RI" class="headerlink" title="Rand Index(RI)"></a>Rand Index(RI)</h3><blockquote><p><a href="https://en.wikipedia.org/wiki/Rand_index" target="_blank" rel="noopener">Rand index - Wikipedia</a></p></blockquote><script type="math/tex; mode=display">RI = \frac{a+d}{a + b + c + d} = \frac{a+d}{\left(\begin{matrix} n \\ 2 \end{matrix}\right)}</script><p>显然，结果值在$[0,1]$之间，且值越大越好。</p><ul><li>当为$0$时，两个聚类无重叠；</li><li>当为$1$时，两个聚类完全重叠。</li></ul><h3 id="Adjust-Rand-Index-ARI"><a href="#Adjust-Rand-Index-ARI" class="headerlink" title="Adjust Rand Index(ARI)"></a>Adjust Rand Index(ARI)</h3><p>让$RI$有了修正机会<code>(corrected-for-chance)</code>，在取值上从$[0,1]$变成$[-1, 1]$</p><p>对于$X$与$Y$的重叠可以用一个列联表<code>(contingency table)</code>表示，记作$[n_{ij}]$，$n_{ij} = |X_i \bigcap Y_j|$<br><img src="/2018/11/21/Metrics/聚类/ARI.svg" alt="ARI"></p><p>则定义$ARI$如下<br><img src="/2018/11/21/Metrics/聚类/ARI_Def.svg" alt="ARI_Def"></p><h3 id="互信息与调整互信息-Adjusted-Mutual-Information-AMI"><a href="#互信息与调整互信息-Adjusted-Mutual-Information-AMI" class="headerlink" title="互信息与调整互信息(Adjusted Mutual Information - AMI)"></a>互信息与调整互信息(Adjusted Mutual Information - AMI)</h3><blockquote><p>关于互信息可查看<a href="">熵</a>一节说明。</p></blockquote><p>$X_i$类别的概率定义为</p><script type="math/tex; mode=display">P(k) = \frac{|X_k|}{N}</script><p>则划分结果的熵定义为</p><script type="math/tex; mode=display">H(X) = - \sum_k P(k) \log P(k)</script><p>类似的</p><script type="math/tex; mode=display">P'(l) = \frac{|Y_l|}{N}</script><script type="math/tex; mode=display">H(Y) = - \sum_j P'(l) \log P'(l)</script><p>另外</p><script type="math/tex; mode=display">P(k, l) = \frac{|X_k, Y_l|}{N}</script><p>那么两种划分的互信息定义为</p><script type="math/tex; mode=display">MI(X, Y) = \sum_{k, l} P(k, l) \log \frac{P(k, l)}{P(k) P'(l)}</script><p>和$ARI$一样，我们对它进行调整。</p><script type="math/tex; mode=display">E[MI(X, Y)] = \sum_k \sum_l \sum_{n_{kl} = \max\{1, a_k + b_l - N\}}^{\min \{a_k, b_l\}}\frac{n_{kl}}{N}\log \left( \frac{N·n_{kl}}{a_k b_l} \right) ×</script><script type="math/tex; mode=display">\frac{a_k!b_l!(N-a_k)!(N-b_l)!}{N!n_{kl}!(a_k-n_{kl})!(b_l-n_{kl})!(N-a_k-b_l+n_{kl})!}</script><p>最终$AMI$表达式为</p><script type="math/tex; mode=display">AMI(X, Y) = \frac{MI(X, Y) - E[MI(X, Y)]}{\max \{H(X), H(Y)\} - E[MI(X, Y)]}</script><h3 id="同质性-Homogeneity-与完整性-Completeness"><a href="#同质性-Homogeneity-与完整性-Completeness" class="headerlink" title="同质性(Homogeneity)与完整性(Completeness)"></a>同质性(Homogeneity)与完整性(Completeness)</h3><p>这两个类似分类种的的准确率<code>(accuracy)</code>与召回率<code>(recall)</code>。</p><ul><li><p>同质性<code>(Homogeneity)</code><br>  即一个簇仅包含一个类别的样本</p><script type="math/tex; mode=display">  H = 1 - \frac{H(X|Y)}{H(X)}</script><p>  其中$H(X|Y)$为条件熵</p><script type="math/tex; mode=display">  H(X|Y) = \sum_k \sum_l P(X_k, Y_l) \log \frac{P(Y_l)}{P(X_k, Y_l)}  = \sum_k \sum_l \frac{n_{kl}}{N} \log \frac{n_{kl}}{N}</script></li><li><p>完整性<code>(Completeness)</code><br>  同类别样本被归类到相同簇中</p><script type="math/tex; mode=display">  C = 1 - \frac{H(Y|X)}{H(Y)}</script></li><li><p>$V-measure$<br>  <code>Homogeneity</code>和<code>Completeness</code>的调和平均</p><script type="math/tex; mode=display">  V = \frac{1}{\frac{1}{2} \left(\frac{1}{H} + \frac{1}{C}\right)} = \frac{2HC}{H + C}</script></li></ul><h3 id="Fowlkes-Mallows-index-FMI"><a href="#Fowlkes-Mallows-index-FMI" class="headerlink" title="Fowlkes-Mallows index(FMI)"></a>Fowlkes-Mallows index(FMI)</h3><p>成对精度和召回率的几何均值</p><blockquote><p><a href="https://en.wikipedia.org/wiki/Fowlkes%E2%80%93Mallows_index" target="_blank" rel="noopener">Fowlkes–Mallows index - Wikipedia</a></p></blockquote><p>定义</p><ul><li>$TP$ as the number of points that are present in the same cluster in both $A_1$ and $A_2$.</li><li>$FP$ as the number of points that are present in the same cluster in $A_1$ but not in $A_2$.</li><li>$FN$ as the number of points that are present in the same cluster in $A_2$ but not in $A_1$.</li><li>$TN$ as the number of points that are in different clusters in both $A_1$ and $A_2$.</li></ul><p>则</p><script type="math/tex; mode=display">TP + FP + TN + FN = \frac{n(n-1)}{2}</script><p>定义</p><script type="math/tex; mode=display">FMI = \sqrt{\frac{TP}{TP + FP} · \frac{TP}{TP + FN}}</script><h3 id="杰卡德系数-Jaccard-Coefficient-JC"><a href="#杰卡德系数-Jaccard-Coefficient-JC" class="headerlink" title="杰卡德系数(Jaccard Coefficient - JC)"></a>杰卡德系数(Jaccard Coefficient - JC)</h3><blockquote><p><a href="https://en.wikipedia.org/wiki/Jaccard_index" target="_blank" rel="noopener">Jaccard index - Wikipedia</a></p></blockquote><p>给定两个具有$n$个元素的集合$A, B$，定义</p><ul><li>$M_{11}$ represents the total number of attributes where $A$ and $B$ both have a value of $1$.</li><li>$M_{01}$ represents the total number of attributes where the attribute of $A$ is $0$ and the attribute of $B$ is $1$.</li><li>$M_{10}$ represents the total number of attributes where the attribute of $A$ is $1$ and the attribute of $B$ is $0$.</li><li>$M_{00}$ represents the total number of attributes where $A$ and $B$ both have a value of $0$.</li></ul><p>则有</p><script type="math/tex; mode=display">M_{11} + M_{01} + M_{10} + M_{00} = n</script><ul><li><p><code>Jaccard</code>相似度系数</p><script type="math/tex; mode=display">  J = \frac{M_{11}}{M_{01} + M_{10} + M_{11}}</script><blockquote><p>也即$J=\frac{A \cap B}{A \cup B}$</p></blockquote></li><li><p><code>Jaccard</code>距离</p><script type="math/tex; mode=display">  D_J = 1 - J</script></li></ul><h2 id="常用内部评估-internal-evaluation"><a href="#常用内部评估-internal-evaluation" class="headerlink" title="常用内部评估(internal evaluation)"></a>常用内部评估(internal evaluation)</h2><h3 id="轮廓系数-Silhouette-coefficient"><a href="#轮廓系数-Silhouette-coefficient" class="headerlink" title="轮廓系数(Silhouette coefficient)"></a>轮廓系数(Silhouette coefficient)</h3><p>又称侧影法，适用于实际类别信息未知的情况，对其中一个样本点$x^{(i)}$，记</p><ul><li>$a(i)$：到本簇其他样本点的距离的平均值</li><li>$b(i)$：该点到其他各个簇的样本点的平均距离的最小值</li></ul><p>定义轮廓系数</p><script type="math/tex; mode=display">S(i) = \frac{b(i) - a(i)}{\max\{a(i), b(i)\}}</script><p>或者</p><script type="math/tex; mode=display">S(i) = \begin{cases}    1 - \frac{a(i)}{b(i)} & a(i) < b(i) \\    0 & a(i) = b(i) \\    \frac{b(i)}{a(i)} - 1 & a(i) > b(i)\end{cases}</script><p>其含义如下</p><ul><li>当$a(i) \ll b(i)$时，无限接近于$1$，则意味着聚类合适；</li><li>当$a(i) \gg b(i)$时，无限接近于$-1$，则意味着把样本i聚类到相邻簇中更合适；</li><li>当$a(i)\approxeq b(i)$时，无限接近于$0$，则意味着样本在两个簇交集处。</li></ul><p>一般再对各个点的轮廓系数求均值</p><script type="math/tex; mode=display">\overline{S} = \frac{1}{n_{samples}} \sum_{i=1}^{n_{samples}} S(i)</script><ul><li>当$\overline{S} &gt; 0.5$，表示聚类合适；</li><li>当$\overline{S} &lt; 0.2$，表示表明数据不存在聚类特征</li></ul><h3 id="Calinski-Harabaz-CH"><a href="#Calinski-Harabaz-CH" class="headerlink" title="Calinski-Harabaz(CH)"></a>Calinski-Harabaz(CH)</h3><p>也适用于实际类别信息未知的情况，以$K$分类为例</p><ul><li><p>类内散度$W$</p><script type="math/tex; mode=display">  W(K) = \sum_k \sum_{C(j)=k} ||x_j - \overline{x_k}||^2</script></li><li><p>类间散度$B$</p><script type="math/tex; mode=display">  B(K) = \sum_k a_k ||\overline{x_k} - \overline{x}||^2</script></li><li><p>$CH$</p><script type="math/tex; mode=display">  CH(K) = \frac{B(K)(N-K)}{W(K)(K-1)}</script></li></ul><h3 id="Davies-Bouldin-Index-DBI"><a href="#Davies-Bouldin-Index-DBI" class="headerlink" title="Davies-Bouldin Index(DBI)"></a>Davies-Bouldin Index(DBI)</h3><p>定义</p><ul><li>$c_k$：簇$C_k$的中心点</li><li>$\sigma_k$：簇$C_k$中所有元素到$c_k$的距离的均值</li><li>$d(c_i, c_j)$：簇中心$c_i$与$c_j$之间的距离</li></ul><p>则</p><script type="math/tex; mode=display">DBI = \frac{1}{K} \sum_{i=1}^K \max_{j \neq i} \left( \frac{\sigma_i + \sigma_j}{d(c_i, c_j)} \right)</script><p>$DBI$越小越好</p><h3 id="Dunn-index-DI"><a href="#Dunn-index-DI" class="headerlink" title="Dunn index(DI)"></a>Dunn index(DI)</h3><p>定义</p><ul><li>$d(i,j)$：两类簇的距离，定义方法多样，例如两类簇中心的距离；</li><li>$d’(k)$：簇$C_k$的类内距离，同样的，可定义多种，例如簇$C_k$中任意两点距离的最大值。</li></ul><p>则</p><script type="math/tex; mode=display">DI = \frac{\min_{1 \leq i < j \leq K} d(i, j)}{\max_{1 \leq k \leq K} d'(k)}</script><h1 id="sklearn中的评价指标"><a href="#sklearn中的评价指标" class="headerlink" title="sklearn中的评价指标"></a>sklearn中的评价指标</h1><blockquote><p><a href="http://sklearn.apachecn.org/en/0.19.0/modules/model_evaluation.html" target="_blank" rel="noopener">3.3. Model evaluation: quantifying the quality of predictions — scikit-learn 0.19.0 documentation - ApacheCN</a></p></blockquote><p><img src="/2018/11/21/Metrics/sklearn_metrics.png" alt="sklearn_metrics"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn import metrics</span><br><span class="line">&gt;&gt;&gt; dir(metrics)</span><br><span class="line">[&#39;SCORERS&#39;, &#39;__all__&#39;, &#39;__builtins__&#39;, &#39;__cached__&#39;, &#39;__doc__&#39;, </span><br><span class="line">&#39;__file__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;__path__&#39;, &#39;__spec__&#39;,</span><br><span class="line"> &#39;accuracy_score&#39;, &#39;adjusted_mutual_info_score&#39;, &#39;adjusted_rand_score&#39;, </span><br><span class="line"> &#39;auc&#39;, &#39;average_precision_score&#39;, &#39;balanced_accuracy_score&#39;, </span><br><span class="line"> &#39;base&#39;, &#39;brier_score_loss&#39;, &#39;calinski_harabaz_score&#39;, &#39;check_scoring&#39;, </span><br><span class="line"> &#39;classification&#39;, &#39;classification_report&#39;, &#39;cluster&#39;, &#39;cohen_kappa_score&#39;, </span><br><span class="line"> &#39;completeness_score&#39;, &#39;confusion_matrix&#39;, &#39;consensus_score&#39;, </span><br><span class="line"> &#39;coverage_error&#39;, &#39;davies_bouldin_score&#39;, &#39;euclidean_distances&#39;, </span><br><span class="line"> &#39;explained_variance_score&#39;, &#39;f1_score&#39;, &#39;fbeta_score&#39;, </span><br><span class="line"> &#39;fowlkes_mallows_score&#39;, &#39;get_scorer&#39;, &#39;hamming_loss&#39;, &#39;hinge_loss&#39;, </span><br><span class="line"> &#39;homogeneity_completeness_v_measure&#39;, &#39;homogeneity_score&#39;, </span><br><span class="line"> &#39;jaccard_similarity_score&#39;, &#39;label_ranking_average_precision_score&#39;, </span><br><span class="line"> &#39;label_ranking_loss&#39;, &#39;log_loss&#39;, &#39;make_scorer&#39;, &#39;matthews_corrcoef&#39;, </span><br><span class="line"> &#39;mean_absolute_error&#39;, &#39;mean_squared_error&#39;, &#39;mean_squared_log_error&#39;, </span><br><span class="line"> &#39;median_absolute_error&#39;, &#39;mutual_info_score&#39;, </span><br><span class="line"> &#39;normalized_mutual_info_score&#39;, &#39;pairwise&#39;, &#39;pairwise_distances&#39;, </span><br><span class="line"> &#39;pairwise_distances_argmin&#39;, &#39;pairwise_distances_argmin_min&#39;, </span><br><span class="line"> &#39;pairwise_distances_chunked&#39;, &#39;pairwise_fast&#39;, &#39;pairwise_kernels&#39;, </span><br><span class="line"> &#39;precision_recall_curve&#39;, &#39;precision_recall_fscore_support&#39;, </span><br><span class="line"> &#39;precision_score&#39;, &#39;r2_score&#39;, &#39;ranking&#39;, &#39;recall_score&#39;, &#39;regression&#39;, </span><br><span class="line"> &#39;roc_auc_score&#39;, &#39;roc_curve&#39;, &#39;scorer&#39;, &#39;silhouette_samples&#39;, </span><br><span class="line"> &#39;silhouette_score&#39;, </span><br><span class="line"> &#39;v_measure_score&#39;, </span><br><span class="line"> &#39;zero_one_loss&#39;]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Entropy</title>
      <link href="/2018/11/21/Entropy/"/>
      <url>/2018/11/21/Entropy/</url>
      
        <content type="html"><![CDATA[<h1 id="信息量"><a href="#信息量" class="headerlink" title="信息量"></a>信息量</h1><p>概率$p$是对确定性的度量，那么信息量就是对不确定性的度量，公式定义为</p><script type="math/tex; mode=display">I(x) = - \log p(x) \tag{1}</script><p>信息量也被称为随机变量$x$的自信息<code>(self-information)</code></p><blockquote><p>底数为$2$时，单位为<code>bit</code>，底数为$e$时，单位为<code>nat</code></p></blockquote><p><img src="/2018/11/21/Entropy/信息量.png" alt="信息量"></p><h1 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h1><p>信息熵<code>(information entropy)</code>定义为</p><script type="math/tex; mode=display">H(X) = - \sum_{x} p(x) \log p(x) \tag{2}</script><p>可看作<strong>信息量的期望</strong>,在$0-1$分布的信息熵为</p><script type="math/tex; mode=display">H(p) = - p \log p - (1 - p) \log (1 - p)</script><p>图像如下，可见在$p=0.5$时，熵最大。<br><img src="/2018/11/21/Entropy/entropy_of_01.png" alt="entropy_of_01"></p><blockquote><p>函数$y=x \log x$的图像<br><img src="/2018/11/21/Entropy/xlogx.png" alt="xlogx"><br>有</p><script type="math/tex; mode=display">\lim_{x \rightarrow 0} y = \lim_{x \rightarrow 1} y = 0</script></blockquote><h1 id="联合熵"><a href="#联合熵" class="headerlink" title="联合熵"></a>联合熵</h1><p>根据信息熵的定义，推广到多维随机变量，就得到联合熵的定义式，以$2$维随机变量为例</p><script type="math/tex; mode=display">H(X, Y) = - \sum_{x, y} p(x, y) \log p(x, y) \tag{3}</script><p>可推广至多维。</p><!-- 机器学习笔记十：各种熵总结 - 谢小小XH - CSDN博客 https://blog.csdn.net/xierhacker/article/details/53463567 --><h1 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h1><p>现在有关于样本集的两个概率分布$p(x)$和$q(x)$，其中$p(x)$为真实分布，$q(x)$非真实分布。</p><p>如果用真实分布$p(x)$来衡量识别别一个样本所需要编码长度的期望（平均编码长度）为:</p><script type="math/tex; mode=display">H(p) = - \sum_x p(x) \log p(x)</script><p>如果用非真实分布$q(x)$来衡量识别别一个样本所需要编码长度的期望（平均编码长度）为:</p><script type="math/tex; mode=display">H(p, q) = - \sum_x p(x) \log q(x) \tag{4}</script><p>注意</p><script type="math/tex; mode=display">H(p, q) - H(p)= \sum_x p(x) \log \frac{p(x)}{q(x)}= D_{KL}(p||q)</script><p>当用非真实分布$q(x)$得到的平均码长比真实分布$p(x)$得到的平均码长多出的比特数就是相对熵。我们希望通过最小化相对熵$D_{KL}(p||q)$使$q(x)$尽量趋近$p(x)$，即</p><script type="math/tex; mode=display">q(x) = \arg \min_{q(x)} D_{KL} (p||q)</script><p>而$H(p)$是样本集的熵，为固定的值，故</p><script type="math/tex; mode=display">q(x) = \arg \min_{q(x)} H(p, q)</script><p>即等价于最小化交叉熵。</p><h1 id="条件熵"><a href="#条件熵" class="headerlink" title="条件熵"></a>条件熵</h1><p>条件熵$H(Y|X)$表示在已知随机变量$X$的条件下随机变量$Y$的不确定性。定义为在给定$X$下$Y$的条件概率分布的熵对$X$的期望，即</p><script type="math/tex; mode=display">H(Y|X) = E_{p(x)} H(Y|X=x)= \sum_x p(x) H(Y|X=x) \tag{5}</script><p>其中</p><script type="math/tex; mode=display">H(Y|X=x) = - \sum_y p(y|x) \log p(y|x)</script><p>故</p><script type="math/tex; mode=display">H(Y|X) = \sum_x p(x) \left[- \sum_y p(y|x) \log p(y|x)\right]</script><script type="math/tex; mode=display">= - \sum_x \sum_y p(x, y) \log p(y|x)</script><p>即</p><script type="math/tex; mode=display">H(Y|X) = - \sum_{x, y} p(x, y) \log p(y|x) \tag{6}</script><p>实际上，条件熵满足</p><script type="math/tex; mode=display">H(Y|X) = H(X, Y) - H(X) \tag{7}</script><blockquote><p>证明：<br>已知</p><script type="math/tex; mode=display">H(X, Y) = - \sum_{x, y} p(x, y) \log p(x, y)</script><script type="math/tex; mode=display">H(X) = - \sum_{x} p(x) \log p(x)</script><p>则</p><script type="math/tex; mode=display">H(X, Y) - H(X)</script><script type="math/tex; mode=display">= - \sum_{x, y} p(x, y) \log p(x, y) + \sum_{x} p(x) \log p(x)</script><script type="math/tex; mode=display">= - \sum_{x, y} p(x, y) \log p(x, y) + \sum_{x, y} p(x, y) \log p(x)</script><script type="math/tex; mode=display">= \sum_{x, y} p(x, y) \log \frac{p(x)}{p(x, y)}</script><script type="math/tex; mode=display">= \sum_{x, y} p(x, y) \log p(y|x)</script><script type="math/tex; mode=display">= H(Y|X)</script></blockquote><h1 id="相对熵"><a href="#相对熵" class="headerlink" title="相对熵"></a>相对熵</h1><p>相对熵<code>(relative entropy)</code>，又称<code>KL</code>散度<code>(Kullback–Leibler divergence)</code>。可以用来衡量两个概率分布之间的差异，就是求$p(x)$与$q(x)$之间的对数差在 pp 上的期望值。</p><script type="math/tex; mode=display">D_{KL} (p||q) = E_{p(x)} \log \frac{p(x)}{q(x)}= \sum_x p(x) \log \frac{p(x)}{q(x)} \tag{8}</script><p>注意</p><ul><li><p>相对熵不具有对称性，即</p><script type="math/tex; mode=display">  D_{KL} (p||q) \neq D_{KL} (q||p)</script></li><li><p>$D_{KL} (p||q) \geq 0$</p><blockquote><p>证明：</p><script type="math/tex; mode=display">D_{KL} (p||q) = \sum_x p(x) \log \frac{p(x)}{q(x)} = - \sum_x p(x) \log \frac{q(x)}{p(x)}</script><p>由<code>Jensen inequality</code></p><script type="math/tex; mode=display">\sum_x p(x) \log \frac{q(x)}{p(x)}\leq \log \sum_x p(x) \frac{q(x)}{p(x)}= \log \sum_x q(x)</script><p>所以</p><script type="math/tex; mode=display">D_{KL} (p||q) \geq - \log \sum_x q(x)</script><p>而$0 \leq q(x) \leq 1$，故</p><script type="math/tex; mode=display">D_{KL} (p||q) \geq 0</script></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Non-parameter Estimation</title>
      <link href="/2018/11/19/Non-parameter-Estimation/"/>
      <url>/2018/11/19/Non-parameter-Estimation/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>若参数估计时我们不知道样本的分布形式，那么就无法确定需要估计的概率密度函数，无法用<a href="https://louishsu.xyz/2018/10/22/%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">最大似然估计、贝叶斯估计等参数估计方法</a>，应该用非参数估计方法。</p><p>需要知道的是，作为非参数方法的共同问题是对样本数量需求较大，只要样本数目足够大众可以保证收敛于任何复杂的位置密度，但是计算量和存储量都比较大。当样本数很少时，如果能够对密度函数有先验认识，则参数估计能取得更好的估计效果。</p><h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>若有$M$个样本$x^{(1)}, …, x^{(M)}$，依概率密度函数$p(x)$独立同分布抽样得到。</p><p>一个样本$x$落在区域$R$中的概率$P$可表示为</p><script type="math/tex; mode=display">P = \int_R p(x) dx \tag{1}</script><p>我们通过计算$P$来估计概率密度$p(x)$。</p><p>$K$个样本落入区域$R$的概率$P_K$为二项分布，即$K \sim B(M, P)$</p><script type="math/tex; mode=display">P_K = \left(\begin{matrix} M\\K \end{matrix}\right) P^K (1-P)^{M-K} \tag{2}</script><p>则$K$的期望与方差分别为</p><script type="math/tex; mode=display">E(K) = MP;　D(K) = MP(1-P)</script><p>样本个数$M$越多，$D(K)$越大，即$K$在期望附近的波峰越明显，因此样本足够多时，用$K/M$作为$P$的一个估计非常准确，即</p><script type="math/tex; mode=display">P \approx \frac{K}{M} \tag{3}</script><p>若我们假设$p(x)$是连续的，且区域$R$足够小，记其体积为$V$，那么有</p><script type="math/tex; mode=display">P = \int_R p(x)dx \approx p(x) V \tag{4}</script><p>所以根据$(3)(4)$，得到</p><script type="math/tex; mode=display">p(x) \approx \frac{K/M}{V} \tag{*}</script><p>但是我们获得的其实为平滑后的概率密度函数</p><script type="math/tex; mode=display">\frac{P}{V} = \frac{\int_R p(x)dx}{\int_R dx}</script><p>我们希望其尽可能地趋近$p(x)$，那么必须要求$V \rightarrow 0$，但是这样就可能不包含任何样本，那么$p(x)\approx 0$，这样估计的结果毫无意义。</p><p>所以在实际中，一般构造多个包含样本$x$的区域$R_1, …, R_i, …, R_n$，第$i$个区域使用$i$个样本，记$V_i$为$R_i$的体积，$M_i$为落在$R_i$中的样本个数，则对$p(x)$第$i$次估计$p_i(x)$表示为</p><script type="math/tex; mode=display">p_i(x) \approx \frac{M_i / M}{V_i} \tag{5}</script><p>若要求$p_i(x)$收敛到$p(x)$，则必须满足</p><ul><li>$\lim_{i\rightarrow \infty} V_i = 0$</li><li>$\lim_{i\rightarrow \infty} M_i = 0$</li><li>$\lim_{i\rightarrow \infty} \frac{M_i}{M} = 0$</li></ul><h1 id="直方图法"><a href="#直方图法" class="headerlink" title="直方图法"></a>直方图法</h1><p>记不记得小学时的直方图统计，直方图方法的思想就是这样，以$1$维样本为例，我们将$x$的取值范围平均等分为$K$个区间，统计每个区间内样本的个数，由此计算区间的概率密度。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>若共有$N$维样本$M$组，在每个维度上$K$等分，就有$K^N$个小空间，每个小空间的体积$V_i$可以定义为</p><script type="math/tex; mode=display">V_i = \prod_{n=1}^N d_n,　i=1,...,K^N</script><p>其中</p><script type="math/tex; mode=display">d_n = \frac{\max x_n - \min x_n}{K}</script><p>假设样本落到各个小空间的概率相同，若第$i$个小空间包含$M_i$个样本，则该空间的概率密度$\hat{p_i}$为</p><script type="math/tex; mode=display">\hat{p_i} = \frac{M_i / M}{V_i} \tag{6}</script><p>估计的效果与小区间的大小密切相连，如果区域选择过大，会导致最终估计出来的概率密度函数非常粗糙；如果区域的选择过小，可能会导致有些区域内根本没有样本或者样本非常少，这样会导致估计出来的概率密度函数很不连续。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://github.com/isLouisHsu/Basic-Machine-Learning-Algorithm/blob/master/algorithm/p64_non_parametric_estmation.py" target="_blank" rel="noopener">@Github: Non-parametric Estmation</a></p><p>我们可以用<code>matplotlib.pyplot.hist()</code>或<code>numpy.histogram()</code>实现</p><ul><li><p><code>matplotlib</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n, bins, patches &#x3D; plt.hist(arr, bins&#x3D;10, normed&#x3D;0, facecolor&#x3D;&#39;black&#39;, edgecolor&#x3D;&#39;black&#39;,alpha&#x3D;1，histtype&#x3D;&#39;bar&#39;)</span><br></pre></td></tr></table></figure><ul><li><code>Args</code><br>  参数很多，选几个常用的讲解<ul><li>arr: 需要计算直方图的一维数组</li><li>bins: 直方图的柱数，可选项，默认为10</li><li>normed: 是否将得到的直方图向量归一化。默认为0</li><li>facecolor: 直方图颜色</li><li>edgecolor: 直方图边框颜色</li><li>alpha: 透明度</li><li>histtype: 直方图类型，‘bar’, ‘barstacked’, ‘step’, ‘stepfilled’</li></ul></li><li><code>Returns</code><ul><li>n: 直方图向量，是否归一化由参数normed设定</li><li>bins: 返回各个bin的区间范围</li><li>patches: 返回每个bin里面包含的数据，是一个list</li></ul></li></ul></li><li><p><code>numpy</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hist, bin_edges &#x3D; histogram(a, bins&#x3D;10, range&#x3D;None, normed&#x3D;None, weights&#x3D;None, density&#x3D;None)</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def histEstimate(X, n_bins, showfig&#x3D;False):</span><br><span class="line">    &quot;&quot;&quot; 直方图密度估计</span><br><span class="line">    Args:</span><br><span class="line">        n_bins: &#123;int&#125; 直方图的条数</span><br><span class="line">    Returns:</span><br><span class="line">        hist: &#123;ndarray(n_bins,)&#125;</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    n, bins, patches &#x3D; plt.hist(X, bins&#x3D;n_bins, normed&#x3D;1, facecolor&#x3D;&#39;lightblue&#39;, edgecolor&#x3D;&#39;white&#39;)</span><br><span class="line">    if showfig: plt.show()</span><br><span class="line">    return n, bins, patches</span><br></pre></td></tr></table></figure><p><code>matplotlib</code>直方图显示如下<br><img src="/2018/11/19/Non-parameter-Estimation/hist_matplotlib.png" alt="hist_matplotlib"></p><p>拟合各中心点显示如下<br><img src="/2018/11/19/Non-parameter-Estimation/hist_ploy.png" alt="hist_ploy"></p><h1 id="K-n-近邻估计法"><a href="#K-n-近邻估计法" class="headerlink" title="$K_n$近邻估计法"></a>$K_n$近邻估计法</h1><p>随着样本数的增加，区域的体积应该尽可能小，同时又必须保证区域内有充分多的样本，但是每个区域的样本数有必须是总样本数的很小的一部分，而不是与直方图估计那样体积不变。</p><p>那么我们想，能否根据样本的分布调整分区大小呢，$K$近邻估计法就是一种采用可变大小区间的密度估计方法。</p><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>根据总样本确定参数$K_n$，在求样本$x$处的密度估计$\hat{p}(x)$时，调整区域体积$V(x)$，直到区域内恰好落入$K_n$个样本，估计公式为</p><script type="math/tex; mode=display">\hat{p}(x) = \frac{K_n/M}{V(x)} \tag{7}</script><p>一般指定超参数$a$，取</p><script type="math/tex; mode=display">K_n = a × \sqrt{M} \tag{8}</script><blockquote><script type="math/tex; mode=display">\hat{p}(x) = \frac{a × \sqrt{M} /M}{V(x)} = \frac{K_n'/M}{V'(x)}</script><p>其中$K_n’ = a,V’(x) = V(x)×\frac{1}{\sqrt{M}}$</p></blockquote><p>在样本密度比较高的区域的体积就会比较小，而在密度低的区域的体积则会自动增大，这样就能够较好的兼顾在高密度区域估计的分辨率和在低密度区域估计的连续性。</p><h1 id="Parzen窗法"><a href="#Parzen窗法" class="headerlink" title="Parzen窗法"></a>Parzen窗法</h1><p>又称核密度估计。</p><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>我们暂时假设待估计点$x$的附近区间$R$为一个$N$维的<strong>超立方体</strong>，用$h$表示边的长度，那么</p><script type="math/tex; mode=display">V_i = h^N</script><p>即<br><img src="/2018/11/19/Non-parameter-Estimation/Parzen_window.jpg" alt="Parzen_window"><br>定义窗函数$\varphi(·)$，表示落入以$x$为中心的超立方体的区域的点</p><script type="math/tex; mode=display">\varphi \left(\frac{x_i-x}{h}\right) = \begin{cases}    1 & \frac{|x_{in}-x_n|}{h} \leq \frac{1}{2},　n=1,...,N \\    0 & otherwise\end{cases} \tag{9}</script><blockquote><script type="math/tex; mode=display">\frac{|x_{in}-x_n|}{h} \leq \frac{1}{2}　即　(x_i-x)_n \leq \frac{h}{2}</script><p>这里的$h$起到单位化的作用，便于推广</p></blockquote><p>那么落入以$x$为中心的<strong>超立方体</strong>的区域的点的个数为</p><script type="math/tex; mode=display">M_i = \sum_{i=1}^M \varphi \left(\frac{x_i-x}{h}\right) \tag{10}</script><p>代入$p(x) \approx \frac{M_i/M}{V_i}$，我们得到</p><script type="math/tex; mode=display">p(x) \approx \frac{\sum_{i=1}^M \varphi \left(\frac{x_i-x}{h}\right)/M}{V_i}= \frac{1}{M} \sum_{i=1}^M \frac{1}{V_i} \varphi \left(\frac{x_i-x}{h}\right) \tag{11}</script><p>我们定义核函数(或称“窗函数”)</p><script type="math/tex; mode=display">\kappa(z) = \frac{1}{V_i} \varphi(z) \tag{12}</script><p>核函数反应了一个观测样本$x_i$对在$x$处的概率密度估计的贡献，与样本$x_i$和$x$的距离有关。而概率密度估计就是在这一点上把所有观测样本的贡献进行平均</p><script type="math/tex; mode=display">p(x) \approx \frac{1}{M} \sum_{i=1}^M \kappa\left(\frac{x_i-x}{h}\right) \tag{13}</script><h2 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h2><p>核函数应满足概率密度的要求，即</p><script type="math/tex; mode=display">\kappa(z) \geq 0　\And　\int \kappa(z)dz = 1</script><p>通常有以下几种核函数</p><ul><li><p>均匀核</p><script type="math/tex; mode=display">  \kappa(z)  = \begin{cases}      1 & |z_n| \leq \frac{1}{2},　n=1,...,N \\      0 & otherwise  \end{cases}</script></li><li><p>高斯核(正态核)<br>  高斯核是将窗放大到整个空间，各个观测样本$x_i$对待观测点$x$的加权和(越远权值越小)。</p><script type="math/tex; mode=display">  \kappa(z)  = \frac{1}{(2\pi)^{N/2}|\Sigma|^{1/2}}  \exp \left(-\frac{1}{2} (z - \mu)^T \Sigma^{-1} (z - \mu)\right)</script></li><li><p>超球窗</p><script type="math/tex; mode=display">  \kappa(z)  = \begin{cases}      V^{-1} & ||z|| \leq 1 \\      0 & otherwise  \end{cases}</script><blockquote><p>$z=\frac{x_i-x}{h}$，故$||z||\leq 1$即$||x_i-x||^2\leq h^2$<br>此时$h$表示超球体的半径</p></blockquote></li></ul><h2 id="sklearn"><a href="#sklearn" class="headerlink" title="sklearn"></a>sklearn</h2><p><a href="http://sklearn.apachecn.org/en/0.19.0/modules/generated/sklearn.neighbors.KernelDensity.html#sklearn.neighbors.KernelDensity" target="_blank" rel="noopener">sklearn.neighbors.KernelDensity — scikit-learn 0.19.0 documentation - ApacheCN</a><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; from sklearn.neighbors import KernelDensity</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; import numpy as np</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; X = np.array([[-1, -1], [-2, -1], [-3, -2], [1, 1], [2, 1], [3, 2]])</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; kde = KernelDensity(kernel=<span class="string">'gaussian'</span>, bandwidth=0.2).fit(X)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; kde.score_samples(X)</span></span><br><span class="line">array([-0.41075698, -0.41075698, -0.41076071, -0.41075698, -0.41075698,</span><br><span class="line">       -0.41076071])</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; kde.sample(10)</span></span><br><span class="line">array([[ 1.80042291,  1.1030739 ],</span><br><span class="line">       [ 0.87299669,  1.0762352 ],</span><br><span class="line">       [-2.40180586, -1.19554374],</span><br><span class="line">       [-1.97985919, -1.19361193],</span><br><span class="line">       [-2.95866231, -2.1972637 ],</span><br><span class="line">       [-1.12739556, -0.80851063],</span><br><span class="line">       [ 1.03756706,  1.24855099],</span><br><span class="line">       [ 1.21729703,  1.02345815],</span><br><span class="line">       [-2.11816867, -1.0486257 ],</span><br><span class="line">       [-1.04875537, -0.89928711]])</span><br></pre></td></tr></table></figure></p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>具体代码见<br><a href="https://github.com/isLouisHsu/Python-Examples-for-Pattern-Recognition-Course/blob/master/examples/p64_non_parametric_estmation.py" target="_blank" rel="noopener">@Github: Non-parametric Estmation</a></p><p>定义核函数如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 高斯核</span></span><br><span class="line">gaussian = <span class="keyword">lambda</span> z: np.exp(<span class="number">-0.5</span>*(np.linalg.norm(z)**<span class="number">2</span>)) / np.sqrt(<span class="number">2</span>*np.pi)</span><br><span class="line"><span class="comment"># 均匀核</span></span><br><span class="line">square = <span class="keyword">lambda</span> z: <span class="number">1</span> <span class="keyword">if</span> (np.linalg.norm(z) &lt;= <span class="number">0.5</span>) <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>密度估计函数如下，需要对连续范围内的各个点，即$x \in [min(X), max(X)]$进行估计获得<code>p</code>，作图显示$x-p$即可<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parzenEstimate</span><span class="params">(X, kernel, h, n_num=<span class="number">50</span>)</span>:</span></span><br><span class="line">    <span class="string">""" 核参数估计</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        X: &#123;ndarray(n_samples,)&#125;</span></span><br><span class="line"><span class="string">        kernel: &#123;function&#125; 可调用的核函数</span></span><br><span class="line"><span class="string">        h: &#123;float&#125; 核函数的参数</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        p: &#123;ndarray(n_num,)&#125;</span></span><br><span class="line"><span class="string">    Notes:</span></span><br><span class="line"><span class="string">        - 一维，故`V_i = h`</span></span><br><span class="line"><span class="string">        - p(x) = \frac&#123;1&#125;&#123;M&#125; \sum_&#123;i=1&#125;^M \kappa \left( \frac&#123;x_i - x&#125;&#123;h&#125; \right)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    x = np.linspace(np.min(X), np.max(X), num=n_num)</span><br><span class="line">    p = np.zeros(shape=(x.shape[<span class="number">0</span>],))</span><br><span class="line">    z = <span class="keyword">lambda</span> x, x_i, h: (x - x_i) / h</span><br><span class="line">    V_i = h; n_samples = X.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> range(x.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(X.shape[<span class="number">0</span>]):</span><br><span class="line">            p[idx] += kernel(z(x[idx], X[i], h)) / V_i</span><br><span class="line">        p[idx] /= n_samples</span><br><span class="line">    <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure></p><h3 id="均匀核"><a href="#均匀核" class="headerlink" title="均匀核"></a>均匀核</h3><ul><li><p>$h=0.5$<br>  <img src="/2018/11/19/Non-parameter-Estimation/01_h_0.5.png" alt="01_h_0.5"></p></li><li><p>$h=0.8$<br>  <img src="/2018/11/19/Non-parameter-Estimation/01_h_0.8.png" alt="01_h_0.8"></p></li><li><p>$h=1.0$<br>  <img src="/2018/11/19/Non-parameter-Estimation/01_h_1.0.png" alt="01_h_1.0"></p></li><li><p>$h=2.0$<br>  <img src="/2018/11/19/Non-parameter-Estimation/01_h_2.0.png" alt="01_h_2.0"></p></li></ul><h3 id="高斯核"><a href="#高斯核" class="headerlink" title="高斯核"></a>高斯核</h3><ul><li><p>$h=0.5$<br>  <img src="/2018/11/19/Non-parameter-Estimation/gaussian_h_0.5.png" alt="gaussian_h_0.5"></p></li><li><p>$h=0.8$<br>  <img src="/2018/11/19/Non-parameter-Estimation/gaussian_h_0.8.png" alt="gaussian_h_0.8"></p></li><li><p>$h=1.0$<br>  <img src="/2018/11/19/Non-parameter-Estimation/gaussian_h_1.0.png" alt="gaussian_h_1.0"></p></li><li><p>$h=2.0$<br>  <img src="/2018/11/19/Non-parameter-Estimation/gaussian_h_2.0.png" alt="gaussian_h_2.0"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Parameter Estimation</title>
      <link href="/2018/11/19/Parameter-Estimation/"/>
      <url>/2018/11/19/Parameter-Estimation/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.zhihu.com/question/20587681/answer/17435552" target="_blank" rel="noopener">贝叶斯学派与频率学派有何不同？ - 任坤的回答 - 知乎</a></p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>参数估计<code>(parameter estimation)</code>，统计推断的一种。根据从总体中抽取的随机样书．来估计总体分布中未知参数的过程。主要介绍最大似然估计<code>(MLE: Maximum Likelihood Estimation)</code>，最大后验概率估计<code>(MAP: Maximum A Posteriori Estimation)</code>，贝叶斯估计<code>(Bayesian Estimation)</code>。</p><blockquote><p>解释一下“似然函数”和“后验概率”，在<a href="https://louishsu.xyz/2018/10/18/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%86%B3%E7%AD%96/" target="_blank" rel="noopener">贝叶斯决策</a>一节，给出定义如下</p><script type="math/tex; mode=display">P(c_k|x)=\frac{p(x|c_k)P(c_k)}{p(x)}</script><p>上式中$ k=1,…,K  $，各部分定义如下<br>$P(c_k|x)$——<code>后验概率(posteriori probability)</code><br>$P(c_k)$——<code>先验概率(priori probability)</code><br>$p(x|c_k)$——$c_k$关于$x$的<code>似然函数(likelihood)</code><br>$p(x)$——<code>证据因子(evidence)</code></p></blockquote><h1 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h1><p>以最经典的掷硬币实验为例，假设有一枚硬币，投掷一次出现正面记$”1”$，投掷$10$次的实验结果如下</p><script type="math/tex; mode=display">\{ 0， 1， 1， 1， 1， 0， 1， 1， 1，0 \}</script><p>记硬币投掷结果为随机变量$X$，且$ x \in {0, 1}$，硬币投掷一次服从二项分布，估计二项分布的参数$\theta$</p><h1 id="最大似然估计-MLE"><a href="#最大似然估计-MLE" class="headerlink" title="最大似然估计(MLE)"></a>最大似然估计(MLE)</h1><h2 id="似然函数"><a href="#似然函数" class="headerlink" title="似然函数"></a>似然函数</h2><blockquote><p><a href="https://en.wikipedia.org/wiki/Likelihood_function#Definition" target="_blank" rel="noopener">Likelihood function - Wikipedia</a></p></blockquote><ul><li><p>离散型</p><script type="math/tex; mode=display">L(x | \theta) = p_{\theta}(x)=P_{\theta}(X = x)</script></li><li><p>连续型</p><script type="math/tex; mode=display">L(x | \theta) = f_{\theta}(x)</script></li></ul><blockquote><p>很多人能讲出一大堆哲学理论来阐明这一对区别。<br>但我觉得，从工程师角度来讲，这样理解就够了:<br>频率 $vs$ 贝叶斯 = $P(X; w)$ $vs$ $P(X|w)$ 或 $P(X,w)$</p><p>作者：许铁-巡洋舰科技<br>链接：<a href="https://www.zhihu.com/question/20587681/answer/122348889" target="_blank" rel="noopener">https://www.zhihu.com/question/20587681/answer/122348889</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>有数据集$D = {x_1, x_2, …, x_N}$，按$c$个类别分成${D_1, D_2, …, D_C}$，各个类别服从的概率分布密度函数模型已给出，估计参数$\hat{\Theta} = {\hat{\theta}_{c_1}, \hat{\theta}_{c_2}, …, \hat{\theta}_{c_C}} $</p><p><strong>假定</strong></p><ul><li>类别间独立，且各自服从概率分布密度函数为$p(x|c_j)$</li><li>各类别的概率密度$p(x|c_j)$以参数$\theta_{c_j}$确定，即$p(x|c_j; \theta_{c_j})$</li></ul><p>故似然函数为</p><script type="math/tex; mode=display">L(D | \Theta) = P(x_1, x_2, ..., x_N | \Theta) = \prod_{i=1}^N p(x_i | \theta_{x_i \in c_j})</script><blockquote><p>理解为，在参数$\Theta$为何值的条件下，实验结果出现数据集$D$的概率最大</p></blockquote><p>求取其极大值对应的参数即可</p><ul><li>一般取对数似然函数<script type="math/tex; mode=display">\log L(D | \Theta) = \sum_{i=1}^N \log p(x_i | \theta_{x_i \in c_j})</script></li><li>极大值即对应梯度为$\vec{0}$的位置，即<script type="math/tex; mode=display">∇_\Theta  \log L(D | \Theta) = \vec{0}\Rightarrow\hat{\Theta}</script></li></ul><blockquote><p>Some comments about ML</p><ul><li>ML estimation is usually simpler than alternative methods. </li><li>Has good convergence properties as the number of training samples increases. </li><li>If the model chosen for p(x|θ) is correct, and independence assumptions among variables are true, ML will give very good results.</li><li>If the model is wrong, ML will give poor results.<div style="text-align: right"> —— Zhao Haitao. Maximum Likelihood and Bayes Estimation </div></li></ul></blockquote><h2 id="例：正态分布的最大似然估计"><a href="#例：正态分布的最大似然估计" class="headerlink" title="例：正态分布的最大似然估计"></a>例：正态分布的最大似然估计</h2><p>数据集(单类别)服从高斯分布$N(\mu, \sigma^2)$时的的最大似然估计</p><script type="math/tex; mode=display">P(x_i | \mu, \sigma^2) = \frac{1}{\sqrt{2\pi} \sigma } e^ {-\frac{(x_i - \mu)^2}{2\sigma^2}}</script><script type="math/tex; mode=display">L(D | \mu, \sigma^2) = \prod_{i=1}^N \frac{1}{\sqrt{2\pi} \sigma } e^ {-\frac{(x_i - \mu)^2}{2\sigma^2}}=\left( \frac{1}{\sqrt{2\pi} \sigma } \right)^N \prod_{i=1}^N e^ {-\frac{(x_i - \mu)^2}{2\sigma^2}}</script><p>取对数似然</p><script type="math/tex; mode=display">\log L(D | \mu, \sigma^2) = - \frac{N}{2} \log(2\pi \sigma^2) - \frac{1}{2\sigma^2} \sum_{i=1}^N (x_i - \mu)^2</script><h3 id="1-参数-mu-的估计"><a href="#1-参数-mu-的估计" class="headerlink" title="1. 参数$\mu$的估计"></a>1. 参数$\mu$的估计</h3><script type="math/tex; mode=display">\frac{∂}{∂\mu} L(D | \mu, \sigma^2) = \frac{1}{\sigma^2} (\sum_{i=1}^N x_i - N\mu)= 0</script><script type="math/tex; mode=display">\Rightarrow\hat{\mu}= \frac{1}{N}\sum_{i=1}^N x_i</script><h3 id="2-参数-sigma-2-的估计"><a href="#2-参数-sigma-2-的估计" class="headerlink" title="2. 参数$\sigma^2$的估计"></a>2. 参数$\sigma^2$的估计</h3><script type="math/tex; mode=display">\frac{∂}{∂\sigma^2} \log L(D | \mu, \sigma^2) = - \frac{N}{2\sigma^2} +\frac{1}{2\sigma^4} \sum_{i=1}^N (x_i - \mu)^2= 0</script><script type="math/tex; mode=display">\Rightarrow\hat{\sigma^2} = \frac{1}{N} \sum_{i=1}^N (x_i - \mu)^2</script><blockquote><p>参数$\hat{\mu}, \hat{\sigma}^2$的值与样本均值和样本方差相等</p></blockquote><h1 id="最大后验概率估计-MAP"><a href="#最大后验概率估计-MAP" class="headerlink" title="最大后验概率估计(MAP)"></a>最大后验概率估计(MAP)</h1><!-- > [高斯混合模型(GMM)与最大期望算法(EM)]() --><h2 id="模型-1"><a href="#模型-1" class="headerlink" title="模型"></a>模型</h2><p>最大似然估计是求参数$\theta$, 使似然函数$P(D | \theta)$最大，最大后验概率估计则是求$\theta$使$P(\theta | D)$最大</p><blockquote><p>理解为，在已出现的实验样本$D$上，参数$\theta$取何值的概率最大</p></blockquote><p>且注意到</p><script type="math/tex; mode=display">P(\theta | D) = \frac{P(D | \theta)P(\theta)}{P(D)}</script><p>故$MAP$不仅仅使似然函数$P(D | \theta)$最大，而且使$P(\theta)$最大，即</p><script type="math/tex; mode=display">\theta = argmax L(\theta | D)</script><script type="math/tex; mode=display">L(\theta | D) = P(\theta) P(D | \theta)= P(\theta) \prod_{i=1}^N p(x_i | \theta)</script><blockquote><p>比$ML$多了一项$P(\theta)$</p></blockquote><ul><li><p>取对数后</p><script type="math/tex; mode=display">\log L(\theta | D) = \sum_{i=1}^N \log p(x_i | \theta) + \log P(\theta)</script></li><li><p>求取极大值</p><script type="math/tex; mode=display">∇_\theta L(\theta | D) = 0\Rightarrow\hat{\theta}</script></li></ul><blockquote><p>$MAP$和$MLE$的区别：<br>$MAP$允许我们把先验知识加入到估计模型中，这在<strong>样本很少</strong>的时候是很有用的，因为样本很少的时候我们的观测结果很可能出现偏差，此时先验知识会把估计的结果“拉”向先验，实际的预估结果将会在先验结果的两侧形成一个顶峰。通过调节先验分布的参数，比如<code>beta</code>分布的$\alpha, \beta$，我们还可以调节把估计的结果“拉”向先验的幅度，$\alpha, \beta$越大，这个顶峰越尖锐。这样的参数，我们叫做预估模型的“超参数”。<br><a href="https://blog.csdn.net/hustlx/article/details/51144710" target="_blank" rel="noopener">极大似然估计，最大后验概率估计(MAP)，贝叶斯估计 - 李鑫o_O - CSDN博客</a></p></blockquote><h2 id="例：正态分布的最大后验概率估计"><a href="#例：正态分布的最大后验概率估计" class="headerlink" title="例：正态分布的最大后验概率估计"></a>例：正态分布的最大后验概率估计</h2><p>数据集(单类别)服从高斯分布$N(\mu, \sigma^2)$时的最大后验概率估计</p><script type="math/tex; mode=display">p(x_i | \mu, \sigma^2) = \frac{1}{\sqrt{2\pi} \sigma } e^ {-\frac{(x_i - \mu)^2}{2\sigma^2}}</script><blockquote><script type="math/tex; mode=display">\log p(x_i | \mu, \sigma^2)= - \frac{1}{2} \log(2\pi \sigma^2) - \frac{1}{2\sigma^2} (x_i - \mu)^2</script></blockquote><h3 id="1-参数-mu-的估计-1"><a href="#1-参数-mu-的估计-1" class="headerlink" title="1. 参数$\mu$的估计"></a>1. 参数$\mu$的估计</h3><p>给定先验条件：$\mu$服从正态分布$N(\mu_0, \sigma_{\mu_0}^2)$，即</p><script type="math/tex; mode=display">p(\mu) = \frac{1}{\sqrt{2\pi}\sigma_{\mu_0}} e^ {-\frac{(\mu - \mu_0)^2}{2\sigma_{\mu_0}^2}}</script><blockquote><script type="math/tex; mode=display">\log p(\mu)= - \frac{1}{2} \log(2\pi \sigma_{\mu_0}^2) - \frac{1}{2\sigma_{\mu_0}^2} (\mu - \mu_0)^2</script></blockquote><p>则</p><script type="math/tex; mode=display">\log L(\mu, \sigma^2 | D)= - \frac{N}{2} \log(2\pi \sigma^2) - \frac{1}{2\sigma^2} \sum_{i=1}^N (x_i - \mu)^2 - \frac{1}{2} \log(2\pi \sigma_{\mu_0}^2) - \frac{1}{2\sigma_{\mu_0}^2} (\mu - \mu_0)^2</script><p>则</p><script type="math/tex; mode=display">\frac{∂}{∂\mu} \log L(\mu, \sigma^2 | D)= \frac{1}{\sigma^2} \sum_{i=0}^N (x_i - \mu) - \frac{1}{\sigma_{\mu_0}^2} (\mu - \mu_0)= 0</script><script type="math/tex; mode=display">\Rightarrow\hat{\mu}= \frac{\mu_0 \sigma^2 + \sigma_{\mu_0}^2 \sum_{i=0}^N x_i}{\sigma^2 + N \sigma_{\mu_0}^2}= \frac{\mu_0 + \frac{\sigma_{\mu_0}^2}{\sigma^2} \sum_{i=0}^N x_i}{1 + \frac{\sigma_{\mu_0}^2}{\sigma^2} N }</script><h3 id="2-参数-sigma-2-的估计-1"><a href="#2-参数-sigma-2-的估计-1" class="headerlink" title="2. 参数$\sigma^2$的估计"></a>2. 参数$\sigma^2$的估计</h3><p>给定先验条件：$\sigma^2$服从正态分布$N(\sigma_0^2, \sigma_{\sigma_0^2}^2)$，即</p><script type="math/tex; mode=display">p(\sigma^2) = \frac{1}{\sqrt{2\pi} \sigma_{\sigma_0^2}} e^ {-\frac{(\sigma^2- \sigma_0^2)^2}{2 \sigma_{\sigma_0^2} ^2}}</script><blockquote><script type="math/tex; mode=display">\log p(\sigma^2) = - \frac{1}{2} \log(2\pi \sigma_{\sigma_0}^2) - \frac{1}{2\sigma_{\sigma_0}^2} (\sigma - \sigma_0)^2</script></blockquote><p>则</p><script type="math/tex; mode=display">\log L(\mu, \sigma^2 | D)= - \frac{N}{2} \log(2\pi \sigma^2) - \frac{1}{2\sigma^2} \sum_{i=1}^N (x_i - \mu)^2 - \frac{1}{2} \log(2\pi \sigma_{\sigma_0}^2) - \frac{1}{2\sigma_{\sigma_0}^2} (\sigma - \sigma_0)^2</script><p>则</p><script type="math/tex; mode=display">\frac{∂}{∂\sigma^2} \log L(\mu, \sigma^2 | D)= - \frac{N}{2\sigma^2} + \frac{1}{2\sigma^4} \sum_{i=1}^N (x_i - \mu)^2 - \frac{1}{2\sigma_{\sigma_0}^2} \frac{\sigma - \sigma_0}{\sigma}\Rightarrow\hat{\sigma^2}(略)</script><blockquote><script type="math/tex; mode=display">\frac{∂}{∂\sigma^2}(\sigma - \sigma_0)^2= 2(\sigma - \sigma_0)\frac{∂}{∂\sigma^2} (\sigma - \sigma_0)= \frac{\sigma - \sigma_0}{\sigma}</script></blockquote><h1 id="贝叶斯估计"><a href="#贝叶斯估计" class="headerlink" title="贝叶斯估计"></a>贝叶斯估计</h1><h2 id="模型-2"><a href="#模型-2" class="headerlink" title="模型"></a>模型</h2><!-- 贝叶斯公式：$$P(c_i|x) = \frac{p(x|c_i)p(c_i)}{\sum_j p(x|c_j)p(c_j)}$$在给定数据集$D=\{x_1, x_2, ..., x_N\}$的情况下，可从数据中估计先验概率和似然函数，即$$P(c_i|x, D) = \frac{p(x|c_i, D)p(c_i, D)}{\sum_j p(x|c_j, D)p(c_j, D)}$$**假定**- 先验概率密度函数为$p(c_i)$已知- 抽样结果几乎与真实分布一致，即$ p(c_i, D) \approx p(c_i) $则$$P(c_i|x, D) = \frac{p(x|c_i, D)p(c_i)}{\sum_j p(x|c_j, D)p(c_j)}$$只需从样本中，估计每个类别的似然函数$p(x|c_i, D)$即可>-----------------------------------------------现考虑**单个类别**中抽取的数据集$D$，如何估计该类别的似然函数$p(x | \theta)$参数$\theta$呢？若概率密度函数为$p(x | \theta)$，记从数据集中估计得到的似然函数为$p(x | D)$，有$$p(x | \theta) \approx p(x | D)$$> $p(x | D)$ would be the estimate of $p(x | \theta)$ given $D$且$$p(x | D) = \int p(x, \theta | D) d \theta= \int p(x | \theta, D) p(\theta | D) d \theta$$> Links $p(x | D)$ with $p(θ | D)$其中- $p(x | \theta, D) \approx p(x | \theta) $- $p(\theta | D) = \frac {P(D | \theta)p(\theta)} {P(D)}= \frac{p(\theta) \prod_{i=1}^N p(x_i | \theta)}{P(D)}$故$$p(x | D) = \int p(x | \theta) p(\theta | D) d \theta$$总的来说 --><script type="math/tex; mode=display">p(\theta | D) = \frac {P(D | \theta)p(\theta)} {P(D)}= a · p(\theta) \prod_{i=1}^N p(x_i | \theta)</script><p>其中$a$是使</p><script type="math/tex; mode=display">\int p(\theta | D)  = 1</script><p>利用“质心公式”求解贝叶斯的点估计</p><script type="math/tex; mode=display">θ_{Bayes} = \int θ·p(θ|D) d θ</script><h2 id="例：正态分布的贝叶斯估计"><a href="#例：正态分布的贝叶斯估计" class="headerlink" title="例：正态分布的贝叶斯估计"></a>例：正态分布的贝叶斯估计</h2><p>数据集(单类别)服从高斯分布$N(\mu, \sigma^2)$时的贝叶斯估计</p><script type="math/tex; mode=display">p(x_i | \mu, \sigma^2) = \frac{1}{\sqrt{2\pi} \sigma } e^ {-\frac{(x_i - \mu)^2}{2\sigma^2}}</script><h3 id="参数-mu-的估计"><a href="#参数-mu-的估计" class="headerlink" title="参数$\mu$的估计"></a>参数$\mu$的估计</h3><p>给定先验条件：$\mu$服从正态分布$N(\mu_0, \sigma_{\mu_0}^2)$，即</p><script type="math/tex; mode=display">p(\mu) = \frac{1}{\sqrt{2\pi}\sigma_{\mu_0}} e^ {-\frac{(\mu - \mu_0)^2}{2\sigma_{\mu_0}^2}}</script><p>则</p><script type="math/tex; mode=display">P(\mu | D) = a · p(\mu) \prod_{i=1}^N p(x_i | \mu)= a · \frac{1}{\sqrt{2\pi}\sigma_{\mu_0}} e^ {-\frac{(\mu - \mu_0)^2}{2\sigma_{\mu_0}^2}}\prod_{i=1}^N \frac{1}{\sqrt{2\pi} \sigma } e^ {-\frac{(x_i - \mu)^2}{2\sigma^2}}</script><script type="math/tex; mode=display">= a · \left( \frac{1}{\sqrt{2\pi}} \right)^{N + 1}\frac{1}{\sigma_{\mu_0} \sigma^N}e^ {-\frac{(\mu - \mu_0)^2}{2\sigma_{\mu_0}^2} -\sum_{i=1}^N \frac{(x_i - \mu)^2}{2\sigma^2}}</script><p>易证</p><blockquote><p></p><p align="right">我已经想到了一个绝妙的证明,但是这台电脑的硬盘太小了,写不下。</p><br><!-- > <p align="right">诶嘿，显然成立，2333333</p> --><p></p></blockquote><script type="math/tex; mode=display">p(\mu | D) = \frac{1}{\sqrt{2\pi}\sigma_N} e^ {-\frac{(\mu - \mu_N)^2}{2\sigma_N^2}}</script><p>其中</p><script type="math/tex; mode=display">\mu_N = \frac{N \sigma_0^2}{N \sigma_0^2 + \sigma^2}\frac{1}{N} \sum_{i=1}^N x_i+\frac{\sigma^2}{N \sigma_0^2 + \sigma^2}\mu_0</script><script type="math/tex; mode=display">\sigma_N^2 = \frac{\sigma_0^2 \sigma^2}{N \sigma_0^2 + \sigma^2}</script><blockquote><p><strong>与$MLE$，$MAP$的区别</strong></p><ul><li>相比较$MLE$与$MAP$的点估计，贝叶斯估计得到的结果是参数$\theta$的密度函数$p(\theta | D)$</li><li><p>最大后验概率估计为求取对应最大后验概率的点</p><script type="math/tex; mode=display">\theta = argmax_\theta p(\theta | D)</script></li><li><p>贝叶斯估计为求取整个取值范围的概率密度$p(\theta | D)$，既然如此，必有</p><script type="math/tex; mode=display">\int p(\theta | D) d\theta = 1</script></li></ul><p><a href="https://www.cnblogs.com/zjh225901/p/7495505.html" target="_blank" rel="noopener">统计学习方法学习笔记（一）—极大似然估计与贝叶斯估计原理及区别 - YJ-20 - 博客园</a></p><script type="math/tex; mode=display">p(\theta | D) = \frac{p(\theta) \prod_{i=1}^N p(x_i | \theta)}{\int_\theta p(\theta) \prod_{i=1}^N p(x_i | \theta) d\theta}</script><p>由于$\theta$是满足一定概率分布的变量，所以在计算的时候需要将考虑所有$\theta$取值的情况，在计算过程中不可避免地高复杂度。所以计算时并不把所有地后验概率$p(\theta | D)$都找出来，而是采用类似于极大似然估计地思想，来极大化后验概率，得到这种有效的叫做$MAP$</p></blockquote><h1 id="引例的求解"><a href="#引例的求解" class="headerlink" title="引例的求解"></a>引例的求解</h1><p>已知硬币投掷结果服从$Bernoulli$分布</p><table>  <tr>    <th>X</th>    <th>0</th>    <th>1</th>  </tr>  <tr>    <td>P</td>    <td>1-θ</td>    <td>θ</td>  </tr></table><p>或者</p><script type="math/tex; mode=display">P(X_i) = \theta ^{X_i} (1 - \theta) ^{1 - X_i}</script><h2 id="最大似然估计"><a href="#最大似然估计" class="headerlink" title="最大似然估计"></a>最大似然估计</h2><p>实验结果中正面出现$7$次，反面出现$3$次，似然函数为</p><script type="math/tex; mode=display">L(\theta) = \prod_{i=1}^{10} \theta ^{X_i} (1 - \theta) ^{1 - X_i} = \theta ^7 (1 - \theta) ^3</script><p>取对数似然函数并求极大值</p><script type="math/tex; mode=display">\log L(\theta) = 7 \log \theta + 3 \log (1 - \theta)</script><p>令</p><script type="math/tex; mode=display">\frac{∂}{∂ \theta} \log L(\theta)= \frac{7}{\theta} - \frac{3}{1-\theta} = 0</script><p>解得</p><script type="math/tex; mode=display">\theta = 0.7</script><p>即硬币服从$B(1, 0.7)$的概率分布</p><blockquote><p>做出$L(\theta)$图像验证，如下<br><img src="/2018/11/19/Parameter-Estimation/最大似然估计.png" alt="最大似然估计"></p></blockquote><h2 id="最大后验概率估计"><a href="#最大后验概率估计" class="headerlink" title="最大后验概率估计"></a>最大后验概率估计</h2><p>给定先验条件</p><script type="math/tex; mode=display">\theta \thicksim N(\theta_0, \sigma_{\theta_0}^2)</script><p>则最大化</p><script type="math/tex; mode=display">L(\theta | D) = \theta ^7 (1 - \theta) ^3 · \frac{1}{\sqrt{2\pi}\sigma_{\theta_0}} e^ {-\frac{(\theta - \theta_0)^2}{2\sigma_{\theta_0}^2}}</script><p>取对数</p><script type="math/tex; mode=display">\log L(\theta | D)= 7 \log \theta + 3 \log (1 - \theta) - \frac{1}{2} \log(2\pi \sigma_{\theta_0}^2) - \frac{1}{2\sigma_{\theta_0}^2} (\theta - \theta_0)^2</script><p>求取极大值点</p><script type="math/tex; mode=display">\frac{∂}{∂\theta} \log L(\theta | D) = \frac {7}{\theta} - \frac{3}{1-\theta} - \frac{\theta - \theta_0}{\sigma_{\theta_0}^2} = 0</script><p>得到</p><script type="math/tex; mode=display">\theta^3 - (\theta_0 + 1) \theta^2 + (\theta_0 - 10\sigma_{\theta_0}^2) \theta + 7\sigma_{\theta_0}^2 = 0</script><p>以下为选取不同先验条件时的$L(\theta | D)$图像，用于对比</p><blockquote><ul><li>第一张图为极大似然估计$L(D|\theta)$</li><li>第二张图为先验概率密度函数$P(\theta)$</li><li>第三张图为最大后验概率估计$L(\theta | D)$，$\hat{\theta}$由查表法求解<br>代码见<a href="https://github.com/isLouisHsu/isLouisHsu.github.io/tree/Hexo/source/_posts//参数估计的几种方法/temp.py" target="_blank" rel="noopener">仓库</a></li></ul></blockquote><ul><li><p>$\theta_0 = 0.3, \sigma_{\theta_0} = 0.1$ $\Rightarrow$ $\hat{\theta} = 0.42$<br><img src="/2018/11/19/Parameter-Estimation/MAP_theta0_0.3&#32;sigma0_0.1.png" alt="对比图"></p></li><li><p>$\theta_0 = 0.5, \sigma_{\theta_0} = 0.1$ $\Rightarrow$ $\hat{\theta} = 0.56$<br><img src="/2018/11/19/Parameter-Estimation/MAP_theta0_0.5&#32;sigma0_0.1.png" alt="对比图"></p></li><li><p>$\theta_0 = 0.7, \sigma_{\theta_0} = 0.1$ $\Rightarrow$ $\hat{\theta} = 0.70$<br><img src="/2018/11/19/Parameter-Estimation/MAP_theta0_0.7&#32;sigma0_0.1.png" alt="对比图"></p></li><li><p>$\theta_0 = 0.5, \sigma_{\theta_0} = 0.01$ $\Rightarrow$ $\hat{\theta} = 0.50$<br><img src="/2018/11/19/Parameter-Estimation/MAP_theta0_0.5&#32;sigma0_0.01.png" alt="对比图"></p></li><li><p>$\theta_0 = 0.5, \sigma_{\theta_0} = 1.0$ $\Rightarrow$ $\hat{\theta} = 0.70$<br><img src="/2018/11/19/Parameter-Estimation/MAP_theta0_0.5&#32;sigma0_1.0.png" alt="对比图"></p></li></ul><blockquote><p>结论</p><ul><li>由图$1, 2, 3$，可以看到当$\theta_0$偏移$0.7$时，$MAP$结果也相应偏移；</li><li>由图$2, 4, 5$，可以看到当$\sigma_{\theta_0}^2$越小，即越确定先验概率分布时，$MAP$结果也越趋向于先验概率分布。</li></ul></blockquote><h2 id="贝叶斯估计-1"><a href="#贝叶斯估计-1" class="headerlink" title="贝叶斯估计"></a>贝叶斯估计</h2><p>先验条件为正态分布</p><script type="math/tex; mode=display">\theta \thicksim N(\theta_0, \sigma_{\theta_0}^2)</script><script type="math/tex; mode=display">p(\theta | D)= a · p(\theta) \prod_{i=1}^N p(x_i | \theta)= a · \frac{1}{\sqrt{2\pi}\sigma_{\theta_0}} e^ {-\frac{(\theta - \theta_0)^2}{2\sigma_{\theta_0}^2}} · \theta ^7 (1 - \theta) ^3</script><blockquote><p>参数$a$使用<code>scipy.integrate.quad</code>求解</p></blockquote><p>选取不同先验条件时的$L(\theta | D)$图像，用于对比</p><ul><li><p>$\theta_0 = 0.3, \sigma_{\theta_0} = 0.1$<br><img src="/2018/11/19/Parameter-Estimation/BE_theta0_0.3&#32;sigma0_0.1.png" alt="对比图"></p></li><li><p>$\theta_0 = 0.5, \sigma_{\theta_0} = 0.1$<br><img src="/2018/11/19/Parameter-Estimation/BE_theta0_0.5&#32;sigma0_0.1.png" alt="对比图"></p></li><li><p>$\theta_0 = 0.7, \sigma_{\theta_0} = 0.1$<br><img src="/2018/11/19/Parameter-Estimation/BE_theta0_0.7&#32;sigma0_0.1.png" alt="对比图"></p></li><li><p>$\theta_0 = 0.5, \sigma_{\theta_0} = 0.01$<br><img src="/2018/11/19/Parameter-Estimation/BE_theta0_0.5&#32;sigma0_0.01.png" alt="对比图"></p></li><li><p>$\theta_0 = 0.5, \sigma_{\theta_0} = 1.0$<br><img src="/2018/11/19/Parameter-Estimation/BE_theta0_0.5&#32;sigma0_1.0.png" alt="对比图"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Clustering</title>
      <link href="/2018/11/16/Clustering/"/>
      <url>/2018/11/16/Clustering/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>这是第一篇关于无监督学习的博文，无监督的学习则不是尝试预测任何东西，而是寻找数据中的特征，在无监督学习中，有一个重要的方法称为聚类，是把具有相同特征的数据聚集在一组。</p><ul><li><a href="#目录">目录</a></li><li><a href="#基础知识">基础知识</a><ul><li><a href="#距离度量方法">距离度量方法</a></li><li><a href="#hard-vs-soft-clustering">hard vs. soft clustering</a></li><li><a href="#聚类方法的分类">聚类方法的分类</a></li></ul></li><li><a href="#常用聚类方法">常用聚类方法</a><ul><li><a href="#k均值k-means">K均值(K-means)</a><ul><li><a href="#原理">原理</a></li><li><a href="#计算步骤">计算步骤</a></li><li><a href="#缺点与部分解决方法">缺点与部分解决方法</a></li><li><a href="#改进">改进</a></li><li><a href="#类似的算法">类似的算法</a></li><li><a href="#代码">代码</a></li></ul></li><li><a href="#均值漂移meanshift">均值漂移(Meanshift)</a><ul><li><a href="#原理-1">原理</a></li><li><a href="#高斯权重">高斯权重</a></li><li><a href="#计算步骤-1">计算步骤</a></li><li><a href="#代码-1">代码</a></li></ul></li><li><a href="#谱聚类spectral-clustering">谱聚类(Spectral Clustering)</a><ul><li><a href="#原理-2">原理</a><ul><li><a href="#无向权重图">无向权重图</a></li><li><a href="#相似矩阵">相似矩阵</a></li><li><a href="#拉普拉斯矩阵graph-laplacians">拉普拉斯矩阵(Graph Laplacians)</a></li><li><a href="#无向图的切图">无向图的切图</a><ul><li><a href="#cut">cut</a></li><li><a href="#ratio-cut">Ratio Cut</a></li><li><a href="#n-cut">N Cut</a></li></ul></li></ul></li><li><a href="#计算步骤-2">计算步骤</a></li><li><a href="#代码-2">代码</a></li></ul></li><li><a href="#dbscan">DBSCAN</a><ul><li><a href="#原理-3">原理</a></li><li><a href="#计算思想">计算思想</a></li><li><a href="#算法步骤">算法步骤</a></li></ul></li><li><a href="#高斯混合模型gmm">高斯混合模型(GMM)</a></li><li><a href="#层次聚类hierarchical-clustering">层次聚类(Hierarchical Clustering)</a></li><li><a href="#图团体检测graph-community-detection">图团体检测(Graph Community Detection)</a></li></ul></li></ul><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="距离度量方法"><a href="#距离度量方法" class="headerlink" title="距离度量方法"></a>距离度量方法</h2><p>机器学习中距离度量方法有很多，以下简单介绍几种。</p><blockquote><p><a href="https://blog.csdn.net/taotiezhengfeng/article/details/80492128" target="_blank" rel="noopener">机器学习常用的距离度量方法 - taotiezhengfeng的博客 - CSDN博客</a><br><a href="https://blog.csdn.net/u014782458/article/details/58180885" target="_blank" rel="noopener">算法中的各种距离（欧式距离，马氏距离，闵可夫斯基距离……） - 啊哦123的博客 - CSDN博客 </a></p></blockquote><p>定义两个$n$维向量</p><script type="math/tex; mode=display">x = [x_1, x_2, ..., x_n]^T</script><script type="math/tex; mode=display">y = [y_1, y_2, ..., y_n]^T</script><ul><li><p>曼哈顿距离<code>(Manhattan Distance)</code></p><script type="math/tex; mode=display">  d = || x - y ||_1 = \sum_i |x_i - y_i|</script></li><li><p>欧氏距离<code>(Euclidean Distance)</code></p><script type="math/tex; mode=display">  d = || x - y ||_2 = \sqrt{\sum_i (x_i - y_i)^2}</script></li><li><p>闽可夫斯基距离<code>(Minkowski Distance)</code></p><script type="math/tex; mode=display">  d = || x - y ||_p = \left(\sum_i | x_i - y_i |^{p} \right)^{\frac{1}{p}}</script><p>  当$p$取$1$时为曼哈顿距离，取$2$时为欧式距离。</p></li><li><p>余弦距离<code>(Cosine)</code></p><script type="math/tex; mode=display">  d = \frac{x^T y}{||x||_2 ||y||_2} = \frac{\sum_i x_i y_i}{\sqrt{\sum_i x_i^2} \sqrt{\sum_i y_i^2}}</script><blockquote><p>突然想到为什么向量的夹角余弦是怎么来的，高中学习一直背的公式，现在给一下证明。<br>证明：向量的夹角公式<br><img src="/2018/11/16/Clustering/cosine_distance.png" alt="cosine_distance"></p><p>从余弦定理(余弦定理用几何即可)出发，有</p><script type="math/tex; mode=display">\cos \theta = \frac{a^2+b^2-c^2}{2ab}</script><p>其中</p><script type="math/tex; mode=display">\begin{cases}    ||\vec{a}|| = \sqrt{x_1^2 + y_1^2} \\    ||\vec{b}|| = \sqrt{x_2^2 + y_2^2} \\    ||\vec{c}|| = \sqrt{(x_1 - x_2)^2 + (x_2 - y_2)^2}\end{cases}</script><p>故</p><script type="math/tex; mode=display">\cos \theta = \frac{(\sqrt{x_1^2 + y_1^2})^2 + (\sqrt{x_2^2 + y_2^2})^2 - (\sqrt{(x_1 - x_2)^2 + (x_2 - y_2)})^2}{2 \sqrt{x_1^2 + y_1^2} \sqrt{x_2^2 + y_2^2}}</script><script type="math/tex; mode=display">= \frac  {x_1 x_2 + y_1 y_2}  {\sqrt{x_1^2 + y_1^2} \sqrt{x_2^2 + y_2^2}}  = \frac{a^T b}{||a||·||b||}</script></blockquote></li></ul><h2 id="hard-vs-soft-clustering"><a href="#hard-vs-soft-clustering" class="headerlink" title="hard vs. soft clustering"></a>hard vs. soft clustering</h2><ul><li>硬聚类<code>(hard clustering)</code><br>  计算的是一个硬分配<code>(hard ssignment)</code>过程,即每个样本仅仅属于一个簇。</li><li>软聚类<code>(soft clustering)</code><br>  分配过程是软的，即一个样本的分配结果是在所有簇上的一个分布，在软分配结果中，一个样本可能对多个簇都具有隶属度。</li></ul><h2 id="聚类方法的分类"><a href="#聚类方法的分类" class="headerlink" title="聚类方法的分类"></a>聚类方法的分类</h2><ul><li>划分方法<br>  <code>K-means</code>，<code>K-medoids</code>，<code>GMM</code>等。</li><li>层次方法<br>  <code>AGNES</code>，<code>DIANA</code>，<code>BIRCH</code>，<code>CURE</code>和<code>CURE-NS</code>等。</li><li>基于密度的方法<br>  <code>DBSCAN</code>，<code>OPTICS</code>，<code>DENCLUE</code>等。</li><li>其他<br>  如<code>STING</code>等。</li></ul><h1 id="常用聚类方法"><a href="#常用聚类方法" class="headerlink" title="常用聚类方法"></a>常用聚类方法</h1><h2 id="K均值-K-means"><a href="#K均值-K-means" class="headerlink" title="K均值(K-means)"></a>K均值(K-means)</h2><p>是最为经典的基于划分的聚类方法，是十大经典数据挖掘算法之一，通常用于寻找次优解，再通过其他算法(如<code>GMM</code>)寻找更优的聚类结果。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>给定$N$维数据集</p><script type="math/tex; mode=display">X = [x^{(1)}, x^{(2)}, ..., x^{(M)}]</script><p>指定类别数$K$与初始中心点$\mu^{(0)}$，将样本划分到中心点距离其最近的簇中，再根据本次划分更新各簇的中心$\mu^{(t)}$，如此迭代直至得到最好的聚类结果。预测测试样本时，将其划分到中心点距其最近的簇，也可通过<code>KNN</code>等方法。</p><p>一般使用欧式距离度量样本到各中心点的距离，也可选择余弦距离等，这也是<code>K-means</code>算法的关键</p><script type="math/tex; mode=display">D(x^{(i)}, \mu_k) = || x^{(i)} - \mu_k ||_2^2</script><p>定义损失函数为</p><script type="math/tex; mode=display">J(\Omega) = \sum_i \sum_k r^{(i)}_k D(x^{(i)}, \mu_k)</script><p>其中</p><script type="math/tex; mode=display">r^{(i)}_k = \begin{cases}    1 & x^{(i)} \in C_k \\    0 & otherwise\end{cases}</script><p>或表示为</p><script type="math/tex; mode=display">r^{(i)} = [0, ..., 1_k, ..., 0]^T</script><p>在迭代过程中，损失函数的值不断下降，优化目标为</p><script type="math/tex; mode=display">\min J(\Omega)</script><h3 id="计算步骤"><a href="#计算步骤" class="headerlink" title="计算步骤"></a>计算步骤</h3><ol><li>随机选取$K$个中心点；</li><li>遍历所有数据，计算每个点到各中心点的距离；</li><li>将每个数据划分到最近的中心点中；</li><li>计算每个聚类的平均值，作为新的中心点；</li><li>重复步骤2-步骤4，直到这k个中线点不再变化(收敛)，或执行了足够多的迭代；</li></ol><p><code>K-means</code>更新迭代过程如下图<br><img src="/2018/11/16/Clustering/kmeans_example.gif" alt="kmeans_example"></p><h3 id="缺点与部分解决方法"><a href="#缺点与部分解决方法" class="headerlink" title="缺点与部分解决方法"></a>缺点与部分解决方法</h3><ul><li>局部最优</li><li>初值敏感<br>  初始点的选择会影响<code>K-means</code>聚类的结果，即可能会陷入局部最优解，如下图<br>  <img src="/2018/11/16/Clustering/k_means_init.png" alt="k_means_init"><br>  可通过如下方法解决<ul><li>多次选择初始点运行<code>K-means</code>算法，选择最优的作为输出结果；</li><li><code>K-means++</code></li></ul></li><li>需要定义<code>mean</code>，对于标称型<code>(categorical)</code>数据不适用</li><li>需要给定聚类簇数目$K$<br>  这里给出一种选择簇数目的方法，选择多个$K$值进行聚类，计算代价函数，做成折线图后如下，可以看到在$K=3$处损失值的变化率出现较大变化，则可选择簇的数目为$3$。<br>  <img src="/2018/11/16/Clustering/k_means_choose_K.png" alt="k_means_choose_K"></li><li>噪声数据干扰大</li><li>对于非凸集<code>(non-convex)</code>数据无能为力<br>  谱聚类可解决非凸集数据的聚类问题。</li></ul><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><ul><li><code>K-means++</code><br>  改进初始点选择方法，第$1$个中心点随机选择；之后的初始中心点根据前面选择的中心点决定，若已选取$n$个初始聚类中心$(0&lt;n&lt;K)$，选取第$n+1$个聚类中心时，距离当前$n$个聚类中心越远的点会有更高的概率被选为第$n+1$个聚类中心。</li><li><code>ISODATA</code><br>  思想：当属于某个类别的样本数过少时把这个类别去除，当属于某个类别的样本数过多、分散程度较大时把这个类别分为两个子类别.</li><li><code>Kernel K-means</code><br>  参照支持向量机中核函数的思想，将所有样本映射到另外一个特征空间中再进行聚类。</li></ul><h3 id="类似的算法"><a href="#类似的算法" class="headerlink" title="类似的算法"></a>类似的算法</h3><p>与<code>K-means</code>类似的算法有很多，例如</p><ul><li><code>K-medoids</code><br>  <code>K-means</code>的取值范围可以是连续空间中的任意值，要求所有数据样本处在一个欧式空间中，对于有很多噪声的数据就会造成极大的误差。<code>K-medoids</code>的取值是数据样本范围中的样本，且可应用在非数值型数据样本上。</li><li><code>k-medians</code><br>  $K$中值，选择中位数更新各簇的中心点。</li><li><code>K-centers</code><br>  <a href="https://www.bjdxs.com/xueshu/28151.html" target="_blank" rel="noopener">混合类型数据的K-Centers聚类算法/The K-Centers Clustering Algorithm for Categorical and Mixe</a></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><a href="https://github.com/isLouisHsu/Basic-Machine-Learning-Algorithm/blob/master/Andrew%20Ng%2C%20Stanford%20University/mlclass-ex7-1-kmeans/KMeans.py" target="_blank" rel="noopener">@Github: K-Means</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">class KMeans():</span><br><span class="line">    def __init__(self, n_cluster, mode):</span><br><span class="line">        self.n_cluster &#x3D; n_cluster  # 簇的个数</span><br><span class="line">        self.mode &#x3D; mode            # 距离度量方式</span><br><span class="line">        self.centroids &#x3D; None       # 簇的中心</span><br><span class="line">        self.loss &#x3D; float(&#39;inf&#39;)    # 优化目标值</span><br><span class="line">        plt.ion()</span><br><span class="line">    def fit(self, X, max_iter&#x3D;5, min_move&#x3D;0.1, display&#x3D;False):</span><br><span class="line">        def initializeCentroids():</span><br><span class="line">            &#39;&#39;&#39;</span><br><span class="line">            选择初始点</span><br><span class="line">            &#39;&#39;&#39;</span><br><span class="line">            centroid &#x3D; np.zeros(shape&#x3D;(self.n_cluster, X.shape[1])) # 保存选出的点</span><br><span class="line">            pointIdx &#x3D; []                                           # 保存已选出的点的索引</span><br><span class="line">            for n in range(self.n_cluster):</span><br><span class="line">                idx &#x3D; np.random.randint(0, X.shape[0])              # 随机选择一个点</span><br><span class="line">                while idx in pointIdx:                              # 若该点已选出，则丢弃重新选择</span><br><span class="line">                    idx &#x3D; np.random.randint(0, X.shape[0])</span><br><span class="line">                pointIdx.append(idx)</span><br><span class="line">                centroid[n] &#x3D; X[idx]</span><br><span class="line">            return centroid</span><br><span class="line">        def dist2Centroids(x, centroids, mode):</span><br><span class="line">            &#39;&#39;&#39;</span><br><span class="line">            返回向量x到k个中心点的距离值</span><br><span class="line">            &#39;&#39;&#39;</span><br><span class="line">            d &#x3D; np.zeros(shape&#x3D;(self.n_cluster,))</span><br><span class="line">            for n in range(self.n_cluster):</span><br><span class="line">                d[n] &#x3D; mathFunc.distance(x, centroids[n], mode)</span><br><span class="line">            return d</span><br><span class="line">        def nearestInfo(centroids, mode):</span><br><span class="line">            &#39;&#39;&#39;</span><br><span class="line">            每个点最近的簇中心索引、距离</span><br><span class="line">            &#39;&#39;&#39;</span><br><span class="line">            ctIdx &#x3D; -np.ones(shape&#x3D;(X.shape[0],), dtype&#x3D;np.int8)    # 每个点最近的簇中心索引，初始化为-1，可作为异常条件</span><br><span class="line">            ctDist &#x3D; np.ones(shape&#x3D;(X.shape[0],), dtype&#x3D;np.float)   # 每个点到最近簇中心的距离</span><br><span class="line">            for i in range(X.shape[0]):</span><br><span class="line">                dists &#x3D; dist2Centroids(X[i], centroids, mode)</span><br><span class="line">                if mode &#x3D;&#x3D; &#39;Euclidean&#39;: ctIdx[i] &#x3D; np.argmin(dists)</span><br><span class="line">                elif mode &#x3D;&#x3D; &#39;Cosine&#39;:  ctIdx[i] &#x3D; np.argmax(dists)</span><br><span class="line">                ctDist[i] &#x3D; dists[ctIdx[i]]             # 保存最相似的距离度量，用于计算loss</span><br><span class="line">            return ctIdx, ctDist</span><br><span class="line">        def updateCentroids(ctIdx):</span><br><span class="line">            &#39;&#39;&#39;</span><br><span class="line">            更新簇中心</span><br><span class="line">            &#39;&#39;&#39;</span><br><span class="line">            centroids &#x3D; np.zeros(shape&#x3D;(self.n_cluster, X.shape[1]))</span><br><span class="line">            for n in range(self.n_cluster):</span><br><span class="line">                X_ &#x3D; X[ctIdx &#x3D;&#x3D; n]                      # 筛选出离簇中心Cn最近的样本点</span><br><span class="line">                centroids[n] &#x3D; np.mean(X_, axis&#x3D;0)      # 根据筛选出的样本点更新中心值</span><br><span class="line">            return centroids</span><br><span class="line">        def loss(dist):</span><br><span class="line">            return np.mean(dist**2)</span><br><span class="line">        # -----------------------------------------</span><br><span class="line">        loss_min &#x3D; float(&#39;inf&#39;)                         # 最优分类时的损失值，最小</span><br><span class="line">        n_iter &#x3D; 0     </span><br><span class="line">        while n_iter &lt; max_iter:                        # 每次迭代选择不同的初始点</span><br><span class="line">            n_iter +&#x3D; 1; isDone &#x3D; False                 # 表示本次迭代是否已收敛</span><br><span class="line">            centroids_tmp &#x3D; initializeCentroids()       # 选择本次迭代的初始点</span><br><span class="line">            loss_last &#x3D; float(&#39;inf&#39;)                    # 本次迭代中，中心点更新前的损失值</span><br><span class="line">            n_update &#x3D; 0                                # 本次迭代的更新次数计数</span><br><span class="line">            while not isDone:</span><br><span class="line">                n_update +&#x3D; 1</span><br><span class="line">                ctIdx, ctDist &#x3D; nearestInfo(centroids_tmp, mode&#x3D;self.mode)</span><br><span class="line">                centroids_tmp &#x3D; updateCentroids(ctIdx)  # 更新簇中心</span><br><span class="line">                # --- 可视化 ---</span><br><span class="line">                if (display&#x3D;&#x3D;True) and (X.shape[1] &#x3D;&#x3D; 2):</span><br><span class="line">                    plt.ion()</span><br><span class="line">                    plt.figure(n_iter); plt.cla()</span><br><span class="line">                    plt.scatter(X[:, 0], X[:, 1], c&#x3D;ctIdx)</span><br><span class="line">                    plt.scatter(centroids_tmp[:, 0], centroids_tmp[:, 1], c&#x3D;&#39;r&#39;)</span><br><span class="line">                    plt.pause(0.5)</span><br><span class="line">                # -------------</span><br><span class="line">                loss_now &#x3D; loss(ctDist); moved &#x3D; np.abs(loss_last - loss_now)</span><br><span class="line">                if moved &lt; min_move:                    # 若移动过小，则本次迭代收敛</span><br><span class="line">                    isDone &#x3D; True</span><br><span class="line">                    print(&#39;第%d次迭代结束，中心点更新%d次&#39; % (n_iter, n_update))</span><br><span class="line">                else: loss_last &#x3D; loss_now</span><br><span class="line">            if loss_now &lt; loss_min:</span><br><span class="line">                self.centroids &#x3D; centroids_tmp          # 保存损失最小的模型(最优)</span><br><span class="line">                loss_min &#x3D; loss_now</span><br><span class="line">                # print(&#39;聚类结果已更新&#39;)</span><br><span class="line">        self.loss &#x3D; loss_min</span><br><span class="line">        print(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 迭代结束 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)</span><br><span class="line">    def predict(self, X):</span><br><span class="line">        &#39;&#39;&#39;</span><br><span class="line">        各个样本的最近簇中心索引</span><br><span class="line">        &#39;&#39;&#39;</span><br><span class="line">        labels &#x3D; -np.ones(shape&#x3D;(X.shape[0],), dtype&#x3D;np.int)    # 初始化为-1，可用作异常条件</span><br><span class="line">        for i in range(X.shape[0]):</span><br><span class="line">            dists_i &#x3D; np.zeros(shape&#x3D;(self.n_cluster,))         # 保存X[i]到中心点Cn的距离</span><br><span class="line">            for n in range(self.n_cluster):</span><br><span class="line">                dists_i[n] &#x3D; mathFunc.distance(X[i], self.centroids[n], mode&#x3D;self.mode)</span><br><span class="line">            if self.mode &#x3D;&#x3D; &#39;Euclidean&#39;:</span><br><span class="line">                labels[i] &#x3D; np.argmin(dists_i)</span><br><span class="line">            elif self.mode &#x3D;&#x3D; &#39;Cosine&#39;:</span><br><span class="line">                labels[i] &#x3D; np.argmax(dists_i)</span><br><span class="line">        return labels</span><br></pre></td></tr></table></figure></p><p>簇数的选择代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def chooseBestK(X, start, stop, step&#x3D;1, mode&#x3D;&#39;Euclidean&#39;):</span><br><span class="line">    Ks &#x3D; np.arange(start, stop + 1, step, dtype&#x3D;np.int) # 待选择的K</span><br><span class="line">    Losses &#x3D; np.zeros(shape&#x3D;Ks.shape)                   # 保存不同K值时的最小损失值</span><br><span class="line">    for k in range(1, Ks.shape[0] + 1):                 # 对于不同的K，训练模型，计算损失</span><br><span class="line">        print(&#39;K &#x3D; %d&#39;, k)</span><br><span class="line">        estimator &#x3D; KMeans(n_cluster&#x3D;k, mode&#x3D;mode)</span><br><span class="line">        estimator.fit(X, max_iter&#x3D;10, min_move&#x3D;0.01, display&#x3D;False)</span><br><span class="line">        Losses[k - 1] &#x3D; estimator.loss</span><br><span class="line">    plt.ioff()</span><br><span class="line">    plt.figure(); plt.xlabel(&#39;n_clusters&#39;); plt.ylabel(&#39;loss&#39;)</span><br><span class="line">    plt.plot(Ks, Losses)                                # 做出loss-K曲线</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure></p><h2 id="均值漂移-Meanshift"><a href="#均值漂移-Meanshift" class="headerlink" title="均值漂移(Meanshift)"></a>均值漂移(Meanshift)</h2><p>本质是一个迭代的过程，能够在一组数据的密度分布中寻找到局部极值，比较稳定，而且是无参密度估计(不需要事先知道样本数据的概率密度分布函数，完全依靠对样本点的计算)，而且在采样充分的情况下，一定会收敛，即可以对服从任意分布的数据进行密度估计。</p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>有一个滑动窗口的思想，即利用当前中心点一定范围内(通常为球域)的点迭代更新中心点，重复移动窗口，直到满足收敛条件。简单的说，<code>Meanshift</code>就是沿着密度上升的方向寻找同属一个簇的数据点。</p><p>定义点$x_0$的$\epsilon$球域如下</p><script type="math/tex; mode=display">S_h(x_0) = \{ x | (x - x_0)^T (x - x_0) \leq \epsilon \}</script><p>若有$n$个点$(x_1, …, x_n)$落在中心点$ptCentroid$的邻域内，其分布如图<br><img src="/2018/11/16/Clustering/DBSCAN4.jpg" alt="DBSCAN4"></p><p>则偏移向量计算方式为</p><script type="math/tex; mode=display">vecShift = \frac{1}{n} \sum_{i=1}^n (x_i - ptCentroid)</script><p>中心点更新公式为</p><script type="math/tex; mode=display">ptCentroid := ptCentroid + vecShift</script><blockquote><p>展开后可发现，其更新公式即</p><script type="math/tex; mode=display">vecShift= \frac{1}{n} \sum_{i=1}^n x_i - ptCentroid</script><script type="math/tex; mode=display">ptCentroid :=  \frac{1}{n} \sum_{i=1}^n x_i</script></blockquote><p><img src="/2018/11/16/Clustering/DBSCAN3.jpg" alt="DBSCAN3"></p><p>一个滑动窗口的动态更新过程如下图<br><img src="/2018/11/16/Clustering/meanshift_example1.gif" alt="meanshift_example1"><br>初始化多个滑动窗口进行<code>MeanShift</code>算法，其更新过程如下，其中每个黑点代表滑动窗口的质心，每个灰点代表一个数据点<br><img src="/2018/11/16/Clustering/meanshift_example2.gif" alt="meanshift_example2"></p><h3 id="高斯权重"><a href="#高斯权重" class="headerlink" title="高斯权重"></a>高斯权重</h3><p>基本思想是，距离当前中心点近的向量对更新结果权重大，而远的权重小，可减小远点的干扰，如下图，$vecShift_2$为高斯权重下的偏移向量<br><img src="/2018/11/16/Clustering/DBSCAN5.jpg" alt="DBSCAN5"></p><p>其偏移向量计算方式为</p><script type="math/tex; mode=display">vecShift = \frac{1}{n} \sum_{i=1}^n w_i · (x_i - ptCentroid)</script><script type="math/tex; mode=display">w_i = \frac{\kappa(x_i - ptCentroid)}{\sum_j \kappa(x_j - ptCentroid)}</script><p>其中</p><script type="math/tex; mode=display">\kappa(z) = \frac{1}{\sqrt{2\pi}} \exp \left( - \frac{||z||^2}{2\sigma^2} \right)</script><p>中心点更新公式仍然为</p><script type="math/tex; mode=display">ptCentroid := ptCentroid + vecShift</script><blockquote><p>展开也可得到</p><script type="math/tex; mode=display">ptCentroid := \frac{\sum_{i=1}^n w_i x_i}{\sum_j w_j}</script></blockquote><h3 id="计算步骤-1"><a href="#计算步骤-1" class="headerlink" title="计算步骤"></a>计算步骤</h3><p>对于给定的$N$维数据集$X = (x^{(1)}, x^{(2)}, …, x^{(M)})$，指定邻域参数$\epsilon_0$，终止条件参数$\epsilon_1$，簇合并参数$\epsilon_2$，并指定样本距离度量方式，目标为将其划分为$K$个簇。</p><ol><li>初始化：<ul><li>在样本集中随机选择$K_0(K_0 \gg K)$个样本作为初始中心点，以邻域大小为$\epsilon_0$建立滑动窗口；</li><li>各个样本初始化一个标记向量，用于记录被各类别访问的次数；</li></ul></li><li>以单个滑动窗口分析，记其中心点为$ptCentroid$，找到滑动窗口内的所有点，记作集合$M$，认为这些点属于该滑动窗口所属的簇类别，同时，这些点被该簇访问的次数$+1$；</li><li>以$ptCentroid$为中心，计算其到集合$M$中各个元素的向量，以这些向量计算得到偏移向量$vecShift$；</li><li>更新中心点：$ptCentroid = ptCentroid + vecShift$，即滑动窗口沿着$vecShift$方向移动，距离为$||vecShift||$；</li><li>重复步骤$2-4$，直到$||vecShift||&lt;\epsilon_1$，保存当前中心点；</li><li>如果收敛时当前簇$ptCentroid$与其它已经存在的簇的中心的距离小于阈值$\epsilon_2$，那么这两个簇合并。否则，把当前簇作为新的簇类，增加$1$类；</li><li>重复迭代直到所有的点都被标记访问；</li><li>根据每个样本被各簇的访问频率，取访问频率最大的那个簇类别作为当前点集的所属类。</li></ol><blockquote><p>即不同类型的滑窗沿着密度上升的方向进行移动，对各样本点进行标记，最后将样本划分为标记最多的类别；当两类非常接近时，合并为一类。</p></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><a href="https://github.com/isLouisHsu/Python-Examples-for-Pattern-Recognition-Course/blob/master/examples/p71_meanshift.py" target="_blank" rel="noopener">@Github: MeanShift</a></p><p>先定义了窗格对象<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SlidingWindow</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Attributes:</span></span><br><span class="line"><span class="string">        centroid: &#123;ndarray(n_features,)&#125;</span></span><br><span class="line"><span class="string">        epsilon: &#123;float&#125; 滑动窗格大小，为半径的平方</span></span><br><span class="line"><span class="string">        sigma: &#123;float&#125; 高斯核函数的参数</span></span><br><span class="line"><span class="string">        label: &#123;int&#125; 该窗格的标记</span></span><br><span class="line"><span class="string">        X: &#123;ndarray(n_samples, n_features)&#125;</span></span><br><span class="line"><span class="string">        containIdx: &#123;ndarray(n_contain,)&#125; 窗格内包含点的索引</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, centroid, epsilon, sigma, label, X)</span>:</span></span><br><span class="line">        self.centroid = centroid</span><br><span class="line">        self.epsilon = epsilon</span><br><span class="line">        self.sigma = sigma</span><br><span class="line">        self.label = label</span><br><span class="line">        self.containIdx = self.updateContain(X)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">k</span><span class="params">(self, z)</span>:</span></span><br><span class="line">        <span class="string">""" 高斯核函数</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            z: &#123;ndarray(n_features,)&#125;</span></span><br><span class="line"><span class="string">        Notes:</span></span><br><span class="line"><span class="string">            - \kappa(z) = \frac&#123;1&#125;&#123;\sqrt&#123;2\pi&#125;&#125; \exp \left( - \frac&#123;||z||^2&#125;&#123;2\sigma^2&#125; \right)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        norm = np.linalg.norm(z)</span><br><span class="line">        <span class="keyword">return</span> np.exp(- <span class="number">0.5</span> * (norm / self.sigma)**<span class="number">2</span>) / np.sqrt(<span class="number">2</span>*np.pi)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">step</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        <span class="string">""" 更新滑动窗格的中心点和所包含点</span></span><br><span class="line"><span class="string">        Returns: &#123;float&#125;</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dshift = self.shift(X)</span><br><span class="line">        self.containIdx = self.updateContain(X)</span><br><span class="line">        <span class="keyword">return</span> dshift</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shift</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        <span class="string">""" 移动窗格</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            vecShift: &#123;ndarray(n_features,)&#125;</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            dshift: &#123;float&#125; 移动的距离</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        (n_samples, n_features) = X.shape</span><br><span class="line">        n_contain = self.containIdx.shape[<span class="number">0</span>]</span><br><span class="line">        contain_weighted_sum = np.zeros(shape=(n_features, ))</span><br><span class="line">        weight_sum = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 按包含的点进行移动</span></span><br><span class="line">        <span class="keyword">for</span> i_contain <span class="keyword">in</span> range(n_contain):</span><br><span class="line">            vector = X[self.containIdx[i_contain]] - self.centroid</span><br><span class="line">            weight = self.k(vector)</span><br><span class="line">            contain_weighted_sum += weight*X[self.containIdx[i_contain]]</span><br><span class="line">            weight_sum += weight</span><br><span class="line">        centroid = contain_weighted_sum / weight_sum </span><br><span class="line">        <span class="comment"># 计算移动的距离   </span></span><br><span class="line">        dshift = np.linalg.norm(self.centroid - centroid)</span><br><span class="line">        self.centroid = centroid</span><br><span class="line">        <span class="keyword">return</span> dshift</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">updateContain</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        <span class="string">""" 更新窗格内的点索引</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            X: &#123;ndarray(n_samples, n_features)&#125;</span></span><br><span class="line"><span class="string">        Notes:</span></span><br><span class="line"><span class="string">            - 用欧式距离作为度量</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        d = <span class="keyword">lambda</span> x_i, x_j: np.linalg.norm(x_i - x_j)</span><br><span class="line">        n_samples = X.shape[<span class="number">0</span>]</span><br><span class="line">        containIdx = np.array([], dtype=<span class="string">'int'</span>)</span><br><span class="line">        <span class="keyword">for</span> i_samples <span class="keyword">in</span> range(n_samples):</span><br><span class="line">            <span class="keyword">if</span> d(X[i_samples], self.centroid) &lt; self.epsilon:</span><br><span class="line">                containIdx = np.r_[containIdx, i_samples]</span><br><span class="line">        <span class="keyword">return</span> containIdx</span><br></pre></td></tr></table></figure></p><p>聚类算法如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MeanShift</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Attributes:</span></span><br><span class="line"><span class="string">        n_clusters: &#123;int&#125; 划分簇的个数</span></span><br><span class="line"><span class="string">        n_windows: &#123;int&#125; 滑动窗格的个数</span></span><br><span class="line"><span class="string">        epsilon: &#123;float&#125; 滑动窗格的大小</span></span><br><span class="line"><span class="string">        sigma: &#123;float&#125; &#123;float&#125; 高斯核参数</span></span><br><span class="line"><span class="string">        thresh: &#123;float&#125; 若两个窗格中心距离小于thresh，则合并两类簇</span></span><br><span class="line"><span class="string">        min_move: &#123;float&#125; 终止条件</span></span><br><span class="line"><span class="string">        windows: &#123;list[class SlidingWindow()]&#125;</span></span><br><span class="line"><span class="string">    Note:</span></span><br><span class="line"><span class="string">        - 假设所有点均被窗格划过</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n_clusters, n_windows=<span class="number">-1</span>, epsilon=<span class="number">0.5</span>, sigma=<span class="number">2</span>, thresh=<span class="number">1e-2</span>, min_move=<span class="number">1e-3</span>)</span>:</span></span><br><span class="line">        self.n_clusters = n_clusters</span><br><span class="line">        self.n_windows = <span class="number">5</span>*n_clusters <span class="keyword">if</span> (n_windows == <span class="number">-1</span>) <span class="keyword">else</span> n_windows</span><br><span class="line">        self.epsilon = epsilon</span><br><span class="line">        self.sigma = sigma</span><br><span class="line">        self.thresh = thresh</span><br><span class="line">        self.min_move = min_move</span><br><span class="line">        self.windows = []</span><br><span class="line">        self.centroids = <span class="keyword">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        (n_samples, n_features) = X.shape</span><br><span class="line">        <span class="comment"># 创建窗格</span></span><br><span class="line">        <span class="keyword">for</span> i_windows <span class="keyword">in</span> range(self.n_windows):</span><br><span class="line">            idx = np.random.randint(n_samples)</span><br><span class="line">            window = SlidingWindow(X[idx], self.epsilon,</span><br><span class="line">                            self.sigma, i_windows, X)</span><br><span class="line">            <span class="comment"># 将各窗格包含的点标记</span></span><br><span class="line">            n_contain = window.containIdx.shape[<span class="number">0</span>]</span><br><span class="line">            self.windows.append(window)</span><br><span class="line"></span><br><span class="line">        dshift = float(<span class="string">'inf'</span>)   <span class="comment"># 初始化为无穷大</span></span><br><span class="line">        plt.figure(); plt.ion()</span><br><span class="line">        <span class="keyword">while</span> dshift &gt; self.min_move:</span><br><span class="line">            <span class="comment"># ------ 做图显示 ------</span></span><br><span class="line">            plt.cla()</span><br><span class="line">            plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=<span class="string">'b'</span>)</span><br><span class="line">            <span class="keyword">for</span> i_windows <span class="keyword">in</span> range(self.n_windows):</span><br><span class="line">                centroid = self.windows[i_windows].centroid</span><br><span class="line">                plt.scatter(centroid[<span class="number">0</span>], centroid[<span class="number">1</span>], c=<span class="string">'r'</span>)</span><br><span class="line">            plt.pause(<span class="number">0.5</span>)</span><br><span class="line">            <span class="comment"># ---------------------</span></span><br><span class="line">            dshift = self.step(X)</span><br><span class="line">        plt.ioff()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 合并窗格</span></span><br><span class="line">        dists = np.zeros(shape=(self.n_windows, self.n_windows))</span><br><span class="line">        <span class="keyword">for</span> i_windows <span class="keyword">in</span> range(self.n_windows):</span><br><span class="line">            <span class="keyword">for</span> j_windows <span class="keyword">in</span> range(i_windows):</span><br><span class="line">                centroid_i = self.windows[i_windows].centroid</span><br><span class="line">                centroid_j = self.windows[j_windows].centroid</span><br><span class="line">                dists[i_windows, j_windows] = np.linalg.norm(centroid_i-centroid_j)</span><br><span class="line">                dists[j_windows, i_windows] = dists[i_windows, j_windows]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 获得距离相近索引</span></span><br><span class="line">        index = np.where(dists&lt;self.thresh)</span><br><span class="line">        <span class="comment"># 用于标记类别</span></span><br><span class="line">        winlabel = np.zeros(shape=(self.n_windows,), dtype=<span class="string">'int'</span>)</span><br><span class="line">        label = <span class="number">1</span>; winlabel[<span class="number">0</span>] = label</span><br><span class="line">        <span class="keyword">for</span> i_windows <span class="keyword">in</span> range(self.n_windows):</span><br><span class="line">            idx_row = index[<span class="number">0</span>][i_windows]</span><br><span class="line">            idx_col = index[<span class="number">1</span>][i_windows]</span><br><span class="line">            <span class="comment"># 若其中一个点被标记，则将令一个点并入该类</span></span><br><span class="line">            <span class="keyword">if</span> winlabel[idx_row]!=<span class="number">0</span>:</span><br><span class="line">                winlabel[idx_col] = winlabel[idx_row]</span><br><span class="line">            <span class="keyword">elif</span> winlabel[idx_col]!=<span class="number">0</span>:</span><br><span class="line">                winlabel[idx_row] = winlabel[idx_col]</span><br><span class="line">            <span class="comment"># 否则新创建类别</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                label += <span class="number">1</span></span><br><span class="line">                winlabel[idx_row] = label</span><br><span class="line">                winlabel[idx_col] = label</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将标签一样的窗格合并</span></span><br><span class="line">        labels = list(set(winlabel))                            <span class="comment"># 去重后的标签</span></span><br><span class="line">        n_labels = len(labels)                                  <span class="comment"># 标签种类数</span></span><br><span class="line">        self.centroids = np.zeros(shape=(n_labels, n_features)) <span class="comment"># 记录最终聚类中心</span></span><br><span class="line">        <span class="keyword">for</span> i_labels <span class="keyword">in</span> range(n_labels):</span><br><span class="line">            cnt = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i_windows <span class="keyword">in</span> range(self.n_windows):</span><br><span class="line">                <span class="keyword">if</span> winlabel[i_windows] == labels[i_labels]:</span><br><span class="line">                    self.centroids[i_labels] += self.windows[i_windows].centroid</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">            self.centroids[i_labels] /= cnt                    <span class="comment"># 取同类窗格中心点的均值</span></span><br><span class="line">        <span class="keyword">return</span> self.centroids</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">step</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        <span class="string">""" update all sliding windows</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            dshift: \sum_i^&#123;n_windows&#125; dshift_&#123;i&#125;</span></span><br><span class="line"><span class="string">        """</span> </span><br><span class="line">        dshift = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i_windows <span class="keyword">in</span> range(self.n_windows):</span><br><span class="line">            dshift += self.windows[i_windows].step(X)</span><br><span class="line">            <span class="comment"># label the points</span></span><br><span class="line">            n_contain = self.windows[i_windows].containIdx.shape[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> dshift</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        <span class="string">""" 简单的用近邻的方法求</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        (n_samples, n_features) = X.shape</span><br><span class="line">        dists = np.zeros(shape=(n_samples, self.n_clusters))</span><br><span class="line">        <span class="keyword">for</span> i_samples <span class="keyword">in</span> range(n_samples):</span><br><span class="line">            <span class="keyword">for</span> i_clusters <span class="keyword">in</span> range(self.n_clusters):</span><br><span class="line">                dists[i_samples, i_clusters] = np.linalg.norm(X[i_samples]-self.centroids[i_clusters])</span><br><span class="line">        <span class="keyword">return</span> np.argmin(dists, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><h2 id="谱聚类-Spectral-Clustering"><a href="#谱聚类-Spectral-Clustering" class="headerlink" title="谱聚类(Spectral Clustering)"></a>谱聚类(Spectral Clustering)</h2><p>谱聚类是从图论中演化出来的算法，后来在聚类中得到了广泛的应用，比起传统的<code>K-Means</code>算法，谱聚类对数据分布的适应性更强，聚类效果也很优秀，同时聚类的计算量也小很多。</p><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><blockquote><p><a href="https://www.cnblogs.com/pinard/p/6221564.html" target="_blank" rel="noopener">谱聚类（spectral clustering）原理总结 - 刘建平Pinard - 博客园 </a></p></blockquote><h4 id="无向权重图"><a href="#无向权重图" class="headerlink" title="无向权重图"></a>无向权重图</h4><p>我们用点的集合$V$和边的集合$E$描述一个图，即$G(V, E)$，其中$V$即数据集中的点</p><script type="math/tex; mode=display">V = [v_1, v_2, ..., v_n]</script><p>而点$v_i, v_j$间连接权值$w_{ij}$组成邻接矩阵$W$，由于为无向图，故满足$w_{ij}=w_{ji}$</p><script type="math/tex; mode=display">W = \left[    \begin{matrix}        w_{11} & ... & w_{1n} \\        ... & ... & ... \\        w_{n1} & ... & w_{nn} \\    \end{matrix}    \right]</script><p>对于图中的任意一个点$v_i$，定义其度$d_i$为</p><script type="math/tex; mode=display">d_i = \sum_{j=1}^n w_{ij}</script><p>则我们可以得到一个度矩阵$D=diag(d_1, …, d_n)$</p><script type="math/tex; mode=display">D = \left[        \begin{matrix}            d_1 & & \\            & ... & \\             & & d_n\\        \end{matrix}    \right]</script><p>除此之外，对于$V$中子集$V_{sub} \subset V$，定义子集$V_{sub}$点的个数为</p><script type="math/tex; mode=display">|V_{sub}| := n_{sub}</script><p>另外，定义该子集中点的度之和为</p><script type="math/tex; mode=display">vol(V_{sub}) = \sum_{i \in V_{sub}} d_i</script><h4 id="相似矩阵"><a href="#相似矩阵" class="headerlink" title="相似矩阵"></a>相似矩阵</h4><p>上面讲到的邻接矩阵$W$可以指定权值，但对于数据量庞大的数据集，这显然不是一个$wise$的选择。我们可以用相似矩阵$S$来获得邻接矩阵$W$，基本思想是，距离较远的两个点之间的边权重值较低，而距离较近的两个点之间的边权重值较高。</p><p>构建邻接矩阵$W$的方法有三类：$\epsilon$-邻近法，$K$邻近法和全连接法，定义距离</p><script type="math/tex; mode=display">d_{ij} = ||x^{(i)} - x^{(j)}||_2^2</script><ul><li><p>$\epsilon$-邻近法<br>  设置距离阈值$\epsilon$，用欧式距离度量两点的距离$d_{ij}$，然后通过下式确定邻接权值$w_{ij}$</p><script type="math/tex; mode=display">  w_{ij} = \begin{cases}      0 & d_{ij} > \epsilon \\      \epsilon & otherwise  \end{cases}</script><blockquote><p>两点间的权重要不就是$\epsilon$，要不就是0，距离远近度量很不精确，因此在实际应用中，我们很少使用$\epsilon$-邻近法。</p></blockquote></li><li><p>$K$邻近法</p><ul><li><p>第一种<br>  只要一个点在另一个点的$K$近邻中，则保留$d_{ij}$</p><script type="math/tex; mode=display">  w_{ij} = \begin{cases}      \exp \left( -\frac{d_{ij}}{2\sigma^2} \right) & x^{(i)} \in KNN(x^{(j)})　or　x^{(j)} \in KNN(x^{(i)}) \\      0 & otherwise  \end{cases}</script></li><li><p>第二种<br>  互为$K$近邻时保留$d_{ij}$</p><script type="math/tex; mode=display">  w_{ij} = \begin{cases}      \exp \left( -\frac{d_{ij}}{2\sigma^2} \right) & x^{(i)} \in KNN(x^{(j)})　and　x^{(j)} \in KNN(x^{(i)}) \\      0 & otherwise  \end{cases}</script></li></ul></li><li><p>全连接法<br>  可以选择不同的核函数来定义边权重，常用的有多项式核函数，高斯核函数和<code>Sigmoid</code>核函数。最常用的是高斯核函数<code>RBF</code>，此时相似矩阵和邻接矩阵相同</p><script type="math/tex; mode=display">  w_{ij} = \exp \left( -\frac{d_{ij}}{2\sigma^2} \right)</script></li></ul><h4 id="拉普拉斯矩阵-Graph-Laplacians"><a href="#拉普拉斯矩阵-Graph-Laplacians" class="headerlink" title="拉普拉斯矩阵(Graph Laplacians)"></a>拉普拉斯矩阵(Graph Laplacians)</h4><p>定义</p><script type="math/tex; mode=display">L = D - W</script><p>正则化的拉普拉斯矩阵为</p><script type="math/tex; mode=display">L = D^{-1} (D - W)</script><p>具有的性质如下</p><ol><li>$L^T = L$</li><li>其特征值均为实数，即$\lambda_i \in \mathbb{R}$</li><li>正定性：$\lambda_i \geq 0$</li><li><p>对于任意向量$x$，都有</p><script type="math/tex; mode=display">x^T L x = \frac{1}{2} \sum_{i,j} w_{ij} (x_i - x_j)^2</script><blockquote><p>证明：</p><script type="math/tex; mode=display">x^T L x = x^T D x - x^T W x = \sum_i d_i x_i^2 - \sum_{ij} w_{ij} x_i x_j</script><script type="math/tex; mode=display">= \frac{1}{2} \left[ \sum_i d_i x_i^2 - 2\sum_{ij} w_{ij} x_i x_j + \sum_j d_j x_j^2 \right]</script><p>其中$ d_i = \sum_j w_{ij} $，所以</p><script type="math/tex; mode=display">x^T L x = \frac{1}{2} \sum_{i,j} w_{ij} (x_i - x_j)^2</script></blockquote></li></ol><h4 id="无向图的切图"><a href="#无向图的切图" class="headerlink" title="无向图的切图"></a>无向图的切图</h4><h5 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h5><p>我们希望把一张无向图$G(V, E)$按一定方法切成多个子图，各个子图间无连接，每个子图的点集为$V_1, …, V_K$，满足</p><ul><li>$\bigcup_{k=1}^K V_k = V$</li><li>$V_i \cap V_j = \emptyset$</li></ul><p>定义两个子图点集合$A, B$之间的切图权重为</p><script type="math/tex; mode=display">W(A, B) = \sum_{i \in A, j \in B} w_{ij}</script><blockquote><p>共有$n_A × n_B$个权值作累加</p></blockquote><p>那么对于$K$个子图点的集合$V_1, …, V_K$，定义切图为</p><script type="math/tex; mode=display">cut(V_1, ..., V_K) = \frac{1}{2} \sum_{i=1}^K cut(V_i, \overline{V_i})</script><script type="math/tex; mode=display">cut(V_i, \overline{V_i}) = W (V_i, \overline{V_i})</script><p>其中$\overline{V_i}$表示$V_i$的补集，或者</p><script type="math/tex; mode=display">\overline{V_i} = \bigcup_{k \neq i} V_k</script><p>通过最小化$cut(V_1, …, V_K)$使子图内权重和大，而子图间权重和小。但是这种方法存在问题，如下图<br><img src="/2018/11/16/Clustering/cut.jpg" alt="cut"></p><p>选择一个权重最小的边缘的<strong>点</strong>，比如$C$和$H$之间进行$cut$，这样可以最小化$cut(V_1, …, V_K)$，但是却不是最优的切图。</p><p>为解决上述问题，需要对每个子图的规模做出限定，以下介绍两种切图方式。</p><h5 id="Ratio-Cut"><a href="#Ratio-Cut" class="headerlink" title="Ratio Cut"></a>Ratio Cut</h5><p>不仅考虑最小化$cut(V_1, …, V_K)$，而且最大化每个子图的点个数，即</p><script type="math/tex; mode=display">RatioCut(V_1, ..., V_K) = \frac{1}{2} \sum_k \frac{cut(V_i, \overline{V_i})}{|V_k|}</script><script type="math/tex; mode=display">cut(V_i, \overline{V_i}) = W (V_i, \overline{V_i})</script><blockquote><ul><li>$W(V_k, \overline{V_k}) = \sum_{i \in V_k, j \in \overline{V_k}} w_{ij}$</li><li>$|V_k| = n_k$</li></ul></blockquote><p>如果按照遍历的方法求解，由前面分析，$W(V_k, \overline{V_k})$需计算$n_{V_k} × n_{\overline{V_k}}$次累加，计算量庞大，那么如何求解呢？</p><p>定义指示向量$h_k$，其构成矩阵$H$</p><script type="math/tex; mode=display">H = [ h_1, ..., h_k, ..., h_K]</script><p>其中</p><script type="math/tex; mode=display">h_k = \left[h_{k1}, h_{k2}, , ..., h_{kM} \right]^T</script><script type="math/tex; mode=display">h_{ki} = \begin{cases}    \frac{1}{\sqrt{|V_k|}} & x^{(i)}\in V_k \\    0 & otherwise\end{cases}</script><blockquote><p>$h_k$为单位向量，且两两正交</p><script type="math/tex; mode=display">h_i^T h_j =       \begin{cases}          \sum_{|V_i|} \frac{1}{|V_i|} = |V_i| · \frac{1}{|V_i|} = 1 & i = j \\          0 & i \neq j      \end{cases}</script></blockquote><p>那么由拉式矩阵性质$4$</p><script type="math/tex; mode=display">h_k^T L h_k = \frac{1}{2} \sum_{i,j} w_{ij} (h_{ki} - h_{kj})^2</script><script type="math/tex; mode=display">= \frac{1}{2}     [        \sum_{i \in V_k, j \in V_k} w_{ij} (h_{ki} - h_{kj})^2 +         \sum_{i \notin V_k, j \in V_k} w_{ij} (h_{ki} - h_{kj})^2 +</script><script type="math/tex; mode=display">        \sum_{i \in V_k, j \notin V_k} w_{ij} (h_{ki} - h_{kj})^2 +         \sum_{i \notin V_k, j \notin V_k} w_{ij} (h_{ki} - h_{kj})^2    ]</script><script type="math/tex; mode=display">= \frac{1}{2}    [        \sum_{i \in V_k, j \in V_k} w_{ij} (\frac{1}{\sqrt{|V_k|}} - \frac{1}{\sqrt{|V_k|}})^2 +         \sum_{i \notin V_k, j \in V_k} w_{ij} (0 - \frac{1}{\sqrt{|V_k|}})^2 +</script><script type="math/tex; mode=display">        \sum_{i \in V_k, j \notin V_k} w_{ij} (\frac{1}{\sqrt{|V_k|}} - 0)^2 +        \sum_{i \notin V_k, j \notin V_k} w_{ij} (0 - 0)^2    ]</script><script type="math/tex; mode=display">= \frac{1}{2}    [        \sum_{i \notin V_k, j \in V_k} w_{ij} \frac{1}{|V_k|} +        \sum_{i \in V_k, j \notin V_k} w_{ij} \frac{1}{|V_k|}    ]</script><blockquote><script type="math/tex; mode=display">cut(V_i, \overline{V_i}) = W (V_i, \overline{V_i}) = \sum_{i \in V_k, j \in \overline{V_k}} w_{ij}</script></blockquote><script type="math/tex; mode=display">h_k^T L h_k = \frac{1}{2} [\frac{1}{|V_k|} cut(V_k, \overline{V_k}) + \frac{1}{|V_k|} cut(V_k, \overline{V_k})]</script><script type="math/tex; mode=display">= \frac{1}{|V_k|} cut(V_k, \overline{V_k})</script><p>推到这里就能理解为什么要定义$h_k$了</p><script type="math/tex; mode=display">RatioCut(V_1, ..., V_K)= \frac{1}{2} \sum_k h_k^T L h_k</script><p>并且</p><script type="math/tex; mode=display">h_k^T L h_k = tr(H^T L H)</script><blockquote><script type="math/tex; mode=display">H^T L H = \left[      \begin{matrix}          — & h_1^T & — \\           & ... &  \\          — & h_K^T & — \\      \end{matrix}\right]L\left[          \begin{matrix}            | & & | \\            h_1 & ... & h_K \\            | & & |        \end{matrix}    \right]</script><script type="math/tex; mode=display">= \left[      \begin{matrix}          h_1^T L h_1 & ... & h_1^T L h_K \\          ... & ... & ... \\          h_K^T L h_K & ... & h_K^T L h_K \\      \end{matrix}\right]</script></blockquote><p>所以最终优化目标为</p><script type="math/tex; mode=display">\min_H tr(H^T L H)</script><script type="math/tex; mode=display">s.t.　H^T H = I</script><blockquote><script type="math/tex; mode=display">H^T H = \left[      \begin{matrix}          h_1^T h_1 & ... & h_1^T h_K \\          ... & ... & ... \\          h_K^T h_K & ... & h_K^T h_K \\      \end{matrix}\right]</script></blockquote><p>而矩阵的正交相似变换$A = P \Lambda P^{-1}$满足</p><script type="math/tex; mode=display">tr(A) = tr(\Lambda) = \sum_i \lambda_i</script><p>故</p><script type="math/tex; mode=display">tr(H^T L H) = tr(L) = \sum_{i=1}^M \lambda_i</script><p>$\lambda_i$为矩阵$L$的特征值。</p><p>我们再进行维度规约，将维度从$M$降到$k_1$，即找到$k_1$个最小的特征值之和。</p><h5 id="N-Cut"><a href="#N-Cut" class="headerlink" title="N Cut"></a>N Cut</h5><p>推导过程与<code>RatioCut</code>完全一致，只是将分母$|V_i|$换成$vol(V_i)$</p><script type="math/tex; mode=display">NCut(V_1, ..., V_K) = \frac{1}{2} \sum_k \frac{cut(V_i, \overline{V_i})}{vol(V_i)}</script><script type="math/tex; mode=display">cut(V_i, \overline{V_i}) = W (V_i, \overline{V_i})</script><blockquote><script type="math/tex; mode=display">vol(V_{sub}) = \sum_{i \in V_{sub}} d_i</script></blockquote><h3 id="计算步骤-2"><a href="#计算步骤-2" class="headerlink" title="计算步骤"></a>计算步骤</h3><p>对于给定的$N$维数据集$X = (x^{(1)}, x^{(2)}, …, x^{(M)})$，将其划分为$K$类$(C_1, …, C_K)$</p><ol><li>根据输入的相似矩阵的生成方式构建样本的相似矩阵$S_{M×M}$；</li><li>根据相似矩阵$S$构建邻接矩阵$W_{M×M}$；</li><li>构建度矩阵$D_{M×M}$；</li><li>计算拉普拉斯矩阵$L_{M×M}$，可进行规范化$ L := D^{-1}L $；</li><li>对$L$进行特征值分解<code>(EVD)</code>，得到特征对$ (\lambda_i, \alpha_i), i=1,…,M $；</li><li>指定超参数$K_1$，选取$K_1$个最小特征值对应的特征向量组成矩阵$F_{M×K_1}$，并将其按行标准化；</li><li>以$F$的行向量作为新的样本数($k_1$维，这里也有降维操作)进行聚类，划分为$K$类，可使用<code>K-means</code>；</li><li>聚类结果即为输出结果</li></ol><p>注意是$K_1$个最小特征值对应的特征向量，别问我为什么知道。。。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p><a href="https://github.com/isLouisHsu/Python-Examples-for-Pattern-Recognition-Course/blob/master/examples/p86_spectral_clustering.py" target="_blank" rel="noopener">@Github: Spectral Clustering</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpectralClustering</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Attributes:</span></span><br><span class="line"><span class="string">        k: &#123;int&#125;, k &lt; n_samples</span></span><br><span class="line"><span class="string">        sigma: &#123;float&#125;</span></span><br><span class="line"><span class="string">    Notes:</span></span><br><span class="line"><span class="string">        Steps:</span></span><br><span class="line"><span class="string">            - similarity matrix [W_&#123;n×n&#125;]</span></span><br><span class="line"><span class="string">            - diagonal matrix [D_&#123;n×n&#125;] is defined as</span></span><br><span class="line"><span class="string">                    D_&#123;ii&#125; = \begin&#123;cases&#125;</span></span><br><span class="line"><span class="string">                                \sum_j W_&#123;ij&#125; &amp; i \neq j \\</span></span><br><span class="line"><span class="string">                                0 &amp; i = j</span></span><br><span class="line"><span class="string">                            \end&#123;cases&#125;</span></span><br><span class="line"><span class="string">            - Laplacian matrix [L_&#123;n×n&#125;], Laplacian matrix is defined as</span></span><br><span class="line"><span class="string">                    L = D - W or L = D^&#123;-1&#125; (D - W)</span></span><br><span class="line"><span class="string">            - EVD: L \alpha_i = \lambda_i \alpha_i</span></span><br><span class="line"><span class="string">            - takes the eigenvector corresponding to the largest eigenvalue as</span></span><br><span class="line"><span class="string">                    B_&#123;n×k&#125; = [\beta_1, \beta_2, ..., \beta_k]</span></span><br><span class="line"><span class="string">            - apply K-Means to the row vectors of matrix B</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k, n_clusters=<span class="number">2</span>, sigma=<span class="number">1.0</span>)</span>:</span></span><br><span class="line">        self.kmeans = KMeans(n_clusters=n_clusters)</span><br><span class="line">        self.k = k</span><br><span class="line">        self.sigma = sigma</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        n_samples = X.shape[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># step 1</span></span><br><span class="line">        kernelGaussian = <span class="keyword">lambda</span> z, sigma: np.exp(<span class="number">-0.5</span> * np.square(z/sigma))</span><br><span class="line">        W = np.zeros((n_samples, n_samples))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n_samples):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                W[i, j] = kernelGaussian(np.linalg.norm(X[i] - X[j]), self.sigma)</span><br><span class="line">                W[j, i] = W[i, j]</span><br><span class="line">        <span class="comment"># step 2</span></span><br><span class="line">        D = np.diag(np.sum(W, axis=<span class="number">1</span>))</span><br><span class="line">        <span class="comment"># step 3</span></span><br><span class="line">        L = D - W</span><br><span class="line">        L = np.linalg.inv(D).dot(L)</span><br><span class="line">        <span class="comment"># step 4</span></span><br><span class="line">        eigval, eigvec = np.linalg.eig(L)</span><br><span class="line">        <span class="comment"># step 5</span></span><br><span class="line">        order = np.argsort(eigval)</span><br><span class="line">        eigvec = eigvec[:, order]</span><br><span class="line">        beta = eigvec[:, :self.k]</span><br><span class="line">        <span class="comment"># step 6</span></span><br><span class="line">        self.kmeans.fit(beta)</span><br><span class="line">        <span class="keyword">return</span> self.kmeans.labels_</span><br></pre></td></tr></table></figure></p><p><img src="/2018/11/16/Clustering/spectral_clustering.png" alt="spectral_clustering"></p><h2 id="DBSCAN"><a href="#DBSCAN" class="headerlink" title="DBSCAN"></a>DBSCAN</h2><p><code>DBSCAN(Density-Based Spatial Clustering of Applications with Noise)</code>，具有噪声的基于密度的聚类方法。假定类别可以通过样本分布的紧密程度决定。同一类别的样本，他们之间的紧密相连的。</p><blockquote><p><a href="https://www.cnblogs.com/pinard/p/6208966.html" target="_blank" rel="noopener">DBSCAN密度聚类算法 - 刘建平Pinard - 博客园</a></p></blockquote><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>先介绍几个关于密度的概念</p><ul><li><p>$\epsilon$-邻域<br>  对于样本$x^{(i)}$，其$\epsilon$-邻域包含样本集中与$x^{(i)}$距离不大于$\epsilon$的子样本集，其样本个数记作$|N_{\epsilon}(x^{(i)})|$。</p><script type="math/tex; mode=display">  N_{\epsilon}(x^{(i)}) = \{ x^{(j)} | d_{ij} \leq \epsilon \}</script></li><li><p>核心对象<br>  对于任一样本$x^{(i)}$，若其$\epsilon$-邻域$N_{\epsilon}(x^{(i)})$至少包含$minPts$个样本，则该样本为核心对象。如图，选择若选取$\epsilon=5$，则红点均为核心对象</p></li><li>密度直达<br>  若样本$x^{(j)} \in N_{\epsilon}(x^{(i)})$，且$x^{(i)}$为核心对象，则称$x^{(j)}$由$x^{(i)}$密度直达。不满足对称性，即反之不一定成立，除非$x^{(j)}$也为核心对象。如图，$x^{(8)}$可由$x^{(6)}$密度直达，而反之$x^{(6)}$不可由$x^{(8)}$密度直达，因为$x^{(8)}$不为核心对象。</li><li>密度可达<br>  若存在样本序列$p_1, p_2, …, p_T$，满足$p_1 = x^{(i)}, p_T = x^{(j)}$，且$p_{t+1}$可由$p_t$密度直达，也就是说$p_1, p_2, …, p_{T-1}$均为核心对象，则称$x^{(j)}$由$x^{(i)}$密度可达。也不满足对称性。如图，$x^{(4)}$可由$x^{(1)}$密度可达，而$x^{(2)}$不可由$x^{(4)}$密度可达，因为$x^{(4)}$不为核心对象。</li><li>密度相连<br>  存在核心对象$x^{(k)}$，使得$x^{(i)}$与$x^{(j)}$均由$x^{(k)}$密度可达，则称$x^{(i)}$与$x^{(j)}$密度相连。注意密度相连满足对称性。如图，$x^{(8)}$与$x^{(4)}$均可由$x^{(1)}$密度可达，则$x^{(8)}$与$x^{(4)}$密度相连。</li></ul><p><img src="/2018/11/16/Clustering/DBSCAN1.jpg" alt="DBSCAN1"></p><h3 id="计算思想"><a href="#计算思想" class="headerlink" title="计算思想"></a>计算思想</h3><p><code>DBSCAN</code>的聚类思想是，由<strong>密度可达关系</strong>导出的最大密度相连的样本集合，即为我们最终聚类的一个簇，这个簇里可能只有一个核心对象，也可能有多个核心对象，若有多个，则簇里的任意一个核心对象的$\epsilon$-邻域中一定有一个其他的核心对象，否则这两个核心对象无法密度可达。</p><p>另外，考虑以下三个问题</p><ul><li>噪音点<br>  一些异常样本点或者说少量游离于簇外的样本点，这些点不在任何一个核心对象在周围，这些样本点标记为噪音点，<code>with Noise</code>就是这个意思。</li><li>距离的度量<br>  一般采用最近邻思想，采用某一种距离度量来衡量样本距离，比如欧式距离。这和<code>KNN</code>算法的最近邻思想完全相同。对应少量的样本，寻找最近邻可以直接去计算所有样本的距离，如果样本量较大，则一般采用<code>KDTree</code>或者球树来快速的搜索最近邻。</li><li>类别重复时的判别<br>  某些样本可能到两个核心对象的距离都小于$\epsilon$，但是这两个核心对象如下图所示，不是密度直达，又不属于同一个聚类簇，那么如果界定这个样本的类别呢？<br>  <img src="/2018/11/16/Clustering/DBSCAN2.jpg" alt="DBSCAN2"><br>  一般来说，此时<code>DBSCAN</code>采用<strong>先来后到</strong>，先进行聚类的类别簇会标记这个样本为它的类别。也就是说<code>BDSCAN</code>不是完全稳定的算法。</li></ul><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>对于给定的$N$维数据集$X = (x^{(1)}, x^{(2)}, …, x^{(M)})$，指定邻域参数$(\epsilon, minPts)$与样本距离度量方式，将其划分为$K$类。</p><ol><li>检测数据库中尚未检查过的对象$p$，如果$p$未被处理(归为某个簇或者标记为噪声)，则检查其邻域：<ul><li>若包含的对象数不小于$minPts$，建立新簇$C$，将其中的所有点加入候选集$N$；</li></ul></li><li>对候选集$N$中所有尚未被处理的对象$q$，检查其邻域：<ul><li>若至少包含$minPts$个对象，则将这些对象加入$N$；</li><li>如果$q$未归入任何一个簇，则将$q$加入$C$；</li></ul></li><li>重复步骤$2$，继续检查$N$中未处理的对象，直到当前候选集$N$为空；</li><li>重复步骤$1$-$3$，直到所有对象都归入了某个簇或标记为噪声。</li></ol><h2 id="高斯混合模型-GMM"><a href="#高斯混合模型-GMM" class="headerlink" title="高斯混合模型(GMM)"></a>高斯混合模型(GMM)</h2><p>详情查看<a href="https://louishsu.xyz/2018/11/12/EM%E7%AE%97%E6%B3%95-GMM%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">EM算法 &amp; GMM模型</a>。</p><h2 id="层次聚类-Hierarchical-Clustering"><a href="#层次聚类-Hierarchical-Clustering" class="headerlink" title="层次聚类(Hierarchical Clustering)"></a>层次聚类(Hierarchical Clustering)</h2><p>层次聚类更多的是一种思想，而不是方法，通过从下往上不断合并簇，或者从上往下不断分离簇形成嵌套的簇。例如上面讲到的<code>DBSCAN</code>最后簇的合并就有这种思想。</p><p>层次的类通过“树状图”来表示，如下<br><img src="/2018/11/16/Clustering/层次聚类.png" alt="层次聚类"></p><p>主要的思想或方法有两种</p><ul><li>自底向上的凝聚方法<code>(agglomerative hierarchical clustering)</code><br>  如<code>AGNES</code>。</li><li>自上向下的分裂方法<code>(divisive hierarchical clustering)</code><br>  如<code>DIANA</code>。</li></ul><h2 id="图团体检测-Graph-Community-Detection"><a href="#图团体检测-Graph-Community-Detection" class="headerlink" title="图团体检测(Graph Community Detection)"></a>图团体检测(Graph Community Detection)</h2><p>略</p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hidden Markov Model</title>
      <link href="/2018/11/13/Hidden-Markov-Model/"/>
      <url>/2018/11/13/Hidden-Markov-Model/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>隐马尔科夫模型</strong>(Hidden Markov Model, HMM)可用于标注问题，描述由隐藏的马尔科夫链随机生成观测序列的过程，属于生成模型。在语音识别、自然语言处理、生物信息等领域有广泛的应用。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>定义</strong>：隐马尔科夫模型是关于时序的概率模型，描述有一个隐藏的<strong>马尔科夫链随</strong>机生成不可观测的状态随机序列(state sequence)，再由各个状态生成一个观测，多个时刻的观测组成观测随机序列(observation sequence)的过程。</p><p>隐马尔科夫模型由<strong>初始概率分布、状态转移概率分布、观测概率分布</strong>确定，形式定义如下</p><ul><li><p><strong>状态集合与观测集合</strong>：$Q$是所有可能状态(共$N$个)的集合，$V$是所有可能观测(共$M$个)的集合，即</p><script type="math/tex; mode=display">Q = \{q_1, q_2, \cdots, q_N\}, \quad V = \{v_1, v_2, \cdots, v_M\} \tag{1.1}</script></li><li><p><strong>状态序列与观测序列</strong>：共进行$T$次观测，状态序列为$S$，观测序列为$O$，即</p><script type="math/tex; mode=display">S = (s^{(1)}, s^{(2)}, \cdots, s^{(T)}), \quad O = (o^{(1)}, o^{(2)}, \cdots, o^{(T)}) \tag{1.2}</script></li><li><p><strong>初始状态概率</strong>：时刻$t = 1$处于状态$q_i$的概率记作$\pi_i$，即</p><script type="math/tex; mode=display">\pi_i = P(s^{(1)} = q_i) \tag{1.3.1}</script><p>  保存为初始状态概率向量$\pi$</p><script type="math/tex; mode=display">\pi = \begin{bmatrix} \pi_1 & \pi_2 & \cdots & \pi_N \end{bmatrix}^T \tag{1.3.2}</script><blockquote><p><strong>注意，$\pi$是“状态概率向量”，$q_i$是“状态向量”。</strong></p></blockquote></li><li><p><strong>状态转移概率</strong>：时刻$t$处于状态$q_i$的条件下，在时刻$t + 1$转移到状态$q_j$的概率为</p><script type="math/tex; mode=display">a_{ij} = P(s^{(t+1)} = q_j | s^{(t)} = q_i) \tag{1.4.1}</script><p>  保存为状态转移矩阵$A$</p><script type="math/tex; mode=display">A_{N \times N} = \begin{bmatrix} a_{ij} \end{bmatrix} \tag{1.4.2}</script></li><li><p><strong>观测概率</strong>：时刻$t$处于状态$q_i$的条件下，得到观测$v_j$的概率为</p><script type="math/tex; mode=display">b_{ij} = P(o^{(t)} = v_j | s^{(t)} = q_i) \tag{1.5.1}</script><p>  保存为观测概率矩阵$B$</p><script type="math/tex; mode=display">B_{N \times M} = \begin{bmatrix} b_{ij} \end{bmatrix} \tag{1.5.2}</script></li></ul><p>那么隐马尔科夫模型可<strong>由初始状态概率$\pi$、状态转移概率矩阵$A$、观测概率矩阵$B$描述</strong>。</p><h2 id="基本假设"><a href="#基本假设" class="headerlink" title="基本假设"></a>基本假设</h2><ol><li><p><strong>齐次马尔科夫性假设</strong>：在任意时刻$t$的状态只依赖于前一时刻$t-1$的状态，与其他时刻状态或观测无关；</p><script type="math/tex; mode=display">P(s^{(t)} | s^{(1)}, o^{(1)}, \cdots, s^{(T)}, o^{(T)}) = P(s^{(t)} | s^{(t-1)}), \quad t = 1, 2, \cdots, T \tag{2.1}</script></li><li><p><strong>观测独立性假设</strong>：在任意时刻$t$的观测只依赖于时刻$t$的状态，与其他时刻状态或观测无关；</p><script type="math/tex; mode=display">P(o^{(t)} | s^{(1)}, o^{(1)}, \cdots, s^{(T)}, o^{(T)}) = P(o^{(t)} | s^{(t)}), \quad t = 1, 2, \cdots, T \tag{2.1}</script></li></ol><h2 id="基本问题"><a href="#基本问题" class="headerlink" title="基本问题"></a>基本问题</h2><p>在给定隐马尔科夫模型$\theta = (A, B, \pi)$下进行$T$次观测的过程如下：</p><ol><li>根据初始状态分布$\pi$产生状态$s^{(1)}$；</li><li>根据状态$s^{(t - 1)}$与状态转移概率$a_{s^{(t)}}$，产生$s^{(t)}, t = 2, \cdots, T$；</li><li>按照状态$s^{(t)}$与观测概率分布$b_{s^{(t)}}$产生观测$o^{(t)}$；</li><li>重复2、3直至得到长度为$T$的观测序列。</li></ol><p>相应地，马尔可夫模型就产生了<strong>三个基本问题</strong>：</p><ol><li><strong>概率计算问题</strong>：给定模型$\theta = (A, B, \pi)$和观测序列$O = (o^{(1)}, o^{(2)}, \cdots, o^{(T)})$，计算该模型下出现该观测序列的概率$P(O | \theta)$；</li><li><strong>学习问题</strong>：给定观测序列$O = (o^{(1)}, o^{(2)}, \cdots, o^{(T)})$，估计模型参数$\theta = (A, B, \pi)$；</li><li><strong>预测问题</strong>：给定模型$\theta = (A, B, \pi)$和观测序列$O = (o^{(1)}, o^{(2)}, \cdots, o^{(T)})$，求给定观测序列$O$下，使$P(S | O)$最大的状态序列$S = (s^{(1)}, s^{(2)}, \cdots, s^{(T)})$。</li></ol><p>以下对上述三个问题分别进行求解。</p><h1 id="概率计算问题"><a href="#概率计算问题" class="headerlink" title="概率计算问题"></a>概率计算问题</h1><h2 id="直接计算法"><a href="#直接计算法" class="headerlink" title="直接计算法"></a>直接计算法</h2><script type="math/tex; mode=display">P(O | \theta) = \sum_S P(O | S, \theta) P(S | \theta)</script><p>枚举$S = (s^{(1)}, \cdots, s^{(T)})$可能的组合，计算相应的观测，累加得到$P(O|\theta)$，这种方法计算时间复杂度为$O(TN^T)$阶，不可行。</p><h2 id="前向-后向算法"><a href="#前向-后向算法" class="headerlink" title="前向-后向算法"></a>前向-后向算法</h2><ol><li><p>前向算法</p><p> 由概率乘法公式，可得各观测的联合分布满足</p><script type="math/tex; mode=display"> \begin{aligned}     P(O | \theta) & = P(o^{(1)}, \cdots, o^{(T)} | \theta) \\     & = P(o^{(1)} | \theta) P(o^{(2)} | o^{(1)}, \theta) P(o^{(3)} | o^{(1)}, o^{(2)}, \theta) \cdots P(o^{(T)} | o^{(1)}, o^{(2)}, \cdots, o^{(T - 1)}, \theta) \\ \end{aligned}</script><p> 注意到</p><script type="math/tex; mode=display"> \begin{cases}     P(o^{(1)} | \theta) =      \sum_{i = 1}^N P(s^{(1)} = q_i | \theta) P(o^{(1)} | s^{(1)} = q_i, \theta)          = \sum_{i = 1}^N \pi_i b_{i, o^{(t)}} \\     \begin{aligned}      P(o^{(2)} | o^{(1)}, \theta) =          & \sum_{i = 1}^N \underbrace{P(s^{(2)} = q_i | o^{(1)}, \theta)}          P(o^{(2)} | s^{(2)} = q_i, o^{(1)}, \theta) \\         = & \sum_{i = 1}^N \left(                  \sum_{j=1}^N P(s^{(2)} = q_i | s^{(1)} = q_j, o^{(1)}, \theta )                  P(s^{(1)} = q_j | o^{(1)}, \theta )              \right) \times P(o^{(2)} | s^{(2)} \\         = & q_i, o^{(1)}, \theta)          = \sum_{i=1}^N \left( \sum_{j=1}^N \pi_j a_{ji} \right) b_{i, o^{(2)}}     \end{aligned}      \cdots \end{cases}</script><p> 由上式，可发现递归规律。</p><p> <strong>定义(前向概率)</strong>：给定马尔科夫模型$\theta$，定义到时刻$t$时状态为$q_i$，且观测序列为$(o^{(1)}, \cdots, o^{(t)})$的概率为<strong>前向概率</strong>$\alpha^{(t)}_i$，即</p><script type="math/tex; mode=display">\alpha^{(t)}_i = P(s^{(t)} = q_i, o^{(1)}, \cdots, o^{(t)} | \theta) \tag{3}</script><p> 那么<strong>初始状态</strong>下有</p><script type="math/tex; mode=display">\alpha^{(1)}_i = P(s^{(1)} = q_i, o^{(1)} | \theta) = \pi_i b_{i, o^{(1)}} \tag{4.1}, \quad i = 1, 2, \cdots, N</script><p> 对于$t = 2, 3, T$时刻，由边缘概率公式和条件概率，得到<strong>递推公式</strong></p><script type="math/tex; mode=display"> \begin{aligned}     \alpha^{(t)}_i & = P(s^{(t)} = q_i, o^{(1)}, \cdots, o^{(t)} | \theta) \\      & = P(s^{(t)} = q_i, o^{(1)}, \cdots, o^{(t-1)} | o^{(t)}, \theta)      P(o^{(t)} | s^{(t)} = q_i, \theta) \\      & = \left(          \sum_{j=1}^N          \underbrace{P(s^{(t - 1)} = q_j, o^{(1)}, \cdots, o^{(t - 1)} | o^{(t)}, \theta)}_{\alpha^{(t-1)}_j}         \underbrace{P(s^{(t)} = q_i | s^{(t - 1)} = q_j, o^{(t)}, \theta)}_{a_{ji}}     \right) \\     & \qquad \underbrace{P(o^{(t)} | s^{(t)} = q_i, \theta)}_{b_{i, o^{(t)}}} \\      = & \left( \sum_{j=1}^N \alpha^{(t-1)}_j a_{ji} \right) b_{i, o^{(t)}}      \end{aligned} \tag{4.2}</script><p> 那么到<strong>时刻$T$时</strong>，由边缘概率公式，可得到$P(O | \theta)$</p><script type="math/tex; mode=display"> \begin{aligned}     P(O | \theta) = P(o^{(1)}, \cdots, o^{(T)} | \theta) =      \sum_{i=1}^N P(s^{(t)} = q_i, o^{(1)}, \cdots, o^{(t)} | \theta) =      \sum_{i=1}^N \alpha^{(T)}_i \tag{4.3} \end{aligned}</script></li><li><p>后向算法<br> <strong>定义(后向概率)</strong>：给定马尔科夫模型$\theta$，定义到时刻$t$时状态为$q_i$的<strong>条件下</strong>，观测序列为$(o^{(t + 1)}, \cdots, o^{(T)})$的概率为<strong>后向概率</strong>$\beta^{(t)}_i$，即</p><script type="math/tex; mode=display">\beta^{(t)}_i = P( o^{(t + 1)}, \cdots, o^{(T)} | s^{(t)} = q_i, \theta) \tag{5}</script><p> 在$T$时刻，有</p><script type="math/tex; mode=display">\beta^{(T)}_i = 1, \quad i = 1, 2, \cdots, N \tag{6.1}</script><p> 对$t = T - 1, T - 2, \cdots, 1$，有<strong>递推公式</strong></p><script type="math/tex; mode=display"> \begin{aligned}     \beta^{(t)}_i & = P( o^{(t + 1)}, \cdots, o^{(T)} | s^{(t)} = q_i, \theta) \\     & = \sum_{j=1}^N P(s^{(t + 1)} = q_j, o^{(t + 1)}, \cdots, o^{(T)} | s^{(t)} = q_i, \theta) \\     & = \sum_{j=1}^N P(s^{(t + 1)} = q_j | s^{(t)} = q_i, \theta)     P(o^{(t + 1)}, \cdots, o^{(T)} | s^{(t + 1)} = q_j, s^{(t)} = q_i, \theta)  \\     & = \sum_{j=1}^N      \underbrace{P(s^{(t + 1)} = q_j | s^{(t)} = q_i, \theta)}_{a_{ij}}     \underbrace{P(o^{(t + 1)} | s^{(t + 1)} = q_j, s^{(t)} = q_i, \theta)}_{b_{j, o^{(t + 1)}}} \\     & \underbrace{P(o^{(t + 2)}, \cdots, o^{(T)} | s^{(t + 1)} = q_j, s^{(t)} = q_i, o^{(t + 1)}, \theta)}_{\beta^{(t + 1)}_j} \\     & = \sum_{j=1}^N a_{ij} b_{j, o^{(t + 1)}} \beta^{(t + 1)}_j  \end{aligned} \tag{6.2}</script><p> 观测序列的概率用下式计算</p><script type="math/tex; mode=display"> P(O | \theta) = \sum_{i=1}^N \pi_i b_{i, o^{(1)}} \beta^{(1)}_i \tag{6.3}</script></li></ol><p><strong>前向-后向计算可统一写成</strong></p><script type="math/tex; mode=display">P(O | \theta) = \sum_{i=1}^N \sum_{j=1}^N \alpha^{(t)}_i a_{ij} b_{j, o^{(t + 1)}} \beta^{(t+1)}_j, \quad t = 1, 2, \cdots, T - 1 \tag{7}</script><script type="math/tex; mode=display">\begin{cases}    \alpha^{(t)}_i = P(s^{(t)} = q_i, o^{(1)}, \cdots, o^{(t)} | \theta) \\    \beta^{(t)}_i = P( o^{(t + 1)}, \cdots, o^{(T)} | s^{(t)} = q_i, \theta)\end{cases}</script><blockquote><script type="math/tex; mode=display">\alpha^{(t)}_i \beta^{(t)}_i = P(s^{(t)} = q_i, O | \theta)</script></blockquote><h1 id="学习问题"><a href="#学习问题" class="headerlink" title="学习问题"></a>学习问题</h1><h2 id="监督学习方法"><a href="#监督学习方法" class="headerlink" title="监督学习方法"></a>监督学习方法</h2><p>若训练数据包含若干个<strong>长度$T$相同</strong>的观测序列和对应的状态序列${(O_1, S_1), (O_2, S_2), \cdots}$，那么可以用<strong>极大似然估计</strong>($MLE$)进行模型参数的学习。状态序列中时刻$t$为状态$q_i$转移到$t+1$时刻为$q_j$频数记作$A_{ij}$，时刻$t$为状态$q_i$并产生观测$v_j$的频数记作$B_{ij}$，初始状态$t=1$时状态为$q_i$的频数记作$\Pi_i$，那么各参数估计为</p><script type="math/tex; mode=display">\begin{cases}    \hat{a}_{ij} = \frac{A_{ij}}{\sum_{j=1}^N A_{ij}} \\    \hat{b}_{ij} = \frac{B_{ij}}{\sum_{j=1}^M B_{ij}} \\    \hat{\pi}_i = \frac{\Pi_i}{\sum_{i=1} \Pi_i}\end{cases} \tag{8}</script><blockquote><p>多项分布(nultinomial distribution)</p></blockquote><h2 id="无监督学习方法"><a href="#无监督学习方法" class="headerlink" title="无监督学习方法"></a>无监督学习方法</h2><p>若训练数据包含若干个<strong>长度$T$相同</strong>的观测序列${O_1, O_2, \cdots}$，但无对应状态序列。此时将状态序列数据视作<strong>隐变量</strong>，可以用$EM$算法求解，<strong>即$Baum-Welch$算法</strong>。</p><p>状态序列$S$与观测序列$O$在模型$\theta$下，<strong>联合概率分布</strong>为</p><script type="math/tex; mode=display">P(O, S | \theta) = P(S | \theta) P(O | S, \theta) \tag{9.1}</script><p>其中</p><script type="math/tex; mode=display">\begin{cases}    P(S | \theta) = P(s^{(1)} | \theta) P(s^{(2)} | s^{(1)}, \theta) \cdots P(s^{(T)} | s^{(1)}, s^{(2)}, \cdots, s^{(T - 1)}, \theta) =     \pi_{s^{(1)}} a_{s^{(1)}s^{(2)}} \cdots a_{s^{(T - 1)}s^{(T)}} \\    P(O | S, \theta) = \sum _{t=1}^T P(o^{(t)} | s^{(t)}, \theta) = b_{s^{(1)}o^{(1)}} \cdots b_{s^{(T)}o^{(T)}}(观测独立性)\end{cases} \tag{9.2}</script><p>那么</p><script type="math/tex; mode=display">P(O, S | \theta) = \pi_{s^{(1)}} a_{s^{(1)}s^{(2)}} b_{s^{(1)}o^{(1)}} \cdots a_{s^{(T - 1)}s^{(T)}} b_{s^{(T)}o^{(T)}} \tag{9}</script><p>确定$EM$算法的$E-step$，$Q$函数为</p><script type="math/tex; mode=display">Q(\theta | \overline{\theta}) = \sum_S P(O, S | \overline{\theta}) \log P(O, S | \theta) \tag{10.1}</script><p>那么$(9)$代入后得到</p><script type="math/tex; mode=display">\begin{aligned}    Q(\theta | \overline{\theta}) & =     \sum_S P(O, S | \overline{\theta}) \log (\pi_{s^{(1)}} a_{s^{(1)}s^{(2)}} b_{s^{(1)}o^{(1)}} \cdots a_{s^{(T - 1)}s^{(T)}} b_{s^{(T)}o^{(T)}}) \\    & = \sum_S P(O, S | \overline{\theta}) \log \pi_{s^{(1)}} +     \sum_S P(O, S | \overline{\theta}) \log \prod_{t=1}^{T-1} a_{s^{(t)}s^{(t+1)}} +     \sum_S P(O, S | \overline{\theta}) \log \prod_{t=1}^{T} b_{s^{(t)}o^{(t)}} \\    & = \sum_{i=1}^N P(O, s^{(1)} = q_i | \theta) \log \pi_i + \\    & \sum_{i=1}^N \sum_{j=1}^N \sum_{t=1}^{T-1} P(O, s^{(t)} = q_i, s^{(t+1)} = q_j | \overline{\theta}) \log a_{ij} + \\    & \sum_{i=1}^N \sum_{t=1}^{T} P(O, s^{(t)} = q_i | \theta) \log b_{i,o^{(t)}}\end{aligned} \tag{10.2}</script><p>那么相应优化问题为</p><script type="math/tex; mode=display">\begin{aligned}    \theta = \arg_{\theta} \max Q(\theta | \overline{\theta}) \\    s.t. \begin{cases}        \sum_{i=1}^N \pi_i = 1 \\        \sum_{j=1}^N a_{ij} = 1 \\        \sum_{j=1}^M b_{ij} = 1 \\    \end{cases}\end{aligned} \tag{10.3}</script><p>并记</p><script type="math/tex; mode=display">\begin{cases}    \gamma^{(t)}_i     = P(S^{(t)} = q_i | O, \theta)     = \frac{P(S^{(t)} = q_i, O | \theta)}{P(O | \theta)}     = \frac{\alpha^{(t)}_i \beta^{(t)}_i}{\sum_{j=1}^N \alpha^{(t)}_j \beta^{(t)}_j} \\    \xi^{(t)}_{ij}     = P(S^{(t)} = q_i, S^{(t+1)} = q_j | O, \theta)    = \frac{P(S^{(t)} = q_i, S^{(t+1)} = q_j, O |  \theta)}{P(O | \theta)}     = \frac{\alpha^{(t)}_i a_{ij} b_{j,o^{(t+1)}} \beta^{(t+1)}_j}{\sum_{i=1}^N \sum_{j=1}^N \alpha^{(t)}_i a_{ij} b_{j,o^{(t+1)}} \beta^{(t+1)}_j}\end{cases} \tag{10.4}</script><p>用拉格朗日乘数法求解$(10.3)$，并将$(10.4)$代入，得</p><script type="math/tex; mode=display">\Rightarrow\begin{cases}    a_{ij} = \frac{\sum_{t=1}^{T-1} \xi^{(t)}_{ij}}{\sum_{t=1}^{T-1} \gamma^{(t)}_i} \\    b_{ij} = \frac{\sum_{t=1, o^{(t)}=v_j}^T \gamma^{(t)}_i}{\sum_{t=1}^T \gamma^{(t)}_i} \\    \pi_i = \gamma^{(1)}_i\end{cases} \tag{10}</script><p>迭代求解参数$(A, B, \pi)$得到模型。</p><h1 id="预测问题"><a href="#预测问题" class="headerlink" title="预测问题"></a>预测问题</h1><h2 id="贪婪策略"><a href="#贪婪策略" class="headerlink" title="贪婪策略"></a>贪婪策略</h2><p>在每个时刻$t$选择在该时刻最有可能出现的状态$s^{(t)<em>}$，从而得到状态序列$S^{</em>}$作为预测结果</p><script type="math/tex; mode=display">S^{*} = (s^{(1)*}, \cdots, s^{(T)*}) \tag{11.1}</script><p>其中</p><script type="math/tex; mode=display">s^{(t)*} = \arg \max_{1 \leq i \leq N} \gamma^{(t)}_i \tag{11.2}</script><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>用动态规划，在状态概率间求解概率最大路径，即<strong>维特比算法</strong>(Viterbi algorithm)，选择状态路径点$s^{(t)} \in Q$使得下式最大</p><script type="math/tex; mode=display">\begin{aligned}    P(s^{(1)}, \cdots, s^{(t)}, o^{(t)} | \theta)\end{aligned}</script><h1 id="例"><a href="#例" class="headerlink" title="例"></a>例</h1><p>假设有$4$个盒子，每个盒子装有红白两色<strong>比例一定</strong>的球若干，在某盒子取球后，以<strong>一定几率</strong>停留在该盒子或转移到另一盒子，转移概率未知，进行$10$次取球，在哪个盒子取球未知，球的颜色序列如下</p><script type="math/tex; mode=display">(红，红，白，白，红，白，红，红，白，红)</script><ol><li>用已知观测数据学习马尔可夫模型；</li><li>用求得得马尔可夫模型计算出现该观测序列的概率$P(O | \theta)$；</li><li>求取最优的状态转移过程。</li></ol><p><strong>解析</strong>：该例中可能的状态集合为$Q = {q_1, q_2, q_3, q_4}$，$q_i$表示在第$i$个盒子进行取球；观测集合为$V = {v_1, v_2}$，表示红、白二色。那么相应的有状态转移概率矩阵$A_{4 \times 4}$、观测概率矩阵$B_{4 \times 2}$、初始状态概率向量$\pi_{4 \times 1}$。由于取球的盒子序列未知，即状态序列未知，用$EM$算法迭代求解。</p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>EM &amp; GMM</title>
      <link href="/2018/11/12/EM-GMM/"/>
      <url>/2018/11/12/EM-GMM/</url>
      
        <content type="html"><![CDATA[<h1 id="EM算法"><a href="#EM算法" class="headerlink" title="EM算法"></a>EM算法</h1><p><code>Expectation Maximization Algorithm</code>，是 Dempster, Laind, Rubin 于 1977 年提出的求参数极大似然估计的一种方法，它可以从非完整数据集中对参数进行 <code>MLE</code> 估计，是一种非常简单实用的学习算法。这种方法可以广泛地应用于处理缺损数据，截尾数据，带有噪声等所谓的不完全数据。</p><h2 id="引例：先挖个坑"><a href="#引例：先挖个坑" class="headerlink" title="引例：先挖个坑"></a>引例：先挖个坑</h2><p>给出李航《统计学习方法》的三硬币模型例子，假设有$3$枚硬币$A, B, C$，各自出现正面的概率分别为$\pi, p, q$，先进行如下实验：先投掷硬币$A$，若结果为正面，则选择硬币$B$投掷一次，否则选择$C$，记录投掷结果如下</p><script type="math/tex; mode=display">1, 1, 0, 1, 0, 0, 1, 0, 1, 1</script><p>只能观测到实验结果，而投掷过程未知，即硬币$A$的投掷结果未知，现欲估计三枚硬币的参数$\pi, p, q$。</p><p><strong>解</strong>：根据题意可以得到三个随机变量$X_1, X_2, X_3$的概率分布如下</p><script type="math/tex; mode=display">P(X_1) = \pi ^ {X_1} (1 - \pi) ^ {1 - X_1}</script><script type="math/tex; mode=display">P(X_2) = p ^ {X_2} (1 - p) ^ {1 - X_2}</script><script type="math/tex; mode=display">P(X_3) = q ^ {X_3} (1 - q) ^ {1 - X_3}</script><p>定义随机变量$X$表示观测结果为正面，由全概率公式可以得到</p><script type="math/tex; mode=display">P(X) = P(X|X_1)P(X_1) + P(X|\overline{X_1})P(\overline{X_1})= \pi p + (1 - \pi) q</script><script type="math/tex; mode=display">P(\overline{X}) = P(\overline{X}|X_1)P(X_1) + P(\overline{X}|\overline{X_1})P(\overline{X_1})= \pi (1 - p) + (1 - \pi) (1 - q)</script><p>即</p><script type="math/tex; mode=display">P(X) = [\pi p + (1 - \pi) q] ^ {X} [\pi (1 - p) + (1 - \pi) (1 - q)] ^ {1 - X} \tag{0}</script><p>利用<strong>最大似然估计</strong>，有</p><script type="math/tex; mode=display">\log L(D | \theta) = 6 \log [\pi p + (1 - \pi) q] + 4 \log [\pi (1 - p) + (1 - \pi) (1 - q)]</script><p>至此，我们一定能想到通过求似然函数极值来求解参数</p><script type="math/tex; mode=display">\frac{∂ }{∂ \pi} \log L = 0 \Rightarrow 5 \pi (p - q) + 5q - 3 = 0</script><script type="math/tex; mode=display">\frac{∂ }{∂ p} \log L = 0 \Rightarrow 5 \pi (p - q) + 5q - 3 = 0</script><script type="math/tex; mode=display">\frac{∂ }{∂ q} \log L = 0 \Rightarrow 5 \pi (p - q) + 5q - 3 = 0</script><p>但是好像出了问题，并不能求解，所以我们引入<code>EM算法</code>迭代求解。</p><h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><p>以$x^{(i)}$表示训练数据，$w_k$表示类别，设当前迭代参数为$\theta^{(t)}$，则下一次迭代应有</p><script type="math/tex; mode=display">\theta^{(t+1)} = \arg \max \sum_i \log P(x^{(i)}|\theta) \tag{1}</script><p>记<strong>隐变量</strong>为$w_k$，那么由<strong>边缘概率公式</strong></p><script type="math/tex; mode=display">\sum_i \log P(x^{(i)}|\theta)= \sum_i \log \sum_k P(x^{(i)}, w_k^{(i)}|\theta) \tag{2}</script><blockquote><p>$P(x^{(i)}, w_k^{(i)}|\theta) = P(x^{(i)} | w_k^{(i)}, \theta) P(w_k^{(i)}|x^{(i)}, \theta)$<br>至此已得出引例中的表达式，其中$P(w_k^{(i)}|x^{(i)}, \theta)$与$P(x^{(i)} | w_k^{(i)}, \theta)$均未知，而通过求极值不能解得参数。</p></blockquote><p>我们引入<strong>迭代参数</strong>$\theta^{(t)}$，即第$t$次迭代时的参数$\theta$，该参数为已知变量</p><script type="math/tex; mode=display">\sum_i \log P(x^{(i)}|\theta)= \sum_i \log \sum_k P(x^{(i)}, w_k^{(i)}|\theta) \frac{P(w_k^{(i)} | \theta^{(t)})}{P(w_k^{(i)} | \theta^{(t)})} \tag{3}</script><blockquote><p>$P(w_k^{(i)}|\theta^{(t)})$表示样本$x^{(i)}$类别为$w_k^{(i)}$的概率，注意上标。</p></blockquote><p>引入<code>Jensen不等式</code>：</p><blockquote><p>For a real convex function $\varphi$, numbers $x_1, …, x_n$ in its domain, and positive weights $a_i$, Jensen’s inequality can be stated as:</p><script type="math/tex; mode=display">\varphi\left(\frac{\sum a_i x_i}{\sum a_i}\right)\leq \frac{\sum a_i \varphi(x_i)}{\sum a_i}</script><p>and the inquality is reversed if $\varphi$ is concave, which is</p><script type="math/tex; mode=display">\varphi\left(\frac{\sum a_i x_i}{\sum a_i}\right)\geq \frac{\sum a_i \varphi(x_i)}{\sum a_i}</script><p>Equality holds if and only if $x_1 = … = x_n$ or $\varphi$ is linear.</p></blockquote><p>$\log(·)$为凹函数<code>(concave)</code>，且满足</p><script type="math/tex; mode=display">\sum_k P(w_k^{(i)} | \theta^{(t)}) = 1</script><p>所以有</p><script type="math/tex; mode=display">\sum_i \log P(x^{(i)}|\theta)= \sum_i \log \sum_k P(x^{(i)}, w_k^{(i)}|\theta) \frac{P(w_k^{(i)}|\theta^{(t)})}{P(w_k^{(i)}|\theta^{(t)})}</script><script type="math/tex; mode=display">\geq \sum_i \sum_k P(w_k^{(i)}|\theta^{(t)}) \log \frac{P(x^{(i)}, w_k^{(i)}|\theta)}{P(w_k^{(i)}|\theta^{(t)})} \tag{4}</script><p>由$Jensen$不等式，当且仅当$　P(x^{(i)}, w_k^{(i)}|\theta)=C　$时取等号。</p><blockquote><script type="math/tex; mode=display">\sum_i \underbrace{\log}_{\varphi} \frac{\sum_k P(x^{(i)}, w_k^{(i)}|\theta) \frac{\underbrace{P(w_k^{(i)}|\theta^{(t)})}_{a}} {P(w_k^{(i)}|\theta^{(t)})}}{\sum_k \underbrace{P(w_k^{(i)} | \theta^{(t)})}_{a}}</script></blockquote><p>此时我们得到似然函数$\sum_i \log P(x^{(i)}|\theta)$的一个<strong>下界</strong>，但必须保证这个下界是<strong>紧的</strong>，也就是至少有点能使等号成立。</p><p>定义</p><script type="math/tex; mode=display">L(\theta|\theta^{(t)})= \sum_i \sum_k P(w_k^{(i)}|\theta^{(t)}) \log \frac{P(x^{(i)}, w_k^{(i)}|\theta)}{P(w_k^{(i)}|\theta^{(t)})}</script><script type="math/tex; mode=display">= \sum_i \sum_k P(w_k^{(i)}|\theta^{(t)}) \log P(x^{(i)}, w_k^{(i)}|\theta) - P(w_k^{(i)}|\theta^{(t)}) \log P(w_k^{(i)}|\theta^{(t)}) \tag{5}</script><p>其中第一项即$\log P(X, w|\theta) | X, \theta^{(t)}$的<strong>期望</strong></p><script type="math/tex; mode=display">E_w\left[    \log P(X, w|\theta) | X, \theta^{(t)}\right] = \sum_i \sum_k P(w_k^{(i)}|\theta^{(t)}) \log P(x^{(i)}, w_k^{(i)}|\theta) \tag{5.1}</script><p>第二项为$P(w | X, \theta^{(t)})$的<strong>信息熵</strong></p><script type="math/tex; mode=display">H[P(w | X, \theta^{(t)})] = - \sum_i \sum_k P(w_k^{(i)}|\theta^{(t)}) \log P(w_k^{(i)}|\theta^{(t)}) \tag{5.2}</script><p>即</p><script type="math/tex; mode=display">L(\theta|\theta^{(t)})= E_w\left[    \log P(X, w|\theta) | X, \theta^{(t)}\right] +H[P(w | X, \theta^{(t)})] \tag{E-step}</script><p>注意到$H[P(w | X, \theta^{(t)})]$项为常数，故也可设</p><script type="math/tex; mode=display">Q(\theta|\theta^{(t)}) = E_w\left[\log P(X, w|\theta) | X, \theta^{(t)} \right]</script><p>代回$(1)$，得到<strong>最终的优化目标</strong></p><script type="math/tex; mode=display">\theta^{(t+1)} = \arg \max L(\theta|\theta^{(t)}) = \arg \max Q(\theta|\theta^{(t)}) \tag{M-step}</script><blockquote><p>其中$x^{(i)}, w_k^{(i)}$的联合概率密度一般用<strong>条件概率</strong>计算</p><script type="math/tex; mode=display">P(x^{(i)}, w_k^{(i)}|\theta) = P(x^{(i)} | w_k^{(i)}, \theta) P(w_k^{(i)} | \theta)</script><p>那么</p><script type="math/tex; mode=display">Q(\theta | \theta^{(t)}) = \sum_i \sum_k P(w_k^{(i)} | \theta^{(t)})\log \left[   P(x^{(i)} | w_k^{(i)}, \theta)  P(w_k^{(i)} | \theta)\right] \tag{*}</script><p>各部分解释如下</p><script type="math/tex; mode=display">\begin{cases}    P(w_k^{(i)} | \theta^{(t)}): \theta^{(t)}参数下，由x^{(i)}求得的隐变量的概率 \\    P(x^{(i)} | w_k^{(i)}, \theta): \theta参数下，隐变量取值为w_k^{(i)}下，x^{(i)}的条件分布概率 \\    P(w_k^{(i)} | \theta): \theta参数下，由x^{(i)}求得的隐变量的分布 \end{cases}</script></blockquote><p><strong>引入迭代变量，并经$Jensen$不等式处理后，各参数可通过迭代求解</strong>，需要不断最大化$L(\theta | \theta^{(t)})$来不断优化，这就是$EM$算法，$E-step$是指求出期望，$M-step$是指迭代更新参数</p><p><img src="/2018/11/12/EM-GMM/EM算法图解.png" alt="EM算法图解"></p><p>伪代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">According to prior knowledge set </span><br><span class="line">    $\theta$</span><br><span class="line">Repeat until convergence&#123;</span><br><span class="line">    E-step: The expectation of hidden variables</span><br><span class="line">    M-step: Finding the maximum of likelihood function</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实际上，从<strong>边缘概率与条件概率</strong>入手，类似的有</p><script type="math/tex; mode=display">\sum_i \log P(x^{(i)}|\theta)= \sum_i \log \sum_k P(x^{(i)}, w_k^{(i)}|\theta)</script><script type="math/tex; mode=display">= \sum_i \log \sum_k P(x^{(i)} | w_k^{(i)}, \theta) P(w_k^{(i)} | \theta)</script><script type="math/tex; mode=display">\geq \sum_i \sum_k P(w_k^{(i)} | \theta) \log P(x^{(i)} | w_k^{(i)}, \theta) \tag{Jensen inequality}</script><script type="math/tex; mode=display">= \sum_i \sum_k P(w_k^{(i)} | \theta) \log \frac{P(x^{(i)}, w_k^{(i)}|\theta)}{P(w_k^{(i)}|\theta)} \tag{6.1}</script><p>而由$(4)$，类似的，<strong>引入迭代变量</strong>可以得到</p><script type="math/tex; mode=display">\sum_i \log P(x^{(i)}|\theta)\geq L(\theta|\theta^{(t)}) \tag{6.2}</script><blockquote><script type="math/tex; mode=display">L(\theta|\theta^{(t)}) = \sum_i \sum_k P(w_k^{(i)}|\theta^{(t)}) \log \frac{P(x^{(i)}, w_k^{(i)}|\theta)}{P(w_k^{(i)}|\theta^{(t)})} \tag{5}</script></blockquote><p>则</p><script type="math/tex; mode=display">\sum_i \log P(x^{(i)}|\theta) - L(\theta|\theta^{(t)})</script><script type="math/tex; mode=display">= \sum_i \sum_k P(w_k^{(i)} | \theta) \log \frac{P(x^{(i)}, w_k^{(i)}|\theta)}{P(w_k^{(i)}|\theta)} -\sum_i \sum_k P(w_k^{(i)}|\theta^{(t)}) \log \frac{P(x^{(i)}, w_k^{(i)}|\theta)}{P(w_k^{(i)}|\theta^{(t)})}</script><script type="math/tex; mode=display">= \sum_i \sum_k P(w_k^{(i)}|\theta^{(t)}) \log \frac{P(w_k^{(i)}|\theta^{(t)})}{P(w_k^{(i)}|\theta)} \tag{6.3}</script><p>而由<code>KL散度( Kullback–Leibler divergence)</code>(又称<code>相对熵(relative entropy)</code>)定义</p><blockquote><script type="math/tex; mode=display">D(P||Q) = \sum P(x) \log \frac{P(x)}{Q(x)}</script></blockquote><p>可知</p><script type="math/tex; mode=display">\sum_i \log P(x^{(i)}|\theta) - L(\theta|\theta^{(t)}) = D\left[ P(w_k^{(i)}|\theta^{(t)}) || P(w_k^{(i)}|\theta) \right] \tag{6.4}</script><p><strong>即迭代的$P(w_k^{(i)}|\theta^{(t)})$与真实的$P(w_k^{(i)}|\theta)$之间的相对熵！</strong></p><!-- 另外，附上证明一则> 证明对数似然函数$\sum_i \log P(x^{(i)} | \theta)$满足> $$> \sum_i \log P(x^{(i)} | \theta^{(t+1)}) > \geq \sum_i \log P(x^{(i)} | \theta^{(t)})> $$> > 证明：由$(M-step)$> $$\sum_i \log P(x^{(i)} | \theta^{(t+1)})> = \max L(\theta | \theta^{(t)})$$> > 而$\theta^{(t+1)}为函数L(\theta|\theta^{(t)})极值点$，所以> $$\max L(\theta | \theta^{(t)})> \geq L(\theta | \theta^{(t)})$$> > 其中> $$> L(\theta | \theta^{(t)})> = \sum_i \log P(x^{(i)} | \theta^{(t)})> $$> > 故> $$> \sum_i \log P(x^{(i)} | \theta^{(t+1)}) > \geq \sum_i \log P(x^{(i)} | \theta^{(t)})> $$ --><h2 id="引例的求解"><a href="#引例的求解" class="headerlink" title="引例的求解"></a>引例的求解</h2><blockquote><script type="math/tex; mode=display">Q(\theta|\theta^{(t)}) = \sum_i \sum_k P(w_k^{(i)}|\theta^{(t)}) \log P(x^{(i)} | w_k^{(i)}, \theta) P(w_k^{(i)} | \theta)</script></blockquote><p>此题中</p><script type="math/tex; mode=display">\begin{cases}    P(w_k|\pi) = \pi^{w_k}(1-\pi)^{1-w_k} \\    P(x | w_1, p) = p^{x^{(i)}}(1-p)^{1-x^{(i)}} \\    P(x | w_2, q) = q^{x^{(i)}}(1-q)^{1-x^{(i)}}\end{cases} \tag{7}</script><ul><li><p>$E-step$</p><script type="math/tex; mode=display">  \begin{aligned}      Q(\pi, p, q | \pi^{(t)}, p^{(t)}, q^{(t)})      = \sum_i \sum_k P(w_k^{(i)}|\pi^{(t)}, p^{(t)}, q^{(t)}) \times \\       \log P(x^{(i)} | w_k^{(i)}, \pi, p, q) P(w_k^{(i)} | \pi, p, q)   \end{aligned} \tag{8}</script><ol><li><p>先求$P(w_k^{(i)}|\pi^{(t)}, p^{(t)}, q^{(t)})$，即第一次投掷结果为$w_k$的概率</p><script type="math/tex; mode=display"> P(w_k^{(i)}|\pi^{(t)}, p^{(t)}, q^{(t)}) = \frac {\left[\pi^{(t)}p^{(t)x^{(i)}}(1-p^{(t)})^{1-x^{(i)}}\right]^{w_k} \left[(1-\pi^{(t)})q^{(t)x^{(i)}}(1-q^{(t)})^{1-x^{(i)}}\right]^{1-w_k}} {\sum_j \left[\pi^{(t)}p^{(t)x^{(i)}}(1-p^{(t)})^{1-x^{(i)}}\right]^{w_j} \left[(1-\pi^{(t)})q^{(t)x^{(i)}}(1-q^{(t)})^{1-x^{(i)}}\right]^{1-w_j}} \tag{8.1}</script><blockquote><script type="math/tex; mode=display">\frac{A正面， 投掷结果为x^{(i)}}{A正面， 投掷结果为x^{(i)} + A反面， 投掷结果为x^{(i)}}</script></blockquote><p> 即</p><script type="math/tex; mode=display"> \begin{cases}     P(w_1^{(i)}|\pi^{(t)}, p^{(t)}, q^{(t)}) = \frac         {\pi^{(t)}p^{(t)x^{(i)}}(1-p^{(t)})^{1-x^{(i)}}}         {\pi^{(t)}p^{(t)x^{(i)}}(1-p^{(t)})^{1-x^{(i)}} +          (1-\pi^{(t)})q^{(t)x^{(i)}}(1-q^{(t)})^{1-x^{(i)}}} \\     P(w_2^{(i)}|\pi^{(t)}, p^{(t)}, q^{(t)}) = \frac         {(1-\pi^{(t)})q^{(t)x^{(i)}}(1-q^{(t)})^{1-x^{(i)}}}         {\pi^{(t)}p^{(t)x^{(i)}}(1-p^{(t)})^{1-x^{(i)}} +          (1-\pi^{(t)})q^{(t)x^{(i)}}(1-q^{(t)})^{1-x^{(i)}}} \end{cases}</script><p> 记</p><script type="math/tex; mode=display"> \begin{cases}     \mu_1^{(i)} = P(w_1^{(i)}|\pi^{(t)}, p^{(t)}, q^{(t)}) \\     \mu_2^{(i)} = 1 - \mu_1^{(i)} \end{cases}</script><blockquote><p>注意$w^{(i)}_k$上标<code>^{(i)}</code></p></blockquote></li><li><p>再求$P(x^{(i)}, w_k^{(i)} | \pi, p, q)$，已知</p><script type="math/tex; mode=display"> P(x^{(i)}, w_k^{(i)} | \pi, p, q) = P(x^{(i)} | w_k^{(i)}, \pi, p, q) P(w_k^{(i)} | \pi, p, q)</script><blockquote><p>$P(x^{(i)} | w_k^{(i)}, \pi, p, q)$为$A$取正/反面下，得到结果$x^{(i)}$的概率；$P(w_k^{(i)} | \pi, p, q)$同$P(w_k^{(i)}|\pi^{(t)}, p^{(t)}, q^{(t)})$。</p></blockquote><p> 所以</p><script type="math/tex; mode=display"> P(x^{(i)}, w_k^{(i)} | \pi, p,q) = \left[\pi p^{x^{(i)}}(1-p)^{1-x^{(i)}}\right]^{w_k} \left[(1-\pi)q^{x^{(i)}}(1-q)^{1-x^{(i)}}\right]^{1-w_k} \tag{8.2}</script><p>综上</p><script type="math/tex; mode=display">\begin{aligned} Q(\pi, p, q | \pi^{(t)}, p^{(t)}, q^{(t)}) \\ = \sum_i \sum_{k=1}^2 \mu^{(i)}_k \log \{ \left[\pi p^{x^{(i)}}(1-p)^{1-x^{(i)}}\right]^{w_k} \left[(1-\pi)q^{x^{(i)}}(1-q)^{1-x^{(i)}}\right]^{1-w_k} \} \\ = \sum_i \mu_1^{(i)} \log \pi p^{x^{(i)}}(1-p)^{1-x^{(i)}} + (1 - \mu_1^{(i)}) \log (1-\pi) q^{x^{(i)}}(1-q)^{1-x^{(i)}}\end{aligned} \tag{9}</script></li></ol></li><li><p>$M-step$</p><ul><li><p>$\frac{∂Q}{∂\pi} = 0$</p><script type="math/tex; mode=display">  \begin{aligned}      \frac{∂Q}{∂\pi}      = \sum_i \mu_1^{(i)}       \frac {p^{x^{(i)}}(1-p)^{1-x^{(i)}}}      {\pi p^{x^{(i)}}(1-p)^{1-x^{(i)}}} +       (1 - \mu_1^{(i)}) \frac {- q^{x^{(i)}}(1-q)^{1-x^{(i)}}}      {(1-\pi) q^{x^{(i)}}(1-q)^{1-x^{(i)}}} \\      = \sum_i \frac{\mu_1^{(i)}}{\pi} + \frac{\mu_1^{(i)} - 1}{1 - \pi} \\      = \sum_i \frac{\mu_1^{(i)} - \pi}{\pi(1 - \pi)}      = \frac{\sum_i \mu_1^{(i)} - n\pi}{\pi(1 - \pi)} \\ = 0 \\      \Rightarrow \pi^{(t+1)} = \frac{1}{n} \sum_i \mu_1^{(i)}   \end{aligned} \tag{10.1}</script></li><li><p>$\frac{∂Q}{∂p} = 0$</p><script type="math/tex; mode=display">  \begin{aligned}  \frac{∂Q}{∂p}  = \sum_i \mu_1^{(i)}   \left[      \frac{x^{(i)}}{p} - \frac{1 - x^{(i)}}{1 - p}  \right] \\  = \frac{1}{p(1 - p)}   \sum_i \mu_1^{(i)} (x^{(i)} - p) \\  = \frac{1}{p(1 - p)}  \left[      \sum_i \mu_1^{(i)} x^{(i)} - p \sum_i \mu_1^{(i)}  \right] \\ = 0 \\  \Rightarrow p^{(t+1)} = \frac{\sum_i \mu_1^{(i)} x^{(i)}}{\sum_i \mu_1^{(i)}}   \end{aligned}\tag{10.2}</script></li><li><p>$\frac{∂Q}{∂q} = 0$</p><script type="math/tex; mode=display">  \begin{aligned}      \frac{∂Q}{∂q}      = \sum_i (1 - \mu_1^{(i)})       \left[          \frac{x^{(i)}}{q} - \frac{1 - x^{(i)}}{1 - q}      \right] \\      = \frac{1}{q(1 - q)}      \sum_i (1 - \mu_1^{(i)})       (x^{(i)} - q) \\      = \frac{1}{q(1 - q)}      \left[          \sum_i (1 - \mu_1^{(i)}) x^{(i)} -          q \sum_i (1 - \mu_1^{(i)})      \right] \\ = 0 \\      \Rightarrow q^{(t+1)} = \frac{\sum_i (1 - \mu_1^{(i)}) x^{(i)}}{\sum_i (1 - \mu_1^{(i)})}   \end{aligned} \tag{10.3}</script></li></ul></li></ul><p>综上</p><script type="math/tex; mode=display">\begin{cases}    \mu_1^{(i)} = P(w_1^{(i)}|\pi^{(t)}, p^{(t)}, q^{(t)}) \\    \pi^{(t+1)} = \frac{1}{n} \sum_i \mu_1^{(i)} \\    p^{(t+1)} = \frac{\sum_i \mu_1^{(i)} x^{(i)}}{\sum_i \mu_1^{(i)}} \\    q^{(t+1)} = \frac{\sum_i (1 - \mu_1^{(i)}) x^{(i)}}{\sum_i (1 - \mu_1^{(i)})} \\\end{cases} \tag{10}</script><p>多次迭代即可求解，终止条件可设置为</p><script type="math/tex; mode=display">|| \theta^{(t+1)} - \theta^{(t)} || < \epsilon \quad 或 \quad ||Q(\theta^{(t+1)} | \theta^{(t)}) - Q(\theta^{(t)} |\theta^{(t)})|| < \epsilon</script><h1 id="GMM模型"><a href="#GMM模型" class="headerlink" title="GMM模型"></a>GMM模型</h1><p><code>Gaussian Mixture Model</code>，是一种无监督学习算法，常用于聚类。<strong>当聚类问题中各个类别的尺寸不同、聚类间有相关关系的时候，往往使用<code>GMM</code>更合适</strong>。对一个样本来说，<code>GMM</code>得到的是其属于各个类的概率(通过计算后验概率得到)，而不是完全的属于某个类，这种聚类方法被成为<strong>软聚类</strong>。一般说来， 任意形状的概率分布都可以用多个高斯分布函数去近似，因而，<code>GMM</code>的应用也比较广泛。</p><p>高斯混合模型，指具有如下形式的概率分布模型：</p><script type="math/tex; mode=display">P(x|\mu, \Sigma)= \sum_{k=1}^K \pi_k N(x|\mu_k, \Sigma_k)</script><p>其中</p><ul><li>$\pi_k(0 \leq \pi_k \leq 1)$是系数，且$\sum_k \pi_k = 1$</li><li>$N(x|\mu_k, \Sigma_k)$为高斯密度函数</li></ul><script type="math/tex; mode=display">N(x|\mu_k, \Sigma_k) = \frac{1}{(2\pi)^{n/2}|\Sigma_k|^{1/2}} \exp \left[    -\frac{1}{2} (x - \mu_k)^T \Sigma_k^{-1} (x - \mu_k)\right]</script><blockquote><ul><li>即多个高斯分布叠加出来的玩意；</li><li>现在我们需要求取系数$\pi_k$及高斯模型的参数$(\mu_k, \Sigma_k)$；</li><li>与<code>K-Means</code>等聚类方法区别是，<code>GMM</code>求出的是连续的分布模型，可计算出“归属于”哪一类的概率。</li></ul></blockquote><h2 id="推导-1"><a href="#推导-1" class="headerlink" title="推导"></a>推导</h2><script type="math/tex; mode=display">\log P(X|\pi, \mu, \Sigma)= \sum_i \log \sum_k \pi_k N(x|\mu_k, \Sigma_k)</script><script type="math/tex; mode=display">s.t.　\sum_k \pi_k = 1</script><h3 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h3><p>以$1$维高斯分布为例</p><script type="math/tex; mode=display">N(x|\mu_k, \sigma_k^2) = \frac{1}{\sqrt{2\pi}\sigma_k} e^{-\frac{(x - \mu_k)^2}{2\sigma_k^2}}</script><p>构造拉格朗日<code>(Lagrange)</code>函数</p><script type="math/tex; mode=display">L(\pi, \mu, \sigma^2) = \sum_i \log \sum_k \pi_k N(x|\mu_k, \sigma_k^2) + \lambda \left(\sum_k \pi_k - 1 \right) \tag{5}</script><script type="math/tex; mode=display">\begin{cases}    \frac{∂}{∂\pi_k} L(\pi, \mu, \sigma^2)         = \sum_i        \frac{N(x^{(i)}|\mu_k, \sigma_k^2)}{\sum_j \pi_j N(x^{(i)}|\mu_j, \sigma_j^2)} + \lambda \\    \frac{∂}{∂\mu_k} L(\pi, \mu, \sigma^2)        = \sum_i        \frac{\pi_k}{\sum_j \pi_j N(x^{(i)}|\mu_j, \sigma_j^2)} \frac{∂}{∂\mu_k}N(x^{(i)}|\mu_k, \sigma_k^2) \\    \frac{∂}{∂\sigma_k^2} L(\pi, \mu, \sigma^2)        = \sum_i        \frac{\pi_k}{\sum_j \pi_j N(x^{(i)}|\mu_j, \sigma_j^2)} \frac{∂}{∂\sigma_k^2}N(x^{(i)}|\mu_k, \sigma_k^2)\end{cases} \tag{6}</script><p>其中</p><script type="math/tex; mode=display">\frac{∂}{∂\mu_k} N(x|\mu_k, \sigma_k^2)= \frac{1}{\sqrt{2\pi}\sigma_k} e^{-\frac{(x - \mu_k)^2}{2\sigma_k^2}} \frac{x-\mu_k}{\sigma_k^2}= N(x|\mu_k, \sigma_k^2) · \frac{x-\mu_k}{\sigma_k^2}</script><script type="math/tex; mode=display">\frac{∂}{∂\sigma_k^2} N(x|\mu_k, \sigma_k^2)= \frac{1}{\sqrt{2\pi}} e^{-\frac{(x - \mu_k)^2}{2\sigma_k^2}} \frac{∂}{∂\sigma_k^2} \left(\frac{1}{\sigma_k}\right) + \frac{1}{\sqrt{2\pi}\sigma_k} e^{-\frac{(x - \mu_k)^2}{2\sigma_k^2}} \left(-\frac{(x - \mu_k)^2}{2}\right) \frac{∂}{∂\sigma_k^2} \left(\frac{1}{\sigma_k^2}\right)</script><blockquote><p>$\frac{∂}{∂\sigma_k^2} \left(\frac{1}{\sigma_k}\right) = - \frac{\sigma_k^{-3}}{2};　\frac{∂}{∂\sigma_k^2} \left(\frac{1}{\sigma_k^2}\right) = - \frac{1}{\sigma_k^4}$</p></blockquote><script type="math/tex; mode=display">= \frac{1}{\sqrt{2\pi}} e^{-\frac{(x - \mu_k)^2}{2\sigma_k^2}} \left(- \frac{\sigma_k^{-3}}{2}\right) + \frac{1}{\sqrt{2\pi}\sigma_k} e^{-\frac{(x - \mu_k)^2}{2\sigma_k^2}} \left(-\frac{(x - \mu_k)^2}{2}\right) \left(- \frac{1}{\sigma_k^4}\right)</script><script type="math/tex; mode=display">= N(x|\mu_k, \sigma_k^2) \left[    \frac{(x - \mu_k)^2}{\sigma_k^2} - 1\right] \frac{1}{2 \sigma_k^2}</script><p>代回$(6)$可以得到</p><script type="math/tex; mode=display">\begin{cases}    \frac{∂}{∂\pi_k} L(\pi, \mu, \sigma^2)        = \sum_i        \frac{N(x^{(i)}|\mu_k, \sigma_k^2)}{\sum_j \pi_j N(x^{(i)}|\mu_j, \sigma_j^2)} + \lambda \\    \frac{∂}{∂\mu_k} L(\pi, \mu, \sigma^2)        = \sum_i        \frac{\pi_k N(x^{(i)}|\mu_k, \sigma_k^2)}{\sum_j \pi_j N(x^{(i)}|\mu_j, \sigma_j^2)} \frac{x^{(i)}-\mu_k}{\sigma_k^2} \\    \frac{∂}{∂\sigma_k^2} L(\pi, \mu, \sigma^2)        = \sum_i        \frac{\pi_k N(x^{(i)}|\mu_k, \sigma_k^2)}{\sum_j \pi_j N(x^{(i)}|\mu_j, \sigma_j^2)} \left[    \frac{(x^{(i)} - \mu_k)^2}{\sigma_k^2} - 1\right] \frac{1}{2 \sigma_k^2}\end{cases} \tag{7}</script><p>令</p><script type="math/tex; mode=display">\gamma^{(i)}_k = \frac{\pi_k N(x^{(i)}|\mu_k, \sigma_k^2)}{\sum_j \pi_j N(x^{(i)}|\mu_j, \sigma_j^2)} \tag{8}</script><blockquote><p>通俗理解：$\gamma^{(i)}_k$表示样本$x^{(i)}$中来自类别$w_k$的“贡献百分比”</p></blockquote><ul><li><p>令$\frac{∂}{∂\mu_k} \log P(X|\pi, \mu, \sigma^2) = 0$，整理得到</p><script type="math/tex; mode=display">  \sum_i \gamma^{(i)}_k (x^{(i)} - \mu_k) = 0  \Rightarrow   \mu_k = \frac{\sum_i \gamma^{(i)}_k x^{(i)}}{\sum_i \gamma^{(i)}_k}</script></li><li><p>令$\frac{∂}{∂\sigma_k^2} \log P(X|\pi, \mu, \sigma^2) = 0$，整理得到</p><script type="math/tex; mode=display">  \sum_i      \gamma^{(i)}_k       \left[          \frac{(x^{(i)} - \mu_k)^2}{\sigma_k^2} - 1      \right] = 0  \Rightarrow  \sigma_k^2 = \frac{\sum_i \gamma^{(i)}_k (x^{(i)} - \mu_k)^2}{\sum_i \gamma^{(i)}_k}</script></li><li><p>对于$\frac{∂}{∂\pi_k} \log P(X|\pi, \mu, \sigma^2) = 0$，需要做一点处理<br>  两边同乘$\pi_k$，得到</p><script type="math/tex; mode=display">  \sum_i \gamma^{(i)}_k = - \lambda \pi_k \tag{9}</script><p>  然后两边对$k$作累加</p><script type="math/tex; mode=display">  \sum_k \sum_i \gamma^{(i)}_k = - \lambda \sum_k \pi_k</script><blockquote><p>$\sum_k \sum_i \gamma^{(i)}_k = \sum_i \sum_k \gamma^{(i)}_k = N,　\sum_k \pi_k = 1$</p></blockquote><script type="math/tex; mode=display">  N = - \lambda　或　\lambda = -N \tag{10}</script><p>  代回$(9)$，得到</p><script type="math/tex; mode=display">  \pi_k = \frac{\sum_i \gamma^{(i)}_k}{N}</script></li></ul><p>综上，我们得到$4$个用于迭代的计算式，将其推广至多维即</p><script type="math/tex; mode=display">\begin{cases}    \gamma^{(i)}_k = \frac{\pi_k N(x^{(i)}|\mu_k, \Sigma_k)}{\sum_j \pi_j N(x^{(i)}|\mu_j, \Sigma_j)} \\    \mu_k = \frac{\sum_i \gamma^{(i)}_k x^{(i)}}{\sum_i \gamma^{(i)}_k} \\    \Sigma_k = \frac{\sum_i \gamma^{(i)}_k (x^{(i)} - \mu_k) (x^{(i)} - \mu_k)^T}{\sum_i \gamma^{(i)}_k} \\    \pi_k = \frac{\sum_i \gamma^{(i)}_k}{N}\end{cases}</script><h3 id="EM算法求解"><a href="#EM算法求解" class="headerlink" title="EM算法求解"></a>EM算法求解</h3><blockquote><script type="math/tex; mode=display">Q(\theta|\theta^{(t)}) = \sum_i \sum_k P(w_k^{(i)}|\theta^{(t)}) \log P(x^{(i)} | w_k^{(i)}, \theta) P(w_k^{(i)} | \theta)</script></blockquote><script type="math/tex; mode=display">Q(\mu_k, \Sigma_k|\mu_k^{(t)}, \Sigma_k^{(t)}) = \sum_i \sum_k P(w_k^{(i)}|\mu_k^{(t)}, \Sigma_k^{(t)})\log P(x^{(i)} | w_k^{(i)}, \mu_k, \Sigma_k) P(w_k^{(i)} | \mu_k, \Sigma_k)</script><ul><li><p>$ M-step $</p><script type="math/tex; mode=display">  \begin{cases}      P(w_k^{(i)}|\mu_k^{(t)}, \Sigma_k^{(t)})      = \frac{\pi_k^{(t)} N(x^{(i)}|\mu_k^{(t)}, \Sigma_k^{(t)})}      {\sum_j \pi_j^{(t)} N(x^{(i)}|\mu_j^{(t)}, \Sigma_j^{(t)})}      = \gamma^{(i)(t)}_k \\      P(x^{(i)} | w_k^{(i)}, \mu_k, \Sigma_k)       P(w_k^{(i)}|\mu_k, \Sigma_k)      = \pi_k N(x^{(i)}|\mu_k, \Sigma_k)  \end{cases}</script><p>  故</p><script type="math/tex; mode=display">  Q(\mu_k, \Sigma_k|\mu_k^{(t)}, \Sigma_k^{(t)})   = \sum_i \sum_k \gamma^{(i)(t)}_k \log \pi_k N(x^{(i)}|\mu_k, \Sigma_k)</script><p>  通过求解极值可得</p><script type="math/tex; mode=display">  \begin{cases}      \gamma^{(i)(t)}_k = \frac{\pi^{(t)}_k N(x^{(i)}|\mu_k^{(t)}, \Sigma_k^{(t)})}{\sum_j \pi_j^{(t)} N(x^{(i)}|\mu_j^{(t)}, \Sigma_j^{(t)})} \\      \mu_k^{(t+1)} = \frac{\sum_i \gamma^{(i)(t)}_k x^{(i)}}{\sum_i \gamma^{(i)(t)}_k} \\      \Sigma_k^{(t+1)} = \frac{\sum_i \gamma^{(i)(t)}_k (x^{(i)} - \mu_k) (x^{(i)} - \mu_k)^T}{\sum_i \gamma^{(i)(t)}_k} \\      \pi_k^{(t+1)} = \frac{\sum_i \gamma^{(i)(t)}_k}{N}  \end{cases}</script><p>  伪代码为</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">According to prior knowledge set</span><br><span class="line">    \pi^&#123;(t)&#125;(n_clusters,)</span><br><span class="line">    \mu^&#123;(t)&#125;(n_clusters, n_features)</span><br><span class="line">    \Sigma^&#123;(t)&#125;(n_clusters, n_features, n_features)</span><br><span class="line">Repeat until convergence&#123;</span><br><span class="line">    # E-step: calculate \gamma^&#123;(t)&#125;</span><br><span class="line">        \gamma(n_samples, n_clusters)</span><br><span class="line">    # M-step: update \pi, \mu, \Sigma</span><br><span class="line">        \pi^&#123;(t+1)&#125;(n_clusters,)</span><br><span class="line">        \mu^&#123;(t+1)&#125;(n_clusters, n_features)</span><br><span class="line">        \Sigma^&#123;(t+1)&#125;(n_clusters, n_features, n_features)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>初始点的选择可以随机选择，也可使用<code>K-Means</code></p></blockquote><p>  <code>GMM</code>算法收敛过程如下<br>  <img src="/2018/11/12/EM-GMM/gmm.gif" alt="gmm"></p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://github.com/isLouisHsu/Python-Examples-for-Pattern-Recognition-Course/blob/master/examples/p82_gmm.py" target="_blank" rel="noopener">@Github: GMM</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GMM</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">""" Gaussian Mixture Model</span></span><br><span class="line"><span class="string">    Attributes:</span></span><br><span class="line"><span class="string">        n_clusters &#123;int&#125;</span></span><br><span class="line"><span class="string">        prior &#123;ndarray(n_clusters,)&#125;</span></span><br><span class="line"><span class="string">        mu &#123;ndarray(n_clusters, n_features)&#125;</span></span><br><span class="line"><span class="string">        sigma &#123;ndarray(n_clusters, n_features, n_features)&#125;</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n_clusters)</span>:</span></span><br><span class="line">        self.n_clusters = n_clusters</span><br><span class="line">        self.prior = <span class="keyword">None</span></span><br><span class="line">        self.mu = <span class="keyword">None</span></span><br><span class="line">        self.sigma = <span class="keyword">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X, delta=<span class="number">0.01</span>)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            X &#123;ndarray(n_samples, n_features)&#125;</span></span><br><span class="line"><span class="string">            delta &#123;float&#125;</span></span><br><span class="line"><span class="string">        Notes:</span></span><br><span class="line"><span class="string">            - Initialize with k-means</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        (n_samples, n_features) = X.shape</span><br><span class="line"></span><br><span class="line">        <span class="comment"># initialize with k-means</span></span><br><span class="line">        clf = KMeans(n_clusters=self.n_clusters)</span><br><span class="line">        clf.fit(X)</span><br><span class="line">        self.mu = clf.cluster_centers_ </span><br><span class="line">        self.prior = np.zeros(self.n_clusters)</span><br><span class="line">        self.sigma = np.zeros((self.n_clusters, n_features, n_features))</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(self.n_clusters):</span><br><span class="line">            X_ = X[clf.labels_==k]</span><br><span class="line">            self.prior[k] = X_.shape[<span class="number">0</span>] / X_.shape[<span class="number">0</span>]</span><br><span class="line">            self.sigma[k] = np.cov(X_.T)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            mu_ = self.mu.copy()</span><br><span class="line">            <span class="comment"># E-step: updata gamma</span></span><br><span class="line">            gamma = np.zeros((n_samples, self.n_clusters))</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n_samples):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(self.n_clusters):</span><br><span class="line">                    denominator = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> range(self.n_clusters):</span><br><span class="line">                        post = self.prior[k] *\</span><br><span class="line">                                    multiGaussian(X[i], self.mu[j], self.sigma[j])</span><br><span class="line">                        denominator += post</span><br><span class="line">                        <span class="keyword">if</span> j==k: numerator = post</span><br><span class="line">                    gamma[i, k] = numerator/denominator</span><br><span class="line">            <span class="comment"># M-step: updata prior, mu, sigma</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(self.n_clusters):</span><br><span class="line">                sum1 = <span class="number">0</span></span><br><span class="line">                sum2 = <span class="number">0</span></span><br><span class="line">                sum3 = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(n_samples):</span><br><span class="line">                    sum1 += gamma[i, k]</span><br><span class="line">                    sum2 += gamma[i, k] * X[i]</span><br><span class="line">                    x_ = np.reshape(X[i] - self.mu[k], (n_features, <span class="number">1</span>))</span><br><span class="line">                    sum3 += gamma[i, k] * x_.dot(x_.T)</span><br><span class="line">                self.prior[k]  = sum1 / n_samples</span><br><span class="line">                self.mu[k]     = sum2 / sum1</span><br><span class="line">                self.sigma[k]  = sum3 / sum1</span><br><span class="line">            <span class="comment"># to stop</span></span><br><span class="line">            mu_delta = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(self.n_clusters):</span><br><span class="line">                mu_delta += nl.norm(self.mu[k] - mu_[k])</span><br><span class="line">            print(mu_delta)</span><br><span class="line">            <span class="keyword">if</span> mu_delta &lt; delta: <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> self.prior, self.mu, self.sigma</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict_proba</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            X &#123;ndarray(n_samples, n_features)&#125;</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            y_pred_proba &#123;ndarray(n_samples, n_clusters)&#125;</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        (n_samples, n_features) = X.shape</span><br><span class="line">        y_pred_proba = np.zeros((n_samples, self.n_clusters))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n_samples):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(self.n_clusters):</span><br><span class="line">                y_pred_proba[i, k] = self.prior[k] *\</span><br><span class="line">                                multiGaussian(X[i], self.mu[k], self.sigma[k])</span><br><span class="line">        <span class="keyword">return</span> y_pred_proba</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            X &#123;ndarray(n_samples, n_features)&#125;</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            y_pred_proba &#123;ndarray(n_samples,)&#125;</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        y_pred_proba = self.predict_proba(X)</span><br><span class="line">        <span class="keyword">return</span> np.argmax(y_pred_proba, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Data Augmentation</title>
      <link href="/2018/11/02/Data-Augmentation/"/>
      <url>/2018/11/02/Data-Augmentation/</url>
      
        <content type="html"><![CDATA[<blockquote><p>“有时候不是由于算法好赢了。而是由于拥有很多其它的数据才赢了。”</p></blockquote><h1 id="数据集扩增"><a href="#数据集扩增" class="headerlink" title="数据集扩增"></a>数据集扩增</h1><p>在深度学习中,很多训练数据意味着能够用更深的网络，训练出更好的模型。既然这样，收集很多其它的数据不即可啦？假设能够收集很多其它能够用的数据当然好，比如<a href="http://www.image-net.org/" target="_blank" rel="noopener">ImageNet</a>上图像数据量已达到$1400$万张，可是非常多时候，收集很多其它的数据意味着须要耗费很多其它的人力物力，这就需要使用一定的方法扩增数据集。</p><h1 id="图像扩增"><a href="#图像扩增" class="headerlink" title="图像扩增"></a>图像扩增</h1><p>大部分借助<code>OpenCV</code>库，这里推荐一位学长的博客，整理了大量的<code>OpenCV</code>使用方法.</p><blockquote><p><a href="http://ex2tron.wang/" target="_blank" rel="noopener">Ex2tron’s Blog</a></p></blockquote><p><code>TensorFlow</code>也提供相应图像处理方法<br><a href="https://tensorflow.google.cn/api_docs/python/tf/image" target="_blank" rel="noopener">Module: tf.image | TensorFlow </a></p><p>需要注意的是，扩增过程中，需注意图像数据类型，可以将数据归一化到$(0, 1)$间再进行处理</p><h2 id="翻转"><a href="#翻转" class="headerlink" title="翻转"></a>翻转</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flip</span><span class="params">(image)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">        image &#123;ndarray(H, W, C)&#125;</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    rand_var = np.random.random()</span><br><span class="line">    image = image[:, ::<span class="number">-1</span>, :] <span class="keyword">if</span> rand_var &gt; <span class="number">0.5</span> <span class="keyword">else</span> image</span><br><span class="line">    <span class="keyword">return</span> image</span><br></pre></td></tr></table></figure><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(image, degree)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">        image &#123;ndarray(H, W, C)&#125;</span></span><br><span class="line"><span class="string">        degree &#123;float&#125;</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    (h, w) = image.shape[:<span class="number">2</span>]</span><br><span class="line">    center = (w // <span class="number">2</span>, h // <span class="number">2</span>)</span><br><span class="line">    random_angel = np.random.randint(-degree, degree)</span><br><span class="line">    M = cv2.getRotationMatrix2D(center, random_angel, <span class="number">1.0</span>)</span><br><span class="line">    image = cv2.warpAffine(image, M, (w, h))</span><br><span class="line">    <span class="keyword">return</span> image</span><br></pre></td></tr></table></figure><h2 id="噪声"><a href="#噪声" class="headerlink" title="噪声"></a>噪声</h2><p>可手动实现，如椒盐噪声代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">saltnoise</span><span class="params">(image, salt=<span class="number">0.0</span>)</span>:</span></span><br><span class="line">    <span class="string">""" add salt &amp; pepper and gaussian noise</span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">        image &#123;ndarray(H, W, C)&#125;</span></span><br><span class="line"><span class="string">        salt &#123;float(0, 1)&#125; number of salt pixel = salt*h*w</span></span><br><span class="line"><span class="string">    Notes:</span></span><br><span class="line"><span class="string">        TODO: gaussain noise</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    (h, w) = image.shape[:<span class="number">2</span>]</span><br><span class="line">    n_salt = int(salt * h * w)</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> range(n_salt):</span><br><span class="line">        hr = np.random.randint(<span class="number">0</span>, h)</span><br><span class="line">        wr = np.random.randint(<span class="number">0</span>, w)</span><br><span class="line">        issalt = (np.random.rand(<span class="number">1</span>) &gt; <span class="number">0.5</span>)</span><br><span class="line">        image[hr, wr] = <span class="number">255</span> <span class="keyword">if</span> issalt <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> image</span><br></pre></td></tr></table></figure></p><p>也可调用<code>scikit-image</code>库，需要注意的是，<code>skimage.util.random_noise()</code>会将原图数据转换为$(0, 1)$间的浮点数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">noise</span><span class="params">(image, gaussian, salt, seed=None)</span>:</span></span><br><span class="line">    <span class="string">""" add noise to image TODO</span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">        image &#123;ndarray(H, W, C)&#125;</span></span><br><span class="line"><span class="string">        gaussian &#123;bool&#125;: </span></span><br><span class="line"><span class="string">        salt &#123;bool&#125;: </span></span><br><span class="line"><span class="string">    Notes:</span></span><br><span class="line"><span class="string">        Function to add random noise of various types to a floating-point image.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    dtype = image.dtype</span><br><span class="line">    <span class="keyword">if</span> gaussian:</span><br><span class="line">        image = skimage.util.random_noise(image, mode=<span class="string">'gaussian'</span>, seed=seed)</span><br><span class="line">    <span class="keyword">if</span> salt:</span><br><span class="line">        image = skimage.util.random_noise(image, mode=<span class="string">'s&amp;p'</span>, seed=seed)</span><br><span class="line"></span><br><span class="line">    image = (image * <span class="number">255</span>).astype(dtype)</span><br><span class="line">    <span class="keyword">return</span> image</span><br></pre></td></tr></table></figure></p><h2 id="亮度与对比度调整"><a href="#亮度与对比度调整" class="headerlink" title="亮度与对比度调整"></a>亮度与对比度调整</h2><p>考虑到数据溢出，先转换为整形数据，再限制其值到$[0, 255]$</p><blockquote><p>注意数据类型</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">brightcontrast</span><span class="params">(image, brtadj=<span class="number">0</span>, cstadj=<span class="number">1.0</span>)</span>:</span></span><br><span class="line">    <span class="string">""" adjust bright and contrast value</span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">        image &#123;ndarray(H, W, C)&#125;</span></span><br><span class="line"><span class="string">        brtadj &#123;int&#125;    if true, adjust bright</span></span><br><span class="line"><span class="string">        cstadj &#123;float&#125;  if true, adjust contrast</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    dtype = image.dtype</span><br><span class="line">    image = image.astype(<span class="string">'int'</span>)*cstadj + brtadj</span><br><span class="line">    image = np.clip(image, <span class="number">0</span>, <span class="number">255</span>).astype(dtype)</span><br><span class="line">    <span class="keyword">return</span> image</span><br></pre></td></tr></table></figure><h2 id="投射变换"><a href="#投射变换" class="headerlink" title="投射变换"></a>投射变换</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">perspective</span><span class="params">(image, prop)</span>:</span></span><br><span class="line">    <span class="string">""" 透射变换</span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">        image &#123;ndarray(H, W, C)&#125;</span></span><br><span class="line"><span class="string">        prop &#123;float&#125;: 在四个顶点多大的方格内选取新顶点，方格大小为(H*prop, W*prop)</span></span><br><span class="line"><span class="string">    Notes:</span></span><br><span class="line"><span class="string">        在四个顶点周围随机选取新的点进行仿射变换，四个点对应左上、右上、左下、右下</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    (h, w) = image.shape[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    ptsrc = np.zeros(shape=(<span class="number">4</span>, <span class="number">2</span>))</span><br><span class="line">    ptdst = np.array([[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, w], [h, <span class="number">0</span>], [h, w]])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        hr = np.random.randint(<span class="number">0</span>, int(h*prop))</span><br><span class="line">        wr = np.random.randint(<span class="number">0</span>, int(w*prop))</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            ptsrc[i] = np.array([hr, wr])</span><br><span class="line">        <span class="keyword">elif</span> i == <span class="number">1</span>:</span><br><span class="line">            ptsrc[i] = np.array([hr, w - wr])</span><br><span class="line">        <span class="keyword">elif</span> i == <span class="number">2</span>:</span><br><span class="line">            ptsrc[i] = np.array([h - hr, wr])</span><br><span class="line">        <span class="keyword">elif</span> i == <span class="number">3</span>:</span><br><span class="line">            ptsrc[i] = np.array([h - hr, w - wr])</span><br><span class="line">    M = cv2.getPerspectiveTransform(ptsrc.astype(<span class="string">'float32'</span>), ptdst.astype(<span class="string">'float32'</span>))</span><br><span class="line">    image = cv2.warpPerspective(image, M, (w, h))</span><br><span class="line">    <span class="keyword">return</span> image</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二次入坑raspberry-pi</title>
      <link href="/2018/10/29/%E4%BA%8C%E6%AC%A1%E5%85%A5%E5%9D%91raspberry-pi/"/>
      <url>/2018/10/29/%E4%BA%8C%E6%AC%A1%E5%85%A5%E5%9D%91raspberry-pi/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>距上一次搭建树莓派平台已经两年了，保存的镜像出了问题，重新搭建一下。</p><h1 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>从官网下载树莓派系统镜像，有以下几种可选</p><blockquote><p><a href="https://www.raspberrypi.org/" target="_blank" rel="noopener">Raspberry Pi — Teach, Learn, and Make with Raspberry Pi </a></p><ol><li>Raspbian &amp; Raspbian Lite，基于Debian</li><li>Noobs &amp; Noobs Lite</li><li>Ubuntu MATE</li><li>Snappy Ubuntu Core</li><li>Windows 10 IOT</li></ol></blockquote><p><del>其余不太了解，之前安装的是Raspbian，对于Debian各种不适，换上界面优雅的Ubuntu Mate玩一下</del><br>老老实实玩Raspbian，笑脸:-)</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>比较简单，准备micro-SD卡，用Win32 Disk Imager烧写镜像</p><blockquote><p><a href="https://sourceforge.net/projects/win32diskimager/" target="_blank" rel="noopener">Win32 Disk Imager download | SourceForge.net</a></p><p><img src="/2018/10/29/%E4%BA%8C%E6%AC%A1%E5%85%A5%E5%9D%91raspberry-pi/二次入坑raspberry-pi/Win32DiskImager.jpg" alt="Win32DiskImager"></p></blockquote><p>安装完软件后可点击<code>Read</code>备份自己的镜像。</p><p>注意第二次开机前需要配置<code>config.txt</code>文件，否则<code>hdmi</code>无法显示</p><blockquote><p><a href="http://shumeipai.nxez.com/2015/11/23/raspberry-pi-configuration-file-config-txt-nstructions.html" target="_blank" rel="noopener">树莓派配置文档 config.txt 说明 | 树莓派实验室</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">disable_overscan&#x3D;1 </span><br><span class="line">hdmi_force_hotplug&#x3D;1</span><br><span class="line">hdmi_group&#x3D;2    # DMT</span><br><span class="line">hdmi_mode&#x3D;32    # 1280x960</span><br><span class="line">hdmi_drive&#x3D;2</span><br><span class="line">config_hdmi_boost&#x3D;4</span><br></pre></td></tr></table></figure><h2 id="修改交换分区"><a href="#修改交换分区" class="headerlink" title="修改交换分区"></a>修改交换分区</h2><h3 id="Ubuntu-Mate"><a href="#Ubuntu-Mate" class="headerlink" title="Ubuntu Mate"></a>Ubuntu Mate</h3><p>查看交换分区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ free -m</span><br></pre></td></tr></table></figure></p><p>未设置时如下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">total     used     free   shared  buffers   cached</span><br><span class="line">Mem:           435       56      379        0        3       16</span><br><span class="line">-/+ buffers/cache:       35      399</span><br><span class="line">Swap:            0        0        0</span><br></pre></td></tr></table></figure></p><p>创建和挂载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 获取权限</span><br><span class="line">$ sudo -i</span><br><span class="line"></span><br><span class="line"># 创建目录</span><br><span class="line">$ mkdir &#x2F;swap</span><br><span class="line">$ cd &#x2F;swap</span><br><span class="line"></span><br><span class="line"># 指定一个大小为1G的名为“swap”的交换文件</span><br><span class="line">$ dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;swap bs&#x3D;1M count&#x3D;1k</span><br><span class="line"># 创建交换文件</span><br><span class="line">$ mkswap swap</span><br><span class="line"># 挂载交换分区</span><br><span class="line">$ swapon swap</span><br><span class="line"></span><br><span class="line"># 卸载交换分区</span><br><span class="line"># $ swapoff swap</span><br></pre></td></tr></table></figure></p><p>查看交换分区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ free -m</span><br></pre></td></tr></table></figure></p><p>未设置时如下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">total     used     free   shared  buffers   cached</span><br><span class="line">Mem:           435       56      379        0        3       16</span><br><span class="line">-/+ buffers/cache:       35      399</span><br><span class="line">Swap:         1023        0     1023</span><br></pre></td></tr></table></figure></p><h3 id="Raspbian"><a href="#Raspbian" class="headerlink" title="Raspbian"></a>Raspbian</h3><p>We will change the configuration in the file <code>/etc/dphys-swapfile</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo nano &#x2F;etc&#x2F;dphys-swapfile</span><br></pre></td></tr></table></figure></p><p>The default value in Raspbian is:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONF_SWAPSIZE&#x3D;100</span><br></pre></td></tr></table></figure></p><p>We will need to change this to:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONF_SWAPSIZE&#x3D;1024</span><br></pre></td></tr></table></figure></p><p>Then you will need to stop and start the service that manages the swapfile own Rasbian:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo &#x2F;etc&#x2F;init.d&#x2F;dphys-swapfile stop</span><br><span class="line">$ sudo &#x2F;etc&#x2F;init.d&#x2F;dphys-swapfile start</span><br></pre></td></tr></table></figure></p><p>You can then verify the amount of memory + swap by issuing the following command:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ free -m</span><br></pre></td></tr></table></figure></p><p>The output should look like:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">total     used     free   shared  buffers   cached</span><br><span class="line">Mem:           435       56      379        0        3       16</span><br><span class="line">-/+ buffers/cache:       35      399</span><br><span class="line">Swap:         1023        0     1023</span><br></pre></td></tr></table></figure></p><h1 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h1><h2 id="安装指令"><a href="#安装指令" class="headerlink" title="安装指令"></a>安装指令</h2><ul><li><p><code>apt-get</code></p><ul><li>安装软件<br><code>apt-get install softname1 softname2 softname3 ...</code></li><li>卸载软件<br><code>apt-get remove softname1 softname2 softname3 ...</code></li><li>卸载并清除配置<br><code>apt-get remove --purge softname1</code></li><li>更新软件信息数据库<br><code>apt-get update</code></li><li>进行系统升级<br><code>apt-get upgrade</code></li><li>搜索软件包<br><code>apt-cache search softname1 softname2 softname3 ...</code></li><li>修正（依赖关系）安装：<br><code>apt-get -f insta</code></li></ul></li><li><p><code>dpkg</code></p><ul><li>安装<code>.deb</code>软件包<br><code>dpkg -i xxx.deb</code></li><li>删除软件包<br><code>dpkg -r xxx.deb</code></li><li>连同配置文件一起删除<br><code>dpkg -r --purge xxx.deb</code></li><li>查看软件包信息<br><code>dpkg -info xxx.deb</code></li><li>查看文件拷贝详情<br><code>dpkg -L xxx.deb</code></li><li>查看系统中已安装软件包信息<br><code>dpkg -l</code></li><li><p>重新配置软件包<br><code>dpkg-reconfigure xx</code></p></li><li><p>卸载软件包及其配置文件，但无法解决依赖关系！<br><code>sudo dpkg -p package_name</code></p></li><li>卸载软件包及其配置文件与依赖关系包<br><code>sudo aptitude purge pkgname</code></li><li>清除所有已删除包的残馀配置文件<br><code>dpkg -l |grep ^rc|awk &#39;{print $2}&#39; |sudo xargs dpkg -P</code></li></ul></li></ul><h2 id="软件源"><a href="#软件源" class="headerlink" title="软件源"></a>软件源</h2><ol><li>备份原始文件 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cp &#x2F;etc&#x2F;apt&#x2F;sources.list &#x2F;etc&#x2F;apt&#x2F;sources.list.backup</span><br></pre></td></tr></table></figure></li><li>修改文件并添加国内源 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi &#x2F;etc&#x2F;apt&#x2F;sources.list</span><br></pre></td></tr></table></figure></li><li><p>注释元文件内的源并添加如下地址</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#Mirror.lupaworld.com 源更新服务器（浙江省杭州市双线服务器，网通同电信都可以用，亚洲地区官方更新服务器）：</span><br><span class="line">deb http:&#x2F;&#x2F;mirror.lupaworld.com&#x2F;ubuntu gutsy main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirror.lupaworld.com&#x2F;ubuntu gutsy-security main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirror.lupaworld.com&#x2F;ubuntu gutsy-updates main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirror.lupaworld.com&#x2F;ubuntu gutsy-backports main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirror.lupaworld.com&#x2F;ubuntu gutsy main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirror.lupaworld.com&#x2F;ubuntu gutsy-security main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirror.lupaworld.com&#x2F;ubuntu gutsy-updates main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirror.lupaworld.com&#x2F;ubuntu gutsy-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">#Ubuntu 官方源 </span><br><span class="line">deb http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F; gutsy main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F; gutsy-security main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F; gutsy-updates main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F; gutsy-proposed main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F; gutsy-backports main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F; gutsy main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F; gutsy-security main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F; gutsy-updates main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F; gutsy-proposed main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F; gutsy-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure><p> 或者</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#阿里云</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-security main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-updates main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-proposed main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-backports main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-security main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-updates main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-proposed main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">#网易163</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; trusty main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; trusty-security main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; trusty-updates main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; trusty-proposed main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; trusty-backports main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; trusty main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; trusty-security main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; trusty-updates main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; trusty-proposed main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; trusty-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure></li><li><p>放置非官方源的包不完整，可在为不添加官方源</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deb http:&#x2F;&#x2F;archive.ubuntu.org.cn&#x2F;ubuntu-cn&#x2F; feisty main restricted universe multiverse</span><br></pre></td></tr></table></figure></li><li>更新源 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br></pre></td></tr></table></figure></li><li>更新软件 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get dist-upgrade</span><br></pre></td></tr></table></figure></li><li>常见的修复安装命令 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get -f install</span><br></pre></td></tr></table></figure></li></ol><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>主要是<code>Python</code>和相关依赖包的安装，使用以下指令可导出已安装的依赖包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure></p><p>并使用指令安装到树莓派<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install -r requirements.txt</span><br></pre></td></tr></table></figure></p><p>注意<code>pip</code>更新<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install --upgrade pip</span><br></pre></td></tr></table></figure></p><p>最新版本会报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImportError: cannot import name main</span><br></pre></td></tr></table></figure></p><p>修改文件<code>/usr/bin/pip</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pip <span class="keyword">import</span> main</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    sys.exit(main())</span><br></pre></td></tr></table></figure></p><p>改为<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pip <span class="keyword">import</span> __main__</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    sys.exit(__main__._main())</span><br></pre></td></tr></table></figure></p><hr><p><del>成功!!!</del><br>失败了，笑脸:-)，手动安装吧。。。</p><ul><li><p>部分包可使用<code>pip3</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ pip3 install numpy</span><br><span class="line">$ pip3 install pandas</span><br><span class="line">$ pip3 install sklearn</span><br></pre></td></tr></table></figure><blockquote><p>若需要权限，加入<code>--user</code></p></blockquote></li><li><p>部分包用<code>apt-get</code>，但是优先安装到<code>Python2.7</code>版本，笑脸:-)</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install python-scipy</span><br><span class="line">$ sudo apt-get install python-matplotlib</span><br><span class="line">$ sudo apt-get install python-opencv</span><br></pre></td></tr></table></figure></li><li><p>部分从<code>PIPY</code>下载<code>.whl</code>或<code>.tar.gz</code>文件</p><blockquote><p><a href="https://pypi.org/" target="_blank" rel="noopener">PyPI – the Python Package Index · PyPI</a></p><ul><li>tensorboardX-1.4-py2.py3-none-any.whl</li><li>visdom-0.1.8.5.tar.gz</li></ul></blockquote><p>  安装指令为</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip3 install xxx.whl</span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zxvf xxx.tar.gz</span><br><span class="line">$ python setup.py install</span><br></pre></td></tr></table></figure></li><li><p><code>Pytorch</code>源码安装</p><blockquote><p><a href="https://github.com/pytorch/pytorch" target="_blank" rel="noopener">pytorch/pytorch: Tensors and Dynamic neural networks in Python with strong GPU acceleration </a></p></blockquote><p>  安装方法<a href="https://github.com/pytorch/pytorch#from-source" target="_blank" rel="noopener">Installation - From Source</a></p><p>  需要用到<code>miniconda</code>，安装方法如下，注意中间回车按慢一点，有两次输入。。。。。(行我慢慢看条款不行么。。笑脸:-))</p><ul><li>第一次是是否同意条款，<code>yes</code></li><li><p>第二次是添加到环境变量，<code>yes</code>，否则自己修改<code>/home/pi/.bashrc</code>添加到环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ wget http:&#x2F;&#x2F;repo.continuum.io&#x2F;miniconda&#x2F;Miniconda3-latest-Linux-armv7l.sh</span><br><span class="line">$ sudo md5sum Miniconda3-latest-Linux-armv7l.sh # (optional) check md5</span><br><span class="line">$ sudo &#x2F;bin&#x2F;bash Miniconda3-latest-Linux-armv7l.sh </span><br><span class="line"># -&gt; change default directory to &#x2F;home&#x2F;pi&#x2F;miniconda3</span><br><span class="line">$ sudo nano &#x2F;home&#x2F;pi&#x2F;.bashrc </span><br><span class="line"># -&gt; add: export PATH&#x3D;&quot;&#x2F;home&#x2F;pi&#x2F;miniconda3&#x2F;bin:$PATH&quot;</span><br><span class="line">$ sudo reboot -h now</span><br><span class="line"></span><br><span class="line">$ conda </span><br><span class="line">$ python --version</span><br><span class="line">$ sudo chown -R pi miniconda3</span><br></pre></td></tr></table></figure><p><del>然后就可以安装了</del>没有对应版本的<code>mkl</code>，笑脸:-)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">export CMAKE_PREFIX_PATH&#x3D;&quot;$(dirname $(which conda))&#x2F;..&#x2F;&quot; # [anaconda root directory]</span><br><span class="line"></span><br><span class="line"># Disable CUDA</span><br><span class="line">export NO_CUDA&#x3D;1</span><br><span class="line"></span><br><span class="line"># Install basic dependencies</span><br><span class="line">conda install numpy pyyaml mkl mkl-include setuptools cmake cffi typing</span><br><span class="line">conda install -c mingfeima mkldnn</span><br><span class="line"></span><br><span class="line"># Install Pytorch</span><br><span class="line">git clone --recursive https:&#x2F;&#x2F;github.com&#x2F;pytorch&#x2F;pytorch</span><br><span class="line">cd pytorch</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>tensorflow</code><br>  安装tensorflow需要的一些依赖和工具</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line"># For Python 2.7</span><br><span class="line">$ sudo apt-get install python-pip python-dev</span><br><span class="line"></span><br><span class="line"># For Python 3.3+</span><br><span class="line">$ sudo apt-get install python3-pip python3-dev</span><br></pre></td></tr></table></figure><p>  安装<code>tensorflow</code></p><blockquote><p>若下载失败，手动打开下面网页下载<code>.whl</code>包</p></blockquote>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># For Python 2.7</span><br><span class="line">$ wget https:&#x2F;&#x2F;github.com&#x2F;samjabrahams&#x2F;tensorflow-on-raspberry-pi&#x2F;releases&#x2F;download&#x2F;v1.1.0&#x2F;tensorflow-1.1.0-cp27-none-linux_armv7l.whl</span><br><span class="line">$ sudo pip install tensorflow-1.1.0-cp27-none-linux_armv7l.whl</span><br><span class="line"></span><br><span class="line"># For Python 3.4</span><br><span class="line">$ wget https:&#x2F;&#x2F;github.com&#x2F;samjabrahams&#x2F;tensorflow-on-raspberry-pi&#x2F;releases&#x2F;download&#x2F;v1.1.0&#x2F;tensorflow-1.1.0-cp34-cp34m-linux_armv7l.whl</span><br><span class="line">$ sudo pip3 install tensorflow-1.1.0-cp34-cp34m-linux_armv7l.whl</span><br></pre></td></tr></table></figure><p>  卸载，重装mock</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># For Python 2.7</span><br><span class="line">$ sudo pip uninstall mock</span><br><span class="line">$ sudo pip install mock</span><br><span class="line"></span><br><span class="line"># For Python 3.3+</span><br><span class="line">$ sudo pip3 uninstall mock</span><br><span class="line">$ sudo pip3 install mock</span><br></pre></td></tr></table></figure><p>  安装的版本<code>tensorflow v1.1.0</code>没有<code>models</code>，因为1.0版本以后models就被<code>Sam Abrahams</code>独立出来了，例如<code>classify_image.py</code>就在<code>models/tutorials/image/imagenet/</code>里</p><blockquote><p><a href="https://github.com/tensorflow/models" target="_blank" rel="noopener">tensorflow/models</a></p></blockquote></li></ul><h2 id="其余"><a href="#其余" class="headerlink" title="其余"></a>其余</h2><ol><li>输入法 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install fcitx fcitx-googlepinyin </span><br><span class="line">$ fcitx-module-cloudpinyin fcitx-sunpinyin</span><br></pre></td></tr></table></figure></li><li><p><code>git</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install git</span><br></pre></td></tr></table></figure><p>配置<code>git</code>和<code>ssh</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Louis Hsu&quot;</span><br><span class="line">$ git config --global user.email is.louishsu@foxmail.com</span><br><span class="line"></span><br><span class="line">$ ssh-keygen -t rsa -C &quot;is.louishsu@foxmail.com&quot;</span><br><span class="line">$ cat ~&#x2F;.ssh&#x2F;id_rsa.pub  # 添加到github</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Underfitting &amp; Overfitting</title>
      <link href="/2018/10/26/Underfitting-Overfitting/"/>
      <url>/2018/10/26/Underfitting-Overfitting/</url>
      
        <content type="html"><![CDATA[<h1 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h1><p>放上一张非常经典的图，以下分别表示二分类模型中的欠拟合(underfit)、恰好(just right)、过拟合(overfit)，来自吴恩达课程笔记。<br><img src="/2018/10/26/Underfitting-Overfitting/underfit_justright_overfit.png" alt="underfit_justright_overfit"></p><ul><li>欠拟合的成因大多是模型不够复杂、拟合函数的能力不够；</li><li>过拟合成因是给定的数据集相对过于简单，使得模型在拟合函数时过分地考虑了噪声等不必要的数据间的关联，或者说相对于给定数据集，模型过于复杂、拟合能力过强。</li></ul><h1 id="判别方法"><a href="#判别方法" class="headerlink" title="判别方法"></a>判别方法</h1><h2 id="学习曲线"><a href="#学习曲线" class="headerlink" title="学习曲线"></a>学习曲线</h2><p>可通过学习曲线<code>(Learning curve)</code>进行欠拟合与过拟合的判别。</p><p>学习曲线就是通过画出<strong>不同训练集大小</strong>时训练集和交叉验证的准确率，可以看到模型在新数据上的表现，进而来判断模型是否方差偏高或偏差过高，以及增大训练集是否可以减小过拟合。</p><h2 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h2><p>横轴为训练样本的数量，纵轴为损失或其他<a href="">评估准则</a>。<br><code>sklearn</code>中学习曲线绘制例程如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> GaussianNB</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_digits</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> learning_curve</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> ShuffleSplit</span><br><span class="line"></span><br><span class="line">digits = load_digits(); X, y = digits.data, digits.target</span><br><span class="line"></span><br><span class="line">cv = ShuffleSplit(n_splits=<span class="number">100</span>, test_size=<span class="number">0.2</span>, random_state=<span class="number">0</span>)</span><br><span class="line">estimator = GaussianNB()</span><br><span class="line">train_sizes, train_scores, test_scores = learning_curve(</span><br><span class="line">        estimator, X, y, cv=cv, n_jobs=<span class="number">4</span>, train_sizes=np.linspace(<span class="number">.1</span>, <span class="number">1.0</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.title(<span class="string">"Learning Curves (Naive Bayes)"</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Training examples"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Score"</span>)</span><br><span class="line"></span><br><span class="line">train_scores_mean = np.mean(train_scores, axis=<span class="number">1</span>)</span><br><span class="line">train_scores_std = np.std(train_scores, axis=<span class="number">1</span>)</span><br><span class="line">test_scores_mean = np.mean(test_scores, axis=<span class="number">1</span>)</span><br><span class="line">test_scores_std = np.std(test_scores, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">plt.fill_between(train_sizes, </span><br><span class="line">                train_scores_mean - train_scores_std,</span><br><span class="line">                train_scores_mean + train_scores_std,</span><br><span class="line">                alpha=<span class="number">0.1</span>, color=<span class="string">"r"</span>)</span><br><span class="line">plt.fill_between(train_sizes,</span><br><span class="line">                test_scores_mean - test_scores_std,</span><br><span class="line">                test_scores_mean + test_scores_std,</span><br><span class="line">                alpha=<span class="number">0.1</span>, color=<span class="string">"g"</span>)</span><br><span class="line">plt.plot(train_sizes, train_scores_mean, <span class="string">'o-'</span>, color=<span class="string">"r"</span>, label=<span class="string">"Training score"</span>)</span><br><span class="line">plt.plot(train_sizes, test_scores_mean,  <span class="string">'o-'</span>, color=<span class="string">"g"</span>, label=<span class="string">"Cross-validation score"</span>)</span><br><span class="line"></span><br><span class="line">plt.grid(); plt.legend(loc=<span class="string">"best"</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/26/Underfitting-Overfitting/learning_curve_nb.png" alt="learning_curve_nb"></p><h2 id="判别"><a href="#判别" class="headerlink" title="判别"></a>判别</h2><ul><li><strong>欠拟合</strong>，即高偏差<code>(high bias)</code>，训练集和测试集的误差收敛但却很高；</li><li><strong>过拟合</strong>，即高方差<code>(high variance)</code>，训练集和测试集的误差之间有大的差距。</li></ul><p><img src="/2018/10/26/Underfitting-Overfitting/learning_curve.png" alt="learning_curve"></p><h1 id="欠拟合解决方法"><a href="#欠拟合解决方法" class="headerlink" title="欠拟合解决方法"></a>欠拟合解决方法</h1><ul><li>增加迭代次数继续训练</li><li>增加模型复杂度</li><li>增加特征</li><li>减少正则化程度</li><li>采用Boosting等集成方法</li></ul><p>此时增加数据集并不能改善欠拟合问题。</p><h1 id="过拟合解决方法"><a href="#过拟合解决方法" class="headerlink" title="过拟合解决方法"></a>过拟合解决方法</h1><ul><li>提前停止训练</li><li>获取更多样本或数据扩增<ul><li>重采样</li><li>上采样</li><li>增加随机噪声</li><li><code>GAN</code></li><li>图像数据的空间变换（平移旋转镜像）</li><li>尺度变换（缩放裁剪）</li><li>颜色变换</li><li>改变分辨率</li><li>对比度</li><li>亮度</li></ul></li><li>降低模型复杂度</li><li>减少特征</li><li>增加正则化程度</li><li>神经网络可采用<code>Dropout</code></li><li>多模型投票方法</li></ul>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Cross Validation &amp; Hyperparameter</title>
      <link href="/2018/10/26/Cross-Validation-Hyperparameter/"/>
      <url>/2018/10/26/Cross-Validation-Hyperparameter/</url>
      
        <content type="html"><![CDATA[<h1 id="交叉验证与超参数选择"><a href="#交叉验证与超参数选择" class="headerlink" title="交叉验证与超参数选择"></a>交叉验证与超参数选择</h1><h2 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h2><p>以下简称交叉验证<code>(Cross Validation)</code>为<code>CV</code>.<code>CV</code>是用来验证分类器的性能一种统计分析方法,基本思想是把在某种意义下将原始数据<code>(dataset)</code>进行分组,一部分做为训练集<code>(train set)</code>,另一部分做为验证集<code>(validation set)</code>,首先用训练集对分类器进行训练,在利用验证集来测试训练得到的模型<code>(model)</code>,以此来做为评价分类器的性能指标。</p><h3 id="交叉验证的几种方法"><a href="#交叉验证的几种方法" class="headerlink" title="交叉验证的几种方法"></a>交叉验证的几种方法</h3><ul><li><p><strong>k折交叉验证(K-fold)</strong></p><ol><li>将全部训练集$S$分成$k$个不相交的子集，假设$S$中的训练样例个数为$m$，则每个子集中有$(\frac{m}{k})$个训练样例，相应子集称作${s_1, s_2, …, s_k}$；</li><li>每次从分好的子集中，拿出$1$个作为测试集，其他$k-1$个作为训练集；</li><li>在$k-1$个训练集上训练出学习器模型，将模型放到测试集上，得到分类率；</li><li>计算k次求得的分类率平均值，作为该模型或者假设函数的真实分类率<br><img src="/2018/10/26/Cross-Validation-Hyperparameter/k-fold.jpg" alt="k-fold"></li></ol></li><li><p><strong>留一法交叉验证(Leave One Out - LOO)</strong><br>  假设有$N$个样本，将每个样本作为测试样本，其他$(N-1)$个样本作为训练样本。这样得到$N$个分类器，$N$个测试结果。用这$N$个结果的平均值衡量模型的性能。</p></li><li><p><strong>留P法交叉验证(Leave P Out - LPO)</strong><br>  将$P$个样本作为测试样本，其他$(N-P)$个样本作为训练样本。这样得到$\left(\begin{matrix}</p><pre><code>  P \\ N</code></pre><p>  \end{matrix}\right)$个训练测试对。当$P＞1$时，测试集会发生重叠。当$P=1$时，变成$LOO$。<br>  <img src="/2018/10/26/Cross-Validation-Hyperparameter/LPO.jpg" alt="LPO"></p></li></ul><h3 id="scikit-learn中的交叉验证"><a href="#scikit-learn中的交叉验证" class="headerlink" title="scikit-learn中的交叉验证"></a><code>scikit-learn</code>中的交叉验证</h3><p><img src="/2018/10/26/Cross-Validation-Hyperparameter/cross_validation_sklearn.png" alt="cross_validation_sklearn"></p><ul><li><p><strong>K-fold</strong></p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; import numpy as np</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; from sklearn.model_selection import KFold</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; X = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; kf = KFold(n_splits=2)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="keyword">for</span> train, <span class="built_in">test</span> <span class="keyword">in</span> kf.split(X):</span></span><br><span class="line">... print("%s %s" % (train, test))</span><br><span class="line">[2 3] [0 1]</span><br><span class="line">[0 1] [2 3]</span><br></pre></td></tr></table></figure></li><li><p><strong>Leave One Out (LOO)</strong></p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; from sklearn.model_selection import LeaveOneOut</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; X = [1, 2, 3, 4]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; loo = LeaveOneOut()</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="keyword">for</span> train, <span class="built_in">test</span> <span class="keyword">in</span> loo.split(X):</span></span><br><span class="line">... print("%s %s" % (train, test))</span><br><span class="line">[1 2 3] [0]</span><br><span class="line">[0 2 3] [1]</span><br><span class="line">[0 1 3] [2]</span><br><span class="line">[0 1 2] [3]</span><br></pre></td></tr></table></figure></li><li><strong>Leave P Out (LPO)</strong>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; from sklearn.model_selection import LeavePOut</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; X = np.ones(4)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; lpo = LeavePOut(p=2)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="keyword">for</span> train, <span class="built_in">test</span> <span class="keyword">in</span> lpo.split(X):</span></span><br><span class="line">... print("%s %s" % (train, test))</span><br><span class="line">[2 3] [0 1]</span><br><span class="line">[1 3] [0 2]</span><br><span class="line">[1 2] [0 3]</span><br><span class="line">[0 3] [1 2]</span><br><span class="line">[0 2] [1 3]</span><br><span class="line">[0 1] [2 3]</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用交叉验证调整超参数"><a href="#使用交叉验证调整超参数" class="headerlink" title="使用交叉验证调整超参数"></a>使用交叉验证调整超参数</h2><p><strong>超参数</strong>：在机器学习的上下文中，超参数是在开始学习过程之前设置值的参数，而不是通过训练得到的参数数据。通常情况下，需要对超参数进行优化，给学习机选择一组最优超参数，以提高学习的性能和效果。<br>超参数例如</p><ul><li><strong>模型</strong>(<code>SVM</code>，<code>Softmax</code>，<code>Multi-layer Neural Network</code>,…)；</li><li><strong>迭代算法</strong>(<code>Adam</code>, <code>SGD</code>, …)(不同的迭代算法还有各种不同的超参数，如<code>beta1</code>,<code>beta2</code>等等，但常见的做法是使用默认值，不进行调参)；</li><li><strong>学习率</strong>(<code>learning rate</code>)；</li><li><strong>正则化方程的选择</strong>(<code>L0</code>,<code>L1</code>,<code>L2</code>)，正则化系数；</li><li><code>dropout</code>的概率</li><li>…</li></ul><h3 id="确定调节范围"><a href="#确定调节范围" class="headerlink" title="确定调节范围"></a>确定调节范围</h3><p>超参数的种类多，调节范围大，需要先进行简单的测试确定调参范围。</p><ul><li><p><strong>模型选择</strong><br>  模型的选择很大程度上取决于具体的实际问题，但必须通过几项基本测试。 </p><ul><li>可以通过<strong>第一个epoch的loss</strong>，观察模型能否无BUG运行，注意此过程需要设置正则项系数为0，因为正则项引入的loss难以估算。 </li><li>模型必须可以<strong>对于小数据集过拟合</strong>，否则应该尝试其他或者更复杂的模型。</li><li><p>若<strong>训练集与验证集loss均较大</strong>，则应该尝试其他或者更复杂的模型。</p><blockquote><p>模型选择的方法为：</p><ol><li>使用训练集训练出 10 个模型</li><li>用 10 个模型分别对交叉验证集计算得出交叉验证误差(代价函数的值)</li><li>选取代价函数值最小的模型</li><li>用步骤 3 中选出的模型对测试集计算得出推广误差(代价函数的值)<p align="right"> —— Andrew Ng, Stanford University </p></li></ol></blockquote></li></ul></li><li><p><strong>学习率</strong></p><ul><li>loss基本不变：学习率过低 </li><li>loss波动明显或者溢出：学习率过高 </li></ul></li><li><p><strong>正则项系数</strong></p><ul><li>val_acc与acc相差较大：正则项系数过小 </li><li>loss逐渐增大：正则项系数过大 </li></ul></li></ul><h3 id="超参数的确定"><a href="#超参数的确定" class="headerlink" title="超参数的确定"></a>超参数的确定</h3><ul><li><strong>先粗调，再细调</strong><br> 先通过数量少，间距大的粗调确定细调的大致范围。然后在小范围内部进行间距小，数量大的细调。</li><li><strong>尝试在对数空间内进行调节</strong><br>  即在对数空间内部随机生成测试参数，而不是在原空间生成，通常用于学习率以及正则项系数等的调节。出发点是该超参数的指数项对于模型的结果影响更显著；而同阶的数据之间即便原域相差较大，对于模型结果的影响反而不如不同阶的数据差距大。</li><li><strong>超参数搜索</strong><br>  随机搜索参数值，而不是网格搜索。</li></ul><h3 id="超参数搜索"><a href="#超参数搜索" class="headerlink" title="超参数搜索"></a>超参数搜索</h3><p><code>scikit-learn</code>提供超参数搜索方法，可参考官方文档</p><ul><li><p><strong>网格搜索</strong><br>  <a href="http://sklearn.apachecn.org/en/0.19.0/modules/grid_search.html#exhaustive-grid-search" target="_blank" rel="noopener">3.2.1. Exhaustive Grid Search</a><br>  调用例程如下</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> randint <span class="keyword">as</span> sp_randint</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> RandomizedSearchCV</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_digits</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"></span><br><span class="line"><span class="comment"># get some data</span></span><br><span class="line">digits = load_digits()</span><br><span class="line">X, y = digits.data, digits.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># build a classifier</span></span><br><span class="line">clf = RandomForestClassifier(n_estimators=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Utility function to report best scores</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">report</span><span class="params">(results, n_top=<span class="number">3</span>)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n_top + <span class="number">1</span>):</span><br><span class="line">        candidates = np.flatnonzero(results[<span class="string">'rank_test_score'</span>] == i)</span><br><span class="line">        <span class="keyword">for</span> candidate <span class="keyword">in</span> candidates:</span><br><span class="line">            print(<span class="string">"Model with rank: &#123;0&#125;"</span>.format(i))</span><br><span class="line">            print(<span class="string">"Mean validation score: &#123;0:.3f&#125; (std: &#123;1:.3f&#125;)"</span>.format(</span><br><span class="line">                results[<span class="string">'mean_test_score'</span>][candidate],</span><br><span class="line">                results[<span class="string">'std_test_score'</span>][candidate]))</span><br><span class="line">            print(<span class="string">"Parameters: &#123;0&#125;"</span>.format(results[<span class="string">'params'</span>][candidate]))</span><br><span class="line">            print(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># use a full grid over all parameters</span></span><br><span class="line">param_grid = &#123;<span class="string">"max_depth"</span>: [<span class="number">3</span>, <span class="keyword">None</span>],</span><br><span class="line">            <span class="string">"max_features"</span>: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>],</span><br><span class="line">            <span class="string">"min_samples_split"</span>: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>],</span><br><span class="line">            <span class="string">"min_samples_leaf"</span>: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>],</span><br><span class="line">            <span class="string">"bootstrap"</span>: [<span class="keyword">True</span>, <span class="keyword">False</span>],</span><br><span class="line">            <span class="string">"criterion"</span>: [<span class="string">"gini"</span>, <span class="string">"entropy"</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># run grid search</span></span><br><span class="line">grid_search = GridSearchCV(clf, param_grid=param_grid)</span><br><span class="line">start = time()</span><br><span class="line">grid_search.fit(X, y)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"GridSearchCV took %.2f seconds for %d candidate parameter settings."</span></span><br><span class="line">    % (time() - start, len(grid_search.cv_results_[<span class="string">'params'</span>])))</span><br><span class="line">report(grid_search.cv_results_)</span><br></pre></td></tr></table></figure></li><li><p><strong>随机搜索</strong><br>  <a href="http://sklearn.apachecn.org/en/0.19.0/modules/grid_search.html#randomized-parameter-optimization" target="_blank" rel="noopener">3.2.2. Randomized Parameter Optimization</a><br>  调用例程如下</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> randint <span class="keyword">as</span> sp_randint</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> RandomizedSearchCV</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_digits</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"></span><br><span class="line"><span class="comment"># get some data</span></span><br><span class="line">digits = load_digits()</span><br><span class="line">X, y = digits.data, digits.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># build a classifier</span></span><br><span class="line">clf = RandomForestClassifier(n_estimators=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Utility function to report best scores</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">report</span><span class="params">(results, n_top=<span class="number">3</span>)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n_top + <span class="number">1</span>):</span><br><span class="line">        candidates = np.flatnonzero(results[<span class="string">'rank_test_score'</span>] == i)</span><br><span class="line">        <span class="keyword">for</span> candidate <span class="keyword">in</span> candidates:</span><br><span class="line">            print(<span class="string">"Model with rank: &#123;0&#125;"</span>.format(i))</span><br><span class="line">            print(<span class="string">"Mean validation score: &#123;0:.3f&#125; (std: &#123;1:.3f&#125;)"</span>.format(</span><br><span class="line">                results[<span class="string">'mean_test_score'</span>][candidate],</span><br><span class="line">                results[<span class="string">'std_test_score'</span>][candidate]))</span><br><span class="line">            print(<span class="string">"Parameters: &#123;0&#125;"</span>.format(results[<span class="string">'params'</span>][candidate]))</span><br><span class="line">            print(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># specify parameters and distributions to sample from</span></span><br><span class="line">param_dist = &#123;<span class="string">"max_depth"</span>: [<span class="number">3</span>, <span class="keyword">None</span>],</span><br><span class="line">            <span class="string">"max_features"</span>: sp_randint(<span class="number">1</span>, <span class="number">11</span>),</span><br><span class="line">            <span class="string">"min_samples_split"</span>: sp_randint(<span class="number">2</span>, <span class="number">11</span>),</span><br><span class="line">            <span class="string">"min_samples_leaf"</span>: sp_randint(<span class="number">1</span>, <span class="number">11</span>),</span><br><span class="line">            <span class="string">"bootstrap"</span>: [<span class="keyword">True</span>, <span class="keyword">False</span>],</span><br><span class="line">            <span class="string">"criterion"</span>: [<span class="string">"gini"</span>, <span class="string">"entropy"</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># run randomized search</span></span><br><span class="line">n_iter_search = <span class="number">20</span></span><br><span class="line">random_search = RandomizedSearchCV(clf, param_distributions=param_dist,</span><br><span class="line">                                n_iter=n_iter_search)</span><br><span class="line"></span><br><span class="line">start = time()</span><br><span class="line">random_search.fit(X, y)</span><br><span class="line">print(<span class="string">"RandomizedSearchCV took %.2f seconds for %d candidates"</span></span><br><span class="line">    <span class="string">" parameter settings."</span> % ((time() - start), n_iter_search))</span><br><span class="line">report(random_search.cv_results_)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spam Classification</title>
      <link href="/2018/10/26/Spam-Classification/"/>
      <url>/2018/10/26/Spam-Classification/</url>
      
        <content type="html"><![CDATA[<blockquote><p>踩坑？？？全部给我踩平！！！</p></blockquote><p>来自<a href="https://www.lintcode.com/ai/spam-message-classification/overview" target="_blank" rel="noopener">LintCode垃圾短信分类</a><br><a href="https://github.com/isLouisHsu/Basic-Machine-Learning-Algorithm/tree/master/ZhaoHaitao%2C%20ECUST/spam%20or%20ham" target="_blank" rel="noopener">@Github: spam or ham</a></p><h1 id="垒代码"><a href="#垒代码" class="headerlink" title="垒代码"></a>垒代码</h1><h2 id="预处理及向量化"><a href="#预处理及向量化" class="headerlink" title="预处理及向量化"></a>预处理及向量化</h2><p>观察各文本后，发现各文本中包含的单词多种多样，包含标点、数字等，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- Go until jurong point, crazy.. Available only in bugis n great world la e buffet... Cine there got amore wat...</span><br><span class="line">- XXXMobileMovieClub: To use your credit, click the WAP link in the next txt message or click here&gt;&gt; http:&#x2F;&#x2F;wap. </span><br><span class="line">- 07732584351 - Rodger Burns - MSG &#x3D; We tried to call you re your reply to our sms for a free nokia mobile + free camcorder.</span><br></pre></td></tr></table></figure></p><p>且按空格分词后，部分单词中仍包含<code>whitespace</code>，故选择的预处理方案是，<strong>去除分词后文本中的标点、数字、空格等，并将单词中字母全部转为小写</strong>。</p><blockquote><p>中文分词可采用<code>jieba</code>(街霸？)</p></blockquote><p>预处理后，按当前的文本内容建立字典，并统计各样本的词数向量，详细代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Words2Vector</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    建立字典，将输入的词列表转换为向量，表示各词出现的次数</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.dict = <span class="keyword">None</span></span><br><span class="line">        self.n_word = <span class="keyword">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit_transform</span><span class="params">(self, words)</span>:</span></span><br><span class="line">        self.fit(words)</span><br><span class="line">        <span class="keyword">return</span> self.transform(words)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, words)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        @param &#123;list[list[str]]&#125; words</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        words = _flatten(words)                                                 <span class="comment"># 展开为1维列表</span></span><br><span class="line">        words = self.filt(words)                                                <span class="comment"># 滤除空格、数字、标点</span></span><br><span class="line"></span><br><span class="line">        self.word = list(set(words))                                            <span class="comment"># 去重</span></span><br><span class="line">        self.n_word = len(set(words))                                           <span class="comment"># 统计词的个数</span></span><br><span class="line">        self.dict = dict(zip(self.word, [_ <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.n_word)]))       <span class="comment"># 各词在字典中的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transform</span><span class="params">(self, words)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        @param &#123;list[list[str]]&#125; words</span></span><br><span class="line"><span class="string">        @return &#123;ndarray&#125; retarray: vector</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        retarray = np.zeros(shape=(len(words), self.n_word))                    <span class="comment"># 返回的词数向量</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(words)):</span><br><span class="line">            words[i] = self.filt(words[i])                                      <span class="comment"># 滤除空格、数字、标点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(words)):</span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> words[i]:</span><br><span class="line">                <span class="keyword">if</span> w <span class="keyword">in</span> self.word:                                              <span class="comment"># 是否在训练集生成的字典中</span></span><br><span class="line">                    retarray[i, self.dict[w]] += <span class="number">1</span>                              <span class="comment"># 查询字典，找到对应特征的下标</span></span><br><span class="line">        <span class="keyword">return</span> retarray</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">filt</span><span class="params">(self, flattenWords)</span>:</span></span><br><span class="line">        retWords = []</span><br><span class="line">        en_stops = set(stopwords.words(<span class="string">'english'</span>))                              <span class="comment"># 停用词列表</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> flattenWords:</span><br><span class="line">            word = word.translate(str.maketrans(<span class="string">''</span>, <span class="string">''</span>, string.whitespace))     <span class="comment"># 去除空白</span></span><br><span class="line">            word = word.translate(str.maketrans(<span class="string">''</span>, <span class="string">''</span>, string.punctuation))    <span class="comment"># 去除标点</span></span><br><span class="line">            word = word.translate(str.maketrans(<span class="string">''</span>, <span class="string">''</span>, string.digits))         <span class="comment"># 去除数字</span></span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> en_stops <span class="keyword">and</span> (len(word) &gt; <span class="number">1</span>):                        <span class="comment"># 删除停用词，并除去长度小于等于2的词</span></span><br><span class="line">                retWords.append(word.lower())</span><br><span class="line">        <span class="keyword">return</span> retWords</span><br></pre></td></tr></table></figure></p><h2 id="TF-IDF方法"><a href="#TF-IDF方法" class="headerlink" title="TF-IDF方法"></a>TF-IDF方法</h2><p>由词数向量可计算词频，但只用词频忽略了各文本在不同文档中的重要程度，关于<code>TF-IDF</code>，在<a href="https://louishsu.xyz/2018/10/25/TF-IDF/" target="_blank" rel="noopener">另一篇博文</a>中详细说明。</p><p>由于剔除了停用词等，部分向量不包含任何内容，即词数向量为$\vec{0}$，这时计算词频和单位化时，会出现<code>nan</code>的运算结果，故只对非空向量进行计算。</p><p>训练后需要保存的是<code>IDF</code>向量，<code>TF</code>向量在新样本输入后重新计算，故无需保存。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TfidfVectorizer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.idf = <span class="keyword">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit_transform</span><span class="params">(self, num_vec)</span>:</span></span><br><span class="line">        self.fit(num_vec)</span><br><span class="line">        <span class="keyword">return</span> self.transform(num_vec)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, num_vec)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        @param &#123;ndarray&#125;: num_vec, shape(N_sample, N_feature)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        num_vec[num_vec&gt;<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        n_doc = num_vec.shape[<span class="number">0</span>]</span><br><span class="line">        n_term = np.sum(num_vec, axis=<span class="number">0</span>)    <span class="comment"># 各词出现过的文档次数</span></span><br><span class="line">        self.idf = np.log((n_doc + <span class="number">1</span>) / (n_term + <span class="number">1</span>)) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.idf</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transform</span><span class="params">(self, num_vec)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        @param &#123;ndarray&#125;: num_vec, shape(N_sample, N_feature)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 求解词频向量，由于部分向量为空，故下句会出现问题</span></span><br><span class="line">        <span class="comment"># tf = num_vec / np.sum(num_vec, axis=1).reshape(-1, 1) =&gt; nan</span></span><br><span class="line">        <span class="comment"># 解决方法：只对非空向量进行词频计算</span></span><br><span class="line">        tf = np.zeros(shape=num_vec.shape)</span><br><span class="line">        n_terms = np.sum(num_vec, axis=<span class="number">1</span>); idx = (n_terms!=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        tf[idx] = num_vec[idx] / n_terms[idx].reshape(<span class="number">-1</span>, <span class="number">1</span>)            <span class="comment"># 计算词频，只对非空向量进行</span></span><br><span class="line">        </span><br><span class="line">        tfidf = tf * self.idf</span><br><span class="line">        tfidf[idx] /= np.linalg.norm(tfidf, axis=<span class="number">1</span>)[idx].reshape(<span class="number">-1</span>, <span class="number">1</span>) <span class="comment"># 单位化，只对非空向量进行</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> tfidf</span><br></pre></td></tr></table></figure><h2 id="贝叶斯决策"><a href="#贝叶斯决策" class="headerlink" title="贝叶斯决策"></a>贝叶斯决策</h2><p>各文本向量化后，就可通过机器学习算法进行模型的训练和预测，这里采用的是贝叶斯决策的方法，需要注意的有以下几点</p><ul><li>似然函数$p(x|c_k)$与<a href="https://louishsu.xyz/2018/10/18/Bayes-Decision/" target="_blank" rel="noopener">贝叶斯决策</a>文中例不同，这里宜采用高斯分布作为分布模型；</li><li><p>按朴素贝叶斯计算$p(x|c_k)$，但注意此处不能将各维特征单独训练$1$维高斯分布模型，然后计算预测样本似然函数值时进行累乘，如下</p><script type="math/tex; mode=display">p(x|c_k) = \prod_{j=1}^{N_feature} p(x_j|c_k)</script><p>因为特征维度特别高，各个特征单独用$1$维高斯分布描述，累乘计算会下溢，故这里采用多元高斯分布</p><script type="math/tex; mode=display">p(x|c_k) = \frac{1}{(2\pi)^{\frac{n}{2}}|\Sigma_k|^{\frac{1}{2}}} · e^{-\frac{1}{2} (x - \mu_k)^T \Sigma_k^{-1} (x - \mu_k)}</script><ul><li>且经主成分分析后，各维度间线性相关性降低，故假定<script type="math/tex; mode=display">\Sigma_k = diag\{\sigma_{k1}, ..., \sigma_{kn}\}</script></li><li><p>但分母$(2\pi)^{\frac{n}{2}}|\Sigma_k|^{\frac{1}{2}}$在计算时不稳定，且各特征标准差大小相差无几，故这里假定</p><script type="math/tex; mode=display">\Sigma_k = I</script></li><li><p>最终简化后的似然函数计算方法为</p><script type="math/tex; mode=display">p(x|c_k) =  e^{-\frac{1}{2} (x - \mu_k)^T (x - \mu_k)}</script></li></ul></li></ul><h3 id="贝叶斯决策模型训练"><a href="#贝叶斯决策模型训练" class="headerlink" title="贝叶斯决策模型训练"></a>贝叶斯决策模型训练</h3><p>基于上述假设，只需训练多元高斯分布的各维均值$\mu_j$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, labels, text)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param &#123;ndarray&#125; labels: shape(N_samples, ), labels[i] \in &#123;0, 1&#125;</span></span><br><span class="line"><span class="string">    @param &#123;list[list[str]]&#125; words</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">    labels = self.encodeLabel(labels); words = self.text2words(self.clean(text))</span><br><span class="line"></span><br><span class="line">    vecwords = self.numvectorizer.fit_transform(words)              <span class="comment"># 向量化</span></span><br><span class="line">    vecwords = self.tfidfvectorizer.fit_transform(vecwords)         <span class="comment"># tfidf, shape(N_samples, N_features)</span></span><br><span class="line"></span><br><span class="line">    isnotEmpty = (np.sum(vecwords, axis=<span class="number">1</span>)!=<span class="number">0</span>)                      <span class="comment"># 去掉空的样本</span></span><br><span class="line">    vecwords = vecwords[isnotEmpty]; labels = labels[isnotEmpty]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># vecwords = self.reduce_dim.fit_transform(vecwords)              # 降维，计算量太大</span></span><br><span class="line">    self.n_features = vecwords.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    labels = OneHotEncoder().fit_transform(labels.reshape((<span class="number">-1</span>, <span class="number">1</span>))).toarray()</span><br><span class="line">        self.priori = np.mean(labels, axis=<span class="number">0</span>)                           <span class="comment"># 先验概率</span></span><br><span class="line"></span><br><span class="line">    self.likelihood_mu = np.zeros(shape=(<span class="number">2</span>, vecwords.shape[<span class="number">1</span>]))    <span class="comment"># 设似然函数p(x|c)为高斯分布</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        vec = vecwords[labels[:, i]==<span class="number">1</span>]</span><br><span class="line">        self.likelihood_mu[i] = np.mean(vec, axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="贝叶斯决策模型预测"><a href="#贝叶斯决策模型预测" class="headerlink" title="贝叶斯决策模型预测"></a>贝叶斯决策模型预测</h3><p>决策函数为</p><script type="math/tex; mode=display">if　p(x|c_i)P(c_i) > p(x|c_j)P(c_j),　then　x \in c_i</script><p>但实际效果显示，等先验概率$P(c_j)$结果更好$(???)$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multigaussian</span><span class="params">(self, x, mu)</span>:</span></span><br><span class="line">    <span class="string">""" 简化</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    x = x - mu</span><br><span class="line">    a = np.exp(<span class="number">-0.5</span> * x.T.dot(x))</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, text)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param &#123;list[list[str]]&#125; words</span></span><br><span class="line"><span class="string">    @note:</span></span><br><span class="line"><span class="string">                      p(x|c)P(c)</span></span><br><span class="line"><span class="string">            P(c|x) = ------------</span></span><br><span class="line"><span class="string">                         p(x)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    pred_porba = np.ones(shape=(len(self.clean(text)), <span class="number">2</span>))      </span><br><span class="line">        </span><br><span class="line">    words = self.text2words(text)</span><br><span class="line">    vecwords = self.tfidfvectorizer.transform(</span><br><span class="line">                                self.numvectorizer.transform(words))    <span class="comment"># 向量化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(vecwords.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">            <span class="comment"># pred_porba[i, c] = self.priori[c] * self.multigaussian(vecwords[i], self.likelihood_mu[c])</span></span><br><span class="line">            pred_porba[i, c] = self.multigaussian(vecwords[i], self.likelihood_mu[c])</span><br><span class="line"></span><br><span class="line">    pred = np.argmax(pred_porba, axis=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> self.decodeLabel(pred)</span><br></pre></td></tr></table></figure><h1 id="调包"><a href="#调包" class="headerlink" title="调包"></a>调包</h1><p>主要用到了<code>scikit-learn</code>机器学习包以下几个功能</p><ul><li><code>sklearn.feature_extraction.text.TfidfVectorizer()</code></li><li><code>sklearn.decomposition.PCA()</code></li><li><code>sklearn.naive_bayes.BernoulliNB()</code></li></ul><p>最终准确率在$97\%$左右，代码比较简单，不进行说明。</p><blockquote><p>采用<code>sklearn.linear_model import.LogisticRegressionCV()</code>效果更佳</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    trainfile = <span class="string">"./data/train.csv"</span></span><br><span class="line">    testfile = <span class="string">"./data/test.csv"</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 读取原始数据</span></span><br><span class="line">    data_train = pd.read_csv(trainfile, names=[<span class="string">'Label'</span>, <span class="string">'Text'</span>])</span><br><span class="line">    txt_train  = list(data_train[<span class="string">'Text'</span>])[<span class="number">1</span>: ]; label_train = list(data_train[<span class="string">'Label'</span>])[<span class="number">1</span>: ]</span><br><span class="line">    drop(txt_train)                                             <span class="comment"># 删除数字和标点</span></span><br><span class="line">    txt_test   = list(pd.read_csv(testfile, names=[<span class="string">'Text'</span>])[<span class="string">'Text'</span>])[<span class="number">1</span>: ]</span><br><span class="line">    drop(txt_test)                                              <span class="comment"># 删除数字和标点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练</span></span><br><span class="line">    vectorizer = TfidfVectorizer(stop_words=<span class="string">'english'</span>)          <span class="comment"># 删除英文停用词</span></span><br><span class="line">    vec_train = vectorizer.fit_transform(txt_train).toarray()   <span class="comment"># 提取文本特征向量</span></span><br><span class="line">    <span class="comment"># reduce_dim = PCA(n_components = 4096)</span></span><br><span class="line">    <span class="comment"># vec_train = reduce_dim.fit_transform(vec_train)</span></span><br><span class="line">    estimator = BernoulliNB()</span><br><span class="line">    estimator.fit(vec_train, label_train)                       <span class="comment"># 训练朴素贝叶斯模型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 测试</span></span><br><span class="line">    label_train_pred = estimator.predict(vec_train)</span><br><span class="line">    acc = np.mean((label_train_pred==label_train).astype(<span class="string">'float'</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 预测</span></span><br><span class="line">    vec_test = vectorizer.transform(txt_test).toarray()</span><br><span class="line">    <span class="comment"># vec_test = reduce_dim.transform(vec_test)</span></span><br><span class="line">    label_test_pred = estimator.predict(vec_test)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'./data/sampleSubmission.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(label_test_pred.shape[<span class="number">0</span>]):</span><br><span class="line">            f.write(label_test_pred[i] + <span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TF-IDF</title>
      <link href="/2018/10/25/TF-IDF/"/>
      <url>/2018/10/25/TF-IDF/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>正在做<a href="https://www.lintcode.com/" target="_blank" rel="noopener">LintCode</a>上的垃圾邮件分类，使用<a href="https://louishsu.xyz/2018/10/18/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%86%B3%E7%AD%96/" target="_blank" rel="noopener">朴素贝叶斯</a>方法解决，涉及到文本特征的提取。<br>TF-IDF（词频-逆文档频率）算法是一种统计方法，用以评估一字词对于一个文件集或一个语料库中的其中一份文件的重要程度。字词的重要性随着它在文件中出现的次数成正比增加，但同时会随着它在语料库中出现的频率成反比下降。</p><h1 id="计算步骤"><a href="#计算步骤" class="headerlink" title="计算步骤"></a>计算步骤</h1><h2 id="词频-TF"><a href="#词频-TF" class="headerlink" title="词频(TF)"></a>词频(TF)</h2><p><code>Term Frequency</code>，就是某个关键字出现的频率，具体来讲，就是词库中的<strong>某个词在当前文章中出现的频率</strong>。那么我们可以写出它的计算公式：</p><script type="math/tex; mode=display">TF_{ij} = \frac{n_{ij}}{\sum_k n_{i, k}}</script><p>其中，$n_{ij}$表示关键词$j$在文档$i$中的出现次数。</p><p>单纯使用TF来评估关键词的重要性忽略了常用词的干扰。常用词就是指那些文章中大量用到的，但是不能反映文章性质的那种词，比如：因为、所以、因此等等的连词，在英文文章里就体现为and、the、of等等的词。这些词往往拥有较高的TF，所以仅仅使用TF来考察一个词的关键性，是不够的。</p><h2 id="逆文档频率-IDF"><a href="#逆文档频率-IDF" class="headerlink" title="逆文档频率(IDF)"></a>逆文档频率(IDF)</h2><p><code>Inverse Document Frequency</code>，文档频率就是<strong>一个词在整个文库词典中出现的频率</strong>，逆文档频率用下式计算</p><script type="math/tex; mode=display">IDF_j = \log \frac{|D|}{|D_j| + 1}</script><p>其中，$|D|$表示总的文档数目，$|D_j|$表示关键词$j$出现过的文档数目</p><p><code>scikit-learn</code>内为</p><script type="math/tex; mode=display">IDF_j = \log \frac{|D| + 1}{|D_j| + 1} + 1</script><p><img src="/2018/10/25/TF-IDF/sklearn.jpg" alt="sklearn_tfidf"></p><h2 id="词频-逆文档频率-TF-IDF"><a href="#词频-逆文档频率-TF-IDF" class="headerlink" title="词频-逆文档频率(TF-IDF)"></a>词频-逆文档频率(TF-IDF)</h2><script type="math/tex; mode=display">TF-IDF_{i} = TF_i × IDF</script><h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><p>例如有如下$3$个文本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">文本1：My dog ate my homework.</span><br><span class="line">文本2：My cat ate the sandwich.</span><br><span class="line">文本3：A dolphin ate the homework.</span><br></pre></td></tr></table></figure></p><p>提取字典，一般需要处理大小写、去除停用词<code>a</code>，处理结果为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ate, cat, dog, dolphin, homework, my, sandwich, the</span><br></pre></td></tr></table></figure></p><p>故各个文本的词数向量为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">文本1：[1, 0, 1, 0, 1, 2, 0, 0]</span><br><span class="line">文本2：[1, 1, 0, 0, 0, 1, 1, 1]</span><br><span class="line">文本3：[1, 0, 0, 1, 1, 0, 0, 1]</span><br></pre></td></tr></table></figure></p><p>各个文本的词频向量(TF)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">文本1：[0.2 , 0.  , 0.2 , 0.  , 0.2 , 0.4 , 0.  , 0.  ]</span><br><span class="line">文本2：[0.2 , 0.2 , 0.  , 0.  , 0.  , 0.2 , 0.2 , 0.2 ]</span><br><span class="line">文本3：[0.25, 0.  , 0.  , 0.25, 0.25, 0.  , 0.  , 0.25]</span><br></pre></td></tr></table></figure></p><p>各词出现过的文档次数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3, 1, 1, 1, 2, 2, 1, 2]</span><br></pre></td></tr></table></figure></p><p>总文档数为$3$，各词的逆文档频率(IDF)向量</p><blockquote><p>这里使用<code>scikit-learn</code>内的方法求解</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1.        , 1.69314718, 1.69314718, 1.69314718, 1.28768207,  1.28768207, 1.69314718, 1.28768207]</span><br></pre></td></tr></table></figure><p>故各文档的TF-IDF向量为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">文本1：</span><br><span class="line">[0.2       , 0.        , 0.33862944, 0.        , 0.25753641, 0.51507283, 0.        , 0.        ]</span><br><span class="line">文本2：</span><br><span class="line">[0.2       , 0.33862944, 0.        , 0.        , 0.        , 0.25753641, 0.33862944, 0.25753641]</span><br><span class="line">文本3：</span><br><span class="line">[0.25      , 0.        , 0.        , 0.4232868 , 0.32192052, 0.        , 0.        , 0.32192052]</span><br></pre></td></tr></table></figure></p><p>经单位化后，有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">文本1：</span><br><span class="line">[0.28680065, 0.        , 0.48559571, 0.        , 0.36930805,  0.73861611, 0.        , 0.        ]</span><br><span class="line">文本2：</span><br><span class="line">[0.31544415, 0.53409337, 0.        , 0.        , 0.        ,  0.40619178, 0.53409337, 0.40619178]</span><br><span class="line">文本3：</span><br><span class="line">[0.37311881, 0.        , 0.        , 0.63174505, 0.4804584 ,  0.        , 0.        , 0.4804584 ]</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; import numpy as np</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; vec_num = np.array([</span></span><br><span class="line">[1, 0, 1, 0, 1, 2, 0, 0],</span><br><span class="line">[1, 1, 0, 0, 0, 1, 1, 1],</span><br><span class="line">[1, 0, 0, 1, 1, 0, 0, 1]</span><br><span class="line">])</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; vec_tf = vec_num / np.sum(vec_num, axis=1).reshape(-1, 1)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; vec_tf</span></span><br><span class="line">array([[0.2 , 0.  , 0.2 , 0.  , 0.2 , 0.4 , 0.  , 0.  ],</span><br><span class="line">       [0.2 , 0.2 , 0.  , 0.  , 0.  , 0.2 , 0.2 , 0.2 ],</span><br><span class="line">       [0.25, 0.  , 0.  , 0.25, 0.25, 0.  , 0.  , 0.25]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; vec_num[vec_num&gt;0] = 1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; n_showup = np.sum(vec_num, axis=0)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; n_showup</span></span><br><span class="line">array([3, 1, 1, 1, 2, 2, 1, 2])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; d = 3</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; vec_idf = np.log((d + 1) / (n_showup + 1)) + 1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; vec_idf</span></span><br><span class="line">array([1.        , 1.69314718, 1.69314718, 1.69314718, 1.28768207, 1.28768207, 1.69314718, 1.28768207])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; vec_tfidf = vec_tf * vec_idf</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; vec_tfidf</span></span><br><span class="line">array([[0.2       , 0.        , 0.33862944, 0.        , 0.25753641, 0.51507283, 0.        , 0.        ],</span><br><span class="line">       [0.2       , 0.33862944, 0.        , 0.        , 0.        , 0.25753641, 0.33862944, 0.25753641],</span><br><span class="line">       [0.25      , 0.        , 0.        , 0.4232868 , 0.32192052, 0.        , 0.        , 0.32192052]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; vec_tfidf = vec_tfidf / np.linalg.norm(vec_tfidf, axis=1).reshape((-1, 1))</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; vec_tfidf</span></span><br><span class="line">array([[0.28680065, 0.        , 0.48559571, 0.        , 0.36930805, 0.73861611, 0.        , 0.        ],</span><br><span class="line">       [0.31544415, 0.53409337, 0.        , 0.        , 0.        , 0.40619178, 0.53409337, 0.40619178],</span><br><span class="line">       [0.37311881, 0.        , 0.        , 0.63174505, 0.4804584 , 0.        , 0.        , 0.4804584 ]])</span><br></pre></td></tr></table></figure><h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>使用<code>scikit-learn</code>机器学习包计算结果<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; from sklearn.feature_extraction.text import TfidfVectorizer</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; vectorizer = TfidfVectorizer()</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; text = [</span></span><br><span class="line">"My dog ate my homework",</span><br><span class="line">"My cat ate the sandwich",</span><br><span class="line">"A dolphin ate the homework"]</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; vectorizer.fit_transform(text).toarray()</span></span><br><span class="line">array([[0.28680065, 0.        , 0.48559571, 0.        , 0.36930805,  0.73861611, 0.        , 0.        ],</span><br><span class="line">       [0.31544415, 0.53409337, 0.        , 0.        , 0.        ,  0.40619178, 0.53409337, 0.40619178],</span><br><span class="line">       [0.37311881, 0.        , 0.        , 0.63174505, 0.4804584 ,  0.        , 0.        , 0.4804584 ]])</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; vectorizer.get_feature_names()</span></span><br><span class="line">['ate', 'cat', 'dog', 'dolphin', 'homework', 'my', 'sandwich', 'the']</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Practice </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SVD</title>
      <link href="/2018/10/23/SVD/"/>
      <url>/2018/10/23/SVD/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>奇异值分解<code>Singular Value Decomposition</code>是线性代数中一种重要的矩阵分解，奇异值分解则是特征分解在任意矩阵上的推广。在信号处理、统计学等领域有重要应用。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="从特征值分解-EVD-讲起"><a href="#从特征值分解-EVD-讲起" class="headerlink" title="从特征值分解(EVD)讲起"></a>从特征值分解(EVD)讲起</h2><p>我们知道对于一个$n$阶方阵$A_{n×n}$，有</p><script type="math/tex; mode=display">A\alpha_i = \lambda_i \alpha_i　i = 1, ..., n</script><p>取</p><script type="math/tex; mode=display">P = \left[\alpha_1, \alpha_2, ..., \alpha_n\right]</script><p>有下式成立</p><script type="math/tex; mode=display">AP = P\Lambda</script><p>其中</p><script type="math/tex; mode=display">\Lambda = \left[        \begin{matrix}            \lambda_1 & & \\            & ... & \\            & & \lambda_n \\        \end{matrix}\right]</script><blockquote><p>特征值一般从大到小排列</p></blockquote><p>利用该式可将方阵$A_{n×n}$化作对角阵$\Lambda_{n×n}$</p><script type="math/tex; mode=display">\Lambda = P^{-1}AP</script><p>或者</p><script type="math/tex; mode=display">A = P \Lambda P^{-1} = \sum_{i=1}^n \lambda_i (P_{,i})(P_{,i})^{-1}</script><blockquote><p>“$_{i}$”表示第$i$行，“$_{,i}$”表示第$i$列</p></blockquote><p>这样我们就可以理解为，矩阵$A$是由$n$个$n$阶矩阵$P_{,i}P^{-1}_{i}$加权组成，特征值$\lambda_i$即为权重。</p><blockquote><p>以上为个人理解，不妥之处可以指出。</p></blockquote><h2 id="奇异值分解-SVD"><a href="#奇异值分解-SVD" class="headerlink" title="奇异值分解(SVD)"></a>奇异值分解(SVD)</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>对于长方阵$A_{m×n}$，不能进行特征值分解，可进行如下分解</p><script type="math/tex; mode=display">A_{m×n} = U_{m×m} \Sigma_{m×n} V_{n×n}^T</script><p>其中$U \in \mathbb{R}^{m×m}, V \in \mathbb{R}^{n×n}$，均为正交矩阵。矩阵$\Sigma_{m×n}$如下</p><ul><li><p>对于$m&gt;n$</p><script type="math/tex; mode=display">  \Sigma_{m×n} = \left[          \begin{matrix}              S_{n×n} \\              --- \\              O_{(m-n)×n}          \end{matrix}  \right]</script></li><li><p>对于$m&lt;n$</p><script type="math/tex; mode=display">  \Sigma_{m×n} = \left[          \begin{matrix}              S_{m×m} & | & O_{m×(n-m)}          \end{matrix}  \right]</script></li></ul><p>矩阵$S_{n×n}$为对角阵，对角元素从大到小排列</p><script type="math/tex; mode=display">S_{n×n} = \left[    \begin{matrix}        \sigma_1 & & \\         & ... & \\         & & \sigma_n\\    \end{matrix}\right]</script><p>直观表示<code>SVD</code>分解如下<br><img src="/2018/10/23/SVD/直观表示SVD.jpg" alt="直观表示SVD"></p><p>当取$r&lt;n$时，有部分奇异值分解，可用于降维</p><script type="math/tex; mode=display">A_{m×n} = U_{m×r} \Sigma_{r×r} V_{r×n}^T</script><h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><blockquote><p>以下仅考虑$m&gt;n$的情况</p></blockquote><ol><li><p>令矩阵$A^T$与$A$相乘，有</p><script type="math/tex; mode=display"> A^TA = (U \Sigma V^T)^T (U \Sigma V^T)</script><script type="math/tex; mode=display"> = V \Sigma^T U^T U \Sigma V^T</script><script type="math/tex; mode=display"> A^TA = V \Sigma^T \Sigma V^T</script><blockquote><p>矩阵$U$为正交阵，即满足$U^TU=I$</p></blockquote><p> 其中</p><script type="math/tex; mode=display"> \Sigma^T \Sigma =          \left[             \begin{matrix}                 S^T_{n×n} & | & O^T_{n×(m-n)}             \end{matrix}         \right]         \left[             \begin{matrix}                 S_{n×n} \\                 --- \\                 O_{(m-n)×n}             \end{matrix}         \right]</script><script type="math/tex; mode=display"> = S_{n×n}^2  = \left[     \begin{matrix}         \sigma_1^2 & & \\         & ... & \\         & & \sigma_n^2\\     \end{matrix} \right]</script><p> 则</p><script type="math/tex; mode=display"> A^T A = V S^2  V^T</script><p> 即矩阵$A^T A$相似对角化为$S^2$，对角元素$\sigma_i^2$与矩阵$V$的列向量$v_i(i=1, …, n)$为矩阵$A^T A$的特征对。</p><p> 那么对矩阵$A^T A$进行特征值分解，有</p><script type="math/tex; mode=display"> (A^T A) \alpha^{(1)}_i = \lambda^{(1)}_i \alpha^{(1)}_i</script><p> 则</p><script type="math/tex; mode=display"> v_i = \alpha^{(1)}_i　\sigma_i = \sqrt{\lambda^{(1)}_i}</script><blockquote><p>注：对于二次型$x^T (A^T A) x$</p><script type="math/tex; mode=display">x^T (A^T A) x = (Ax)^T(Ax) \geq 0</script><p>故矩阵$A^T A$半正定，$\sigma_i = \sqrt{\lambda_i}$有解</p></blockquote></li></ol><ol><li><p>同理，令矩阵$A$与$A^T$相乘，可证得</p><script type="math/tex; mode=display"> A A^T = U \Sigma \Sigma^T U^T</script><p> 其中</p><script type="math/tex; mode=display"> \Sigma \Sigma^T =          \left[             \begin{matrix}                 S_{n×n} \\                 --- \\                 O_{(m-n)×n}             \end{matrix}         \right]         \left[             \begin{matrix}                 S^T_{n×n} & | & O^T_{n×(m-n)}             \end{matrix}         \right]</script><script type="math/tex; mode=display"> = \left[     \begin{matrix}         S^2_{n×n} & O_{n×(m-n)} \\         O_{(m-n)×n} & O_{(m-n)×(m-n)}     \end{matrix} \right]</script><p> 即矩阵$A A^T$相似对角化，对角元素$\sigma_i^2$与矩阵$U$的列向量$u_i(i=1, …, m)$为矩阵$A A^T$的特征对。</p><p> 对矩阵$A A^T$进行特征值分解，有</p><script type="math/tex; mode=display"> (A^T A) \alpha^{(2)}_i = \lambda^{(2)}_i \alpha^{(2)}_i</script><p> 则</p><script type="math/tex; mode=display"> u_i = \alpha^{(2)}_i　\sigma_i = \sqrt{\lambda^{(2)}_i}</script><blockquote><p>同理可证得$A A^T$半正定，略。</p></blockquote></li></ol><p>一般来说，为减少计算量，计算奇异值分解只进行一次特征值分解，如对于矩阵$X_{m×n}(m&gt;n)$，选取$n$阶矩阵$X^T X$进行特征值分解计算$v_i$，计算$u_i$方法下面介绍。</p><p>根据前面推导，我们有特征值分解</p><script type="math/tex; mode=display">(A^T A) \alpha^{(1)}_i = \lambda^{(1)}_i \alpha^{(1)}_i</script><script type="math/tex; mode=display">(A A^T) \alpha^{(2)}_i = \lambda^{(2)}_i \alpha^{(2)}_i</script><p>其中$\lambda^{(1)}_i = \lambda^{(2)}_i = \sigma_i^2$，$v_i = \alpha^{(1)}_i$，$u_i = \alpha^{(2)}_i$，即</p><script type="math/tex; mode=display">A^T A v_i = \sigma_i^2 v_i \tag{1}</script><script type="math/tex; mode=display">A A^T u_i = \sigma_i^2 u_i \tag{2}</script><p>$(1)$式左右乘$A$，有</p><script type="math/tex; mode=display">A A^T A v_i = \sigma_i^2 A v_i</script><p>发现什么？这是另一个特征值分解的表达式！</p><script type="math/tex; mode=display">(A A^T) (A v_i) = \sigma_i^2 (A v_i)</script><p>故</p><script type="math/tex; mode=display">u_i \propto A v_i　或　u_i = k · A v_i \tag{3}</script><p>现在求解系数$k$，根据定义</p><script type="math/tex; mode=display">A = U \Sigma V^T　\Rightarrow　AV = U \Sigma</script><p>则</p><script type="math/tex; mode=display">A v_i = \sigma_i u_i　\Rightarrow　u_i = \frac{1}{\sigma_i} A v_i</script><p>或者</p><script type="math/tex; mode=display">U = A V \Sigma^{-1}</script><blockquote><p>注：只能求前$n$个$u_i$，之后的需要列写方程求解</p></blockquote><h1 id="举栗"><a href="#举栗" class="headerlink" title="举栗"></a>举栗</h1><p>将矩阵$A$进行分解</p><script type="math/tex; mode=display">A = \left[    \begin{matrix}        0 & 1 \\        1 & 1 \\        1 & 0    \end{matrix}\right]</script><p>为减少计算量，取$A^T A$计算</p><script type="math/tex; mode=display">A^T A = \left[    \begin{matrix}        2 & 1 \\        1 & 2     \end{matrix}\right]</script><p>特征值分解，有</p><script type="math/tex; mode=display">A\left[    \begin{matrix}        \frac{1}{\sqrt{2}} & -\frac{1}{\sqrt{2}} \\        \frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}}    \end{matrix} \right]= \left[    \begin{matrix}        \frac{1}{\sqrt{2}} & -\frac{1}{\sqrt{2}} \\        \frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}}    \end{matrix} \right]\left[    \begin{matrix}        3 &  \\          & 1    \end{matrix} \right]</script><p>故</p><script type="math/tex; mode=display">\Sigma = \left[    \begin{matrix}        \sqrt{3} &  \\          & 1    \end{matrix} \right]　V = \left[    \begin{matrix}        \frac{1}{\sqrt{2}} & -\frac{1}{\sqrt{2}} \\        \frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}}    \end{matrix} \right]</script><script type="math/tex; mode=display">U = A V \Sigma^{-1} = \left[    \begin{matrix}        \frac{1}{\sqrt{6}} & \frac{1}{\sqrt{2}} \\        \frac{2}{\sqrt{6}} & 0 \\        \frac{1}{\sqrt{6}} & -\frac{1}{\sqrt{2}}    \end{matrix} \right]</script><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; import numpy as np</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; A = np.array([</span></span><br><span class="line">[0, 1], [1, 1], [1, 0]</span><br><span class="line">])</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; ATA = A.T.dot(A)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; eigval, eigvec= np.linalg.eig(ATA)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; V = eigvec.copy()</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; S = np.diag(np.sqrt(eigval))</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; U = A.dot(V).dot(np.linalg.inv(S))</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; U</span></span><br><span class="line">array([[ 0.40824829,  0.70710678],</span><br><span class="line">       [ 0.81649658,  0.        ],</span><br><span class="line">       [ 0.40824829, -0.70710678]])</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; S</span></span><br><span class="line">array([[1.73205081, 0.        ],</span><br><span class="line">       [0.        , 1.        ]])</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; V</span></span><br><span class="line">array([[ 0.70710678, -0.70710678],</span><br><span class="line">       [ 0.70710678,  0.70710678]])</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="comment"># 验证</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; U.dot(S).dot(V.T)</span></span><br><span class="line">array([[-2.23711432e-17,  1.00000000e+00],</span><br><span class="line">       [ 1.00000000e+00,  1.00000000e+00],</span><br><span class="line">       [ 1.00000000e+00, -2.23711432e-17]])</span><br></pre></td></tr></table></figure><h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><p>展开表达式，取$r \leq n$时，</p><script type="math/tex; mode=display">A = U_{m×r} \Sigma_{r×r} V_{r×n}^T = \sum_{i=1}^r \sigma_i (U_{,i}) (V_{,i})^T</script><p>就得到与<code>PCA</code>相同的结论，矩阵$A$可由$r$个$m×n$的矩阵$(U_{,i}) (V_{,i})^T$加权组成。一般来说，前$10\%$甚至$1\%$的奇异值就占了全部奇异值之和的$99\%$，极大地保留了信息，而大大减少了存储空间。</p><blockquote><p>以图片为例，若原有<code>24bit</code>图片，其大小为<code>(1024, 768)</code>，则不计图片信息，仅仅数据共占<code>1024×768×3 B</code>，或<code>2.25 MB</code>。用奇异值分解进行压缩，保留$60\%$的奇异值，可达到几乎无损的程度，此时需要保存向量矩阵$U_{1024×60}$，$V_{60×768}$以及$60$个奇异值，以浮点数<code>float32</code>存储，一共占<code>420 KB</code>即可。</p><script type="math/tex; mode=display">(1024 × 60 + 60 × 768 + 60) × 4 / 2^{10} = 420.23</script><p>说句题外话，存储量的压缩必然以计算量的增大为代价，相反亦然，所以需要协调好<code>RAM</code>与<code>ROM</code>容量，考虑计算机的计算速度。换句话说，空间和时间上必然是互补的，哲学的味道hhhh。</p></blockquote><h1 id="分解结果的信息保留"><a href="#分解结果的信息保留" class="headerlink" title="分解结果的信息保留"></a>分解结果的信息保留</h1><p>分解后各样本间的欧式距离与角度信息应不变，给出证明如下<br>设有$m$组$n$维样本样本</p><script type="math/tex; mode=display">X_{n×m} = [X^{(1)}, X^{(2)}, ..., X^{(m)}]</script><p>经奇异值分解，有</p><script type="math/tex; mode=display">X_{n×m} = U_{n×r} \Sigma_{r×r} V_{r×m}^T</script><p>记</p><script type="math/tex; mode=display">Z_{r×m} = \Sigma V^T = [Z^{(1)}, Z^{(2)}, ..., Z^{(N)}]</script><p>有</p><script type="math/tex; mode=display">X = U Z</script><ul><li><p>欧式距离</p><script type="math/tex; mode=display">  || X^{(i)} - X^{(j)} ||_2^2 = || U (Z^{(i)} - Z^{(j)}) ||_2^2</script><script type="math/tex; mode=display">  = \left[ U (Z^{(i)} - Z^{(j)}) \right]^T \left[ U (Z^{(i)} - Z^{(j)}) \right]</script><script type="math/tex; mode=display">  = (Z^{(i)} - Z^{(j)})^T U^T U (Z^{(i)} - Z^{(j)})</script><script type="math/tex; mode=display">  = || Z^{(i)} - Z^{(j)} ||_2^2</script><p>  即</p><script type="math/tex; mode=display">  || X^{(i)} - X^{(j)} ||_2^2 = || Z^{(i)} - Z^{(j)} ||_2^2</script></li><li><p>角度信息</p><script type="math/tex; mode=display">  \frac{X^{(i)T}X^{(j)}}{||X^{(i)}||_2||X^{(j)}||_2}</script><script type="math/tex; mode=display">  = \frac{(UZ^{(i)})^T(UZ^{(j)})}{||UZ^{(i)}||_2||UZ^{(j)}||_2}</script><script type="math/tex; mode=display">  = \frac{(UZ^{(i)})^T(UZ^{(j)})}{\sqrt{(UZ^{(i)})^T(UZ^{(i)})} \sqrt{(UZ^{(j)})^T(UZ^{(j)})}}</script><script type="math/tex; mode=display">  = \frac{Z^{(i)T}Z^{(j)}}{||Z^{(i)}||_2||Z^{(j)}||_2}</script><p>  即</p><script type="math/tex; mode=display">  \frac{X^{(i)T}X^{(j)}}{||X^{(i)}||_2||X^{(j)}||_2} =   \frac{Z^{(i)T}Z^{(j)}}{||Z^{(i)}||_2||Z^{(j)}||_2}</script></li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://github.com/isLouisHsu/Python-Examples-for-Pattern-Recognition-Course/blob/master/examples/p15_svd.py" target="_blank" rel="noopener">@Github: Code of SVD</a><br>对图片进行了分解<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SVD</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">""" Singular Value Decomposition</span></span><br><span class="line"><span class="string">    Attributes:</span></span><br><span class="line"><span class="string">        m &#123;int&#125;</span></span><br><span class="line"><span class="string">        n &#123;int&#125;</span></span><br><span class="line"><span class="string">        r &#123;int&#125;: if r == -1, then r = n</span></span><br><span class="line"><span class="string">        isTrains &#123;bool&#125;: isTrains = True if input.shape[0] &lt; input.shape[1]</span></span><br><span class="line"><span class="string">        U &#123;ndarray(m, r)&#125;</span></span><br><span class="line"><span class="string">        S &#123;ndarray(r, )&#125;</span></span><br><span class="line"><span class="string">        V &#123;ndarray(n, r)&#125;</span></span><br><span class="line"><span class="string">    Notes:</span></span><br><span class="line"><span class="string">        - Transpose input matrix if m &lt; n, and m, n := n, m</span></span><br><span class="line"><span class="string">        - Reassign r if eigvals contains zero</span></span><br><span class="line"><span class="string">        - Singular values are stored in a 1-dim array `S`</span></span><br><span class="line"><span class="string">        - X' = U S V^T</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, r=<span class="number">-1</span>)</span>:</span></span><br><span class="line">        self.m = <span class="keyword">None</span></span><br><span class="line">        self.n = <span class="keyword">None</span></span><br><span class="line">        self.r = r</span><br><span class="line">        self.isTrans = <span class="keyword">False</span></span><br><span class="line">        self.U = <span class="keyword">None</span></span><br><span class="line">        self.S = <span class="keyword">None</span></span><br><span class="line">        self.V = <span class="keyword">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        <span class="string">""" calculate components</span></span><br><span class="line"><span class="string">        Notes:</span></span><br><span class="line"><span class="string">            - Transpose input matrix if m &lt; n, and m, n := n, m</span></span><br><span class="line"><span class="string">            - reassign self.r if eigvals contains zero</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        (self.m, self.n) = X.shape</span><br><span class="line">        <span class="keyword">if</span> self.m &lt; self.n:</span><br><span class="line">            X = X.T</span><br><span class="line">            self.m, self.n = self.n, self.m</span><br><span class="line">            self.isTrans = <span class="keyword">True</span></span><br><span class="line">        self.r = self.n <span class="keyword">if</span> (self.r == <span class="number">-1</span>) <span class="keyword">else</span> self.r</span><br><span class="line"></span><br><span class="line">        XTX = X.T.dot(X)</span><br><span class="line">        eigval, eigvec = np.linalg.eig(X.T.dot(X))</span><br><span class="line">        eigval, eigvec = np.real(eigval), np.real(eigvec)</span><br><span class="line">        </span><br><span class="line">        self.S = np.sqrt(np.clip(eigval, <span class="number">0</span>, float(<span class="string">'inf'</span>)))</span><br><span class="line">        self.S = self.S[self.S &gt; <span class="number">0</span>]</span><br><span class="line">        self.r = min(self.r, self.S.shape[<span class="number">0</span>])               <span class="comment"># reassign self.r</span></span><br><span class="line">        order = np.argsort(eigval)[::<span class="number">-1</span>][: self.r]          <span class="comment"># sort eigval from large to small</span></span><br><span class="line">        eigval = eigval[order]; eigvec = eigvec[:, order]</span><br><span class="line">        self.V = eigvec.copy()</span><br><span class="line">        self.U = X.dot(self.V).dot(</span><br><span class="line">                    np.linalg.inv(np.diag(self.S)))</span><br><span class="line">        <span class="keyword">return</span> self.U, self.S, self.V</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compose</span><span class="params">(self, r=<span class="number">-1</span>)</span>:</span></span><br><span class="line">        <span class="string">""" merge first r components</span></span><br><span class="line"><span class="string">        Parameters:</span></span><br><span class="line"><span class="string">            r &#123;int&#125;: if r==-1, merge all components</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            X &#123;ndarray(m, n)&#125;</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> r == <span class="number">-1</span>:</span><br><span class="line">            X = self.U.dot(np.diag(self.S)).dot(self.V.T)</span><br><span class="line">            X = X.T <span class="keyword">if</span> self.isTrans <span class="keyword">else</span> X</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            (m, n) = (self.n, self.m) <span class="keyword">if</span> self.isTrans <span class="keyword">else</span> (self.m, self.n)</span><br><span class="line">            X = np.zeros(shape=(m, n))</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(r):</span><br><span class="line">                X += self.__getitem__(i)</span><br><span class="line">        <span class="keyword">return</span> X</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, idx)</span>:</span></span><br><span class="line">        <span class="string">""" get a component</span></span><br><span class="line"><span class="string">        Parameters:</span></span><br><span class="line"><span class="string">            index &#123;int&#125;: range from (0, self.r)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        u = self.U[:, idx]</span><br><span class="line">        v = self.V[:, idx]</span><br><span class="line">        s = self.S[idx]</span><br><span class="line">        x = s * u.reshape(self.m, <span class="number">1</span>).\</span><br><span class="line">                    dot(v.reshape(<span class="number">1</span>, self.n))</span><br><span class="line">        x = x.T <span class="keyword">if</span> self.isTrans <span class="keyword">else</span> x</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">showComponets</span><span class="params">(self, r=<span class="number">-1</span>)</span>:</span></span><br><span class="line">        <span class="string">""" display components</span></span><br><span class="line"><span class="string">        Notes:</span></span><br><span class="line"><span class="string">            - Resize components' shape into (40, 30)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m, n = self.m, self.n</span><br><span class="line">        r = self.r <span class="keyword">if</span> r==<span class="number">-1</span> <span class="keyword">else</span> r</span><br><span class="line">        n_images = <span class="number">10</span>; m_images = r // n_images + <span class="number">1</span></span><br><span class="line">        m_size, n_size = <span class="number">40</span>, <span class="number">30</span></span><br><span class="line">        showfig = np.zeros(shape=(m_images*m_size, n_images*n_size))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(r):</span><br><span class="line">            m_pos = i // n_images</span><br><span class="line">            n_pos = i %  n_images</span><br><span class="line">            component = self.__getitem__(i)</span><br><span class="line">            component = component.T <span class="keyword">if</span> self.isTrans <span class="keyword">else</span> component</span><br><span class="line">            component = cv2.resize(component, (<span class="number">30</span>, <span class="number">40</span>))</span><br><span class="line">            showfig[m_pos*m_size: (m_pos+<span class="number">1</span>)*m_size, n_pos*n_size: (n_pos+<span class="number">1</span>)*n_size] = component</span><br><span class="line">        plt.figure(<span class="string">'components'</span>)</span><br><span class="line">        plt.imshow(showfig)</span><br><span class="line">        plt.show()</span><br></pre></td></tr></table></figure></p><p>用上面的代码进行实验<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 读取一张图片</span></span><br><span class="line">X = load_images()[0].reshape((32, 32))</span><br><span class="line">showmat2d(X)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 对图片进行奇异值分解</span></span><br><span class="line">decomposer = SVD(r=-1)</span><br><span class="line">decomposer.fit(X)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示一下分量</span></span><br><span class="line">decomposer.showComponets(r=-1)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将全部分量组合，并显示</span></span><br><span class="line">X_ = decomposer.compose(r=-1)</span><br><span class="line">showmat2d(X_)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将前5个分量组合，并显示</span></span><br><span class="line">X_ = decomposer.compose(r=5)</span><br><span class="line">showmat2d(X_)</span><br></pre></td></tr></table></figure></p><ul><li><p>载入原图如下<br><img src="/2018/10/23/SVD/source.png" alt="source"></p></li><li><p>分量显示如下<br><img src="/2018/10/23/SVD/components.png" alt="components"></p></li><li><p>组合分量显示如下</p><ul><li>组合全部<br>  <img src="/2018/10/23/SVD/merge_all.png" alt="merge_all"></li><li>组合前5个分量<br>  <img src="/2018/10/23/SVD/merge_5.png" alt="merge_5"></li></ul></li></ul><h1 id="应用：推荐系统"><a href="#应用：推荐系统" class="headerlink" title="应用：推荐系统"></a>应用：推荐系统</h1><blockquote><p>详情查看<a href="https://github.com/isLouisHsu/Basic-Machine-Learning-Algorithm/blob/master/ZhaoHaitao%2C%20ECUST/recommend.py" target="_blank" rel="noopener">Basic-Machine-Learning-Algorithm/ZhaoHaitao, ECUST/recommend.py</a></p></blockquote><p>数据可从<a href="http://files.grouplens.org/datasets/movielens/" target="_blank" rel="noopener">MoiveLens</a>下载，实验使用<a href="http://files.grouplens.org/datasets/movielens/ml-100k.zip" target="_blank" rel="noopener">ml-100k.zip</a>。假设有用户$N_{user}$人，电影$N_{item}$部，先每个人对其看过的部分电影已进行评分，及其稀疏，现希望从这些数据预测出未知数据。</p><p>存储数据为矩阵</p><script type="math/tex; mode=display">M_{N_{user} \times N_{item}} = \left[\begin{matrix}    r_{ij}\end{matrix}\right]</script><p>现希望从用户相似度的角度，找出臭味相投的一些用户，用他们的评分均值作为该用户的评分，先对上述矩阵进行SVD分解</p><script type="math/tex; mode=display">M_{N_{user} \times N_{item}} = U_{N_{user} \times N_{user}} \cdot \Sigma_{N_{user} \times N_{item}} \cdot (V_{N_{item} \times N_{item}})^T \tag{4}</script><p>其中</p><script type="math/tex; mode=display">U_{N_{user} \times N_{user}} = \left[\begin{matrix}    \vec{u_{1}} & \vec{u_{2}} & \cdots & \vec{u_{N_{user}}}\end{matrix}\right]</script><script type="math/tex; mode=display">V_{N_{item} \times N_{item}} = \left[\begin{matrix}    \vec{v_{1}} & \vec{v_{2}} & \cdots & \vec{v_{N_{item}}}\end{matrix}\right]</script><p>利用矩阵$V$提取用户的特征，设特征维度为$D_u$</p><script type="math/tex; mode=display">M^u = M_{N_{user} \times N_{item}} \cdot V_{N_{item} \times D_u} \tag{5}</script><p>而</p><script type="math/tex; mode=display">V_{N_{item} \times N_{item}} = \left[\begin{matrix}    V_{N_{item} \times D_u} & | & V_{N_{item} \times (N_{item} - D_u)}\end{matrix}\right]</script><script type="math/tex; mode=display">(V_{N_{item} \times N_{item}})^T \cdot V_{N_{item} \times D_u} = \left[\begin{matrix}    I_{D_u \times D_u} \\ --- \\ O_{(N_{item} - D_u) \times D_u}\end{matrix}\right] \tag{6}</script><p>所以$(4)(6)$代入$(5)$，亦可化简为</p><script type="math/tex; mode=display">M^u = U_{N_{user} \times N_{user}} \cdot \Sigma_{N_{user} \times N_{item}} \cdot (V_{N_{item} \times N_{item}})^T \cdot V_{N_{item} \times D_u}</script><script type="math/tex; mode=display">= U_{N_{user} \times D_u} \cdot \Sigma_{D_u \times D_u} \tag{7}</script><p>现计算用户间的相似度矩阵，可用余弦度量，即</p><script type="math/tex; mode=display">s_{ij} = \frac{M^{u_iT} M^u_j}{||M^u_i|| ||M^u_j||}</script><p>或者</p><script type="math/tex; mode=display">M^u_i := \frac{M^u_i}{||M^u_i||}</script><script type="math/tex; mode=display">S_{N_{user} \times N_{user}} = M^u \cdot M^{uT} \tag{8}</script><p>对于某部电影$\text{item}^{(j)}$，先找到该用户$\text{user}^{(i)}$的最近似的几个用户$\text{user}^{(k)}, k \in {1, \cdots, N_{user} }, k \neq i$，取其均值作为该用户的评分。</p><p>若利用电影的相似度，只需</p><script type="math/tex; mode=display">M^i = (U_{N_{item} \times D_i})^T \cdot M_{N_{user} \times N_{item}} \tag{9}</script><p>以下同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">according_to_user</span><span class="params">(train_matrix, test_matrix, cols=<span class="number">80</span>, n_keep=<span class="number">50</span>)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将矩阵SVD分解</span></span><br><span class="line">    _, _, vh = np.linalg.svd(train_matrix)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 压缩原矩阵，A' = A V[:, :k]</span></span><br><span class="line">    train_compressed_col = train_matrix.dot(vh[: cols].T)   <span class="comment"># N_USERS x cols</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算相似度矩阵</span></span><br><span class="line">    similarity_user = get_cosine_similarity_matrix(train_compressed_col)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 预测</span></span><br><span class="line">    pred_matrix = np.zeros_like(test_matrix)        <span class="comment"># 保存预测结果</span></span><br><span class="line">    to_pred = np.array(np.where(test_matrix != <span class="number">0</span>))  <span class="comment"># 需要预测的数据位置, (2, n)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(to_pred.shape[<span class="number">1</span>]):</span><br><span class="line"></span><br><span class="line">        r, c = to_pred[:, i]                        <span class="comment"># r为用户索引，c为电影索引</span></span><br><span class="line"></span><br><span class="line">        id = np.argsort(similarity_user[r])[::<span class="number">-1</span>]   <span class="comment"># 将用户以相似度从大到小排序</span></span><br><span class="line">        id = id[<span class="number">1</span>: n_keep + <span class="number">1</span>]                      <span class="comment"># 获取相似度最大的几个用户，除自身</span></span><br><span class="line">        rates = train_matrix[id, c]                 <span class="comment"># 获取这几个用户对该电影的评分</span></span><br><span class="line">        rates = rates[rates!=<span class="number">0</span>]                     <span class="comment"># 已评价的数据</span></span><br><span class="line"></span><br><span class="line">        rate = np.mean(rates) <span class="keyword">if</span> rates.shape[<span class="number">0</span>] != <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        pred_matrix[r, c] = rate</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pred_matrix</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>删除停用词</title>
      <link href="/2018/10/23/%E5%88%A0%E9%99%A4%E5%81%9C%E7%94%A8%E8%AF%8D/"/>
      <url>/2018/10/23/%E5%88%A0%E9%99%A4%E5%81%9C%E7%94%A8%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.yiibai.com/python_text_processing/python_remove_stopwords.html" target="_blank" rel="noopener">删除停用词 - Python文本处理教程™</a></p></blockquote><p>停用词是对句子没有多大意义的英语单词。 在不牺牲句子含义的情况下，可以安全地忽略它们。 例如，the, he, have等等的单词已经在名为语料库的语料库中捕获了这些单词。</p><h1 id="下载语料库"><a href="#下载语料库" class="headerlink" title="下载语料库"></a>下载语料库</h1><ul><li><p>安装<code>nltk</code>模块</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install nltk</span><br></pre></td></tr></table></figure></li><li><p>下载语料库</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import nltk</span><br><span class="line">nltk.download(&#39;stopwords&#39;)</span><br></pre></td></tr></table></figure></li></ul><h1 id="使用库料库"><a href="#使用库料库" class="headerlink" title="使用库料库"></a>使用库料库</h1><ul><li><p>验证停用词</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; from nltk.corpus import stopwords</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; stopwords.words(<span class="string">'english'</span>)</span></span><br><span class="line">['i', 'me', 'my', 'myself', 'we', 'our', 'ours', 'ourselves', </span><br><span class="line">'you', "you're", "you've", "you'll", "you'd", 'your', 'yours', </span><br><span class="line">'yourself', 'yourselves', 'he', 'him', 'his', 'himself', 'she',</span><br><span class="line">"she's", 'her', 'hers', 'herself', 'it', "it's", 'its', </span><br><span class="line">'itself', 'they', 'them', 'their', 'theirs', 'themselves', </span><br><span class="line">'what', 'which', 'who', 'whom', 'this', 'that', "that'll", </span><br><span class="line">'these', 'those', 'am', 'is', 'are', 'was', 'were', 'be', </span><br><span class="line">'been', 'being', 'have', 'has', 'had', 'having', 'do', 'does', </span><br><span class="line">'did', 'doing', 'a', 'an', 'the', 'and', 'but', 'if', 'or', </span><br><span class="line">'because', 'as', 'until', 'while', 'of', 'at', 'by', 'for', </span><br><span class="line">'with', 'about', 'against', 'between', 'into', 'through', </span><br><span class="line">'during', 'before', 'after', 'above', 'below', 'to', 'from', </span><br><span class="line">'up', 'down', 'in', 'out', 'on', 'off', 'over', 'under', </span><br><span class="line">'again', 'further', 'then', 'once', 'here', 'there', 'when',</span><br><span class="line">'where', 'why', 'how', 'all', 'any', 'both', 'each', 'few', </span><br><span class="line">'more', 'most', 'other', 'some', 'such', 'no', 'nor', 'not', </span><br><span class="line">'only', 'own', 'same', 'so', 'than', 'too', 'very', 's', 't', </span><br><span class="line">'can', 'will', 'just', 'don', "don't", 'should', "should've", </span><br><span class="line">'now', 'd', 'll', 'm', 'o', 're', 've', 'y', 'ain', 'aren', </span><br><span class="line">"aren't", 'couldn', "couldn't", 'didn', "didn't", 'doesn', </span><br><span class="line">"doesn't", 'hadn', "hadn't", 'hasn', "hasn't", 'haven', </span><br><span class="line">"haven't", 'isn', "isn't", 'ma', 'mightn', "mightn't", 'mustn',</span><br><span class="line">"mustn't", 'needn', "needn't", 'shan', "shan't", 'shouldn', </span><br><span class="line">"shouldn't", 'wasn', "wasn't", 'weren', "weren't", 'won', </span><br><span class="line">"won't", 'wouldn', "wouldn't"]</span><br></pre></td></tr></table></figure><p>  除了英语之外，具有这些停用词的各种语言如下。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; stopwords.fileids()</span></span><br><span class="line">['arabic', 'azerbaijani', 'danish', 'dutch', 'english', 'finnish', </span><br><span class="line">'french', 'german', 'greek', 'hungarian', 'indonesian', 'italian', </span><br><span class="line">'kazakh', 'nepali', 'norwegian', 'portuguese', 'romanian', 'russian',</span><br><span class="line">'spanish', 'swedish', 'turkish']</span><br></pre></td></tr></table></figure></li><li><p>示例<br>  从单词列表中删除停用词。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; from nltk.corpus import stopwords</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; en_stops = <span class="built_in">set</span>(stopwords.words(<span class="string">'english'</span>))</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; all_words = [<span class="string">'There'</span>, <span class="string">'is'</span>, <span class="string">'a'</span>, <span class="string">'tree'</span>,<span class="string">'near'</span>,<span class="string">'the'</span>,<span class="string">'river'</span>]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="keyword">for</span> word <span class="keyword">in</span> all_words:</span></span><br><span class="line">if word not in en_stops:</span><br><span class="line">print(word)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">There</span><br><span class="line">tree</span><br><span class="line">near</span><br><span class="line">river</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PCA</title>
      <link href="/2018/10/22/PCA/"/>
      <url>/2018/10/22/PCA/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><code>PCA</code>全称<code>Principal Component Analysis</code>，即主成分分析，是一种常用的数据降维方法。它可以通过线性变换将原始数据变换为一组各维度线性无关的表示，以此来提取数据的主要线性分量。</p><h1 id="向量的投影"><a href="#向量的投影" class="headerlink" title="向量的投影"></a>向量的投影</h1><p>现有两个任意不共线向量$\vec{u}, \vec{v}$，将$\vec{u}$投射到$\vec{v}$上<br><img src="/2018/10/22/PCA/向量投影.jpg" alt="向量投影"></p><p>投影后，可以得到两个正交向量</p><script type="math/tex; mode=display">\vec{u}' · (\vec{u} - \vec{u}') = 0</script><p>我们设</p><script type="math/tex; mode=display">\vec{u}' = \mu \vec{v} \tag{1}</script><p>代入后有</p><script type="math/tex; mode=display">\mu \vec{v} · (\vec{u} - \mu \vec{v}) = 0</script><p>引入矩阵运算，即</p><script type="math/tex; mode=display">(\mu v)^T (u - \mu v) = 0</script><p>有</p><script type="math/tex; mode=display">v^T u = \mu v^T v</script><p>则得到$u’$以$v$为基向量的坐标</p><script type="math/tex; mode=display">\mu  = (v^T v)^{-1} v^T u \tag{2}</script><p>所以得到</p><script type="math/tex; mode=display">u' = v (v^T v)^{-1} v^T u \tag{*}</script><blockquote><ul><li><p>坐标变换求解投影向量：$u’$可视作$u$经坐标变换$u’ = P u$得到，所以</p><script type="math/tex; mode=display">P = v (v^T v)^{-1} v^T</script></li><li><p>推广至多个向量的投影，即得到</p><script type="math/tex; mode=display">P = X (X^T X)^{-1} X^T</script><p>这与<a href="https://louishsu.xyz/2018/10/18/Linear-Regression/" target="_blank" rel="noopener">线性回归</a>中得到的结论一致。</p></li></ul></blockquote><p>实际上</p><script type="math/tex; mode=display">u' = v (v^T v)^{-1} v^T u = \frac{v}{||v||} (\frac{v}{||v||})^T u</script><p>记单位向量$\frac{v}{||v||}$为$v_0$，得到</p><script type="math/tex; mode=display">u' = v_0 v_0^T u</script><p>由几何关系，可以计算得投影后的长度为</p><script type="math/tex; mode=display">d = ||u|| \cos \theta = ||u|| \frac{v^T u}{||u||||v||}= v_0^T u</script><p>所以在向量投影中，$u^T v_0$表示以$v_0$为基向量的坐标。</p><h1 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h1><p>现在有$N$维数据集$D={x^{(1)}, x^{(2)}, …, x^{(M)}}$，其中$x^{(i)} = \left[x^{(i)}_1, x^{(i)}_2, …, x^{(i)}_N\right]^T$，各维特征$D_{j}$间存在线性相关性，利用主成分分析可使</p><ul><li>数据维度降低；</li><li>提取主成分，且各成分间不相关。</li></ul><blockquote><p>说明</p><ul><li>由于选取的特征轴是正交的，所以计算结果线性无关；</li><li>提取了方差较大的几个特征，为主要线性分量。</li></ul></blockquote><p>以二维空间中的数据$x^{(i)} = \left[\begin{matrix}<br>    x^{(i)}_1 \ x^{(i)}_2<br>\end{matrix}\right]$为例，每个样本点可降至一维空间，如下图所示。<br><img src="/2018/10/22/PCA/PCA动态图.gif" alt="PCA动态图"></p><p>主轴可有无穷多种选择，那么问题就是<strong>如何选取最优的主轴</strong>。先给出<code>PCA</code>的计算步骤。</p><h2 id="计算步骤"><a href="#计算步骤" class="headerlink" title="计算步骤"></a>计算步骤</h2><p>输入的$M$个$N$维样本，有样本矩阵</p><script type="math/tex; mode=display">X_{N×M} = \left[x^{(1)}, x^{(2)}, ..., x^{(M)} \right]= \left[    \begin{matrix}        x^{(1)}_1 & x^{(2)}_1 & ... & x^{(M)}_1 \\        x^{(1)}_2 & x^{(2)}_2 & ... & x^{(M)}_2 \\        ... \\        x^{(1)}_N & x^{(2)}_N & ... & x^{(M)}_N \\    \end{matrix}\right]</script><h3 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h3><ol><li><p>对每个维度(行)进行去均值化</p><script type="math/tex; mode=display">X_j := X_j - \mu_j</script><p> 其中$\mu_j = \overline{X_j}$，$j = 1, 2, …, N$</p></li><li><p>求各维度间的协方差矩阵$\Sigma_{N×N}$</p><script type="math/tex; mode=display">\Sigma_{ij} = Cov(x_i, x_j)</script><p> 或</p><script type="math/tex; mode=display"> \Sigma = \frac{1}{M} X X^T</script><blockquote><p>注：</p><ol><li><script type="math/tex; mode=display">X X^T = \left[           \begin{matrix}   \sum_{i=1}^M x^{(i)}_1 x^{(i)}_1 &    \sum_{i=1}^M x^{(i)}_1 x^{(i)}_2 &   ... &   \sum_{i=1}^M x^{(i)}_1 x^{(i)}_N \\   \sum_{i=1}^M x^{(i)}_2 x^{(i)}_1 &    \sum_{i=1}^M x^{(i)}_2 x^{(i)}_2 &   ... &   \sum_{i=1}^M x^{(i)}_2 x^{(i)}_N \\   ... &   ... &   ... &   ... \\   \sum_{i=1}^M x^{(i)}_N x^{(i)}_1 &    \sum_{i=1}^M x^{(i)}_N x^{(i)}_2 &   ... &   \sum_{i=1}^M x^{(i)}_N x^{(i)}_N\end{matrix}\right]</script><script type="math/tex; mode=display">= \sum_{i=1}^M \left[           \begin{matrix}       x^{(i)}_1 x^{(i)}_1 &        x^{(i)}_1 x^{(i)}_2 &       ... &       x^{(i)}_1 x^{(i)}_N \\       x^{(i)}_2 x^{(i)}_1 &        x^{(i)}_2 x^{(i)}_2 &       ... &       x^{(i)}_2 x^{(i)}_N \\       ... &       ... &       ... &       ... \\       x^{(i)}_N x^{(i)}_1 &        x^{(i)}_N x^{(i)}_2 &       ... &       x^{(i)}_N x^{(i)}_N\end{matrix}\right]</script><script type="math/tex; mode=display">= \sum_{i=1}^M x^{(i)} x^{(i)T}</script></li><li><p>协方差定义式如下，这也是<strong>PCA去均值化的原因</strong></p><script type="math/tex; mode=display">   Cov(x,y)≝\frac{1}{n-1} ∑_{i=1}^n (x_i−\overline{x})^T(y_i−\overline{y})</script><p>其中$x=[x_1, x_2, …, x_n]^T, y=[y_1, y_2, …, y_n]^T$</p></li></ol></blockquote></li><li><p>求协方差矩阵$\Sigma$的特征值$λ_i$及其对应特征向量$α_i$，$i=1, …, N$；</p></li><li><p>按照特征值从大到小排列特征对$(λ_i,α_i)$，选取$K$个最大特征值对应的特征向量作为降维后的主轴$ \beta_1, \beta_2, …, \beta_K $，其中$\beta_k$为单位向量</p><script type="math/tex; mode=display">\beta_k = \left[ \beta_{k1}, \beta_{k2}, ..., \beta_{kN} \right]^T</script><p>记</p><script type="math/tex; mode=display">B_{N×K} = \left[ \beta_1, \beta_2, ..., \beta_K \right]</script><p>$K$的选取方法有如下两种：</p><ul><li>指定选取$K$个主轴</li><li>保留$99\%$的方差<script type="math/tex; mode=display">\frac{\sum_{i=1}^K \lambda_i}{\sum_{j=1}^N \lambda_j} > 0.99</script></li></ul></li></ol><ol><li><p>将样本点投射到$K$维坐标系上<br> 样本$X^{(i)}$投射到主成分轴$\beta_k$上，其坐标表示为向量，为</p><script type="math/tex; mode=display"> S^{(i)}_k = X^{(i)T}\beta_k</script><blockquote><p>注意此时的基座标为$\beta_k$，或者说$X’^{(i)} = S^{(i)} \frac{\beta_k}{||\beta_k||}$</p></blockquote><p> 所有样本在主轴$\beta_k$上的投影坐标即</p><script type="math/tex; mode=display"> S = B^T X</script><p> 其中$S_{K×M}$，$B_{N×K}$，$X_{N×M}$</p></li></ol><p>若取$K=N$，可进行数据重建，去除维度间的相关性，如下<br><img src="/2018/10/22/PCA/pca_restructure1.png" alt="pca_restructure1"><br><img src="/2018/10/22/PCA/pca_restructure2.png" alt="pca_restructure2"></p><h3 id="复原"><a href="#复原" class="headerlink" title="复原"></a>复原</h3><p>第$5$步中，样本点向量$X^{(i)}$的主要分量投射到$K$个$N$维向量上，投影坐标为$S^{(i)}_k$，即</p><script type="math/tex; mode=display">X^{(i)} \approx \sum_{k=1}^K S^{(i)}_k \beta_k</script><p>以上就是样本点的复原公式，矩阵形式即</p><script type="math/tex; mode=display">\hat{X} = BS</script><p>其中$\hat{X}_{N×M}$，$B_{N×K}$，$S_{K×M}$</p><p>考虑到已去均值化，故</p><script type="math/tex; mode=display">\hat{X}_j \approx \hat{X}_j + \mu_j</script><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><blockquote><p>投影向量的$2$范数最大，或者说，投影后的坐标平方和(方差)最大</p></blockquote><p>当所有样本$X$投射到第一主轴$\beta_1$上，其坐标为</p><script type="math/tex; mode=display">S_1 = X^T \beta_1</script><p>所有元素的平方和，或向量$S_1$的$2$范数为</p><script type="math/tex; mode=display">||S_1||_2^2 = S_1^T S_1 = \beta_1^T X X^T \beta_1 \tag{1}</script><p>即优化目标为</p><script type="math/tex; mode=display">\max ||S_1||_2^2</script><script type="math/tex; mode=display">s.t.　||\beta_1||_2^2 = 1</script><p>矩阵$C_{N \times N}=XX^T$为对称矩阵，故可单位正交化(半正定)</p><script type="math/tex; mode=display">C = W \Lambda W^T</script><script type="math/tex; mode=display">W = \left[\begin{matrix}    | & & |\\    w_1 & ... & w_N\\    | & & |\\\end{matrix}\right]　\Lambda = \left[\begin{matrix}    \lambda_1 &  & \\     & ... & \\     &  & \lambda_N\\\end{matrix}\right]</script><p>其中$\lambda_1 &gt; …&gt; \lambda_N$，$w_i(i=1,…,N)$为矩阵$C$的特征向量(单位向量，互相正交)</p><blockquote><p>实际上$R(C) \leq (n-1)$，即最多有$(n-1)$个特征值大于$0$。</p></blockquote><script type="math/tex; mode=display">||S_1||_2^2= \beta_1^T W \Lambda W^T \beta_1 \tag{2}</script><p>令$\alpha_1 = W^T \beta_1, \beta_1 = W \alpha_1$，可得</p><script type="math/tex; mode=display">||S_1||_2^2= \alpha_1^T \Lambda \alpha_1 \tag{3}</script><p>即</p><script type="math/tex; mode=display">||S_1||_2^2 = \sum_{i=1}^N \lambda_i \alpha_{1i}^2 \tag{4}</script><p>假设特征值已降序排序，那么进一步</p><script type="math/tex; mode=display">\sum_{i=1}^N \lambda_i \alpha_{1i}^2\leq \lambda_1 \sum_{i=1}^N \alpha_{1i}^2 \tag{5}</script><p>且由于$\beta_1^T\beta_1 = 1$，故</p><script type="math/tex; mode=display">1 = \beta_1^T\beta_1 = \alpha_1^T W^T W \alpha = \alpha^T \alpha = \sum_{i=1}^N \alpha_{1i}^2</script><p>可得</p><script type="math/tex; mode=display">||S_1||_2^2= \sum_{i=1}^N \lambda_i \alpha_{1i}^2\leq \lambda_1  \tag{6}</script><p>为使$(6)$取等号，即达最大值，可使</p><script type="math/tex; mode=display">\begin{cases}    \alpha_{11} = 1 \\    \alpha_{12} = ... = \alpha_{1N} = 0\end{cases}</script><p>即令</p><script type="math/tex; mode=display">\beta_1 = W \alpha_1 = w_1</script><blockquote><p>$\alpha_1 = [1, 0, …, 0]^T$</p></blockquote><p>所以$\beta_1$对应矩阵$C=XX^T$的特征向量$w_1$，且有</p><script type="math/tex; mode=display">||S_1||_2^2 = \lambda_1</script><blockquote><p>或者第一主成分的证明也可以这样，建立优化目标</p><script type="math/tex; mode=display">\beta_1 = \arg \max　||S_1||_2^2</script><script type="math/tex; mode=display">s.t.　||\beta_1||_2^2 = 1</script><p>构造<strong>拉格朗日函数</strong></p><script type="math/tex; mode=display">L(\beta_1, \lambda_1) = ||S_1||_2^2 + \lambda_1 (1 - ||\beta_1||_2^2)</script><p>也即</p><script type="math/tex; mode=display">L(\beta_1, \lambda_1) = \beta_1^T X X^T \beta_1 + \lambda_1 (1 - \beta_1^T \beta_1)</script><p>求其极值点</p><script type="math/tex; mode=display">▽_{\beta_1}L(\beta_1) = 2 X X^T \beta_1 - 2 \lambda_1 \beta_1 = 0</script><p>有</p><script type="math/tex; mode=display">X X^T \beta_1 = \lambda_1 \beta_1</script><p>可见$\beta_1$即方阵$X X^T$的特征向量</p></blockquote><p>当我们希望用更多的主成分刻画数据，如已经求得主成分$\beta_1, …, \beta_{r-1}$，现需求解$\beta_r$，引入正交约束$\beta_r^T \beta_i = 0$，即目标函数为</p><script type="math/tex; mode=display">||S_r||_2^2 = \beta_r^T C \beta_r</script><script type="math/tex; mode=display">s.t.　\beta_r^T \beta_i = 0, i = 1, ..., r-1</script><script type="math/tex; mode=display">||\beta_r||_2^2 = 1</script><p>令$\beta_r = W \alpha_r$，则</p><script type="math/tex; mode=display">||S_r||_2^2= \alpha_r^T \Lambda \alpha_r= \sum_i \lambda_i \alpha_{ri}^2 \tag{7}</script><p>而根据正交约束，$\beta_r = W \alpha_r, \beta_i = w_i$代入后有</p><script type="math/tex; mode=display">0 = \beta_r^T \beta_i = (\alpha_r^T W^T) w_i = \alpha_{ri},　i = 1, ..., r-1 \tag{8}</script><blockquote><p>$ W^T w_i = \left[0, …, 1_i, …, 0\right]^T$</p></blockquote><p>$(8)$代入$(7)$后得到</p><script type="math/tex; mode=display">||S_r||_2^2 = \sum_i \lambda_i \alpha_{ri}^2 = \lambda_r \alpha_{rr}^2 \tag{9}</script><p>又因为$\beta_r^T \beta_r = 1$(单位向量)，故</p><script type="math/tex; mode=display">\beta_r^T \beta_r = \alpha_r^T W^T W \alpha_r = \alpha_r^T \alpha_r = \sum_i \alpha_{ri}^2 = 1 \tag{10}</script><p>那么类似的，为在满足正交和单位约束下，使$(9)$取最大，取</p><script type="math/tex; mode=display">\begin{cases}    \alpha_{rr} = 1\\    \alpha_{ri} = 0,　i = 1, ..., N, i \neq r\end{cases}</script><blockquote><p>$\alpha_r = [0, …, 1_r, …, 0]$</p></blockquote><p>则此时</p><script type="math/tex; mode=display">\beta_r = W \alpha_r = w_r</script><p>且有</p><script type="math/tex; mode=display">||S_r||_2^2 = \lambda_r</script><p>证毕。</p><p><strong>证明过程总结如下</strong></p><script type="math/tex; mode=display">\begin{aligned}    \left. \begin{aligned}        \left. \begin{aligned}            ||S_1||_2^2 = S_1^T S_1 \\            S_1 = X^T \beta_1        \end{aligned} \right\} \Rightarrow        ||S_1||_2^2 = \beta_1^T \underbrace{X X^T}_C \beta_1 \\        C = X X^T = W \Lambda W^T    \end{aligned} \right\} \Rightarrow \\    \left. \begin{aligned}        ||S_1||_2^2 = \beta_1^T W \Lambda \underbrace{W^T \beta_1}_{\alpha_1} = \sum_{i=1}^N \lambda_i \alpha_{1i} \leq \lambda_1 \sum_{i=1}^N \alpha_{1i} \\        \beta_1^T \beta_1 = \alpha_1^T W^T W \alpha = \alpha_1^T \alpha = \sum_{i=1}^N \alpha_{1i} = 1(单位约束)    \end{aligned} \right\} \Rightarrow \\    ||S_1||_2^2 \leq \lambda_1 \quad 为使||S_1||_2^2极大化，取 \\    \begin{cases}        \alpha_{11} = 1\\        \alpha_{1i} = 0, i = 2, 3, \cdots, N    \end{cases} \Rightarrow     \beta_1 = W \alpha_1 = w_1\end{aligned} \tag{*1}</script><hr><script type="math/tex; mode=display">\begin{aligned}    \left. \begin{aligned}        \left. \begin{aligned}            ||S_r||_2^2 = S_r^T S_r \\            S_r = X^T \beta_r        \end{aligned} \right\} \Rightarrow        ||S_r||_2^2 = \beta_r^T \underbrace{X X^T}_C \beta_r \\        C = X X^T = W \Lambda W^T    \end{aligned} \right\} \Rightarrow \\    \left. \begin{aligned}        ||S_r||_2^2 = \beta_r^T W \Lambda \underbrace{W^T \beta_r}_{\alpha_r} = \sum_{i=1}^N \lambda_i \alpha_{ri} \\        \beta_r^T \beta_i =(W \alpha_r)^T (w_i) = \alpha_{ri} = 0, i \neq r (正交约束) \\        \beta_r^T \beta_r = \alpha_r^T W^T W \alpha = \alpha_r^T \alpha = \sum_{i=1}^N \alpha_{1i} = 1(单位约束)    \end{aligned} \right\} \Rightarrow \\    ||S_r||_2^2 = \lambda_r \alpha_{rr} \quad 为使||S_r||_2^2极大化，取 \\    \begin{cases}        \alpha_{rr} = 1 \\        \alpha_{ri} = 0, i = \neq r    \end{cases} \Rightarrow     \beta_r = W \alpha_r = w_r\end{aligned} \tag{*2}</script><h2 id="白化-whitening"><a href="#白化-whitening" class="headerlink" title="白化(whitening)"></a>白化(whitening)</h2><p><code>whitening</code>的目的是去掉数据之间的相关联度，是很多算法进行预处理的步骤。比如说当训练图片数据时，由于图片中相邻像素值有一定的关联，所以很多信息是冗余的。这时候去相关的操作就可以采用白化操作。</p><p>数据的<code>whitening</code>必须满足两个条件：</p><ol><li>不同特征间相关性最小，接近$0$；</li><li>所有特征的方差相等（不一定为$1$）。</li></ol><p>常见的白化操作有<code>PCA whitening</code>和<code>ZCA whitening</code>。</p><blockquote><p><a href="http://deeplearning.stanford.edu/wiki/index.php/Whitening" target="_blank" rel="noopener">Whitening - Ufldl</a></p></blockquote><ul><li>PCA whitening<br>  <code>PCA whitening</code>指将数据$X$经过<code>PCA</code>降维为$S$后，可以看出$S$中每一维是独立的，满足<code>whitening</code>的第一个条件，这是只需要将$S$中的每一维都除以标准差就得到了每一维的方差为$1$，也就是说方差相等。<script type="math/tex; mode=display">  X_{PCAwhite, j} = \frac{X_{rot, j}}{\sqrt{\lambda_j}}</script></li></ul><ul><li>ZCA whitening<br>  <code>ZCA whitening</code>是指数据$X$先经过<code>PCA</code>变换为$S$，但是并不降维，因为这里是把所有的成分都选进去了。这是也同样满足<code>whtienning</code>的第一个条件，特征间相互独立。然后同样进行方差为$1$的操作，最后将得到的矩阵左乘一个特征向量矩阵$U$即可。<script type="math/tex; mode=display">  X_{ZCAwhite} = U · X_{PCAwhite}</script></li></ul><h1 id="Kernel-PCA"><a href="#Kernel-PCA" class="headerlink" title="Kernel PCA"></a>Kernel PCA</h1><p><code>Kernel PCA</code>的思想是在高维的特征空间中求解协方差矩阵</p><script type="math/tex; mode=display">\Sigma = \frac{1}{M} \sum_{i=1}^M \Phi(X^{(i)}) \Phi(X^{(i)})^T</script><p>其中$\Phi(X^{(i)})$表示将样本$i$映射到高维空间后中的向量，即</p><script type="math/tex; mode=display">\Phi(X^{(i)}) = \left[ \phi^{(i)}_1, \phi^{(i)}_2, ..., \phi^{(i)}_{N'} \right]^T</script><p>其中$N’ &gt; N$，由于$\Phi(X^{(i)})$为隐式的，故设置核函数求解，记</p><script type="math/tex; mode=display">\kappa(i, j) = \Phi(X^{(i)}) \Phi(X^{(i)})^T</script><blockquote><p>关于核技巧，移步<a href="">非线性支持向量机</a></p></blockquote><p><img src="/2018/10/22/PCA/kernel_pca.jpg" alt="kernel_pca"></p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>可利用<code>PCA</code>与线性回归求解$3$维空间中平面的法向量</p><ol><li>利用<code>PCA</code>重建数据(不降维，此时为$3$维)，此时第$1, 2$主成分轴可张成所求平面，即该平面可表示为<script type="math/tex; mode=display"> \Pi = span \{ \beta_1, \beta_2 \}</script></li></ol><blockquote><p>就是说，第一、二主成分是这些点“拉伸”最大的方向 :-)，好懂不？</p></blockquote><ol><li><p>由<a href="https://louishsu.xyz/2018/10/18/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/" target="_blank" rel="noopener">正交投影</a>可知，平面外一点$y$可通过最小二乘(线性回归)的方法投射到平面上，向量运算，不考虑偏置项，即</p><script type="math/tex; mode=display"> \hat{y}  = \theta_1 x_1 + \theta_2 x_2 \tag{*}</script><p> 其中$x_1, x_2$表示第一、第二主成分$\beta_1, \beta_2$，为$3$维向量</p><script type="math/tex; mode=display"> \hat{y} = \left[     \begin{matrix}         \hat{y_1} \\         \hat{y_2} \\         \hat{y_3} \\     \end{matrix} \right]　 x_i = \left[     \begin{matrix}         x_{i1} \\         x_{i2} \\         x_{i3} \\     \end{matrix} \right]</script><p> 可利用公式求解回归参数$\theta$</p><script type="math/tex; mode=display"> \theta = (X^TX+\lambda I)^{-1} X^T y</script><blockquote><p>注意：$X(n_samples, n_features)$，这里把$(x_{1j}, x_{2j}, y_{j})作为一组样本$</p></blockquote><p> 此时该参数表示在主轴上的坐标$(\theta_1, \theta_2)$，带回$(*))$即可解得$\hat{y}$</p><script type="math/tex; mode=display"> \hat{y}  = \theta_1 \beta_1 + \theta_2 \beta_2 \tag{*}</script><p> 通俗理解，一掌把$y$拍平在了平面$\Pi$上，变成了$\hat{y}$，但是哪有这么好拍。。。这个时候刺在掌心里一定有一个垂直的向量分量，即为该平面的法向量</p><script type="math/tex; mode=display"> \vec{n} = y - \hat{y}</script><p> <strong>也可使用粗暴一点的方法，直接将第三主成分作为法向量。</strong></p><blockquote><p>或者直接上投影公式：</p><script type="math/tex; mode=display">\hat{y} = Py</script><script type="math/tex; mode=display">　P = X (X^TX+\lambda I)^{-1} X^T</script></blockquote></li></ol><pre><code>![projection](/PCA/projection.jpg)总体的运算流程如下- 利用所有样本点(近似平面)计算主成分，第一、二主成分张成平面$\Pi$；- 选出其中一个样本点，将平行于平面$\Pi$的成分投射到$\Pi$上；- 该样本点剩余分量即法向量；- 一般来说，取所有点法向量的均值。</code></pre><h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><p><a href="https://github.com/isLouisHsu/Basic-Machine-Learning-Algorithm/tree/master/Andrew%20Ng%2C%20Stanford%20University/mlclass-ex7-3-pca" target="_blank" rel="noopener">@Github: PCA</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrincipalComponentAnalysis</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n_component=<span class="number">-1</span>)</span>:</span></span><br><span class="line">        self.n_component = n_component</span><br><span class="line">        self.meanVal = <span class="keyword">None</span></span><br><span class="line">        self.axis = <span class="keyword">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X, prop=<span class="number">0.99</span>)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        the parameter 'prop' is only for 'n_component = -1'</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="comment"># 第一步: 归一化</span></span><br><span class="line">        self.meanVal = np.mean(X, axis=<span class="number">0</span>)                   <span class="comment"># 训练样本每个特征上的的均值</span></span><br><span class="line">        X_normalized = (X - self.meanVal)                   <span class="comment"># 归一化训练样本</span></span><br><span class="line">        <span class="comment"># 第二步：计算协方差矩阵</span></span><br><span class="line">        <span class="comment"># cov = X_normalized.T.dot(X_normalized)</span></span><br><span class="line">        cov = np.cov(X_normalized.T)                        <span class="comment"># 协方差矩阵</span></span><br><span class="line">        eigVal, eigVec = np.linalg.eig(cov)                 <span class="comment"># EVD</span></span><br><span class="line">        order = np.argsort(eigVal)[::<span class="number">-1</span>]                    <span class="comment"># 从大到小排序</span></span><br><span class="line">        eigVal = eigVal[order]</span><br><span class="line">        eigVec = eigVec.T[order].T</span><br><span class="line">        <span class="comment"># 选择主成分的数量</span></span><br><span class="line">        <span class="keyword">if</span> self.n_component == <span class="number">-1</span>:</span><br><span class="line">            sumOfEigVal = np.sum(eigVal)</span><br><span class="line">            sum_tmp = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(eigVal.shape[<span class="number">0</span>]):</span><br><span class="line">                sum_tmp += eigVal[k]</span><br><span class="line">                <span class="keyword">if</span> sum_tmp &gt; prop * sumOfEigVal:            <span class="comment"># 平均均方误差与训练集方差的比例尽可能小的情况下选择尽可能小的 K 值</span></span><br><span class="line">                    self.n_component = k + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 选择投影坐标轴</span></span><br><span class="line">        self.axis = eigVec[:, :self.n_component]            <span class="comment"># 选择前n_component个特征向量作为投影坐标轴</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transform</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        <span class="comment"># 第一步：归一化</span></span><br><span class="line">        X_normalized = (X - self.meanVal)                   <span class="comment"># 归一化测试样本</span></span><br><span class="line">        <span class="comment"># 第二步：投影 X_nxk · V_kxk' = X'_nxk'</span></span><br><span class="line">        X_transformed = X_normalized.dot(self.axis)</span><br><span class="line">        <span class="keyword">return</span> X_transformed</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit_transform</span><span class="params">(self, X, prop=<span class="number">0.99</span>)</span>:</span></span><br><span class="line">        self.fit(X, prop=prop)</span><br><span class="line">        <span class="keyword">return</span> self.transform(X)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transform_inv</span><span class="params">(self, X_transformed)</span>:</span></span><br><span class="line">        <span class="comment"># 视投影向量长度为一个单位长度，投影结果为投影向量上的坐标</span></span><br><span class="line">        <span class="comment"># X'_nxk' · V_kxk'.T = X''_nxk</span></span><br><span class="line">        X_restructed = X_transformed.dot(self.axis.T)</span><br><span class="line">        <span class="comment"># 还原数据</span></span><br><span class="line">        X_restructed = X_restructed + self.meanVal</span><br><span class="line">        <span class="keyword">return</span> X_restructed</span><br></pre></td></tr></table></figure><p>实验结果</p><ul><li><p>Demo1: PCA applied on 2-d datasets<br>  <img src="/2018/10/22/PCA/2d_restructed.png" alt="2d_restructed"></p></li><li><p>Demo2: PCA applied on wild face</p><ul><li>origin<br><img src="/2018/10/22/PCA/face_origin.png" alt="origin"></li><li>reduced<br><img src="/2018/10/22/PCA/face_reduced.png" alt="reduced"></li><li>restructured<br><img src="/2018/10/22/PCA/face_restructed.png" alt="restructured"></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 降维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Activate Functions</title>
      <link href="/2018/10/20/Activate-Functions/"/>
      <url>/2018/10/20/Activate-Functions/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247483977&amp;idx=1&amp;sn=401b211bf72bc70f733d6ac90f7352cc&amp;chksm=fdb69fdecac116c81aad9e5adae42142d67f50258106f501af07dc651d2c1473c52fad8678c3&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">SigAI 理解神经网络的激活函数</a><br><a href="https://www.cnblogs.com/silence-tommy/p/7113405.html" target="_blank" rel="noopener">机器学习笔记：形象的解释神经网络激活函数的作用是什么？ - 不说话的汤姆猫 - 博客园</a></p></blockquote><h1 id="激活函数的作用"><a href="#激活函数的作用" class="headerlink" title="激活函数的作用"></a>激活函数的作用</h1><h2 id="复合函数"><a href="#复合函数" class="headerlink" title="复合函数"></a>复合函数</h2><p>神经网络可以看作一个多层复合函数，以下图隐含层的激活函数为例，讲解其非线性作用。<br><img src="/2018/10/20/Activate-Functions/激活函数的非线性作用.png" alt="激活函数的非线性作用"></p><p>记激活函数为$\sigma(·)$，上图神经网络各层间具有如下关系</p><script type="math/tex; mode=display">a = \sigma(w^{(1)}_{11}x + w^{(1)}_{12}y + b^{(1)}_1)</script><script type="math/tex; mode=display">b = \sigma(w^{(1)}_{21}x + w^{(1)}_{22}y + b^{(1)}_2)</script><script type="math/tex; mode=display">c = \sigma(w^{(1)}_{31}x + w^{(1)}_{32}y + b^{(1)}_3)</script><p>输出层采用线性单元</p><script type="math/tex; mode=display">A = w^{(2)}_{1}a + w^{(2)}_{2}b + w^{(2)}_{3}c + b^{(2)}</script><!-- 或者写作复合函数$$A = w^{(2)}_{1} \sigma(w^{(1)}_{11}x + w^{(1)}_{12}y + b^{(1)}_1) +     w^{(2)}_{2} \sigma(w^{(1)}_{21}x + w^{(1)}_{22}y + b^{(1)}_2) +     w^{(2)}_{3} \sigma(w^{(1)}_{31}x + w^{(1)}_{32}y + b^{(1)}_3) +     b^{(2)}$$ --><p>为便于作图，固定参数</p><script type="math/tex; mode=display">W^{(1)} = \left[    \begin{matrix}        1   &  1 \\        0.1 & -1 \\        1   & -1    \end{matrix}\right],b^{(1)} = \left[    \begin{matrix}        -2  \\        1.5 \\        -1    \end{matrix}\right]W^{(2)} = \left[    \begin{matrix}        1 & 2 & 3    \end{matrix}\right],b^{(2)} = \left[    \begin{matrix}        -1    \end{matrix}\right]</script><ul><li><p>线性单元作为激活函数<br>  此时神经网络的输出为</p><script type="math/tex; mode=display">  A = (x + y - 2) +       2 (0.1x - y + 1.5) +       3 (x - y - 1)- 1</script><p>  可见仍为线性函数，做出图像如下所示<br>  <img src="/2018/10/20/Activate-Functions/Linear.png" alt="Linear"></p></li><li><p>非线性单元作为激活函数<br>  此时神经网络的输出为</p><script type="math/tex; mode=display">  A = \sigma(x + y - 2) +       2 \sigma(0.1x - y + 1.5) +       3 \sigma(x - y - 1)- 1</script><p>  激活函数选择<code>Sigmoid</code>，做出图像如下所示<br>  <img src="/2018/10/20/Activate-Functions/nonLinear.png" alt="nonLinear"></p></li></ul><h2 id="分割平面"><a href="#分割平面" class="headerlink" title="分割平面"></a>分割平面</h2><p>神经网络可实现逻辑运算，各个神经元视作分割超平面时，可分割出不同形状的平面，在线性和非线性激活函数时分割效果如图。当神经元组合的情况更复杂时，表达能力就会更强。<br><img src="/2018/10/20/Activate-Functions/激活函数的非线性作用.jpg" alt=""></p><h1 id="激活函数的性质"><a href="#激活函数的性质" class="headerlink" title="激活函数的性质"></a>激活函数的性质</h1><p>已经证明，只要激活函数选择得当，神经元个数足够多，使用3层即包含一个隐含层的神经网络就可以实现对任何一个从输入向量到输出向量的连续映射函数的逼近，这个结论称为万能逼近（universal approximation）定理。</p><blockquote><p>如果$\varphi(x)$是一个非常数、有界、单调递增的连续函数，$I_{m}$是$m$维的单位立方体，$I_{m}$中的连续函数空间为$C(I_{m})$。对于任意$\varepsilon&gt;0$以及函数$f\in C(I_{m})$，存在整数$N$，实数$v_{i},b_{i}$，实向量$w_{i}\in R^{m}$，通过它们构造函数$F(x)$作为函数$f$的逼近：</p><script type="math/tex; mode=display">F(x) = \sum_{i=1}^N v_i \varphi(w_i^T x + b_i)</script><p>对任意的$X\in I_{m}$满足：</p><script type="math/tex; mode=display">| F(x) - f(x) | < \varepsilon</script><p>Cybenko, G. Approximation by superpositions of a sigmoid function. Mathematics of Control, Signals, and Systems, 2, 303-314, 1989.</p></blockquote><p>这个定理对激活函数的要求是<strong>必须非常数、有界、单调递增，并且连续</strong>。</p><p>神经网络的训练使用梯度下降法进行求解，需要计算损失函数对参数的梯度值，涉及到计算激活函数的导数，因此激活函数必须是可导的。实际应用时并不要求它在定义域内处处可导，只要是几乎处处可导即可。</p><blockquote><p>定义$R$为一维欧氏空间，$E\subset R$是它的一个子集，$mE$为点集$E$的<strong>Lebesgue测度</strong>。如果$E$为$R$中的可测集，$f(x)$为定义在上$E$的实函数，如果存在$N\subset E$，满足：$mN=0$，对于任意的$x_{0}\in E/N$函数$f(x)$在$x_{0}$处都可导，则称$f(x)$在$E$上几乎处处可导。</p></blockquote><p>如果将激活函数输入值$x$看做是随机变量，则它落在这些不可导点处的概率是$0$。在计算机实现时，因此有一定的概率会落在不可导点处，但概率非常小。</p><blockquote><p>例如ReLU函数在$x=0$处不可导</p><script type="math/tex; mode=display">f(x) = \begin{cases}    x & x \geq 0 \\    0 & x < 0\end{cases}</script></blockquote><h1 id="常用的激活函数"><a href="#常用的激活函数" class="headerlink" title="常用的激活函数"></a>常用的激活函数</h1><p><img src="/2018/10/20/Activate-Functions/常用的激活函数.jpg" alt="常用的激活函数"></p>]]></content>
      
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Feedforward Neural Network</title>
      <link href="/2018/10/20/Feedforward-Neural-Network/"/>
      <url>/2018/10/20/Feedforward-Neural-Network/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前馈神经网络是一种最简单的神经网络，各神经元分层排列。每个神经元只与前一层的神经元相连。接收前一层的输出，并输出给下一层．各层间没有反馈。是目前应用最广泛、发展最迅速的人工神经网络之一，既可以用于解决分类问题，也可以用于解决回归问题。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>前馈神经网络也叫作多层感知机，包含输入层，隐含层和输出层三个部分。它的目的是为了实现输入到输出的映射。</p><script type="math/tex; mode=display">y = f(x;W)</script><p>由于各层采用了非线性激活函数，神经网络具有良好的非线性特性，如下图所示。</p><ul><li>激活函数为线性单元<br><img src="/2018/10/20/Feedforward-Neural-Network/Linear.png" alt="Linear"></li><li>激活函数为非线性单元<br><img src="/2018/10/20/Feedforward-Neural-Network/nonLinear.png" alt="nonLinear"></li></ul><p>前馈神经网络可用于解决非线性的分类或回归问题，参数通过反向传播算法<code>(Back Propagation)</code>学习。</p><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><h2 id="神经元与网络结构图"><a href="#神经元与网络结构图" class="headerlink" title="神经元与网络结构图"></a>神经元与网络结构图</h2><p>单个神经元的示意图如下，输入为前一层的输出参数$X^{(l-1)}$</p><script type="math/tex; mode=display">h_{w, b}(x) = \sigma (WX + b)</script><p>$\sigma(·)$表示激活函数。</p><p><img src="/2018/10/20/Feedforward-Neural-Network/单个神经元示意图.png" alt="单个神经元示意图"></p><p>以下为典型的神经网络结构图<br><img src="/2018/10/20/Feedforward-Neural-Network/前馈神经网络结构图.png" alt="前馈神经网络结构图"></p><ul><li>第一层为输入层<code>input layer</code>，一般不设置权值，预处理在输入网络前完成；</li><li>最后一层为输出层<code>output layer</code>；</li><li>其余层称为隐藏层<code>hidden layer</code>，隐藏层用于提取数据特征，隐藏层层数与各层神经元个数为超参数。</li></ul><blockquote><p>神经元权值取值不同，可实现不同的逻辑运算，单个超平面只能进行二元划分，利用逻辑运算可将多个超平面划分的区域拼接起来，如图<br><img src="/2018/10/20/Feedforward-Neural-Network/超平面划分区域的拼接.jpg" alt="超平面划分区域的拼接"></p><p>以下说明逻辑运算的实现方法<br><img src="/2018/10/20/Feedforward-Neural-Network/二元逻辑运算.png" alt="二元逻辑运算"><br>其中</p><script type="math/tex; mode=display">f(z) = \begin{cases}    1 & z \geq 0 \\    0 & otherwise\end{cases}</script><ul><li><p>与运算 $a ∧ b$</p><script type="math/tex; mode=display">w_1 = 20, w_2 = 20, b = -30</script></li><li><p>或运算 $a ∧ b$</p><script type="math/tex; mode=display">w_1 = 20, w_2 = 20, b = -10</script></li><li><p>非运算 $a = \overline{b}$</p><script type="math/tex; mode=display">w_1 = -20, w_2 = 0, b = 0</script></li><li><p>异或运算 $a \bigoplus b$，可通过组合运算实现</p><script type="math/tex; mode=display">a \bigoplus b = (\overline{a} ∧ b) ∨ (a ∧ \overline{b})</script></li></ul></blockquote><h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h2><ul><li><p>隐藏层的激活函数，详情可查看<a href="https://louishsu.xyz/2018/10/20/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/" target="_blank" rel="noopener">另一篇博文：神经网络的激活函数</a>；</p></li><li><p>输出层的激活函数</p><ul><li><p>回归问题时，采用线性单元即可</p><script type="math/tex; mode=display">  f(x) = x</script></li><li><p>分类问题时，一般有以下几种选择</p><ul><li><p>单类别概率输出<br>  即每个神经元的输出对应该类别的$0-1$分布输出，这就需要将输出值限制在$[0, 1]$内，例如</p><script type="math/tex; mode=display">P(y=1|x )= max\{0, min\{1, z\}\}</script><p>  <img src="/2018/10/20/Feedforward-Neural-Network/clf_linearout.png" alt="线性输出单元"></p><p>  但是可以看到，当$(w^Tx+b)$处于单位区间外时，模型的输出对它的参数的梯度都将为$0$ ，不利于网络的训练，故采用$S$形函数<code>Sigmoid</code>(<a href="https://louishsu.xyz/2018/10/18/Logistic%E5%9B%9E%E5%BD%92/" target="_blank" rel="noopener">详情</a>)</p><script type="math/tex; mode=display">  P(y=1|x ) = \frac{1}{1+e^{-(w^Tx+b)}}</script><blockquote><p>$(1)$ <code>Sigmoid</code>函数定义域为$(-\infty, \infty)$，值域为$(0, 1)$，且在整个定义域上单调递增，即为单值函数，故可将线性输出单元的结果映射到$(0, 1)$范围内；<br>$(2)$ 在定义域上处处可导。</p></blockquote></li><li><p>多类别的概率输出<br>  即每个神经元的输出对应判别为该类别的概率，且有</p><script type="math/tex; mode=display">  \sum_{i=1}^C y_i = 1</script><p>  例如</p><script type="math/tex; mode=display">  y_i = \frac{z_i}{\sum_j z_j}</script><p>  但是分式求导异常麻烦，故采用<code>Softmax</code>函数(<a href="https://louishsu.xyz/2018/10/18/softmax%E5%9B%9E%E5%BD%92/" target="_blank" rel="noopener">详情</a>)作为输出结点的激活函数，该函数求导结果比较简洁，且可利用输出计算导数，计算量减少。</p><script type="math/tex; mode=display">  Softmax(x) = \frac              {1}              {\sum_{k=1}^K exp(x_k)}              \left[                  \begin{matrix}                      exp(x_1)\\                      exp(x_2)\\                      ...\\                      exp(x_K)                  \end{matrix}              \right]</script></li></ul></li></ul></li></ul><h1 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h1><ul><li><p>回归问题<br>  常见的用于回归问题的损失函数为<code>MSE</code>，即</p><script type="math/tex; mode=display">  L(y, \hat{y}) = \frac{1}{2M} \sum_{i=1}^M (\hat{y}^{(i)} - y^{(i)})^2</script></li><li><p>分类问题<br>  一般采用交叉熵作为损失函数，如下</p><script type="math/tex; mode=display">  L(\hat{y}, y) = - \frac{1}{M} \sum_{i=1}^M 1\{y^{(i)}_j=k\}   \log (\hat{y}^{(i)}_j)</script><script type="math/tex; mode=display">  1\{y^{(i)}_j=k\} =       \begin{cases}          1 & y^{(i)}_j = k \\          0 & y^{(i)}_j \neq k       \end{cases}　j = 1, ..., N</script><p>  或者</p><script type="math/tex; mode=display">  L(\hat{y}, y) = - \frac{1}{M} \sum_{i=1}^M   y^{(i)T} \log (\hat{y}^{(i)})</script><p>  其中$y^{(i)}, \hat{y}^{(i)}$均表示向量，采用<code>one-hot</code>编码。</p></li></ul><h1 id="梯度推导"><a href="#梯度推导" class="headerlink" title="梯度推导"></a>梯度推导</h1><p>以上内容网上资料一大堆，进入重点，反向传播时的梯度推导，给出网络结构如下。</p><ul><li>回归与分类在输出层有所区别；</li><li>各层激活函数的输入变量以$z^{(l)}$表示，输出变量均以$x^{(l)}$表示；</li><li>$W^{(l)}$表示从第$l$层到第$(l+1)$层的权值矩阵，则$w^{(l)}_{ij}$表示第$l$层第$j$个神经元到$(l+1)$层第$i$个神经元的连接权值；</li><li>$b^{(l)}$表示第$l$层到第$(l+1)$层的偏置，则$b^{(l)}_i$表示到第$(l+1)$层第$i$个神经元的偏置值；</li><li>各层变量维度推广为输入$d_{i}$，中间层$d_{h}$，输出层$d_{o}$；</li><li>全连接，部分线条已省略，激活函数已省略；</li></ul><p><img src="/2018/10/20/Feedforward-Neural-Network/fnn.jpg" alt="FNN"></p><p>则各层参数矩阵为</p><script type="math/tex; mode=display">W^{(1)} = \left[        \begin{matrix}            w^{(1)}_{11} & ... & w^{(1)}_{1d_i} \\            ... & ... & ... \\            w^{(1)}_{d_h1} & ... & w^{(1)}_{d_hd_i}        \end{matrix}\right]　b^{(1)} = \left[        \begin{matrix}            b^{(1)}_{1} \\            ... \\            b^{(1)}_{d_h}        \end{matrix}\right]</script><script type="math/tex; mode=display">W^{(2)} = \left[        \begin{matrix}            w^{(2)}_{11} & ... & w^{(2)}_{1d_h} \\            ... & ... & ... \\            w^{(2)}_{d_o1} & ... & w^{(2)}_{d_od_h}        \end{matrix}\right]　b^{(2)} = \left[        \begin{matrix}            b^{(2)}_{1} \\            ... \\            b^{(2)}_{d_o}        \end{matrix}\right]</script><p>有</p><script type="math/tex; mode=display">Z^{(2)} = W^{(1)} X^{(1)} + b^{(1)}</script><script type="math/tex; mode=display">X^{(2)} = \sigma_1 (Z^{(2)})</script><script type="math/tex; mode=display">Z^{(3)} = W^{(2)} X^{(2)} + b^{(2)}</script><script type="math/tex; mode=display">X^{(3)} = \sigma_2 (Z^{(3)})</script><script type="math/tex; mode=display">X^{(1)} = X　\hat{Y} = X^{(3)}</script><h2 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a>回归问题</h2><p>损失函数采用<code>MSE</code>，即</p><script type="math/tex; mode=display">L(Y, \hat{Y}) = \frac{1}{M} \sum_{i=1}^M L(Y^{(i)}, \hat{Y}^{(i)})</script><script type="math/tex; mode=display">L(Y^{(i)}, \hat{Y}^{(i)}) = \frac{1}{2} || \hat{Y}^{(i)} - Y^{(i)} ||_2^2= \frac{1}{2} \sum_{d_2=1}^{d_o}(\hat{y}^{(i)}_{d_2} - y^{(i)}_{d_2})^2</script><p>下面推导单个样本的损失函数的梯度，该批数据的梯度为均值。</p><blockquote><p>省略样本标记<code>$^{(i)}$</code></p></blockquote><ul><li><p>隐含层到输出层</p><ul><li><p>对权值矩阵的梯度</p><script type="math/tex; mode=display">  \frac{∂L}{∂w^{(2)}_{ij}}  = \frac{∂}{∂w^{(2)}_{ij}} \frac{1}{2} \sum_{d_2=1}^{d_o} (\hat{y}_{d_2} - y_{d_2})^2</script><script type="math/tex; mode=display">  = \sum_{d_2=1}^{d_o} (\hat{y}_{d_2} - y_{d_2}) \frac{∂}{∂w^{(2)}_{ij}} \hat{y}_{d_2} \tag{1}</script><p>  其中</p><script type="math/tex; mode=display">  \begin{cases}      \hat{y}_{d_2} = \sigma_2 (z_{d_2}^{(3)}) \\      z_{d_2}^{(3)} = \sum_{d_1=1}^{d_h} w^{(2)}_{d_2 d_1} x^{(2)}_{d_1} + b^{(2)}_{d_2}  \end{cases}</script><p>  且</p><script type="math/tex; mode=display">  \frac{∂}{∂w^{(2)}_{ij}} \hat{y}_{d_2}  = \sigma_2' (z_{d_2}^{(3)}) \frac{∂z_{d_2}^{(3)}}{∂w^{(2)}_{ij}} \tag{2}</script><script type="math/tex; mode=display">  \frac{∂}{∂w^{(2)}_{ij}} z_{d_2}^{(3)} =       \begin{cases}          x^{(2)}_{d_1} & d_1 = j, d_2 = i \\          0 & otherwise      \end{cases} \tag{3}</script><p>  $(3)$代入$(2)$，再代入$(1)$可得到</p><script type="math/tex; mode=display">  \frac{∂L}{∂w^{(2)}_{ij}}  = (\hat{y}_{d_2} - y_{d_2}) \sigma_2' (z_{d_2}^{(3)}) x^{(2)}_{d_1} | _{d_1=j, d_2=i}  = (\hat{y}_{i} - y_{i}) \sigma_2' (z_{i}^{(3)}) x^{(2)}_{j} \tag{*1}</script></li><li><p>对偏置矩阵的梯度</p><script type="math/tex; mode=display">  \frac{∂L}{∂b^{(2)}_i}  = \frac{∂}{∂b^{(2)}_i} \frac{1}{2} \sum_{d_2=1}^{d_o} (\hat{y}_{d_2} - y_{d_2})^2</script><script type="math/tex; mode=display">  = \sum_{d_2=1}^{d_o} (\hat{y}_{d_2} - y_{d_2}) \frac{∂}{∂b^{(2)}_i} \hat{y}_{d_2} \tag{4}</script><p>  其中</p><script type="math/tex; mode=display">  \begin{cases}      \hat{y}_{d_2} = \sigma_2 (z_{d_2}^{(3)}) \\      z_{d_2}^{(3)} = \sum_{d_1=1}^{d_h} w^{(2)}_{d_2 d_1} x^{(2)}_{d_1} + b^{(2)}_{d_2}  \end{cases}</script><p>  有</p><script type="math/tex; mode=display">  \frac{∂}{∂b^{(2)}_i} z_{d_2}^{(3)} =       \begin{cases}          1 &  d_2 = i \\          0 & otherwise      \end{cases} \tag{5}</script><p>  所以</p><script type="math/tex; mode=display">  \frac{∂L}{∂b^{(2)}_i} = (\hat{y}_{d_2} - y_{d_2}) \sigma_2' (z_{d_2}^{(3)}) | _{d_2=i}  = (\hat{y}_{i} - y_{i}) \sigma_2' (z_i^{(3)}) \tag{*2}</script></li></ul></li><li><p>输入层到隐含层</p><ul><li><p>对权值矩阵的梯度</p><script type="math/tex; mode=display">  \frac{∂L}{∂w^{(1)}_{ij}}  = \frac{∂}{∂w^{(1)}_{ij}} \frac{1}{2} \sum_{d_2=1}^{d_o} (\hat{y}_{d_2} - y_{d_2})^2</script><script type="math/tex; mode=display">  = \sum_{d_2=1}^{d_o} (\hat{y}_{d_2} - y_{d_2}) \frac{∂}{∂w^{(1)}_{ij}} \hat{y}_{d_2} \tag{6}</script><p>  其中</p><script type="math/tex; mode=display">  \begin{cases}      \hat{y}_{d_2} = \sigma_2 (z_{d_2}^{(3)}) \\      z_{d_2}^{(3)} = \sum_{d_1=1}^{d_h} w^{(2)}_{d_2 d_1} x^{(2)}_{d_1} + b^{(2)}_{d_2} \\      x^{(2)}_{d_1} = \sigma_1 (z_{d_1}^{(2)}) \\      z_{d_1}^{(2)} = \sum_{d_0=1}^{d_i} w^{(1)}_{d_1 d_0} x^{(1)}_{d_0} + b^{(1)}_{d_1}  \end{cases}</script><p>  故</p><script type="math/tex; mode=display">  \frac{∂}{∂w^{(1)}_{ij}} \hat{y}_{d_2}  = \frac{∂\hat{y}_{d_2}}{∂z_{d_2}^{(3)}}       \frac{∂z_{d_2}^{(3)}}{∂w^{(1)}_{ij}} \tag{7}</script><p>  其中</p><script type="math/tex; mode=display">  \frac{∂\hat{y}_{d_2}}{∂z_{d_2}^{(3)}}   = \sigma_2' (z_{d_2}^{(3)})  \tag{8}</script><script type="math/tex; mode=display">  \frac{∂z_{d_2}^{(3)}}{∂w^{(1)}_{ij}}   = \sum_{d1=1}^{d_h} w^{(2)}_{d_2 d_1} \frac{∂x^{(2)}_{d_1}}{∂w^{(1)}_{ij}} \tag{9}</script><script type="math/tex; mode=display">  \frac{∂x^{(2)}_{d_1}}{∂w^{(1)}_{ij}}  = \frac{∂x^{(2)}_{d_1}}{∂z_{d_1}^{(2)}}      \frac{∂z_{d_1}^{(2)}}{∂w^{(1)}_{ij}}  \tag{10}</script><p>  而其中</p><script type="math/tex; mode=display">  \frac{∂x^{(2)}_{d_1}}{∂z_{d_1}^{(2)}} = x^{(2)}_{d_1} = \sigma_1' (z_{d_1}^{(2)}) \tag{11}</script><script type="math/tex; mode=display">  \frac{∂z_{d_1}^{(2)}}{∂w^{(1)}_{ij}} =   \begin{cases}      x^{(1)}_{d_0} & d_1 = i, d_0 = j\\      0 & otherwise  \end{cases} \tag{12}</script><p>  $(11),(12)$代入$(10)$得到</p><script type="math/tex; mode=display">  \frac{∂x^{(2)}_{d_1}}{∂w^{(1)}_{ij}} =   \sigma_1' (z_{d_1}^{(2)})      x^{(1)}_{d_0} | _{d_1 = i, d_0 = j} \tag{13}</script><p>  $(13)$代回$(9)$，有</p><script type="math/tex; mode=display">  \frac{∂z_{d_2}^{(3)}}{∂w^{(1)}_{ij}}   = \sum_{d1=1}^{d_h}   \left[      w^{(2)}_{d_2 d_1}       \sigma_1' (z_{d_1}^{(2)})      x^{(1)}_{d_0}  \right] | _{d_1 = i, d_0 = j}</script><script type="math/tex; mode=display">  = w^{(2)}_{d_2 i}       \sigma_1' (z_i^{(2)})      x^{(1)}_j \tag{14}</script><p>  将$(8),(14)$代入$(7)$得到</p><script type="math/tex; mode=display">  \frac{∂}{∂w^{(1)}_{ij}} \hat{y}_{d_2}  = \sigma_2' (z_{d_2}^{(3)})        w^{(2)}_{d_2 i}       \sigma_1' (z_i^{(2)})      x^{(1)}_j \tag{15}</script><p>  $(15)$代入$(6)$有</p><script type="math/tex; mode=display">  \frac{∂L}{∂w^{(1)}_{ij}}  = \sum_{d_2=1}^{d_o}       (\hat{y}_{d_2} - y_{d_2})            \sigma_2' (z_{d_2}^{(3)})        w^{(2)}_{d_2 i}       \sigma_1' (z_i^{(2)})      x^{(1)}_j \tag{*3}</script></li><li><p>对偏置矩阵的梯度</p><script type="math/tex; mode=display">  \frac{∂L}{∂b^{(1)}_i}  = \frac{∂}{∂b^{(1)}_i} \frac{1}{2} \sum_{d_2=1}^{d_o} (\hat{y}_{d_2} - y_{d_2})^2</script><script type="math/tex; mode=display">  = \sum_{d_2=1}^{d_o} (\hat{y}_{d_2} - y_{d_2}) \frac{∂}{∂b^{(1)}_i} \hat{y}_{d_2} \tag{16}</script><p>  同理可得</p><script type="math/tex; mode=display">  \frac{∂}{∂b^{(1)}_i} \hat{y}_{d_2}  = \sigma_2' (z_{d_2}^{(3)})        w^{(2)}_{d_2 i}       \sigma_1' (z_i^{(2)})  \tag{17}</script><p>  所以</p><script type="math/tex; mode=display">  \frac{∂L}{∂b^{(1)}_i} =  \sum_{d_2=1}^{d_o}       (\hat{y}_{d_2} - y_{d_2})            \sigma_2' (z_{d_2}^{(3)})        w^{(2)}_{d_2 i}       \sigma_1' (z_i^{(2)}) \tag{*4}</script></li></ul></li></ul><p>综上所述</p><script type="math/tex; mode=display">\frac{∂L}{∂w^{(2)}_{ij}}= (\hat{y}_{i} - y_{i})     \sigma_2' (z_{i}^{(3)}) x^{(2)}_{j}</script><script type="math/tex; mode=display">\frac{∂L}{∂b^{(2)}_i} = (\hat{y}_{i} - y_{i})     \sigma_2' (z_i^{(3)})</script><script type="math/tex; mode=display">\frac{∂L}{∂w^{(1)}_{ij}}= \sum_{d_2=1}^{d_o}     (\hat{y}_{d_2} - y_{d_2})          \sigma_2' (z_{d_2}^{(3)})     w^{(2)}_{d_2 i}     \sigma_1' (z_i^{(2)})    x^{(1)}_j</script><script type="math/tex; mode=display">\frac{∂L}{∂b^{(1)}_i} = \sum_{d_2=1}^{d_o}     (\hat{y}_{d_2} - y_{d_2})          \sigma_2' (z_{d_2}^{(3)})     w^{(2)}_{d_2 i}     \sigma_1' (z_i^{(2)})</script><p>令</p><script type="math/tex; mode=display">\begin{cases}    \delta^{(2)}_i     = (\hat{y}_{i} - y_{i})         \sigma_2' (z_i^{(3)}) \\    \delta^{(1)}_i     = \sum_{d_2=1}^{d_o}         \delta^{(2)}_{d_2}         w^{(2)}_{d_2 i}         \sigma_1' (z_i^{(2)})\end{cases}</script><p>有</p><script type="math/tex; mode=display">\begin{cases}    \frac{∂L}{∂w^{(2)}_{ij}} = \delta^{(2)}_i x^{(2)}_{j}\\    \frac{∂L}{∂b^{(2)}_i}    = \delta^{(2)}_i\\    \frac{∂L}{∂w^{(1)}_{ij}} = \delta^{(1)}_i x^{(1)}_j\\    \frac{∂L}{∂b^{(1)}_i}    = \delta^{(1)}_i\end{cases}</script><p>至此推导完毕。</p><blockquote><p>当隐藏层采用<code>Sigmoid</code>函数，输出层采用线性单元，可得到</p><script type="math/tex; mode=display">\sigma_1' (z_i^{(2)}) = \sigma_1 (z_i^{(2)})     \left[1 - \sigma_1 (z_i^{(2)}) \right]= x_i^{(2)} (1 - x_i^{(2)})</script><script type="math/tex; mode=display">\sigma_2' (z_i^{(3)}) = z_i^{(3)}</script><p>此时</p><script type="math/tex; mode=display">\begin{cases}    \frac{∂L}{∂w^{(2)}_{ij}} = (\hat{y}_{i} - y_{i}) z_i^{(3)} x^{(2)}_{j} \\    \frac{∂L}{∂b^{(2)}_i}    = (\hat{y}_{i} - y_{i}) z_i^{(3)} \\    \frac{∂L}{∂w^{(1)}_{ij}} = \sum_{d_2=1}^{d_o} \delta^{(2)}_{d_2} w^{(2)}_{d_2 i} z_i^{(2)} x^{(1)}_j \\    \frac{∂L}{∂b^{(1)}_i}    = \sum_{d_2=1}^{d_o} \delta^{(2)}_{d_2} w^{(2)}_{d_2 i} z_i^{(2)}\end{cases}</script><p>可以看到，计算梯度时使用的数据在上一次前向传播时已计算得，故可减少计算量。</p></blockquote><h2 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h2><p>损失函数采用<code>Cross Entropy</code>，即</p><script type="math/tex; mode=display">L(\hat{y}, y) = \frac{1}{M} \sum_{i=1}^M L(\hat{y}^{(i)}, y^{(i)})</script><script type="math/tex; mode=display">L(\hat{y}^{(i)}, y^{(i)}) = - y^{(i)T} \log (\hat{y}^{(i)})</script><p>上式中，$y^{(i)}, \hat{y}^{(i)}$均为列向量，且$y^{(i)}$表示<code>one-hot</code>编码后的标签向量，也可写作</p><script type="math/tex; mode=display">L(\hat{y}^{(i)}, y^{(i)})= - \log \hat{y}^{(i)}_{y^{(i)}}</script><ul><li>由该式可以看出，若输出层激活函数采用<code>Sigmoid</code>作为激活函数，则隐藏层——输出层之间权值矩阵$W^{(2)}$只会更新$w^{(i)}_{y^{(i)} d_1}, d_1 = 1, …, d_h$；</li><li>一般采用<code>SoftMax</code>作为输出层激活函数，<code>Sigmoid</code>下面不作推导。</li></ul><blockquote><p>关于<code>SoftMax</code>的梯度，移步<a href="https://louishsu.xyz/2018/10/18/Softmax-Regression/" target="_blank" rel="noopener">SoftMax Regression</a>中查看详细推导过程，这里直接给出结论。<br>对于</p><script type="math/tex; mode=display">S(x) = \frac {1} {\sum_{k=1}^K exp(x_k)} \left[ \begin{matrix} exp(x_1)\\ exp(x_2)\\ ...\\ exp(x_K) \end{matrix} \right]</script><p>其梯度为</p><script type="math/tex; mode=display">\frac{∂S(x)}{∂x_i}_{K×1} =  \left[ \begin{matrix} 0\\ ...\\ p_i\\ ...\\ 0 \end{matrix} \right] -  \left[ \begin{matrix} p_i p_1\\ ...\\ p_i^2\\ ...\\ p_i p_K \end{matrix} \right]= \left( \left[ \begin{matrix}  0 \\ ...\\ 1\\ ...\\ 0 \end{matrix} \right] - p \right)p_i</script><p>省略样本标记<code>$^{(i)}$</code></p></blockquote><ul><li><p>隐含层到输出层</p><ul><li><p>对权值矩阵的梯度</p><script type="math/tex; mode=display">  \frac{∂L}{∂w^{(2)}_{ij}}  = - \frac{∂}{∂w^{(2)}_{ij}} \log \hat{y}_{y}  = - \frac{1}{\hat{y}_y}       \frac{∂\hat{y}_{y}}{∂w^{(2)}_{ij}} \tag{18}</script><p>  其中$\hat{y}_{y}$与$z^{(3)}_{d_2}(d_2 = 1, …, d_o) $均有联系，故</p><script type="math/tex; mode=display">  \frac{∂\hat{y}_{y}}{∂w^{(2)}_{ij}}  = \sum_{d2=1}^{d_o}       \frac{∂\hat{y}_{y}}{∂z^{(3)}_{d_2}}       \frac{∂z^{(3)}_{d_2}}{∂w^{(2)}_{ij}} \tag{19}</script><p>  而</p><script type="math/tex; mode=display">  \frac{∂\hat{y}_{y}}{∂z^{(3)}_{d_2}}  = \begin{cases}      \hat{y}_{y} (1 - \hat{y}_{d_2}) & d_2 = y \\      - \hat{y}_{y} \hat{y}_{d_2} & otherwise  \end{cases}</script><script type="math/tex; mode=display">  \frac{∂z^{(3)}_{d_2}}{∂w^{(2)}_{ij}}  = \begin{cases}      x^{(2)}_{d_1} & i = d_2, j = d_1 \\      0 & otherwise  \end{cases}</script><blockquote><p>$z^{(3)}_{d_2} = \sum_{d_1=0}^{d_h} w^{(2)}_{d_2d_1} x^{(2)}_{d_1} + b^{(2)}_{d_2}$</p></blockquote><p>  代回$(19)$，再带回$(18)$，有</p><script type="math/tex; mode=display">  \frac{∂L}{∂w^{(2)}_{ij}}  = - \frac{1}{\hat{y}_{y}}       \sum_{d_2=1}^{d_o}       \frac{∂\hat{y}_{y}}{∂z^{(3)}_{d_2}}       x^{(2)}_{d_1} | _{d_2=i, d_1=j}</script><script type="math/tex; mode=display">  = \begin{cases}      - \frac{1}{\hat{y}_{y}} \hat{y}_{y} (1 - \hat{y}_i) x^{(2)}_j & i = y \\      - \frac{1}{\hat{y}_{y}} (- \hat{y}_{y} \hat{y}_i) x^{(2)}_j & otherwise  \end{cases}</script><script type="math/tex; mode=display">  = \begin{cases}      (\hat{y}_i - 1) x^{(2)}_j & i = y \\      \hat{y}_i x^{(2)}_j & otherwise  \end{cases}</script><p>  即</p><script type="math/tex; mode=display">  \frac{∂L}{∂w^{(2)}_{ij}}  = (\hat{y}_i - y_i) x^{(2)}_j \tag{*5}</script></li><li><p>对偏置矩阵的梯度</p><script type="math/tex; mode=display">  \frac{∂L}{∂b^{(2)}_i}  = \hat{y}_i - y_i \tag{*6}</script></li></ul></li><li><p>输入层到隐含层</p><ul><li><p>对权值矩阵的梯度</p><script type="math/tex; mode=display">  \frac{∂L}{∂w^{(1)}_{ij}}  = - \frac{∂}{∂w^{(1)}_{ij}} \log \hat{y}_{y}  = - \frac{1}{\hat{y}_{y}}       \frac{∂\hat{y}_{y}}{∂w^{(1)}_{ij}} \tag{20}</script><p>  其中</p><script type="math/tex; mode=display">  \frac{∂\hat{y}_{y}}{∂w^{(1)}_{ij}}  = \sum_{d_2=1}^{d_o}       \frac{∂\hat{y}_{y}}{∂z^{(3)}_{d_2}}       \frac{∂z^{(3)}_{d_2}}{∂w^{(1)}_{ij}} \tag{21}</script><p>  $\frac{∂z^{(3)}_{d_2}}{∂w^{(1)}_{ij}}$部分与回归相同，有</p><script type="math/tex; mode=display">  \frac{∂z_{d_2}^{(3)}}{∂w^{(1)}_{ij}}  = w^{(2)}_{d_2 i} \sigma_1' (z_i^{(2)}) x^{(1)}_j</script><p>  由上面分析可得</p><script type="math/tex; mode=display">  \frac{∂\hat{y}_{y}}{∂z^{(3)}_{d_2}}  = \begin{cases}      \hat{y}_{y} (1 - \hat{y}_{d_2}) & d_2 = y \\      - \hat{y}_{y} \hat{y}_{d_2} & otherwise  \end{cases}</script><p>  故代回$(20)$可得到</p><script type="math/tex; mode=display">  \frac{∂L}{∂w^{(1)}_{ij}}  = - \frac{1}{\hat{y}_{y}}      \sum_{d_2=1}^{d_o}       \frac{∂\hat{y}_{y}}{∂z^{(3)}_{d_2}}       \frac{∂z^{(3)}_{d_2}}{∂w^{(1)}_{ij}}</script><script type="math/tex; mode=display">  = - \frac{1}{\hat{y}_{y}}      \sum_{d_2=1}^{d_o}       \frac{∂\hat{y}_{y}}{∂z^{(3)}_{d_2}}       w^{(2)}_{d_2 i} \sigma_1' (z_i^{(2)}) x^{(1)}_j</script><script type="math/tex; mode=display">  = \left[       \sum_{d_2=1, d_2 \neq y}^{d_o} \hat{y}_{d_2} w^{(2)}_{d_2 i} +       (\hat{y}_y - 1) w^{(2)}_{y i}   \right] \sigma_1' (z_i^{(2)}) x^{(1)}_j</script><script type="math/tex; mode=display">  = \left[       \sum_{d_2=1}^{d_o} \hat{y}_{d_2} w^{(2)}_{d_2 i} -       w^{(2)}_{y i}  \right] \sigma_1' (z_i^{(2)}) x^{(1)}_j \tag{*7}</script></li><li><p>对偏置矩阵的梯度</p><script type="math/tex; mode=display">  \frac{∂L}{∂b^{(1)}_i}  = \left[       \sum_{d_2=1}^{d_o} \hat{y}_{d_2} w^{(2)}_{d_2 i} -       w^{(2)}_{y i}  \right] \sigma_1' (z_i^{(2)}) \tag{*8}</script></li></ul></li></ul><p>至此推导完毕。</p><blockquote><p>这个推导，仅供参考</p></blockquote><h1 id="过拟合问题"><a href="#过拟合问题" class="headerlink" title="过拟合问题"></a>过拟合问题</h1><p>和其他算法一样，前馈神经网络也存在过拟合的问题，解决方法有以下几种</p><ul><li><p>正则化<br>  与线性回归类似，神经网络也可以加入范数惩罚项，以下$C$表示普通的损失函数，$\lambda$为惩罚系数，$n$为样本数目，$w$表示权值参数。</p><ul><li><code>L1</code>正则化<br>  惩罚项为网络所有权值的绝对值之和。<script type="math/tex; mode=display">  C = C_0 + \frac{\lambda}{n} \sum_w |w|</script></li><li><code>L2</code>正则化<br>  又称权值衰减<code>weights decay</code>，惩罚项为网络所有权值的平方和。<script type="math/tex; mode=display">  C = C_0 + \frac{\lambda}{2n} \sum_w w^2</script></li></ul></li><li><p>Dropout<br>  以概率大小为<code>p</code>使部分神经元输出值直接为0，如此可以使反向传播时相关权值系数不做更新，只有被保留下来的权值和偏置值会被更新。<br>  <img src="/2018/10/20/Feedforward-Neural-Network/dropout_1.png" alt="dropout_1"><br>  <img src="/2018/10/20/Feedforward-Neural-Network/dropout_2.png" alt="dropout_2"></p></li><li><p>增加训练数据大小<br>  可在原数据上加以变换或噪声，图像的扩增方法可查看<a href="https://louishsu.xyz/2018/11/02/%E5%9B%BE%E5%83%8F%E6%95%B0%E6%8D%AE%E9%9B%86%E6%89%A9%E5%A2%9E-Augment-%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">图像数据集扩增</a>。</p></li></ul><h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><p><a href="https://github.com/isLouisHsu/Python-Examples-for-PyTorch-Tutorial/blob/master/NeuralNetwork_ANN_MNIST.py" target="_blank" rel="noopener">@Github: Code of Neural Network</a></p><p>使用<code>PyTorch</code>实现神经网络，以下为模型定义<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnNet</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(AnnNet, self).__init__()</span><br><span class="line">        self.input_size = <span class="number">28</span> * <span class="number">28</span></span><br><span class="line">        self.hidden_size = <span class="number">100</span></span><br><span class="line">        self.output_size = <span class="number">10</span></span><br><span class="line">        self.fc1 = nn.Linear(self.input_size,  self.hidden_size)    <span class="comment"># input   - hidden</span></span><br><span class="line">        self.fc2 = nn.Linear(self.hidden_size, self.output_size )   <span class="comment"># hidden  - output</span></span><br><span class="line">        <span class="comment"># self.activate = nn.Sigmoid()  # 参数更新非常慢，特别是层数多时</span></span><br><span class="line">        self.activate = nn.ReLU()       <span class="comment"># 事实证明ReLU作为激活函数更加合适</span></span><br><span class="line">        self.softmax = nn.Softmax()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        h = self.activate(self.fc1(X))</span><br><span class="line">        y_pred = self.softmax(self.fc2(h))</span><br><span class="line">        <span class="keyword">return</span> y_pred</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分类问题的决策平面</title>
      <link href="/2018/10/19/%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%E7%9A%84%E5%86%B3%E7%AD%96%E5%B9%B3%E9%9D%A2/"/>
      <url>/2018/10/19/%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%E7%9A%84%E5%86%B3%E7%AD%96%E5%B9%B3%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>对于分类问题，计算结果一般为概率值，那么如何根据计算得的概率进行判别分类呢？</p><blockquote><p>这部分理解后，<a href="https://louishsu.xyz/2018/10/18/Logistic-Regression/" target="_blank" rel="noopener">Logistic回归</a>与<a href="https://louishsu.xyz/2018/10/18/Softmax-Regression/" target="_blank" rel="noopener">Softmax回归</a>的模型就很容易推得。</p></blockquote><h1 id="判别函数"><a href="#判别函数" class="headerlink" title="判别函数"></a>判别函数</h1><p>对于一个类别为$K$的分类问题，如果对于所有的$ i,j=1,…,K, j\neq i$，有</p><script type="math/tex; mode=display">g_i(x) > g_j(x)</script><p>则此分类器将这个样本对应的特征向量$x$判别为$w_i$，则此分类器的作用是，计算$K$个判别函数并选取与最大判别值最大对应的类别。</p><blockquote><p>判别函数的形式并不唯一，可以将所有的判别函数乘上相同的正常数或者加上一个相同的常量而不影响其判决结果。更一般的情况下，我们使用单调递增函数$f(·)$进行映射，将每一个$g_i(x)$替换成$f(g_i(x))$，分类结果不变。</p><div style="text-align: right"> ——《模式识别原理与应用课程笔记》</div></blockquote><p>例如<a href="https://louishsu.xyz/2018/10/18/Bayes-Decision/" target="_blank" rel="noopener">最小风险贝叶斯决策</a></p><h1 id="正态分布下的判别函数"><a href="#正态分布下的判别函数" class="headerlink" title="正态分布下的判别函数"></a>正态分布下的判别函数</h1><blockquote><p><a href="https://www.cnblogs.com/bingjianing/p/9117330.html" target="_blank" rel="noopener">多元高斯分布（The Multivariate normal distribution） - bingjianing - 博客园</a></p></blockquote><p>由大数定理可知，在样本足够的情况下，数据服从正态分布。多元正态分布形式如下</p><script type="math/tex; mode=display">f(x) = \frac{1}{ (2\pi)^{\frac{n}{2}} |\Sigma|^{\frac{1}{2}}} exp(-\frac{1}{2} (x-\mu)^T \Sigma^{-1} (x-\mu))</script><p>其中</p><script type="math/tex; mode=display">x = [x_1, ..., x_n]^T</script><script type="math/tex; mode=display">\mu = [\mu_1, ..., \mu_n]^T</script><script type="math/tex; mode=display">\Sigma_{ij} = cov(x_i, x_j)</script><!-- $$\Sigma =  \left[​    \begin{matrix}​        1 & 2 & 3 \\​        4 & 5 & 6 \\​        7 & 8 & 9​    \end{matrix}\right] \tag{3}$$ --><p>在<a href="https://louishsu.xyz/2018/10/19/%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%E7%9A%84%E5%86%B3%E7%AD%96%E5%B9%B3%E9%9D%A2/" target="_blank" rel="noopener">最小错误率判别</a>时</p><script type="math/tex; mode=display">g_i(x) = P(x|c_i)P(c_i)</script><p>即</p><script type="math/tex; mode=display">g_i(x) = \frac{1}{ (2\pi)^{\frac{n}{2}} |\Sigma_i|^{\frac{1}{2}}}exp(-\frac{1}{2} (x-\mu_i)^T \Sigma^{-1} (x-\mu_i)) ·P(c_i)</script><p>取对数运算，并舍去常数项，展开整理得</p><script type="math/tex; mode=display">g_i(x) = -\frac{1}{2}x^T \Sigma_i ^{-1} x + \mu_i^T \Sigma_i ^{-1} x  -\frac{1}{2} \mu_i ^T \Sigma_i ^{-1} \mu_i + ln P(c_i) \tag{0}</script><blockquote><p><strong>注</strong>： 协方差矩阵 $ \Sigma^T = \Sigma $</p></blockquote><h2 id="独立同分布-Sigma-i-sigma-2-I"><a href="#独立同分布-Sigma-i-sigma-2-I" class="headerlink" title="独立同分布: $\Sigma_i = \sigma^2 I$"></a>独立同分布: $\Sigma_i = \sigma^2 I$</h2><p>$\Sigma_i^{-1} = \frac{1}{\sigma^2} I$代入$(0)$，有</p><script type="math/tex; mode=display">g_i(x) = \frac{1}{\sigma^2}\mu_i^T x - \frac{1}{2\sigma^2} (x^Tx + \mu_i ^T \mu_i) + ln P(c_i)\tag{1}</script><p>定义</p><script type="math/tex; mode=display">w_i = \frac{1}{\sigma^2}\mu_i^T</script><script type="math/tex; mode=display">w_0 =  - \frac{1}{2\sigma^2} (x^Tx + \mu_i ^T \mu_i) + ln P(c_i)</script><p>有一般形式如下，表示取$c_i$的概率</p><script type="math/tex; mode=display">g_i(x) = w_i x + w_0\tag{2}</script><p>设决策平面为</p><script type="math/tex; mode=display">w^T (x−x_0)=0\tag{3}</script><p>决策平面上，取$c_i$和$c_j$的概率相等，即</p><script type="math/tex; mode=display">g_i(x) = g_j(x)</script><p>可得</p><script type="math/tex; mode=display">(\mu_i - \mu_j)^Tx = \frac{1}{2} (\mu_i ^T \mu_i - \mu_j ^T \mu_j) -ln \frac{P(c_i)}{P(c_j)} \tag{4}</script><blockquote><p>推导过程如下，将$(1)$代入上式<br>$ \frac{1}{\sigma^2}\mu_i^T x - \frac{1}{2\sigma^2} (x^Tx + \mu_i ^T \mu_i) + ln P(c_i) = \frac{1}{\sigma^2}\mu_j^T x - \frac{1}{2\sigma^2} (x^Tx + \mu_j ^T \mu_j) + ln P(c_j) $<br>$ \mu_i^T x - \frac{1}{2} \mu_i ^T \mu_i + ln P(c_i) = \mu_j^T x - \frac{1}{2} \mu_j ^T \mu_j + ln P(c_j) $<br>$ (\mu_i - \mu_j)^Tx = \frac{1}{2} (\mu_i ^T \mu_i - \mu_j ^T \mu_j) -ln \frac{P(c_i)}{P(c_j)} $</p></blockquote><p>由$(3)$$(4)$，利用待定系数法，可得</p><script type="math/tex; mode=display">w = \mu_i - \mu_j</script><script type="math/tex; mode=display">w^T x_0 = \frac{1}{2} (\mu_i ^T \mu_i - \mu_j ^T \mu_j) -ln \frac{P(c_i)}{P(c_j)}</script><p>特别地，当等先验概率时，即$P(c_i) = P(c_j)$时</p><script type="math/tex; mode=display">w^T x_0 = \frac{1}{2} (\mu_i ^T \mu_i - \mu_j ^T \mu_j)</script><p>故</p><script type="math/tex; mode=display">x_0 = \frac{1}{2}(\mu_i + \mu_j)</script><p>结论：等先验概率时超平面$ w^T (x−x_0)=0 $平分判别空间</p><blockquote><p>$\mu_i$与$\mu_j$分别表示两个类别的中心，由向量运算，$x_0$为两类中心的连线的中点。</p></blockquote><h2 id="不独立但同分布-Sigma-i-Sigma"><a href="#不独立但同分布-Sigma-i-Sigma" class="headerlink" title="不独立但同分布: $\Sigma_i = \Sigma$"></a>不独立但同分布: $\Sigma_i = \Sigma$</h2><p>代入$(0)$后可得</p><script type="math/tex; mode=display">g_i(x) =  \mu_i^T \Sigma ^{-1} x - \frac{1}{2}x^T \Sigma ^{-1} x   -\frac{1}{2} \mu_i ^T \Sigma ^{-1} \mu_i + ln P(c_i) \tag{5}</script><p>定义</p><script type="math/tex; mode=display">w_i = \mu_i^T \Sigma ^{-1}</script><script type="math/tex; mode=display">w_0 = - \frac{1}{2}x^T \Sigma ^{-1} x   -\frac{1}{2} \mu_i ^T \Sigma ^{-1} \mu_i + ln P(c_i)</script><p>有一般形式如下，表示取$c_i$的概率</p><script type="math/tex; mode=display">g_i(x) = w_i x + w_0\tag{6}</script><p>同样的，设决策平面为</p><script type="math/tex; mode=display">w^T (x−x_0)=0\tag{7}</script><p>决策平面上，取$c_i$和$c_j$的概率相等，即</p><script type="math/tex; mode=display">g_i(x) = g_j(x)</script><p>有</p><script type="math/tex; mode=display">(\mu_i - \mu_j)^T \Sigma ^{-1} x = \frac{1}{2} (\mu_i - \mu_j)^T \Sigma ^{-1} (\mu_i - \mu_j) - ln \frac{P(c_i)}{P(c_j)}</script><blockquote><p>$ \mu_i^T \Sigma ^{-1} x - \frac{1}{2}x^T \Sigma ^{-1} x   -\frac{1}{2} \mu_i ^T \Sigma ^{-1} \mu_i + ln P(c_i) = \mu_j^T \Sigma ^{-1} x - \frac{1}{2}x^T \Sigma ^{-1} x   -\frac{1}{2} \mu_j ^T \Sigma ^{-1} \mu_j + ln P(c_j) $<br>$ \mu_i^T \Sigma ^{-1} x -\frac{1}{2} \mu_i ^T \Sigma ^{-1} \mu_i + ln P(c_i) = \mu_j^T \Sigma ^{-1} x -\frac{1}{2} \mu_j ^T \Sigma ^{-1} \mu_j + ln P(c_j) $<br>$ (\mu_i - \mu_j)^T \Sigma ^{-1} x = \frac{1}{2} (\mu_i ^T \Sigma ^{-1} \mu_i + \mu_j ^T \Sigma ^{-1} \mu_j) - ln \frac{P(c_i)}{P(c_j)} $</p></blockquote><p>特别的，当取等先验概率时</p><script type="math/tex; mode=display">(\mu_i - \mu_j)^T \Sigma ^{-1} x = \frac{1}{2} (\mu_i ^T \Sigma ^{-1} \mu_i + \mu_j ^T \Sigma ^{-1} \mu_j)</script><p>由$(7)$$(8)$，利用待定系数法</p><script type="math/tex; mode=display">w^T = (\mu_i - \mu_j)^T \Sigma^{-1}</script><script type="math/tex; mode=display">w^T x_0 = \frac{1}{2} (\mu_i ^T \Sigma ^{-1} \mu_i + \mu_j ^T \Sigma ^{-1} \mu_j)</script><blockquote><p><code>注：</code> 协方差矩阵 $ \Sigma^T = \Sigma $</p></blockquote><script type="math/tex; mode=display">w = \Sigma^{-1}(\mu_i - \mu_j)</script><script type="math/tex; mode=display">x_0 = \frac{1}{2} (\mu_i + \mu_j)</script><p>由于通常$w=Σ^{−1}(μ_i−μ_j)$并非朝着$(μ_i−μ_j)$的方向，因而通常分离两类的超平面也并非与均值的连线垂直正交。但是， 如果先验概率相等，其判定面确实是与均值连线交于中点$x_0$处的。如果先验概率不等，最优边界超平面将远离可能性较大的均值。同前，如果偏移量足够大，判定面可以不落在两个均值向量之间。</p><h2 id="不独立且不同分布-Sigma-i-Sigma-i-∀"><a href="#不独立且不同分布-Sigma-i-Sigma-i-∀" class="headerlink" title="不独立且不同分布: $\Sigma_i = \Sigma_i(∀) $"></a>不独立且不同分布: $\Sigma_i = \Sigma_i(∀) $</h2><script type="math/tex; mode=display">g_i(x) =  -\frac{1}{2}x^T \Sigma_i ^{-1} x + \mu_i^T \Sigma_i ^{-1} x  -\frac{1}{2} \mu_i ^T \Sigma_i ^{-1} \mu_i + ln P(c_i)</script><p>定义</p><script type="math/tex; mode=display">W_i = -\frac{1}{2} \Sigma_i ^{-1}</script><script type="math/tex; mode=display">w_i = \mu_i^T \Sigma_i ^{-1}</script><script type="math/tex; mode=display">w_0 = -\frac{1}{2} \mu_i ^T \Sigma_i ^{-1} \mu_i + ln P(c_i)</script><p>有</p><script type="math/tex; mode=display">g_i(x) = x^TW_ix + w_ix + w_0</script>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Bayes Decision</title>
      <link href="/2018/10/18/Bayes-Decision/"/>
      <url>/2018/10/18/Bayes-Decision/</url>
      
        <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>基于贝叶斯公式</p><script type="math/tex; mode=display">P(c_k|x)=\frac{p(x|c_k)P(c_k)}{p(x)}</script><script type="math/tex; mode=display">P(x)=\sum_j p(x|c_j)P(c_j)</script><h1 id="几种常用的贝叶斯决策"><a href="#几种常用的贝叶斯决策" class="headerlink" title="几种常用的贝叶斯决策"></a>几种常用的贝叶斯决策</h1><h2 id="最小错误率贝叶斯决策"><a href="#最小错误率贝叶斯决策" class="headerlink" title="最小错误率贝叶斯决策"></a>最小错误率贝叶斯决策</h2><p>在分类问题中，我们往往希望尽可能减少分类错误，即目标是追求最小错误率。假设有$K$分类问题，由贝叶斯公式</p><script type="math/tex; mode=display">P(c_k|x)=\frac{p(x|c_k)P(c_k)}{p(x)}</script><p>上式中$ k=1,…,K  $，各部分定义如下</p><blockquote><p>$P(c_k|x)$——<code>后验概率(posteriori probability)</code><br>$P(c_k)$——<code>先验概率(priori probability)</code>，<br>$p(x|c_k)$——$c_k$关于$x$的<code>似然函数(likelihood)</code>，<br>$p(x)$——<code>证据因子(evidence)</code>，</p></blockquote><p>证据因子由下式计算</p><script type="math/tex; mode=display">p(x)=\sum_{j=0}^K p(x|c_j)P(c_j)</script><p>以上就是从样本中训练的参数，在预测阶段，定义决策规则为</p><blockquote><p>$if$ $P(c_i|x)&gt;P(c_j|x)$, $then$ $ x \in c_i $</p></blockquote><p>由于分母为标量，对于任意输入的样本特征$x$，$P(x)$一定，故决策规则可简化为</p><blockquote><p>$if$ $P(x|c_i)P(c_i)&gt;P(x|c_j)P(c_j)$, $then$ $ x \in c_i $</p></blockquote><p>而对于分类错误的样本，如样本$x$属于分类$c_i$，但错误分类为$c_{err}, err \neq i$，样本的错误分类概率为</p><script type="math/tex; mode=display">P(error|x) = P(c_{err}|x)</script><p>上式被称作<code>误差概率</code>，某类后验概率越大，则相应的误差概率就越小，定义平均误差概率</p><script type="math/tex; mode=display">P_{mean} = \int P(error|x)P(x)dx</script><h2 id="带有拒绝域的最小错误率贝叶斯决策"><a href="#带有拒绝域的最小错误率贝叶斯决策" class="headerlink" title="带有拒绝域的最小错误率贝叶斯决策"></a>带有拒绝域的最小错误率贝叶斯决策</h2><p>一些情况下，某样本对应特征$x$计算结果中，属于各类别的概率没有显著比较大的数值，换句话说都比较小，那么对这次的判别就不太信任，选择拒绝决策结果。<br>将决策平面划分为两个区域</p><script type="math/tex; mode=display">Acquired = \{x|max_j P(c_j|x)\geq 1-t\}</script><script type="math/tex; mode=display">Rejected = \{x|max_j P(c_j|x) < 1-t\}</script><p>其中$t$为阈值，$t$越小时，拒绝域$Rejected$越大，当满足</p><script type="math/tex; mode=display">1-t \leq \frac{1}{K}</script><p>或者 </p><script type="math/tex; mode=display">t \geq \frac{K-1}{K}</script><p>此时拒绝域为</p><script type="math/tex; mode=display">Rejected = \{x|max_j P(c_j|x) < \frac{1}{K}\}</script><p>而当且仅当各分类概率相等时才有 $ max_j P(c_j|x) = \frac{1}{K} $，因此此时拒绝域为空，接受所有决策结果</p><h2 id="最小风险贝叶斯决策"><a href="#最小风险贝叶斯决策" class="headerlink" title="最小风险贝叶斯决策"></a>最小风险贝叶斯决策</h2><p>在决策过程中，不同类型的决策错误所产生的代价是不同的。引入风险函数</p><script type="math/tex; mode=display">\lambda_{i, j} = \lambda (\alpha_i|c_j)</script><p>表示实际类别为$c_j$时，采取错误判断为$c_i$的行为$\alpha_i$所产生的损失。该函数称为损失函数，通常它可以用表格的形式给出，叫做决策表，形如<br><img src="/2018/10/18/Bayes-Decision/decision_table.jpg" alt="决策表"><br>定义条件风险</p><script type="math/tex; mode=display">R(\alpha_i|c_j) = \sum_j \lambda (\alpha_i|c_j) P(c_j|x)</script><p>特别地，取$0-1$损失时，即最小错误率贝叶斯决策</p><script type="math/tex; mode=display">\lambda (\alpha_i|c_j) = \begin{cases}0 & i = j \\1 & i \neq j\end{cases}</script><!-- $$函数名 = \begin{cases}公式1 & 条件1 \\公式2 & 条件2 \\公式3 & 条件3 \end{cases}$$--><p>可能比较抽象，这里举了一个例子</p><div style="align: center"><img src="/2018/10/18/Bayes-Decision/最小风险贝叶斯决策例.png"></div><h1 id="关于判别函数"><a href="#关于判别函数" class="headerlink" title="关于判别函数"></a>关于判别函数</h1><p>可查看<a href="https://louishsu.xyz/2018/10/19/%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%E7%9A%84%E5%86%B3%E7%AD%96%E5%B9%B3%E9%9D%A2/" target="_blank" rel="noopener">分类问题的决策平面</a></p><h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><p><img src="/2018/10/18/Bayes-Decision/李航-例4.1.png" alt="例4.1"></p><p>为帮助理解，先手动计算一遍结果</p><blockquote><p>先验概率(<code>priori probability</code>):<br>$ P(Y = -1) = \frac{6}{15} $<br>$ P(Y = 1) = \frac{9}{15} $<br>似然函数(<code>likelihood</code>)<br>$ P(X^{(1)} = 1|Y=-1) = \frac{3}{6}$<br>$ P(X^{(1)} = 2|Y=-1) = \frac{2}{6}$<br>$ P(X^{(1)} = 3|Y=-1) = \frac{1}{6}$<br>$ P(X^{(2)} = S|Y=-1) = \frac{3}{6}$<br>$ P(X^{(2)} = M|Y=-1) = \frac{2}{6}$<br>$ P(X^{(2)} = L|Y=-1) = \frac{1}{6}$<br>$ P(X^{(1)} = 1|Y=1) = \frac{2}{9}$<br>$ P(X^{(1)} = 2|Y=1) = \frac{3}{9}$<br>$ P(X^{(1)} = 3|Y=1) = \frac{4}{9}$<br>$ P(X^{(2)} = S|Y=1) = \frac{1}{9}$<br>$ P(X^{(2)} = M|Y=1) = \frac{4}{9}$<br>$ P(X^{(2)} = L|Y=1) = \frac{4}{9}$</p></blockquote><p>注意：证据因子(<code>evidence</code>)不能用如下朴素贝叶斯求解</p><script type="math/tex; mode=display">P(X) = P(X^{(1)}) P(X^{(2)})</script><p>而是</p><script type="math/tex; mode=display">P(X) =  P(X^{(1)}|Y=-1)P(Y = -1) + P(X^{(2)}|Y=-1)P(Y = -1)</script><p>一般分子用朴素贝叶斯求解</p><script type="math/tex; mode=display">P(X|Y) = P(X^{(1)}|Y) P(X^{(2)}|Y)</script><p>将其加和作为分母</p><script type="math/tex; mode=display">c_k: P(X)_k = \sum_{k=0}^2 P(X^{(1)}|Y=k) P(X^{(2)}|Y=k)</script><script type="math/tex; mode=display">P(Y_k|X) = \frac{P(X|Y_k)P(Y_k)}{P(X)_k}</script><p>选取最大概率的$ k $类别作为判别类别</p><script type="math/tex; mode=display">k = argmax_k P(Y_k|X)</script><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://github.com/isLouisHsu/Python-Examples-for-ML/blob/master/Statistical%20Learning%20Method%2C%20Li%20Hang/naive_bayes_algorithm_demo.py" target="_blank" rel="noopener">@Github: Code for Naive Bayes Decision</a></p><h3 id="training-step"><a href="#training-step" class="headerlink" title="training step"></a>training step</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X, y)</span>:</span></span><br><span class="line">    X_encoded = self.featureEncoder.fit_transform(X).toarray()</span><br><span class="line">    y_encoded = OneHotEncoder().fit_transform(y.reshape((<span class="number">-1</span>, <span class="number">1</span>))).toarray()</span><br><span class="line">    self.P_X = np.mean(X_encoded, axis=<span class="number">0</span>)                           <span class="comment"># one-hot编码下，各列的均值即各特征的概率</span></span><br><span class="line">    self.P_Y = np.mean(y_encoded, axis=<span class="number">0</span>)                           <span class="comment"># one-hot编码下，各列的均值即各了别的概率</span></span><br><span class="line">    self.n_labels, self.n_features = y_encoded.shape[<span class="number">1</span>], X_encoded.shape[<span class="number">1</span>]   </span><br><span class="line">    self.P_X_Y = np.zeros(shape=(self.n_labels, self.n_features))   <span class="comment"># 各个类别下，分别统计各特征的概率</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(self.n_labels):</span><br><span class="line">        X_encoded_of_yi = X_encoded[y_encoded[:, i]==<span class="number">1</span>]             <span class="comment"># 取出属于i类别的样本</span></span><br><span class="line">        self.P_X_Y[i] = np.mean(X_encoded_of_yi, axis=<span class="number">0</span>)            <span class="comment"># one-hot编码下，各列的均值即各特征的概率</span></span><br></pre></td></tr></table></figure><h3 id="predict-step"><a href="#predict-step" class="headerlink" title="predict step"></a>predict step</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, X)</span>:</span></span><br><span class="line">    X_encoded = self.featureEncoder.transform(X).toarray()</span><br><span class="line">    n_samples = X_encoded.shape[<span class="number">0</span>]</span><br><span class="line">    y_pred_prob = np.zeros(shape=(n_samples, self.n_labels))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n_samples):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(self.n_labels):</span><br><span class="line">            P_Xi_encoded_Yj = X_encoded[i] * self.P_X_Y[j]          <span class="comment"># 在Yj类别下，选出输入样本Xi对应的条件概率</span></span><br><span class="line">            P_Xi_encoded_Yj[P_Xi_encoded_Yj==<span class="number">0.0</span>] = <span class="number">1.0</span>             <span class="comment"># 将为0值替换为1，便于求解ΠP(Xi|yc)，只要将各元素累乘即可</span></span><br><span class="line">            y_pred_prob[i, j] = self.P_Y[j] * P_Xi_encoded_Yj.prod()</span><br><span class="line">        y_pred_prob[i] /= np.sum(y_pred_prob[i])                    <span class="comment"># 分母一般是将分子加和，不能假定各特征独立并用朴素贝叶斯计算分母</span></span><br><span class="line">    <span class="keyword">return</span> np.argmax(y_pred_prob, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">X = [</span><br><span class="line">    [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="number">0</span>], [<span class="number">2</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">3</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">1</span>], [<span class="number">3</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br><span class="line">y = [<span class="number">0</span> ,<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">estimator = NaiveBayes()</span><br><span class="line">estimator.fit(X, y)</span><br><span class="line"></span><br><span class="line">X_test = np.array([[<span class="number">2</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line">y_pred = estimator.predict(X_test)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Softmax Regression</title>
      <link href="/2018/10/18/Softmax-Regression/"/>
      <url>/2018/10/18/Softmax-Regression/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="http://ufldl.stanford.edu/tutorial/supervised/SoftmaxRegression/" target="_blank" rel="noopener">Unsupervised Feature Learning and Deep Learning Tutorial</a></p></blockquote><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><code>Logistic Regression</code>中采用的非线性函数为<code>Sigmoid</code>，将输出值映射到$(0, 1)$之间作为概率输出，处理的是二分类问题，那么对于多分类的问题怎么处理呢？</p><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><blockquote><p>由<a href="https://louishsu.xyz/2018/10/18/Logistic%E5%9B%9E%E5%BD%92/" target="_blank" rel="noopener">Logistic回归</a>推广而来</p></blockquote><h2 id="Softmax"><a href="#Softmax" class="headerlink" title="Softmax"></a>Softmax</h2><p><code>Softmax</code>在机器学习和深度学习中有着非常广泛的应用。尤其在处理多分类$(K&gt;2)$问题，分类器最后的输出单元需要<code>Softmax</code>函数进行数值处理。</p><script type="math/tex; mode=display">S(x) = \frac            {1}            {\sum_{k=1}^K exp(x_k)}            \left[                \begin{matrix}                    exp(x_1)\\                    exp(x_2)\\                    ...\\                    exp(x_K)                \end{matrix}            \right]</script><p>其中$x$为矩阵形式的向量，其维度为$(K×1)$，$K$为类别数目。<code>Softmax</code>的输出向量维度与$x$相同，各元素$x_i$加和为$1$，可用于表示取各个类别的概率。</p><p>注意到，对于函数$e^x$</p><script type="math/tex; mode=display">\lim_{x \rightarrow - \infty} e^x = 0</script><script type="math/tex; mode=display">\lim_{x \rightarrow + \infty} e^x = +\infty</script><blockquote><p>假设所有的$x_i$等于某常数$c$，理论上对所有$x_i$上式结果为$\frac{1}{n}$</p><ul><li>若$c$为很小的负数，$e^c$下溢，结果为$NaN$；</li><li>若$c$量级很大，$e^c$上溢，结果为$NaN$。</li></ul></blockquote><p>在数值计算时并不稳定，但是<code>Softmax</code>所有输入增加同一常数时，输出不变，得稳定版本：</p><script type="math/tex; mode=display">S(x) := S(x - max(x_i))</script><blockquote><script type="math/tex; mode=display">e^{x_{max} - max(x_i)} = 1</script><ul><li>减去最大值导致$e^x$最大为$1$，排除上溢；</li><li>分母中至少有一项为$1$，排除分母下溢导致处以$0$的情况。</li></ul><p>其对数</p><script type="math/tex; mode=display">log S(x)_i = x_i - log ({\sum_{k=1}^K exp(x_k)})</script><ul><li>注意到，第一项表示输入$x_i$总是对代价函数有直接的贡献。这一项不会饱和，所以即使$x_i$对上式的第二项的贡献很小，学习依然可以进行；</li><li>当最大化对数似然时，第一项鼓励$x_i$被推高，而第二项则鼓励所有的$x$被压低；</li><li>第二项$log ({\sum_{k=1}^K exp(x_k)})$可以大致近似为$max(x_k)$，这种近似是基于对任何明显小于$max(x_k)$的$x_k$都是不重要的，<strong>负对数似然代价函数总是强烈地惩罚最活跃的不正确预测</strong></li><li>除了对数似然之外的许多目标函数对 softmax 函数不起作用。具体来说，那些不使用对数来抵消 softmax 中的指数的目标函数，当指数函数的变量取非常小的负值时会造成梯度消失，从而无法学习</li></ul><hr><p>作者：NirHeavenX<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/qsczse943062710/article/details/61912464" target="_blank" rel="noopener">https://blog.csdn.net/qsczse943062710/article/details/61912464</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p></blockquote><h2 id="Softmax解决多分类问题"><a href="#Softmax解决多分类问题" class="headerlink" title="Softmax解决多分类问题"></a>Softmax解决多分类问题</h2><p>对于具有$K$个分类的问题，每个类别训练一组参数$ w_k $</p><script type="math/tex; mode=display">z_k^{(i)} = w_k^Tx^{(i)}</script><p>或写作矩阵形式</p><script type="math/tex; mode=display">z^{(i)} = W^Tx^{(i)}</script><p>其中</p><script type="math/tex; mode=display">x^{(i)} =     \left[        \begin{matrix}            x_0^{(i)}\\            x_1^{(i)}\\            ...\\            x_n^{(i)}        \end{matrix}    \right]_{n×1},x_0^{(i)}=1</script><script type="math/tex; mode=display">W = [w_1, w_2, ..., w_K]_{(n+1)×K}</script><script type="math/tex; mode=display">w_i =     \left[        \begin{matrix}            w_{i0}\\            w_{i1}\\            ...\\            w_{in}        \end{matrix}    \right]_{n×1}</script><p>最终各类别输出概率为</p><script type="math/tex; mode=display">\hat{y}^{(i)} = Softmax(z^{(i)})</script><blockquote><p><strong>产生了一个奇怪的脑洞。。。</strong><br>二分类问题</p><script type="math/tex; mode=display">p(x_1) = \frac{ e^{x_1} }{ e^{x_1} + e^{x_2} } = \frac{ 1 }{ 1 + e^{ - (x_1 - x_2) } }</script><p>定义二分类线性单元输出的差值为</p><script type="math/tex; mode=display">z = x_1 - x_2</script><p>得到</p><script type="math/tex; mode=display">p(x_1) = \frac{1}{1 + e^{-z}}</script><p>以$x_1 = [x_{11}, x_{12}]^T$为例(二维特征)，取$w_1=1, w_2=2, b=3$</p><script type="math/tex; mode=display">p(x_1) = \frac{1}{1 + e^{-(w_1 x_{11} + w_2 x_{12} + b)}}</script><p><img src="/2018/10/18/Softmax-Regression/Sigmoid_2dim.png" alt="特征为2时的决策平面"></p><p>而多分类问题，以$3$分类为例</p><script type="math/tex; mode=display">p(x_1) = \frac{ e^{x_1} }{ e^{x_1} + e^{x_2} + e^{x_3}} = \frac{ 1 }{ 1 + e^{ - (x_1 - x_2) } + e^{ - (x_1 - x_3)} }</script><p>定义线性单元输出的差值为</p><script type="math/tex; mode=display">z_{12} = x_1 - x_2</script><script type="math/tex; mode=display">z_{13} = x_1 - x_3</script><script type="math/tex; mode=display">p(x_1) = \frac{ 1 }{ 1 + e^{ - z_{12} } + e^{ - z_{13}} }</script><p>做出图像为<br><img src="/2018/10/18/Softmax-Regression/3D_sigmoid_1.png" alt="3D_sigmoid_1"><br><img src="/2018/10/18/Softmax-Regression/3D_sigmoid_2.png" alt="3D_sigmoid_2"></p></blockquote><h1 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h1><h2 id="由交叉熵理解"><a href="#由交叉熵理解" class="headerlink" title="由交叉熵理解"></a>由交叉熵理解</h2><script type="math/tex; mode=display">CrossEnt = \sum_j p_j log \frac{1}{q_j}</script><p>而对于样本$ (X^{(i)}, y^{(i)}) $，为确定事件，故标签概率各元素的取值$p_j$为$ y^{(i)}_j ∈ {0,1}$，$ q_j即预测输出的概率值\hat{y}^{(i)}_j$</p><p>一般取各个样本损失的均值$(\frac{1}{N})$</p><script type="math/tex; mode=display">L(\hat{y}, y) = - \frac{1}{N} \sum_{i=1}^N 1\{y^{(i)}_j=k\} log (\hat{y}^{(i)}_j)</script><script type="math/tex; mode=display">1\{y^{(i)}_j=k\} =     \begin{cases}        1 & y^{(i)}_j = k \\        0 & y^{(i)}_j \neq k     \end{cases}</script><p>可对实际标签$y^{(i)}$采取<code>One-Hot</code>编码，便于计算</p><script type="math/tex; mode=display">y^{(i)} = \left[         \begin{matrix}            0, ..., 1_{y^{(i)}}, ..., 0        \end{matrix}     \right]^T</script><p>则</p><script type="math/tex; mode=display">L(\hat{y}, y) = - \frac{1}{N} \sum_{i=1}^N y^{(i)T}log (\hat{y}^{(i)})</script><blockquote><p>实际上，由熵定义</p><script type="math/tex; mode=display">H(p) = \sum_x p(x) \log \frac{1}{p(x)}</script><p>交叉熵为</p><script type="math/tex; mode=display">H(p, q) = \sum_x p(x) \log \frac{1}{q(x)}</script><p>K-L散度为</p><script type="math/tex; mode=display">D_{KL}(p || q) = \sum_x p(x) \log \frac{p(x)}{q(x)}</script><p>也即</p><script type="math/tex; mode=display">D_{KL}(p || q) = H(p, q) - H(p)</script><p>常常用于衡量两个概率分布$p(x), q(x)$之间的差异。而对于固定的数据集，$H(p)$为常熟，故最小化交叉熵$H(p, q)$实际上为最小化K-L散度$D_{KL}(p || q)$。</p></blockquote><h2 id="由决策平面理解"><a href="#由决策平面理解" class="headerlink" title="由决策平面理解"></a>由决策平面理解</h2><p>从<a href="https://louishsu.xyz/2018/10/18/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%86%B3%E7%AD%96/" target="_blank" rel="noopener">贝叶斯决策</a>和<a href="https://louishsu.xyz/2018/10/19/%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%E7%9A%84%E5%86%B3%E7%AD%96%E5%B9%B3%E9%9D%A2/" target="_blank" rel="noopener">分类问题的决策平面</a>可知，对于类别$c_i$，有</p><script type="math/tex; mode=display">P(c_i|x) = \frac{P(x|c_i)}{\sum_{j=0}^KP(x|c_j)}</script><blockquote><p>假设每个类别的样本服从正态分布，先验概率相等，各类别样本特征间协方差相等。证明略.</p></blockquote><h1 id="梯度推导"><a href="#梯度推导" class="headerlink" title="梯度推导"></a>梯度推导</h1><h2 id="Softmax函数的导数"><a href="#Softmax函数的导数" class="headerlink" title="Softmax函数的导数"></a>Softmax函数的导数</h2><p>对于</p><script type="math/tex; mode=display">S(x) = \frac            {1}            {\sum_{k=1}^K exp(x_k)}            \left[                \begin{matrix}                    exp(x_1)\\                    exp(x_2)\\                    ...\\                    exp(x_K)                \end{matrix}            \right]</script><p>一般输出作为概率值，记</p><script type="math/tex; mode=display">P = S(x)</script><script type="math/tex; mode=display">p_i = S(x)_i</script><p>对向量$x$中某元素求导</p><script type="math/tex; mode=display">\frac{∂S(x)}{∂x_i} = \frac{∂}{∂x_i}                    \left[                        \begin{matrix}                            ...\\                            \frac{exp(x_k)}{\sum_{j=1}^K exp(x_j)}\\                            ...\\                        \end{matrix}                    \right]</script><blockquote><p>$(1)$ $i=k$<br>$<br>\frac{∂}{∂x_i} \frac{exp(x_i)}{\sum_{j=1}^K exp(x_j)}$<br>$ = \frac{exp’(x_i)·\sum_{j=1}^K exp(x_j) - exp(x_i)·(\sum_{j=1}^K exp(x_j))’}<br>{(\sum_{j=1}^K exp(x_j))^2}$<br>$ = \frac{exp(x_i)·\sum_{j=1}^K exp(x_j) - exp^2(x_i)}<br>{(\sum_{j=1}^K exp(x_j))^2}$<br>$ = \frac{exp(x_i)}{\sum_{j=1}^K exp(x_j)} -<br>(\frac{exp(x_i)}{\sum_{j=1}^K exp(x_j)})^2<br>$<br>$ = p_i (1 - p_i)<br>$</p><p>$(2)$ $i\neq k$<br>$<br>\frac{∂}{∂x_i} \frac{exp(x_k)}{\sum_{j=1}^K exp(x_j)}$<br>$ = \frac{exp’(x_k)·\sum_{j=1}^K exp(x_j) - exp(x_k)·(\sum_{j=1}^K exp(x_j))’}<br>{(\sum_{j=1}^K exp(x_j))^2}$<br>$ = \frac{- exp(x_k)exp(x_i)}<br>{(\sum_{j=1}^K exp(x_j))^2}$<br>$= - p_i p_k$</p><p>综上</p><script type="math/tex; mode=display">\frac{∂S(x)}{∂x_i}_{K×1} =  \left[                          \begin{matrix}                              0\\                              ...\\                              p_i\\                              ...\\                              0                           \end{matrix}                      \right] -                       \left[                          \begin{matrix}                                p_i p_1\\                                ...\\                                p_i^2\\                                ...\\                                p_i p_K                            \end{matrix}                      \right]=     \left(                      \left[                          \begin{matrix}                              0\\                              ...\\                              1\\                              ...\\                              0                           \end{matrix}                      \right] -                       p      \right)p_i</script></blockquote><h2 id="损失函数梯度"><a href="#损失函数梯度" class="headerlink" title="损失函数梯度"></a>损失函数梯度</h2><p>在<code>OneHot</code>编码下，损失函数形式为</p><script type="math/tex; mode=display">L(\hat{y},y) = \frac{1}{N} \sum_{i=1}^N L (y^{(i)}, \hat{y}^{(i)})</script><script type="math/tex; mode=display">L (y^{(i)}, \hat{y}^{(i)}) = - y^{(i)T}log \hat{y}^{(i)}</script><script type="math/tex; mode=display">\hat{y}^{(i)} = S(z^{(i)})</script><script type="math/tex; mode=display">z^{(i)} = W^T x^{(i)}</script><p>即只考虑实际分类对应的概率值</p><script type="math/tex; mode=display">L (y^{(i)}, \hat{y}^{(i)}) = - log \hat{y}^{(i)}_{y^{(i)}}</script><blockquote><p>由于 $S(z^{(i)})_{t^{(i)}}$与$z^{(i)}$向量各个元素都有关，由链式求导法则</p><script type="math/tex; mode=display">\frac{∂ L^{(i)} }{∂w_{pq}} = - \frac{1}{ \hat{y}^{(i)}_{y^{(i)}} } (\sum_{k=1}^K  \frac{∂ \hat{y}^{(i)}_{y^{(i)}} }{∂z^{(i)}_k}  \frac{∂z^{(i)}_k}{∂w_{pq}})</script><p>$1.$ 考察 $\frac{∂ \hat{y}^{(i)}_{y^{(i)}} }{∂z^{(i)}_k}$</p><script type="math/tex; mode=display">  \frac{∂ \hat{y}^{(i)}_{y^{(i)}} }{∂z^{(i)}_k} = ​      \begin{cases}​          \hat{y}^{(i)}_{y^{(i)}} (1 - \hat{y}^{(i)}_k) & k=y^{(i)} \\​          - \hat{y}^{(i)}_{y^{(i)}} \hat{y}^{(i)}_k & k \neq y^{(i)} ​      \end{cases}</script><p>$2.$ 考察 $\frac{∂z^{(i)}_k}{∂w_{pq}}$</p><script type="math/tex; mode=display">  \frac{∂z^{(i)}_k}{∂w_{pq}} =       \begin{cases}            \frac{∂z^{(i)}_k}{∂w_{pq}} = x^{(i)}_p & k=q\\            \frac{∂z^{(i)}_k}{∂w_{pq}} = 0 & k \neq q        \end{cases}</script></blockquote><p>综上所述</p><script type="math/tex; mode=display">\frac{∂ L^{(i)} }{∂w_{pq}} = - \frac{1}{ \hat{y}^{(i)}_{y^{(i)}} }   \frac{∂ \hat{y}^{(i)}_{y^{(i)}} }{∂z^{(i)}_q}  \frac{∂z^{(i)}_q}{∂w_{pq}}</script><p>其中</p><script type="math/tex; mode=display">\frac{∂ \hat{y}^{(i)}_{y^{(i)}} }{∂z^{(i)}_q}= \begin{cases}        \hat{y}^{(i)}_{y^{(i)}} (1 - \hat{y}^{(i)}_q) & q = y^{(i)}\\        - \hat{y}^{(i)}_{y^{(i)}} \hat{y}^{(i)}_q & q \neq y^{(i)}    \end{cases}</script><script type="math/tex; mode=display">\frac{∂z^{(i)}_q}{∂w_{pq}} = x^{(i)}_p</script><p>故对于单个样本$(X^{(i)}, y^{(i)})$，当样本标签采用$OneHot$编码时</p><script type="math/tex; mode=display">\frac{∂L^{(i)}}{∂w_{pq}}  = - \frac{1}{ \hat{y}^{(i)}_{y^{(i)}} }   \frac{∂ \hat{y}^{(i)}_{y^{(i)}} }{∂z^{(i)}_q}  x^{(i)}_p= \begin{cases}    (\hat{y}^{(i)}_q - 1)x^{(i)}_p & q = y^{(i)}\\    \hat{y}^{(i)}_qx^{(i)}_p & q \neq y^{(i)}\end{cases}</script><blockquote><p>注： 这里可以约分去掉$\hat{y}^{(i)}_{y^{(i)}}$</p></blockquote><script type="math/tex; mode=display">\frac{∂L^{(i)}}{∂w_{pq}} = ( \hat{y}^{(i)}_q - y^{(i)}_q) x^{(i)}_p</script><p>更一般的，写成矩阵形式，记$X = [x_1, x_2, …, x_m]^T$，$x_i$为样本特征(列向量)</p><script type="math/tex; mode=display">∇_W L = X^T(\hat{Y} - Y)</script><blockquote><p><strong>用线性模型解决分类和回归问题时，形式竟如此统一!</strong></p></blockquote><p>至此为止，梯度推导结束，利用梯度下降法迭代求解参数矩阵$W$即可。</p><script type="math/tex; mode=display">W := W - \alpha ∇_W L</script><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://github.com/isLouisHsu/Basic-Machine-Learning-Algorithm/tree/master/Andrew%20Ng%2C%20Stanford%20University/mlclass-ex3-2-softmax_regression" target="_blank" rel="noopener">@GitHub: Code of Softmax Regression</a></p><h2 id="Softmax-1"><a href="#Softmax-1" class="headerlink" title="Softmax"></a>Softmax</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">softmax</span><span class="params">(X)</span>:</span></span><br><span class="line">    <span class="string">""" 数值计算稳定版本的softmax函数</span></span><br><span class="line"><span class="string">    @param &#123;ndarray&#125; X: shape(batch_size, n_labels)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    X_max = np.max(X, axis=<span class="number">1</span>).reshape((<span class="number">-1</span>, <span class="number">1</span>))  <span class="comment"># 每行的最大值</span></span><br><span class="line">    X = X - X_max                        <span class="comment"># 每行减去最大值</span></span><br><span class="line">    X = np.exp(X)</span><br><span class="line">    <span class="keyword">return</span> X / np.sum(X, axis=<span class="number">1</span>).reshape((<span class="number">-1</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><h2 id="cost-function"><a href="#cost-function" class="headerlink" title="cost function"></a>cost function</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crossEnt</span><span class="params">(self, y_label_true, y_prob_pred)</span>:</span></span><br><span class="line">    <span class="string">""" 计算交叉熵损失函数</span></span><br><span class="line"><span class="string">    @param &#123;ndarray&#125; y_label_true: 真实标签 shape(batch_size,)</span></span><br><span class="line"><span class="string">    @param &#123;ndarray&#125; y_prob_pred: 预测输出 shape(batch_size, n_labels)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    mask = self.encoder.transform(y_label_true.reshape(<span class="number">-1</span>, <span class="number">1</span>)).toarray()  <span class="comment"># shape(batch_size, n_labels)</span></span><br><span class="line">    y_prob_masked = np.sum(mask * y_prob_pred, axis=<span class="number">1</span>)          <span class="comment"># 每行真实标签对应的预测输出值</span></span><br><span class="line">    y_prob_masked[y_prob_masked==<span class="number">0.</span>] = <span class="number">1.</span></span><br><span class="line">    y_loss = np.log(y_prob_masked)</span><br><span class="line">    loss = - np.mean(y_loss)                                    <span class="comment"># 求各样本损失的均值</span></span><br><span class="line">    <span class="keyword">return</span> loss</span><br></pre></td></tr></table></figure><h2 id="gradient"><a href="#gradient" class="headerlink" title="gradient"></a>gradient</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grad</span><span class="params">(self, X_train, y_train, y_prob_pred)</span>:</span></span><br><span class="line">    <span class="string">""" 计算梯度 \frac &#123;∂L&#125; &#123;∂W_&#123;pq&#125;&#125;</span></span><br><span class="line"><span class="string">    @param X_train: 训练集特征</span></span><br><span class="line"><span class="string">    @param y_train: 训练集标签</span></span><br><span class="line"><span class="string">    @param y_prob_pred:  训练集预测概率输出</span></span><br><span class="line"><span class="string">    @param y_label_pred: 训练集预测标签输出</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    y_train = self.encoder.transform(y_train)</span><br><span class="line">    dW = X_train.T.dot(y_prob_pred - y_train)</span><br><span class="line">    <span class="keyword">return</span> dW</span><br></pre></td></tr></table></figure><h2 id="training-step"><a href="#training-step" class="headerlink" title="training step"></a>training step</h2><p>省略可视化和验证部分的代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X_train, X_valid, y_train, y_valid, min_acc=<span class="number">0.95</span>, max_epoch=<span class="number">20</span>, batch_size=<span class="number">20</span>)</span>:</span></span><br><span class="line">    <span class="string">""" 训练</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 添加首1列，输入到偏置w0</span></span><br><span class="line">    X_train = np.c_[np.ones(shape=(X_train.shape[<span class="number">0</span>],)), X_train]</span><br><span class="line">    X_valid = np.c_[np.ones(shape=(X_valid.shape[<span class="number">0</span>],)), X_valid]</span><br><span class="line">    X_train = self.scaler.fit_transform(X_train)    <span class="comment"># 尺度归一化</span></span><br><span class="line">    X_valid = self.scaler.transform(X_valid)        <span class="comment"># 尺度归一化</span></span><br><span class="line">    self.encoder.fit(y_train.reshape(<span class="number">-1</span>, <span class="number">1</span>))</span><br><span class="line">    self.n_features = X_train.shape[<span class="number">1</span>]</span><br><span class="line">    self.n_labels = self.encoder.transform(y_train).shape[<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 初始化参数</span></span><br><span class="line">    self.W = np.random.normal(loc=<span class="number">0</span>, scale=<span class="number">1.0</span>, size=(self.n_features, self.n_labels))</span><br><span class="line">    n_batch = X_train.shape[<span class="number">0</span>] // batch_size</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 可视化相关</span></span><br><span class="line">    plt.ion()</span><br><span class="line">    plt.figure(<span class="string">'loss'</span>); plt.figure(<span class="string">'accuracy'</span>)</span><br><span class="line">    loss_train_epoch = []; loss_valid_epoch = []</span><br><span class="line">    acc_train_epoch = [];  acc_valid_epoch = []</span><br><span class="line">    <span class="keyword">for</span> i_epoch <span class="keyword">in</span> range(max_epoch):</span><br><span class="line">        <span class="keyword">for</span> i_batch <span class="keyword">in</span> range(n_batch):              <span class="comment"># 批处理梯度下降</span></span><br><span class="line">            n1, n2 = i_batch * batch_size, (i_batch + <span class="number">1</span>) * batch_size</span><br><span class="line">            X_train_batch, y_train_batch = X_train[n1: n2], y_train[n1: n2]</span><br><span class="line">            <span class="comment"># 预测</span></span><br><span class="line">            y_prob_train = self.predict(X_train_batch, preprocessed=<span class="keyword">True</span>)</span><br><span class="line">            <span class="comment"># 计算损失</span></span><br><span class="line">            loss_train_batch = self.crossEnt(y_train_batch, y_prob_train)</span><br><span class="line">            <span class="comment"># 计算准确率</span></span><br><span class="line">            y_label_train = np.argmax(y_prob_train, axis=<span class="number">1</span>)</span><br><span class="line">            a = y_train_batch.reshape((<span class="number">-1</span>,))</span><br><span class="line">            acc_train_batch = np.mean((y_label_train == y_train_batch.reshape((<span class="number">-1</span>,))).astype(<span class="string">'float'</span>))</span><br><span class="line">            <span class="comment"># 计算梯度 dW</span></span><br><span class="line">            dW = self.grad(X_train_batch, y_train_batch, y_prob_train)</span><br><span class="line">            <span class="comment"># 更新参数</span></span><br><span class="line">            self.W -= self.lr * dW</span><br></pre></td></tr></table></figure></p><h2 id="predict-step"><a href="#predict-step" class="headerlink" title="predict step"></a>predict step</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, X, preprocessed=False)</span>:</span></span><br><span class="line">    <span class="string">""" 对输入的样本进行预测，输出标签</span></span><br><span class="line"><span class="string">    @param &#123;ndarray&#125; X: shape(batch_size, n_features)</span></span><br><span class="line"><span class="string">    @return &#123;ndarray&#125; y_prob: probability, shape(batch_size, n_labels)</span></span><br><span class="line"><span class="string">            &#123;ndarray&#125; y_label: labels, shape(batch_size,)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> preprocessed:    <span class="comment"># 训练过程中调用此函数时，不用加首1列</span></span><br><span class="line">        X = np.c_[np.ones(shape=(X.shape[<span class="number">0</span>],)), X]              <span class="comment"># 添加首1项，输入到偏置w0</span></span><br><span class="line">    X = self.scaler.transform(X)</span><br><span class="line"></span><br><span class="line">    y_prob = softmax(X.dot(self.W))                             <span class="comment"># 预测概率值 shape(batch_size, n_labels)</span></span><br><span class="line">    <span class="keyword">return</span> y_prob</span><br></pre></td></tr></table></figure><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>以下蓝线为训练集参数，红线为验证集参数，若稳定训练(如<code>batch_size = 20</code>的结果)，最终准确率在$80\%$左右。</p><blockquote><ul><li>由于<code>随机梯度下降(SGD)</code>遍历次数太多，运行较慢，没有用<code>SGD</code>方法训练，就前几个<code>epoch</code>来看，效果没有<code>batch_size = 20</code>的好；</li><li>添加隐含层形成三层结构的<code>前馈神经网络</code>，可提高准确率；</li><li>还有一点，使用<code>批处理梯度下降(n_batch = 1)</code>训练时，可以看到损失值已经趋于$0$，但准确率却很低，说明已经陷入局部最优解。</li></ul></blockquote><ul><li><p>batch size = 20</p><ul><li>损失<br><img src="/2018/10/18/Softmax-Regression/loss_batchsize_20.png" alt="loss_batchsize_20"></li><li>准确率<br><img src="/2018/10/18/Softmax-Regression/accuracy_batchsize_20.png" alt="accuracy_batchsize_20"></li></ul></li><li><p>batch_size = 200</p><ul><li>损失<br><img src="/2018/10/18/Softmax-Regression/loss_batchsize_200.png" alt="loss_batchsize_200"></li><li>准确率<br><img src="/2018/10/18/Softmax-Regression/accuracy_batchsize_200.png" alt="accuracy_batchsize_200"></li></ul></li><li><p>n_batch = 1</p><ul><li>损失<br><img src="/2018/10/18/Softmax-Regression/loss_batch_1.png" alt="loss_batch_1"></li><li>准确率<br><img src="/2018/10/18/Softmax-Regression/accuracy_batch_1.png" alt="accuracy_batch_1"></li></ul></li></ul><h1 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h1><p>推公式要我老命。。。。</p><p><code>Softmax</code>回归可以视作<strong>不含隐含层的<a href="https://louishsu.xyz/2018/10/20/Feedforward-Neural-Network/" target="_blank" rel="noopener">前馈神经网络</a></strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Logistic Regression</title>
      <link href="/2018/10/18/Logistic-Regression/"/>
      <url>/2018/10/18/Logistic-Regression/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>逻辑回归（Logistic Regression）是用于处理因变量为分类变量的回归问题，常见的是二分类或二项分布问题，也可以处理多分类问题，它实际上是属于一种分类方法。</p><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><p>先给出模型，推导过程稍后给出，逻辑回归包含<code>Sigmoid</code>函数</p><script type="math/tex; mode=display">f(z) = \frac{1}{1+e^{-z}}</script><p>其图像如下<br><img src="/2018/10/18/Logistic-Regression/Sigmoid.png" alt="`Sigmod函数`"></p><p>定义</p><script type="math/tex; mode=display">z = w^Tx</script><p>其中$x=[x_0, x_1, …, x_n]^T, x_0=1$</p><script type="math/tex; mode=display">h_w(x) = g(z) =  \frac{1}{1+e^{-z}}</script><h1 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h1><h2 id="由最大似然估计推导"><a href="#由最大似然估计推导" class="headerlink" title="由最大似然估计推导"></a>由最大似然估计推导</h2><p>对于二元分类问题，其取值作为随机变量，服从二项分布 $B(1, p)$，其中$p$即为预测输出概率$\hat{y}$</p><script type="math/tex; mode=display">P(y^{(i)}) = (\hat{y}^{(i)})^{y^{(i)}}(1-\hat{y}^{(i)})^{1-y^{(i)}}</script><p>由极大似然估计</p><script type="math/tex; mode=display">L = \prod_{i=1}^N P(y^{(i)}) = \prod_{i=1}^N (\hat{y}^{(i)})^{y^{(i)}}(1-\hat{y}^{(i)})^{1-y^{(i)}}</script><p>取对数似然函数</p><script type="math/tex; mode=display">logL = \sum_{i=1}^N [y^{(i)} log \hat{y}^{(i)} + (1-y^{(i)}) log (1-\hat{y}^{(i)})]</script><p>优化目标是</p><script type="math/tex; mode=display">w = argmax_w logL</script><p>优化问题一般表述成<code>minimize</code>问题，添加负号，构成<code>Neg Log Likelihood</code>损失</p><script type="math/tex; mode=display">w = argmin_w (-logL)</script><p>一般取均值</p><script type="math/tex; mode=display">L(\hat{y}, y)=- \frac{1}{N} \sum_i [y^{(i)} log(\hat{y}^{(i)})+(1 - y^{(i)})log(1-\hat{y}^{(i)})]</script><p>其中$y$表示真实值，$\hat{y}$表示预测值</p><h2 id="从交叉熵理解"><a href="#从交叉熵理解" class="headerlink" title="从交叉熵理解"></a>从交叉熵理解</h2><p>已知交叉熵<code>cross entropy</code>定义如下</p><script type="math/tex; mode=display">CrossEnt = \sum_i p_i log \frac{1}{q_i}</script><p>而对于样本$ (X_i, y_i) $，为确定事件，故标签概率的取值为$ p_i = y_i ∈ {0,1}$，$ q_i即预测输出的概率值\hat{y}_i $，可得到与上面相同的推导结论</p><h2 id="从决策平面和贝叶斯决策理解"><a href="#从决策平面和贝叶斯决策理解" class="headerlink" title="从决策平面和贝叶斯决策理解"></a>从决策平面和贝叶斯决策理解</h2><blockquote><p>相关内容查看<a href="https://louishsu.xyz/2018/10/19/%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%E7%9A%84%E5%86%B3%E7%AD%96%E5%B9%B3%E9%9D%A2/" target="_blank" rel="noopener">分类问题的决策平面</a>和<a href="https://louishsu.xyz/2018/10/18/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%86%B3%E7%AD%96/" target="_blank" rel="noopener">贝叶斯决策</a>，逻辑回归考虑的一般是等先验概率问题，故决策函数定义为</p><script type="math/tex; mode=display">if \quad P(c_i|x)>P(c_j|x) \quad then \quad x \in c_i, \quad i, j = 1, 2</script></blockquote><p>从贝叶斯决策可知，对于类别$c_1$，有</p><script type="math/tex; mode=display">P(c_1|x) = \frac{P(x|c_1)}{P(x|c_1) + P(x|c_2)}</script><p>设在各个类别下，特征$x$服从正态分布</p><script type="math/tex; mode=display">P(x|c_i) = \frac{1}{ (2\pi)^{\frac{n}{2}} |\Sigma_i|^{\frac{1}{2}}}exp(-\frac{1}{2} (x-\mu_i)^T \Sigma^{-1} (x-\mu_i))</script><p>则</p><script type="math/tex; mode=display">P(c_1|x) = \frac{1}{    1 + exp(-z)}</script><script type="math/tex; mode=display">P(c_2|x) = 1 - P(c_1|x) = \frac{exp(-z)}{1+exp(-z)}</script><blockquote><p>$<br>P(c_1|x) = \frac<br>{exp(-\frac{1}{2} (x-\mu_1)^T \Sigma_1^{-1} (x-\mu_1)}<br>{exp(-\frac{1}{2} (x-\mu_1)^T \Sigma_1^{-1} (x-\mu_1) + exp(-\frac{1}{2} (x-\mu_2)^T \Sigma_2^{-1} (x-\mu_2)}<br>$</p><p>$<br>P(c_1|x) = \frac<br>{1}<br>{1 + \frac{exp(-\frac{1}{2} (x-\mu_2)^T \Sigma_2^{-1} (x-\mu_2)}{exp(-\frac{1}{2} (x-\mu_1)^T \Sigma_1^{-1} (x-\mu_1)}<br>}<br>$</p><p>假定各分类的样本方差相等，$ \Sigma_1 = \Sigma_2 = \sigma^2 I $</p><p>$ P(c_1|x) = \frac {1}{1 + exp(- [ \frac{1}{\sigma^2} (\mu_1-\mu_2)^T x - \frac{1}{2 \sigma^2} (\mu_1^T\mu_1 - \mu_2^T\mu_2) ])}<br>$</p><p>令</p><script type="math/tex; mode=display">w = \frac{1}{\sigma^2} (\mu_1 -\mu_2)</script><script type="math/tex; mode=display">b = - \frac{1}{2\sigma^2}(\mu_1^T \mu_1 - \mu_2^T \mu_2)</script><p>即可得到</p><script type="math/tex; mode=display">P(c_1|x) = \frac{1}{    1 + exp(-z)}</script><p>其中</p><script type="math/tex; mode=display">z = w^T x + b</script></blockquote><h1 id="梯度推导"><a href="#梯度推导" class="headerlink" title="梯度推导"></a>梯度推导</h1><p>先推导<code>Sigmoid</code>函数的导数</p><script type="math/tex; mode=display">f'(z) = (1 - f(z))f(z)</script><p>值得注意的是，从$f’(z)$的图像可以看到，在$ x=0 $处$f’(z)$取极大值，且</p><script type="math/tex; mode=display">f'(z)_{max} = f'(z)|_{z=0} = 0.25</script><script type="math/tex; mode=display">\lim_{z \rightarrow \infty} f'(z) = 0</script><p>在多层神经网络反向传播更新参数时，由于梯度多次累乘，<code>Sigmoid</code>作为<a href="https://louishsu.xyz/2018/10/20/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/" target="_blank" rel="noopener">激活函数</a>会存在“梯度消失”的问题，使得参数更新非常缓慢。</p><p><img src="/2018/10/18/Logistic-Regression/Sigmoid_gradient.png" alt="`Sigmod导函数`"></p><blockquote><p>$ f’(z) $<br>$ = (\frac{1}{1+e^{-z}})’ $<br>$ = \frac<br>​          {-(1+e^{-z})’}<br>​          {(1+e^{-z})^2} $<br>$ = \frac<br>​          {e^{-z}}<br>​          {(1+e^{-z})^2} $<br>$ = \frac<br>​          {e^{-z}}<br>​          {1+e^{-z}}<br>​    \frac<br>​          {1}<br>​          {1+e^{-z}}$<br>$ = (1 - f(z))f(z)$</p></blockquote><p>利用链式求导法则可得</p><script type="math/tex; mode=display">\begin{aligned}    \frac{∂L}{∂w_j}     = -\frac{∂}{∂w_j} \frac{1}{N} \sum_i [y^{(i)} log(\hat{y}^{(i)})+(1-y^{(i)})log(1-\hat{y}^{(i)})]  \\    = - \frac{1}{N} \sum_i [y^{(i)} \frac{1}{\hat{y}^{(i)}}\frac{∂\hat{y}^{(i)}}{∂w_j}-(1-y^{(i)})\frac{1}{1-\hat{y}^{(i)}}\frac{∂\hat{y}^{(i)}}{∂w_j}] \\    = - \frac{1}{N} \sum_i [y^{(i)} \frac{1}{\hat{y}^{(i)}}\hat{y}^{(i)}(1-\hat{y}^{(i)})x_j-(1-y^{(i)})\frac{1}{1-\hat{y}^{(i)}}\hat{y}^{(i)}(1-\hat{y}^{(i)})x_j] \\    = - \frac{1}{N} \sum_i [y^{(i)} (1-\hat{y}^{(i)})x_j-(1-y^{(i)}) y^{(i)} x_j] \\    =  \frac{1}{N} \sum_i (\hat{y}^{(i)} - y^{(i)})x_j     \end{aligned}</script><p>写作矩阵形式，记$X = [x_1, x_2, …, x_m]^T$，$x_i$为样本特征(列向量)</p><script type="math/tex; mode=display">∇_w L = X^T (\hat{Y} - Y)</script><h1 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h1><p>和线性回归一样，采用梯度下降法求解</p><script type="math/tex; mode=display">w := w - \alpha ∇_w L</script><h1 id="处理多分类问题"><a href="#处理多分类问题" class="headerlink" title="处理多分类问题"></a>处理多分类问题</h1><p>假设有$K$个类别，则依次以类别$c_i$为正样本训练模型，一共训练$K$个。测试样本在每个模型上计算，最终将概率最大的作为分类结果。</p><blockquote><p>这样划分数据集，会使训练集正负样本数目严重不对称，特别是类别很多的情况，对结果会产生影响。可推广至<a href="https://louishsu.xyz/2018/10/18/softmax%E5%9B%9E%E5%BD%92/" target="_blank" rel="noopener">softmax回归</a>解决这个问题。</p></blockquote><h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://github.com/isLouisHsu/Python-Examples-for-ML/blob/master/Andrew%20Ng%2C%20Stanford%20University/mlclass-ex2-logisticregression/LogReg.py" target="_blank" rel="noopener">@Github: Code for Logistic Regression</a></p><h2 id="cost-function"><a href="#cost-function" class="headerlink" title="cost function"></a>cost function</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lossFunctionDerivative</span><span class="params">(self, X, theta, y_true)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    计算损失函数对参数theta的梯度</span></span><br><span class="line"><span class="string">    对theta[j]的梯度为：(y_pred - y_true)*x[j]</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    err = self.predict_prob(X, theta) - y_true</span><br><span class="line">    <span class="keyword">return</span> X.T.dot(err)/y_true.shape[<span class="number">0</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lossFunction</span><span class="params">(self, y_pred_prob, y_true)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    未使用</span></span><br><span class="line"><span class="string">    计算损失值: Cross-Entropy</span></span><br><span class="line"><span class="string">    y_pred_prob, y_true: NumPy array, shape=(n,)</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    tmp = y_true*np.log(y_pred_prob) + (<span class="number">1</span> - y_true)*np.log(<span class="number">1</span> - y_pred_prob)</span><br><span class="line">    <span class="keyword">return</span> np.mean(-tmp)</span><br></pre></td></tr></table></figure><h2 id="training-step"><a href="#training-step" class="headerlink" title="training step"></a>training step</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradDescent</span><span class="params">(self, min_acc, learning_rate=<span class="number">0.01</span>, max_iter=<span class="number">10000</span>)</span>:</span></span><br><span class="line">    acc = <span class="number">0</span>; n_iter = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n_iter <span class="keyword">in</span> range(max_iter):</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> range(self.n_batch):</span><br><span class="line">            X_batch = self.X[n*self.batch_size:(n+<span class="number">1</span>)*self.batch_size]</span><br><span class="line">            t_batch = self.t[n*self.batch_size:(n+<span class="number">1</span>)*self.batch_size]</span><br><span class="line">            grad = self.lossFunctionDerivative(X_batch, self.theta, t_batch)</span><br><span class="line">            self.theta -= learning_rate * grad <span class="comment"># 梯度下降</span></span><br><span class="line">            acc = self.accuracyRate(self.predict_prob(self.X, self.theta), self.t)</span><br><span class="line">            <span class="keyword">if</span> acc &gt; min_acc:</span><br><span class="line">                print(<span class="string">'第%d次迭代, 第%d批数据'</span> % (n_iter, n))</span><br><span class="line">                print(<span class="string">"当前总体样本准确率为: "</span>, acc)</span><br><span class="line">                print(<span class="string">"当前参数值为: "</span>, self.theta)</span><br><span class="line">                <span class="keyword">return</span> self.theta</span><br><span class="line">        <span class="keyword">if</span> n_iter%<span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">'第%d次迭代'</span> % n_iter)</span><br><span class="line">            print(<span class="string">'准确率： '</span>, acc)</span><br><span class="line">    print(<span class="string">"超过迭代次数"</span>)</span><br><span class="line">    print(<span class="string">"当前总体样本准确率为: "</span>, acc)</span><br><span class="line">    print(<span class="string">"当前参数值为: "</span>, self.theta)</span><br><span class="line">    <span class="keyword">return</span> self.theta</span><br></pre></td></tr></table></figure><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="/2018/10/18/Logistic-Regression/logistic_regression_result.png" alt="实验结果"></p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linear Regression</title>
      <link href="/2018/10/18/Linear-Regression/"/>
      <url>/2018/10/18/Linear-Regression/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>线性回归可以说是机器学习最基础的算法</p><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><script type="math/tex; mode=display">\hat{y}^{(i)} = w^Tx^{(i)}</script><p>其中$x^{(i)}_{(n + 1) \times 1}$为第$i$个$n$维向量，$i = 1, \cdots, m$，$w_{(n + 1) \times 1}$为权值向量</p><script type="math/tex; mode=display">\begin{cases}    x^{(i)}=\begin{bmatrix} x_0^{(i)} & x_1^{(i)} & ... & x_n^{(i)} \end{bmatrix}^T, x_0^{(i)}=1 \\     w = \begin{bmatrix} w_0 & w_1 & \cdots & w_n \end{bmatrix}^T\end{cases}</script><p>$x_0^{(i)}=1$项对应偏置项$b$，即$b=w_0$。</p><blockquote><p>注：若需要获得非线性特征，可构造高次特征如$x^{(i)}_{n+1} = (x^{(i)}_{j})^a, a \neq 0, 1$。</p></blockquote><h1 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h1><h2 id="定义误差"><a href="#定义误差" class="headerlink" title="定义误差"></a>定义误差</h2><script type="math/tex; mode=display">e^{(i)} = \hat{y}^{(i)} - y^{(i)}</script><p>其中$y^{(i)}$表示真实值</p><h2 id="定义损失函数"><a href="#定义损失函数" class="headerlink" title="定义损失函数"></a>定义损失函数</h2><p>单个样本的误差定义为</p><script type="math/tex; mode=display">L_{single}(\hat{y}^{(i)}, y^{(i)})=\frac{1}{2}||e^{(i)}||_2^2=\frac{1}{2}(\hat{y}^{(i)}-y^{(i)})^2</script><p>所有样本的误差(<strong>经验误差/风险</strong>)定义为</p><script type="math/tex; mode=display">L_{emp}(y, t)=\frac{1}{2N}\sum_i (\hat{y}^{(i)}-y^{(i)})^2</script><p>也可以定义为误差的和而不是均值，对结果无影响，可视作学习率$α$除去一个常数</p><h1 id="梯度推导"><a href="#梯度推导" class="headerlink" title="梯度推导"></a>梯度推导</h1><script type="math/tex; mode=display">\begin{aligned}    \frac{\partial L}{\partial w_j} = \frac{\partial }{\partial w_j}\frac{1}{2N}\sum_i(\hat{y}^{(i)}-y^{(i)})^2 \\    = \frac{1}{2N} \sum_i \frac{\partial }{\partial w_j} (\hat{y}^{(i)}-y^{(i)})^2 \\    = \frac{1}{N} \sum_i (\hat{y}^{(i)}-y^{(i)}) \frac{\partial t^{(i)}}{\partial w_j} \\    =  \frac{1}{N} \sum_i (\hat{y}^{(i)}-y^{(i)}) x_j^{(i)}\end{aligned}</script><p>或者使用矩阵推导，记$m$个$n$维样本组成的样本矩阵为$X_{m \times (n+1)} = \begin{bmatrix} x^{(1)} &amp; x^{(2)} &amp; \cdots &amp; x^{(m)} \end{bmatrix}^T$，$x^{(i)}$为第$i$个样本的特征(行向量)，$Y_{m \times 1}$为$m$个样本groundtruth组成的向量，那么有</p><script type="math/tex; mode=display">L = \frac{1}{2}(Xw-Y)^T(Xw-Y)</script><script type="math/tex; mode=display">∇_w L = X^T(\hat{Y}-Y)</script><blockquote><script type="math/tex; mode=display">\begin{aligned}    ∇_w L = \frac{1}{2} ∇_w (w^TX^TXw - Y^TXw - w^TX^TY + Y^TY) \\    = \frac{1}{2} (2X^TXw - X^TY - X^TY)     = X^T(Xw-Y)\end{aligned}</script></blockquote><p>在梯度为$\vec{0}$的点，即$∇_w L = \vec{0}$时求解得$w$的<strong>无偏估计</strong>$\hat{w}$</p><script type="math/tex; mode=display">$$令$X^T(Xw-Y) = 0$，有</script><p>\begin{aligned}<br>    X^T(Xw-Y) = 0 \Rightarrow \ X^TXw = X^TY \Rightarrow \ \hat{w} =(X^TX)^{-1} X^TY<br>\end{aligned} </p><script type="math/tex; mode=display">其中$X^+=(X^TX)^{-1} X^T$，表示矩阵$X_{m×n}$的伪逆。但是当$$ rank(X_{m \times (n + 1)}) < n + 1</script><blockquote><ol><li>样本数$m$小于特征维度数$n+1$；</li><li>存在多重共线性问题。</li></ol></blockquote><p>$X^TX$<strong>奇异</strong>无法求逆，用<strong>岭回归</strong>可以解决这个问题，在后面介绍，求得<strong>岭回归估计</strong>如下</p><script type="math/tex; mode=display">\hat{w}(\lambda) =(X^TX+\lambda I)^{-1}X^TY</script><h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><p>采用梯度下降法求解</p><script type="math/tex; mode=display">w := w - \alpha ∇_w L</script><p>其中$w$表示参数向量</p><blockquote><p>进一步思考：为什么使用梯度下降可以求取最优解呢？</p><script type="math/tex; mode=display">∇_w^2 L = ∇_w X^T(Xw-Y) = X^TX</script><p>而对于矩阵 $ X^TX $</p><script type="math/tex; mode=display">u^T(X^TX)u = (Xu)^T(Xu) \geq 0</script><p>即损失函数的<code>Hessian</code>矩阵$∇_w^2 L$为正定矩阵，$L$为凸函数，存在全局最优解</p></blockquote><h1 id="从投影的角度理解线性回归"><a href="#从投影的角度理解线性回归" class="headerlink" title="从投影的角度理解线性回归"></a>从投影的角度理解线性回归</h1><p><img src="/2018/10/18/Linear-Regression/projection_linreg2.png" alt="投影理解"></p><p><img src="/2018/10/18/Linear-Regression/projection_linreg3.png" alt="用投影推导最优解"></p><h1 id="线性回归的正则化"><a href="#线性回归的正则化" class="headerlink" title="线性回归的正则化"></a>线性回归的正则化</h1><p>添加$L_2$正则也称为<strong>岭回归</strong>(Ridge Regression)，添加$L_1$正则称为<strong>Lasso回归</strong>(一般用作特征选择)。</p><h2 id="岭回归"><a href="#岭回归" class="headerlink" title="岭回归"></a>岭回归</h2><p>为克服过拟合问题，可加入正则化项$||w||_2^2$，此时损失函数(<strong>结构误差/风险</strong>)定义为</p><script type="math/tex; mode=display">L(\hat{y}, y) = \frac{1}{2} ||\hat{y}^{(i)}-y^{(i)}||_2^2 + \lambda ||w||_2^2</script><p>那么<strong>优化问题</strong>如下</p><script type="math/tex; mode=display">\hat{w}^{ridge} = \arg \min L(\hat{y}, y)</script><p>或者</p><script type="math/tex; mode=display">\begin{aligned}    \hat{w}^{ridge} = \arg \min \left\{ \frac{1}{2} ||\hat{y}^{(i)}-y^{(i)}||_2^2 \right\} \\    s.t. \quad ||w||_2^2 \leq t(与\lambda有关)\end{aligned}</script><p>几何意义<br><img src="/2018/10/18/Linear-Regression/ridge_gragh.png" alt="ridge_gragh"></p><p>梯度为</p><script type="math/tex; mode=display">\frac{\partial L}{\partial w_j} = \frac{1}{N} \sum_i (\hat{y}^{(i)}-y^{(i)}) x_j^{(i)} + \frac{\lambda}{N}w_j, j = 1, ..., n + 1</script><p>此时对应的<strong>岭回归参数估计</strong>如下</p><script type="math/tex; mode=display">\hat{w}(\lambda) =(X^TX+\lambda I)^{-1}X^TY</script><ul><li>当$X^TX$出现奇异时，添加矩阵$\lambda I$可以使其<strong>奇异程度降低</strong>；</li><li>岭回归估计比最小二乘估计稳定，后者是其特殊情况($\lambda=0$)。</li></ul><p><strong>性质</strong></p><ul><li>$\hat{w}(\lambda)$是$w$的<strong>有偏估计</strong>，残差平方和增大但是系数检验效果更好；</li><li>当认为$\lambda$是与$y$无关的常数时，$\hat{w}(\lambda) =(X^TX+\lambda I)^{-1}X^TY = (X^TX+\lambda I)^{-1}X^T X \hat{w}$，即$\hat{w}(\lambda)$是$\hat{w}$的<strong>线性变换</strong>；</li><li>对于<strong>任意</strong>$\lambda &gt; 0$，$||\hat{w}|| \neq 0$，总有$|| \hat{w}(\lambda) || &lt; ||\hat{w}||$；</li><li><strong>存在</strong>$\lambda &gt; 0$，使得$MSE(\hat{w}(\lambda)) &lt; MSE(\hat{w})$。</li></ul><p>由于参数$\lambda$并不是唯一确定的，所以得到的$\hat{w}(\lambda)$是回归参数$w$的一个<strong>估计族</strong>，$\hat{w}_{j}(\lambda) - \lambda$图称为<strong>岭迹图</strong>，根据以下规则可以筛选有效特征</p><ul><li>当$\lambda = 0$时为最小二乘估计，参数$\hat{w}_{j}$<strong>不应趋向无穷</strong>；</li><li>当不存在奇异时，岭迹应<strong>稳定渐进趋向$0$</strong>；</li><li><p>通过岭迹图可以剔除变量解决多重共线性问题(个别情形下适用)</p><ul><li>可以剔除掉标准化岭回归<strong>系数比较稳定且绝对值很小</strong>的自变量;</li><li>随着$\lambda$的增加，回归系数不稳定，<strong>震荡趋于零</strong>的自变量也可以剔除;</li><li>如果依照上述去掉变量的原则，有若干个回归系数不稳定，究竟去掉几个，去掉哪几个，这幵无一般原则可循，这需根据<strong>去掉某个变量后重新进行岭回归分析</strong>的效果来确定。</li></ul></li></ul><p>一些岭迹图<br><img src="/2018/10/18/Linear-Regression/ridge_plot.png" alt="ridge_plot"></p><p>通过岭迹图<strong>选择参数$\lambda$的原则</strong></p><ul><li>各回归系数的岭估计基本稳定(如正负)；</li><li>用最小二乘估计时符号不合理的回归系数，其岭估计的符号变得合理；</li><li>回归系数没有不合乎实际意义的绝对值；</li><li>残差平方和增大不太多。</li></ul><blockquote><p>还有<strong>方差扩大因子法</strong>，注意不同方法建议的选择可能不一致。</p></blockquote><p><img src="/2018/10/18/Linear-Regression/ridge_param.png" alt="ridge_param"></p><p>存在的问题</p><ul><li>岭参数$\lambda$计算方法太多且差异很大；</li><li>用岭迹图进行变量筛选，随意性太大，且只能一定程度消除多重共线性，而不能解决其他问题；</li><li>岭回归返回的模型若<strong>没有经过特征筛选</strong>，包含全部变量。</li></ul><h2 id="Lasso回归"><a href="#Lasso回归" class="headerlink" title="Lasso回归"></a>Lasso回归</h2><p><strong>Lasso</strong>(The Least Absolute Shrinkage and Selectionator operator)通过构造<strong>一阶惩罚函数</strong>获得一个精炼的模型，最终能确定<strong>一些指标的系数为$0$</strong>，擅长处理具有多重共线性的数据，与岭回归一样时<strong>有偏估计</strong>。</p><p>Lasso回归的<strong>优化问题</strong>是</p><script type="math/tex; mode=display">\hat{w}^{lasso} = \arg \min \left\{ \frac{1}{2} ||\hat{y}^{(i)}-y^{(i)}||_2^2 + \lambda ||w||_1 \right\}</script><p>或者</p><script type="math/tex; mode=display">\begin{aligned}    \hat{w}^{lasso} = \arg \min \left\{ \frac{1}{2} ||\hat{y}^{(i)}-y^{(i)}||_2^2 \right\} \\    s.t. \quad ||w||_1 \leq t(与\lambda有关)\end{aligned}</script><p>几何意义<br><img src="/2018/10/18/Linear-Regression/lasso_graph.png" alt="lasso_graph"></p><p>但是$L_1$范数不可导，优化目标问题很复杂，可以用最小角回归(Least Angle Regression, LAR)解决，通过收缩的(shrinkage)方法依次选择变量加入。</p><p>首先介绍<strong>相关系数的几何意义</strong>，将$A, B$两个向量<strong>去中心化、单位化</strong>，即</p><script type="math/tex; mode=display">\begin{cases}    \hat{a}_i = (a_i - \overline{A}) / \sigma_A \\    \hat{b}_i = (b_i - \overline{B}) / \sigma_B\end{cases}</script><p>那么相关系数也即这两个向量的<strong>余弦距离</strong></p><script type="math/tex; mode=display">r_{AB} = \frac{\sum_{i=1}^n (a_i - \overline{A})(b_i - \overline{B})}{\sigma_A \sigma_B} = \frac{1}{n} \sum_{i=1}^n \hat{a}_i \hat{b}_i = \hat{A} \cdot \hat{B}= \cos<\hat{A}, \hat{B}></script><p>LAR<strong>具体算法</strong>如下，是一种线性的方法，求解结果与Lasso结果几乎一致(并不完全一致，但近似相同)</p><ol><li><strong>初始化</strong>：计算输出向量$Y$和属性向量$X_j, j = 1, \cdots. (n + 1)$的相关系数$r_j$，并按相关系数从大到小将属性排序；</li><li><strong>第一个特征选择</strong>：从原点开始沿着<em>相关系数最大</em>的属性$X_1$游走，得到的向量作为预测输出$\hat{Y}$，残差对应为$Y - \hat{Y}$，那么在这个过程中残差与$X_1$的相关性降低<script type="math/tex; mode=display">r_1' = (Y - \hat{Y}) \cdot X_1</script></li><li><strong>剩余特征加入</strong>：当步骤2中相关系数降低至<strong>存在特征$X_2$与残差的相关系数与$r_j’$相等</strong>时，即游走到$w_1 X_1$时，将该特征加入，开始沿着$w_1 X_1, X_2 - w_1 X_1$两向量的角平分线$(w_1 X_1 + X_2’)$游走，其中$X_2’ = X_2 - w1 X_1$；</li><li>重复步骤2，直至<strong>所有加入的特征</strong>与残差$Y - \hat{Y}$相关系数小于指定的较小常数$\epsilon$；</li><li>此时<strong>剩余的特征被丢弃</strong>，达到特征筛选的作用。</li></ol><p>如下图，当残差为$R_2$时，$R_2$几乎与$X_1, X_2$垂直，相关系数为$0$，停止游走，特征$X_3$被丢弃。</p><p><img src="/2018/10/18/Linear-Regression/lar.jpg" alt="lar"></p><h2 id="弹性网-elasticnet"><a href="#弹性网-elasticnet" class="headerlink" title="弹性网(elasticnet)"></a>弹性网(elasticnet)</h2><script type="math/tex; mode=display">\hat{w} = \arg \min \left\{ \frac{1}{2} ||\hat{y}^{(i)}-y^{(i)}||_2^2 + \lambda \left[ \alpha ||w||_2^2 + (1 - \alpha) ||w||_1 \right] \right\}</script><h2 id="q阶惩罚"><a href="#q阶惩罚" class="headerlink" title="q阶惩罚"></a>q阶惩罚</h2><script type="math/tex; mode=display">\hat{w} = \arg \min \left\{ \frac{1}{2} ||\hat{y}^{(i)}-y^{(i)}||_2^2 + \lambda ||w||_q^q \right\}</script><p><img src="/2018/10/18/Linear-Regression/contours.png" alt="contours"></p><h1 id="局部加权线性回归"><a href="#局部加权线性回归" class="headerlink" title="局部加权线性回归"></a>局部加权线性回归</h1><p>目标函数定义为</p><script type="math/tex; mode=display">L(y, t)=\frac{1}{2N}\sum_i w^{(i)} (\hat{y}^{(i)}-y^{(i)})^2</script><p>其中</p><script type="math/tex; mode=display">w^{(i)} = e^{-\frac{(x^{(i)}-x)^2}{2\tau^2}}</script><p>$x$表示输入的预测样本，$x^{(i)}$表示训练样本</p><p><div style="align: center"><img src="/2018/10/18/Linear-Regression/w_i_x_i.png"></div><br>离很近的样本，权值接近于1，而对于离很远的样本，此时权值接近于0，这样就是在局部构成线性回归，它依赖的也只是周边的点。</p><p>对于线性回归算法，一旦拟合出适合训练数据的参数$w$，保存这些参数$w$，对于之后的预测，不需要再使用原始训练数据集，所以是参数学习算法。而对于局部加权线性回归算法，每次进行预测都需要全部的训练数据（每次进行的预测得到不同的参数$w$），没有固定的参数$w$，所以是非参数算法。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://github.com/isLouisHsu/Python-Examples-for-ML/tree/master/Andrew%20Ng%2C%20Stanford%20University/mlclass-ex5-regularizedllinearregression" target="_blank" rel="noopener">@Github: Code for Linear Regression</a></p><h2 id="training-step"><a href="#training-step" class="headerlink" title="training step"></a>training step</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X, y, learning_rate=<span class="number">0.01</span>, max_iter=<span class="number">5000</span>, min_loss=<span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="comment"># --------------- 数据预处理部分 ---------------</span></span><br><span class="line">    <span class="comment"># 加入全1列</span></span><br><span class="line">    X = np.c_[np.ones(shape=(X.shape[<span class="number">0</span>])), X]</span><br><span class="line">    <span class="comment"># 构造高次特征</span></span><br><span class="line">    <span class="keyword">if</span> self.n_ploy &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, self.n_ploy + <span class="number">1</span>):</span><br><span class="line">            X = np.c_[X, X[:, <span class="number">1</span>]**i]</span><br><span class="line">    <span class="comment"># ---------------- 参数迭代部分 ----------------</span></span><br><span class="line">    <span class="comment"># 初始化参数</span></span><br><span class="line">    self.theta = np.random.uniform(<span class="number">-1</span>, <span class="number">1</span>, size=(X.shape[<span class="number">1</span>],))</span><br><span class="line">    <span class="comment"># 数据批次</span></span><br><span class="line">    n_batch = X.shape[<span class="number">0</span>] <span class="keyword">if</span> self.n_batch==<span class="number">-1</span> <span class="keyword">else</span> self.n_batch</span><br><span class="line">    batch_size = X.shape[<span class="number">0</span>] // n_batch</span><br><span class="line">    <span class="comment"># 停止条件</span></span><br><span class="line">    n_iter = <span class="number">0</span>; loss = float(<span class="string">'inf'</span>)</span><br><span class="line">    <span class="comment"># 开始迭代</span></span><br><span class="line">    <span class="keyword">for</span> n_iter <span class="keyword">in</span> range(max_iter):</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> range(n_batch):</span><br><span class="line">            n1, n2 = n*batch_size, (n+<span class="number">1</span>)*batch_size</span><br><span class="line">            X_batch = X[n1: n2]; y_batch = y[n1: n2]</span><br><span class="line">            </span><br><span class="line">            grad = self.lossFunctionDerivative(X_batch, y_batch)</span><br><span class="line">            self.theta -= learning_rate * grad</span><br><span class="line">            </span><br><span class="line">            loss = self.score(y_batch, self.predict(X_batch))</span><br><span class="line">            <span class="keyword">if</span> loss &lt; min_loss:</span><br><span class="line">                print(<span class="string">'第%d次迭代, 第%d批数据'</span> % (n_iter, n))</span><br><span class="line">                print(<span class="string">"当前总体样本损失为: "</span>, loss)</span><br><span class="line">                <span class="keyword">return</span> self.theta</span><br><span class="line">        <span class="keyword">if</span> n_iter%<span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">'第%d次迭代'</span> % n_iter)</span><br><span class="line">            print(<span class="string">"当前总体样本损失为: "</span>, loss)</span><br><span class="line">    print(<span class="string">"超过迭代次数"</span>)</span><br><span class="line">    print(<span class="string">"当前总体样本损失为: "</span>, loss)</span><br><span class="line">    <span class="keyword">return</span> self.theta</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lossFunctionDerivative</span><span class="params">(self, X, y)</span>:</span></span><br><span class="line">    y_pred = self.predict(X)</span><br><span class="line">    <span class="comment"># theta = self.theta;     # ！注意：theta = self.theta 不仅仅是赋值，类似引用，修改theta会影响self.theta</span></span><br><span class="line">    theta = self.theta.copy()</span><br><span class="line">    theta[<span class="number">0</span>] = <span class="number">0</span>            <span class="comment"># θ0不需要正则化</span></span><br><span class="line">    <span class="keyword">return</span> (X.T.dot(y_pred - y) + self.regularize * theta) / X.shape[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="predict-step"><a href="#predict-step" class="headerlink" title="predict step"></a>predict step</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, X, preprocessed=False)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> preprocessed:</span><br><span class="line">        <span class="comment"># 加入全1列</span></span><br><span class="line">        X = np.c_[np.ones(shape=(X.shape[<span class="number">0</span>])), X]</span><br><span class="line">        <span class="comment"># 构造高次特征</span></span><br><span class="line">        <span class="keyword">if</span> self.n_ploy &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, self.n_ploy + <span class="number">1</span>):</span><br><span class="line">                X = np.c_[X, X[:, <span class="number">1</span>]**i]</span><br><span class="line">    <span class="keyword">return</span> X.dot(self.theta)</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><ul><li><p>无正则化<br>  <img src="/2018/10/18/Linear-Regression/result_linreg_noreg.png" alt="无正则化的线性回归结果"></p></li><li><p>正则化<br>  <img src="/2018/10/18/Linear-Regression/result_linreg_reg.png" alt="正则化的线性回归结果"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
